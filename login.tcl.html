<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>login.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#login.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>login.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="login.tcl-annot.html">annotations</a> | <a href="login.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line">#load {expect52.dll}</span>
set auto_path [linsert $auto_path 0 . ]
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: Login</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that used to login to a switch through console IP</span>
<span class="comment-line">#              or serial com</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       device: ip address of the switch, or the ip address </span>
<span class="comment-line">#                     of the terminal server or the serial port from</span>
<span class="comment-line">#		      com1 to com4 where switch serial connection is made</span>
<span class="comment-line">#             fd: a file descriptor for log/debug purpose</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             Login $DUT1_CONNECT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::Login_24">proc <a href="login.tcl-annot.html#::::Login">::::Login</a></a></strong> {{device &#34;0.0.0.0&#34;} args } {
 
    global MAIN
    global whichDutNow whichMsmNow
    global MGMT_REG
    global FAILCOUNT

    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> Login $args {
    	fd &#34;NULL&#34;
    	userid &#34;admin&#34;
    	passwd &#34;&#34;
    	<a name="::CheckOperational(1)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a> &#34;1&#34;
    	masterCheck &#34;1&#34;
    	loginType &#34;telnet&#34;
    }

    set whichMsmNow &#34;&#34;
    set msmList &#34;B C D E F G H&#34;
    <span class="comment-line"># Save the original login attempt.  This will be used for a second login attempt later</span>
    set MGMT_REG(actualLoginString) &#34;\&#34;$device\&#34;&#34;
    set localString $MGMT_REG(actualLoginString);<span class="comment-line"># if Login gets called below the global gets corrupted</span>
    if {![info exists MAIN(NODECOUNT)]} {_getTestBedNumNodes;}
    if {![info exists MAIN(STDBYLIST)]} {_getTestBedStandbyNodes;}

    for {set i 1} {$i &lt;= $MAIN(NODECOUNT)} {incr i} {
	    global DUT${i}_CONNECT DUT${i}_CONNECTB DUT${i}_IP
	    foreach m $msmList {
            global DUT${i}_CONNECT${m}
            if {![info exists DUT${i}_CONNECT${m}]} {
                continue;
            }
            if { [info exists DUT${i}_CONNECT${m}] } {
                if {$device==[set DUT${i}_CONNECT${m}]} {
                    set whichMsmNow $m
                    set whichDutNow $i
                    set MGMT_REG(connType) &#34;console&#34;
                    break;
                }
            }
        }
        if { $device==[set DUT${i}_CONNECT] } {
            set whichDutNow $i
            set MGMT_REG(connType) &#34;console&#34;
            break
        }
        if { $device==[set DUT${i}_IP] } {
            set whichDutNow $i
            set MGMT_REG(connType) &#34;mgmt&#34;
            break
        }
    }
    foreach s $MAIN(STDBYLIST) {
        global STDBY${s}_CONNECT
        if { $device==[set STDBY${s}_CONNECT] } {
            set whichDutNow [expr 100 + $s]
            set whichStandBy $s
            set MGMT_REG(connType) &#34;console&#34;
            break
        }        
    }
    global stacking
    global pioneerPlatform
    global everestChassis
    if { [info exists whichDutNow] &amp;&amp; $whichDutNow &lt; 100} {
    	global DUT${whichDutNow}_CONNECTB DUT${whichDutNow}_Stacking_msmb_slot DUT${whichDutNow}_Stacking_msma_slot
    	if { [info exists DUT${whichDutNow}_CONNECTB ] } {
    	    if { $device == [set DUT${whichDutNow}_CONNECTB] } {
        		if { [regexp -nocase &#34;$stacking&#34; [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] } {
        		    set loginString &#34;DUT$whichDutNow Slot [set DUT${whichDutNow}_Stacking_msmb_slot]&#34;
        		} elseif {[regexp -nocase $pioneerPlatform [<a name="::GetPlatform(2)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] || \
                                  [regexp -nocase $everestChassis [<a name="::GetPlatform(3)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]]} {
                    set loginString &#34;DUT$whichDutNow MM-B&#34;
        		} else {
        		    set loginString &#34;DUT$whichDutNow MSM-B&#34;
        		}
    	    } else {
        		if { [regexp -nocase &#34;$stacking&#34; [<a name="::GetPlatform(4)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] } {
        		    set loginString &#34;DUT$whichDutNow Slot [set DUT${whichDutNow}_Stacking_msma_slot]&#34;
        		} elseif {[regexp -nocase $pioneerPlatform [<a name="::GetPlatform(5)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] || \
                                  [regexp -nocase $everestChassis [<a name="::GetPlatform(6)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]]} {
                    set loginString &#34;DUT$whichDutNow MM-A&#34;
        		} else {
        		    set loginString &#34;DUT$whichDutNow MSM-A&#34;
        		}
    	    }
    	} else {
    	    set loginString &#34;DUT$whichDutNow&#34;
    	}
    } elseif {[info exists whichStandBy]} {
        set loginString &#34;STDBY$whichStandBy&#34;
    } else {
    	set loginString &#34;$device&#34;
    }
    <span class="comment-line"># If a recent test has removed the mgmt ipa this section will put a mgmt ip back on</span>
    <span class="comment-line">#   via the console, then relogin using the mgmt ip</span>
    if {$MGMT_REG(telnetNeedsConfig) == 1 &amp;&amp; !$MGMT_REG(forceConsole)} {
        puts &#34;\n@@@ !!!!!\n In reconfig \n@@@ !!!&#34;
        <a name="::::_ConfigMgmtNetworkAll(1)"><a href="./SystemSetup.tcl.html#::::_ConfigMgmtNetworkAll_3115">::::_ConfigMgmtNetworkAll</a></a>; <span class="comment-line">#Login will be called during this function</span>
        set MGMT_REG(currentConnectionType) telnet
        set MGMT_REG(telnetNeedsConfig) 0
        set MGMT_REG(useTelnetLocalFlag) 1
        set MGMT_REG(actualLoginString) $localString
    }
    <span class="comment-line"># If the global MGMT_REG(useTelnet) flag is enabled, login to the DUTs_IP of the test bed.</span>
    if {$whichMsmNow != &#34;&#34;} {
        set viaType &#34;&#34;
    } elseif {$MGMT_REG(currentConnectionType) == &#34;telnet&#34; &amp;&amp; \
           $MGMT_REG(useTelnetGlobalFlag)==1 &amp;&amp; $MGMT_REG(useTelnetLocalFlag)==1 &amp;&amp; \
           !$MGMT_REG(forceConsole)} {
        set device [set DUT${whichDutNow}_IP]
        set MGMT_REG(currentConnectionType) telnet
        set MGMT_REG(connType) &#34;mgmt&#34;
        set viaType via_mgmt
    } else {
        set viaType &#34;&#34;
    }
    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\[\[\[\[\[\[\[\[ Login on device $device: $loginString $viaType\]\]\]\]\]\]\]\]&#34;

    switch -glob -- $device \
	    &#34;com?&#34; {
        <a name="::login_comm(1)"><a href="./login.tcl.html#::login_comm_898">::login_comm</a></a> $device $fd $userid $passwd $masterCheck
    } default {
        return [<a name="::login_telnet(1)"><a href="./login.tcl.html#::login_telnet_168">::login_telnet</a></a> $device $fd $userid $passwd $CheckOperational $masterCheck $loginType]
    }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: login_telnet</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: internal proc that used to login to a switch through telnet ip address</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       ipaddr: ip address of the switch</span>
<span class="comment-line">#       fd: a file descriptor for log/debug purpose</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         login_telnet $device $fd</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::login_telnet_168">proc <a href="login.tcl-annot.html#::::login_telnet">::::login_telnet</a></a></strong> {ipAddr {fd &#34;NULL&#34;} {userid &#34;admin&#34;} {passwd &#34;&#34;} \
	{<a name="::CheckOperational(2)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a> &#34;1&#34;} {masterCheck &#34;1&#34;} {loginType &#34;telnet&#34;} } {
    global spawn_id
    global hostname 
    global spawn_ids
    global ReportLoginError
    global MGMT_REG
    global whichDutNow whichMsmNow
    global FAILCOUNT connectionTimeout

    <span class="comment-line">#exp_internal 1</span>
    set newConnection 1
    <span class="comment-line">#check for existing connection</span>
    if { [ info exists hostname ] == &#34;1&#34; } {
        foreach name $hostname {
            if { $name == $ipAddr } {
                set spawn_id $spawn_ids($name)
                if { $spawn_id != &#34;INVALID&#34; } {
                    <span class="comment-line"># --- use it for delay without using sleep</span>
                    if {[info exists whichDutNow]} {
                        set whichStr &#34;$whichDutNow&#34;
                    } else {
                        set whichStr &#34;&#34;
                    }
                    puts &#34;Login $ipAddr $whichStr - Connection already exists pid=$spawn_id&#34;
                    set newConnection 0
                }
            }
        }
        <span class="comment-line">#if brand new connection, add to host name list</span>
        if { [lsearch $hostname $ipAddr] == -1 } {
            lappend hostname $ipAddr
        }
    } else {
        lappend hostname $ipAddr
    }

    if {![info exists FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))]} {
        set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0
    } elseif {$FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) &gt; 3} {
        error &#34;ERROR - CONSOLE IS HUNG OR IN USE BY SOMEONE - CANNOT CONTINUE!!\n\n&#34;
    }
    <span class="comment-line">#spawn new connection if not exists</span>
    if { $newConnection == 1 } {
        if { [regexp -nocase &#34;ssh&#34; $loginType] } {
            set cmd &#34;spawn $loginType admin@$ipAddr&#34;
        } else {
            set cmd &#34;spawn $loginType $ipAddr&#34;
        }
        if [catch &#34;$cmd&#34; reason] {
            <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;failed to spawn program: $reason\n&#34;
            error &#34;failed to spawn program: $reason\n&#34;
        }

        set spawn_ids($ipAddr) $spawn_id
        set timeout 10
        <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Login $loginType $ipAddr,  pid=$spawn_id&#34;
        <span class="comment-line">#wait for connection</span>
        expect {
            &#34;continue connecting&#34;  {
                if { [regexp -nocase &#34;ssh&#34; $loginType] } {
                    <a name="::::result_debug_expect(1)"><a href="./telnet.tcl.html#::::result_debug_expect_12">::::result_debug_expect</a></a>
                    exp_send &#34;yes\r&#34;
                }
            }	
            &#34;?nable to ?onnect&#34; {
                if {$FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) &lt; 3} {
                    incr FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))
                    <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;EXECUTING ClearConsoleDUT $ipAddr&#34;
                    <a name="::::ClearConsoleDUT(1)"><a href="./termServer.tcl.html#::::ClearConsoleDUT_40">::::ClearConsoleDUT</a></a> &#34;$ipAddr&#34;
                    set spawn_ids($ipAddr) &#34;INVALID&#34;
                    set rValue [<a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> &#34;$ipAddr&#34; -fd &#34;$fd&#34; -userid &#34;$userid&#34; -passwd &#34;$passwd&#34; \
                        -CheckOperational &#34;$CheckOperational&#34; -masterCheck &#34;$masterCheck&#34; -loginType &#34;$loginType&#34;]
                    return $rValue
                } else {
                    error &#34;Unable to connect - Hit No Connection refused on DUT $whichDutNow&#34;
                }
                if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
                    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
                } else {
                    <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
                }
                expect *
                <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
                if {$MGMT_REG(currentConnectionType) == &#34;console&#34;} {
                    error &#34;Unable to connect&#34;
                }

                if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
                    <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
                    <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unable to connect&#34;
                } else {
                    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
                    if {$MGMT_REG(currentConnectionType) == &#34;console&#34;} {
                        error &#34;Unable to connect&#34;
                    }
                }
                if {$MGMT_REG(currentConnectionType) == &#34;telnet&#34;} {
                    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;@@@\nLogin through the mgmt vlan failed. Try the console\n@@@&#34;
                    <a name="::WriteToMainLog(1)"><a href="./logging.tcl.html#::WriteToMainLog_32">::WriteToMainLog</a></a> &#34;Login through the mgmt vlan failed DUT $whichDutNow. Try the console&#34;
                    set MGMT_REG(currentConnectionType) console
                    set MGMT_REG(useTelnetLocalFlag) 0
                    <a name="::_clearDutConnectionVars(1)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                    set rValue [<a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $MGMT_REG(actualLoginString)]
                    return $rValue 
                }
            }
            &#34;?o route to ?ost&#34; {
                if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
                    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit No route to host on DUT $whichDutNow&#34;
                    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
                } else {
                    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit No route to host on DUT $whichDutNow&#34;
                    <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
                }
                expect *
                <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
                if {$MGMT_REG(currentConnectionType) == &#34;console&#34;} {
                    error &#34;Unable to connect - Hit No route to host on DUT $whichDutNow&#34;
                }
                if {$MGMT_REG(currentConnectionType) == &#34;telnet&#34;} {
                    <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;@@@\nLogin through the mgmt vlan failed. Try the console\n@@@&#34;
                    <a name="::WriteToMainLog(2)"><a href="./logging.tcl.html#::WriteToMainLog_32">::WriteToMainLog</a></a> &#34;Login through the mgmt vlan failed. Try the console DUT$whichDutNow&#34;
                    set MGMT_REG(currentConnectionType) console
                    set MGMT_REG(useTelnetLocalFlag) 0
                    <a name="::_clearDutConnectionVars(2)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                    <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Set to use console:  Login via original console call $MGMT_REG(actualLoginString)&#34;
                    set rValue [<a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $MGMT_REG(actualLoginString)]
                    return $rValue 
                }
            }
            &#34;?onnection refused&#34; {
                <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;HIT CONNECTION REFUSED&#34;
                if {$FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) &lt; 3} {
                    incr FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))
                    <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;EXECUTING ClearConsoleDUT $ipAddr&#34;
                    <a name="::::ClearConsoleDUT(2)"><a href="./termServer.tcl.html#::::ClearConsoleDUT_40">::::ClearConsoleDUT</a></a> &#34;$ipAddr&#34;
                    set spawn_ids($ipAddr) &#34;INVALID&#34;
                    set rValue [<a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> &#34;$ipAddr&#34; -fd &#34;$fd&#34; -userid &#34;$userid&#34; -passwd &#34;$passwd&#34; \
                    -CheckOperational &#34;$CheckOperational&#34; -masterCheck &#34;$masterCheck&#34; -loginType &#34;$loginType&#34;]
                    return $rValue
                } else {
                    error &#34;Unable to connect - Hit No Connection refused on DUT $whichDutNow&#34;
                }            
                if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
                    <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit Connection Refused on DUT $whichDutNow&#34;
                    <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
                } else {
                    <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit Connection Refused ERROR on DUT $whichDutNow&#34;
                    <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
                }
                expect *
                <a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
                if {$MGMT_REG(currentConnectionType) == &#34;console&#34;} {
                    error &#34;Unable to connect - Hit No Connection refused on DUT $whichDutNow&#34;
                }
                if {$MGMT_REG(currentConnectionType) == &#34;telnet&#34;} {
                    <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;@@@\nLogin through the mgmt vlan failed, Connection Refused. Try the console\n@@@&#34;
                    <a name="::WriteToMainLog(3)"><a href="./logging.tcl.html#::WriteToMainLog_32">::WriteToMainLog</a></a> &#34;Login through the mgmt vlan failed, Connection Refused. Try the console DUT$whichDutNow&#34;
                    <a name="::_clearDutConnectionVars(3)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                    incr FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))
                    set MGMT_REG(currentConnectionType) console
                    set MGMT_REG(useTelnetLocalFlag) 0
                    <a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Set to use console:  Login via original console call $MGMT_REG(actualLoginString)&#34;
                    set rValue [<a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $MGMT_REG(actualLoginString)]
                    return $rValue
                }
            }
            &#34;?onnected to&#34; {
                <a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Successful Connection&#34;
                set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0
                <span class="comment-line">#wait for all remaining characters to come</span>
                <span class="comment-line">#puts &#34;Connection established&#34;</span>
            }
            timeout {
                <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timeout on first login attempt&#34;
            }
        }

    }

    set timeout $connectionTimeout

    set loginStatus [<a name="::try_login_on_switch(1)"><a href="./login.tcl.html#::try_login_on_switch_981">::try_login_on_switch</a></a>  $ipAddr $userid $passwd $masterCheck $loginType]
    if { $loginStatus == 0 } {
        if {$MGMT_REG(currentConnectionType) == &#34;telnet&#34;} {
            <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;@@@\nLogin through the mgmt vlan failed. Try the console\n@@@&#34;
            <a name="::WriteToMainLog(4)"><a href="./logging.tcl.html#::WriteToMainLog_32">::WriteToMainLog</a></a> &#34;Login through the mgmt vlan failed. Try the console DUT$whichDutNow&#34;
            set MGMT_REG(currentConnectionType) console
            set MGMT_REG(useTelnetLocalFlag) 0
            set rValue [<a name="::Login(6)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $MGMT_REG(actualLoginString)]
            return $rValue
        }
        <span class="comment-line"># The expect_out array won't be set if expect times out, so</span>
        <span class="comment-line"># check to make sure it exists before using it.</span>
        if {[info exists expect_out(buffer)]} {
            <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer);
        }
        if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
            <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unable to login&#34;;
        } else {
            error &#34;Unable to login&#34;;
        }
        return $loginStatus;
    }

    if { $newConnection == 1 &amp;&amp; $CheckOperational } {
        <span class="comment-line">#make sure slots are operational</span>
        set output [<a name="::CheckOperational(3)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>]
        if { $output == 0 } {
            <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Some slots not operational&#34;
            error &#34;Some slots not operational&#34;
        }
    }
    puts &#34;Successfully completed login DUT $whichDutNow&#34;
    return $loginStatus
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: LoginFast</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Tries to login via telnet.  If this connection fails</span>
<span class="comment-line">#              it will login via console, clean up all of the telnet</span>
<span class="comment-line">#              config and continue on with the test</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       DUT Number to log in to</span>
<span class="comment-line">#       multi args common to previous Login and login_telnet</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         LoginFast 1</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LoginFast_403">proc <a href="login.tcl-annot.html#::::LoginFast">::::LoginFast</a></a></strong> {DUTNum args} {

   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> LoginFast $args {
      fd &#34;NULL&#34;
      userid &#34;admin&#34;
      passwd &#34;&#34;
      <a name="::CheckOperational(4)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a> &#34;0&#34;
      masterCheck &#34;1&#34;
      noTelnet &#34;0&#34;
   }

global DUTs_info
global numDUT

for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
   global DUT${dut}_IP
}

<span class="comment-line"># There purpose of the NoLoginTelnet Global option allows the LoginFast</span>
<span class="comment-line">#  proc to be called throughout different procedures with nested LoginFast</span>
<span class="comment-line">#  and disable telnet at a single point.  See the VPLS test cases for an</span>
<span class="comment-line">#  example.  A setup script creates a network and multiple procs verify</span>
<span class="comment-line">#  the network.  The logins are all internal to the procs, so it is </span>
<span class="comment-line">#  necessary to be able to turn off telnet and use the console if</span>
<span class="comment-line">#  the login and out via telnet is not beneficial </span>
if {![info exist DUTs_info(DUT${DUTNum},NoLoginTelnet)]} {
   <a name="::result_debug(27)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SET INITIAL NoLoginTelnet 0&#34;
   set DUTs_info(DUT${DUTNum},NoLoginTelnet) 0;
}
if {$noTelnet == 1} {
   set DUTs_info(DUT${DUTNum},NoLoginTelnet) 1;
   <a name="::result_debug(28)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SET NoLoginTelnet 1&#34;
}

if {![info exist DUTs_info(DUT${DUTNum},regRouterNet)]} {
   set DUTs_info(DUT${DUTNum},regRouterNet) 1;
   <a name="::result_debug(29)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SET regRouterNet 1&#34;
}
set loginTelnetStatus 1

   <a name="::Login(7)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT${DUTNum},connect)
   if {$DUTs_info(DUT${DUTNum},regRouterNet) &amp;&amp; \
      ($DUTs_info(DUT${DUTNum},NoLoginTelnet)==0)} {
      <span class="comment-line">#This condition will make it so the code will not try to log in via</span>
      <span class="comment-line">#  telnet if it fails once due to network issues.</span>
      <a name="::ConfigGatewayNetwork(1)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
      set loginTelnetStatus [<a name="::login_telnet_graceful(1)"><a href="./login.tcl.html#::login_telnet_graceful_526">::login_telnet_graceful</a></a> [set DUT${DUTNum}_IP] &#34;$fd&#34; \
                    &#34;$userid&#34; &#34;$passwd&#34; &#34;$CheckOperational&#34; &#34;$masterCheck&#34;]
   
      if {$loginTelnetStatus} {
         set DUTs_info(DUT${DUTNum},regRouterNet) 1;
         return 1;
      } else {
         <a name="::Login(8)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT${DUTNum},connect)
         <a name="::UnconfigGatewayNetwork(1)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
         set DUTs_info(DUT${DUTNum},regRouterNet) 0;
         return 0;
      }
   }
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: LogoutFast</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Logout of a switch.  If the initial connection via</span>
<span class="comment-line">#              telnet did not work there shoud be nothing to clean</span>
<span class="comment-line">#              if it did work, the regRouter network will have to</span>
<span class="comment-line">#              be cleaned up</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       DUT Number list</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         LogoutFast &#34;1 2&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LogoutFast_481">proc <a href="login.tcl-annot.html#::::LogoutFast">::::LogoutFast</a></a></strong> {{DUTNumList &#34;1&#34;} {NoTelnetOff &#34;null&#34;} {UnconfigNetwork &#34;yes&#34;} } {

global DUTs_info
global numDUT

   for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
      global DUT${dut}_IP
   }

   foreach num $DUTNumList {
      if {$DUTs_info(DUT${num},NoLoginTelnet)==0} {
         set regNet $DUTs_info(DUT${num},regRouterNet)
         if {$regNet} {
            <a name="::login_telnet_graceful(2)"><a href="./login.tcl.html#::login_telnet_graceful_526">::login_telnet_graceful</a></a> [set DUT${num}_IP]
            <a name="::logout(1)"><a href="./logout.tcl.html#::logout_21">::logout</a></a>
            if {$UnconfigNetwork == &#34;yes&#34;} {
                <a name="::Login(9)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT${num},connect)
                <a name="::UnconfigGatewayNetwork(2)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>      
            }
         }
      }
      if {$NoTelnetOff==1} {
         unset DUTs_info(DUT${num},NoLoginTelnet)
      }
   }
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: login_telnet_graceful</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: internal proc that used to login to a switch </span>
<span class="comment-line">#              through telnet ip address. Called by LoginFast</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       ipaddr: ip address of the switch</span>
<span class="comment-line">#       fd: a file descriptor for log/debug purpose</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         login_telnet_graceful $device $fd</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::login_telnet_graceful_526">proc <a href="login.tcl-annot.html#::::login_telnet_graceful">::::login_telnet_graceful</a></a></strong> {ipAddr {fd &#34;NULL&#34;} {userid &#34;admin&#34;} {passwd &#34;&#34;} \
	{<a name="::CheckOperational(5)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a> &#34;1&#34;} {masterCheck &#34;1&#34;} } {
  global spawn_id
  global hostname 
  global spawn_ids
  global ReportLoginError connectionTimeout
 
<span class="comment-line">#exp_internal 1</span>
  set newConnection 1
  set spawnGood 1
  <span class="comment-line">#check for existing connection</span>
  if { [ info exists hostname ] == &#34;1&#34; } {
    foreach name $hostname {
      if { $name == $ipAddr } {
        set spawn_id $spawn_ids($name)
        if { $spawn_id != &#34;INVALID&#34; } {
          <span class="comment-line"># --- use it for delay without using sleep</span>
          puts &#34;Login $ipAddr - Connection already exists pid=$spawn_id&#34;
          set newConnection 0
        }
      }
    }
    <span class="comment-line">#if brand new connection, add to host name list</span>
    if { [lsearch $hostname $ipAddr] == -1 } {
       lappend hostname $ipAddr
    }
  } else {
       lappend hostname $ipAddr
  }
    
    
    <span class="comment-line">#spawn new connection if not exists</span>
   if { $newConnection == 1 } {
      set time1 [clock seconds];
      if [catch &#34;spawn telnet $ipAddr&#34; reason] {
         <a name="::result_debug(30)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;failed to spawn program: $reason\n&#34;
         <span class="comment-line">#error &#34;failed to spawn program: $reason\n&#34;</span>
         <a name="::result_debug(31)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error failed to spawn program: $reason\n&#34;
         return 0;
      }
      set spawn_ids($ipAddr) $spawn_id
      set timeout 15
      <a name="::result_debug(32)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Login telnet $ipAddr,  pid=$spawn_id&#34;
      send &#34;\n&#34;
      <span class="comment-line">#wait for connection</span>
      expect {
         -nocase -re &#34;unable.*connect&#34; {
            if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
               <a name="::result_debug(33)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
            } else {
               <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
            }
            expect *
            <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
            <span class="comment-line">#error &#34;Unable to connect&#34;</span>
            <a name="::result_debug(34)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error Unable to connect&#34;
            set spawn_ids($ipAddr) &#34;INVALID&#34;;
            return 0;
            if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
               <a name="::result_debug(35)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $expect_out(buffer)
               <a name="::result_debug(36)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unable to connect&#34;
            } else {
               <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer)
               <span class="comment-line">#error &#34;Unable to connect&#34;</span>
               <a name="::result_debug(37)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error Unable to connect&#34;
               set spawn_ids($ipAddr) &#34;INVALID&#34;;
               return 0;
            }
         }
         -nocase -re &#34;.*onnected&#34; {
            <span class="comment-line">#wait for all remaining characters to come</span>
            <span class="comment-line">#		puts &#34;Connection established&#34;</span>
         }
         timeout {
            after 15
            <a name="::result_debug(38)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Slow Connection Time: 15 secs. Possible Network Issues. Use Console&#34;
            set spawn_ids($ipAddr) &#34;INVALID&#34;;
            return 0;
         }
      }
   }
   set loginStatus [<a name="::try_login_on_switch(2)"><a href="./login.tcl.html#::try_login_on_switch_981">::try_login_on_switch</a></a>  $ipAddr $userid $passwd $masterCheck]
   if { $loginStatus == 0 } {
      <span class="comment-line"># The expect_out array won't be set if expect times out, so</span>
      <span class="comment-line"># check to make sure it exists before using it.</span>
      if {[info exists expect_out(buffer)]} {
         <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> $expect_out(buffer);
      }
      if {[info exists ReportLoginError] &amp;&amp; $ReportLoginError == &#34;no&#34;} {
         <a name="::result_debug(39)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unable to login&#34;;
      } else {
         <span class="comment-line">#error &#34;Unable to login&#34;;</span>
         <a name="::result_debug(40)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error Unable to Connect&#34;
         return 0;
      }
      return $loginStatus;
   }

   if { $newConnection == 1 &amp;&amp; $CheckOperational } {
      <span class="comment-line">#make sure slots are operational</span>
      set output [<a name="::CheckOperational(6)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>]
      if { $output == 0 } {
         <a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Some slots not operational&#34;
         <span class="comment-line">#error &#34;Some slots not operational&#34;</span>
         <a name="::result_debug(41)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error Some slots not operational&#34;;
         return 0;
      }
   }
   return $loginStatus

}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckOperational</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: check that all slots are in operational state</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line">#       </span>
<span class="comment-line"># Output args: return 1 if all slots are operational</span>
<span class="comment-line">#              return 0 if some slot is not operational</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         CheckOperational</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">################################################################## </span>
<strong><a name="::::CheckOperational_653">proc <a href="login.tcl-annot.html#::::CheckOperational">::::CheckOperational</a></a></strong> { args } {
    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckOperational $args {
        waitforloadcfg &#34;no&#34;  ; <span class="comment-line"># used for scalability test cases that have to reboot with huge cfg</span>
    }

    global chassis
    global whichDutNow
    global spawn_id
    global spawn_ids
    global pioneerPlatform
    global everestChassis
    global DUTs_info
    global CFG_PLATFORM


    <span class="comment-line"># Check the cfg file platform name override</span>
    if {[info exists CFG_PLATFORM($whichDutNow)] &amp;&amp; $CFG_PLATFORM($whichDutNow) != &#34;null&#34;} {
        set DUTs_info(DUT${whichDutNow},platform) $CFG_PLATFORM($whichDutNow)
    }
    if {![info exists whichDutNow]} {
        set whichDutNow 1;
    }
    if {![info exists DUTs_info(DUT$whichDutNow,SHOWPROCESSES)]} {
        set DUTs_info(DUT$whichDutNow,SHOWPROCESSES) 1;
        set procReady 0
    } elseif {$DUTs_info(DUT$whichDutNow,SHOWPROCESSES) == 0} {
        set procReady 1
    } else {
        set procReady 0
    }
    set procList &#34;&#34;
    lappend procList {{^Slot-|^msm} 5}
    set timeDuration 0

    if { $waitforloadcfg == &#34;no&#34; } {
        set processreadytime 60
        set SlotOperationalWait  45
    } else {
        set processreadytime 250
        set SlotOperationalWait 150
    }

    <span class="comment-line"># Check for MSM Operational</span>
    global DUT${whichDutNow}_CONNECTB
    if {[regexp -nocase $chassis [<a name="::GetSystemType(1)"><a href="./misc.tcl.html#::GetSystemType_513">::GetSystemType</a></a> $whichDutNow]] &amp;&amp; \
                                     [info exists DUT${whichDutNow}_CONNECTB]} {

        <span class="comment-line">#find out the ipAddr of this session if it is MSM-A or MSM-B</span>
        global hostname
        foreach name $hostname {
            if { $spawn_id == $spawn_ids($name) } {
                set ipAddr $name
            }
        }
        if { $ipAddr == [set DUT${whichDutNow}_CONNECTB] } {
            <span class="comment-line"># Current slot is b, check operational on slot a</span>
            set slot a
        } else {
            <span class="comment-line"># Current slot is a, check operational on slot b</span>
            set slot b
        }
        set bStat &#34;&#34;
        lappend bStat &#34;State: 1&#34;
        set slotBState [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot $slot&#34; $bStat]
        if {[regexp -nocase $slotBState &#34;empty&#34;]} {
            <a name="::result_debug(42)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Slot $slot not present&#34;
        } elseif {[regexp -nocase $slotBState &#34;operational&#34;]!=1} {
            <a name="::result_debug(43)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Verifying slot $slot operational&#34;
            set slotBState &#34;&#34;
            lappend slotBState &#34;{State:} {Operational} inLine exists&#34;
            if { $waitforloadcfg == &#34;no&#34; } {
                <span class="comment-line">## Increased sleep to 300 for pioneer originally it was 120</span>
                if { [<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show slot $slot&#34; \
                      $slotBState -time {s: 1 i: 30 d: 420 f: 600 r}] != &#34;ok&#34; } {
                    return 0
                }
                set showSwitchOutput &#34;&#34;
                lappend showSwitchOutput &#34;{Current State:} {In *Sync} inLine exists&#34;
                if {[<a name="::CheckKeyValue(2)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show switch&#34; $showSwitchOutput -time {s: 1 i: 5 d: 150 f: 400 r} \
                                   -comment &#34;check both MSMs up in sh switch output&#34;]==&#34;error&#34;} {
                    return 0
                }

            } else {
                if { [<a name="::CheckKeyValue(3)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show slot $slot&#34; \
                    $slotBState -time {s: 1 i: 20 d: 200 f: 200  r}] != &#34;ok&#34; } {
                    return 0
                }
                set showSwitchOutput &#34;&#34;
                lappend showSwitchOutput &#34;{Current State:} {In *Sync} inLine exists&#34;
                if {[<a name="::CheckKeyValue(4)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show switch&#34; $showSwitchOutput -time {s: 1 i: 5 d: 150 f: 400 r} \
                                      -comment &#34;check both MSMs up in sh switch output&#34;]==&#34;error&#34;} {
                    return 0
                }
            }
        }
        global bcmChassis
        if {[regexp -nocase $bcmChassis [<a name="::GetSystemType(2)"><a href="./misc.tcl.html#::GetSystemType_513">::GetSystemType</a></a> $whichDutNow]]} {
            <span class="comment-line">#set SlotOperationalMaxWait 120</span>
            if { $waitforloadcfg == &#34;no&#34; } {
                if {[regexp -nocase $everestChassis [<a name="::GetSystemType(3)"><a href="./misc.tcl.html#::GetSystemType_513">::GetSystemType</a></a> $whichDutNow]]} {
                    set SlotOperationalMaxWait 600
                } else {
                    set SlotOperationalMaxWait 250
                }
            } else {
                set SlotOperationalMaxWait 300
            }
        } else {
            if { $waitforloadcfg == &#34;no&#34; } {
                set SlotOperationalMaxWait 500
            } else {
                set SlotOperationalMaxWait 250 
            }
        }
    } else {
        if { $waitforloadcfg == &#34;no&#34; } {
            set SlotOperationalMaxWait 500
        } else {
            set SlotOperationalMaxWait 250 

        }
    }
    while {$procReady!=1} {
        set result [<a name="::ldelete(1)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> [<a name="::GetKeyValue(2)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show process&#34; $procList] &#34;&#34;]
        foreach res $result {
            if {![regexp -nocase &#34;ready|unknown|0|no|stopped|loadcfg&#34; $res]} {
                <span class="comment-line"># 0 for &#34;Not supported&#34; bgp</span>
                <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 3
                set procReady 0
                break
            } else {
                set procReady 1
            }
        }
        incr timeDuration 3
        if {$waitforloadcfg == &#34;no&#34; } {
            set processreadytime 60
        } else {
            set processreadytime 150
        }

        if {$timeDuration&gt;=$processreadytime} {
            break
        }
    }
    <span class="comment-line"># Tmp set column</span>
    <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure cli column 255&#34;

    if {$procReady==0} {
        <a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;All processes not ready even after $processreadytime secs  wait&#34;
        return 0
    }

    if {[regexp -nocase $chassis [<a name="::GetSystemType(4)"><a href="./misc.tcl.html#::GetSystemType_513">::GetSystemType</a></a> $whichDutNow]] || \
                      [regexp -nocase &#34;vpex&#34; [<a name="::GetSystemType(5)"><a href="./misc.tcl.html#::GetSystemType_513">::GetSystemType</a></a> $whichDutNow]]} {
        set slotStatusList &#34;&#34;
        set slotOperational 0
        set timeDuration 0
        lappend slotStatusList &#34;slot Operational inLine&#34;
        set listElem &#34;&#34;
        set SlotStatusLength 33 
        set startCol 30 
        set endCol [expr $startCol+$SlotStatusLength]
        lappend listElem &#34;$startCol $endCol&#34;
        set spankTheSlot 0
        while {$slotOperational!=1} {
            <span class="comment-line"># EY-08-15-2008: Added check for blank line to endKey parameter.</span>
            set slotStatusString [<a name="::GetColumnValues(1)"><a href="./OptionCheck.tcl.html#::GetColumnValues_593">::GetColumnValues</a></a> &#34;show slot&#34; $listElem &#34;----&#34; &#34;MSM-A|MM-A|Flags|^$&#34;]
            <a name="::result_debug(44)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The slotStatusString $slotStatusString&#34;
            foreach res [lindex $slotStatusString 0] {
                if {![regexp -nocase &#34;Operational|^ *empty&#34; $res]&amp;&amp;$res!=&#34;&#34;} {
                    <span class="comment-line">#exSleep 3</span>
                    <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 6
                    set slotOperational 0
                    break
                } else {
                    set slotOperational 1
                }
            }
            if { ![regexp -nocase &#34;Operational&#34; $slotStatusString] } {
                set slotOperational 0
            }
            incr timeDuration 3
            <a name="::result_debug(45)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Total of $timeDuration out of $SlotOperationalMaxWait&#34;
            if {$timeDuration&gt;=$SlotOperationalMaxWait} {
                break
            }
        }
        if {$slotOperational==0} {
            <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;All slots not Operational even after $SlotOperationalMaxWait wait&#34;
            return 0
        }
        if {[regexp -nocase &#34;vpex&#34; [<a name="::GetSystemType(6)"><a href="./misc.tcl.html#::GetSystemType_513">::GetSystemType</a></a> $whichDutNow]] &amp;&amp; ![<a name="::::VerifyBpeSlotsOperational(1)"><a href="./vpex.tcl.html#::::VerifyBpeSlotsOperational_117">::::VerifyBpeSlotsOperational</a></a>]} {
            <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;All VPEX slots are not Operational&#34;
            return 0

            <span class="comment-line"># For port extender (BPE), card state machine is not currently aware of </span>
            <span class="comment-line"># extended port (E-channel) states.  This means there can be a long delay </span>
            <span class="comment-line"># (up to 75 secs) between BPE slots going operational and extended ports </span>
            <span class="comment-line"># showing link up on controlling bridge side  Temporarily need to verify </span>
            <span class="comment-line"># ports are up on controlling bridge side before returning as operational.</span>
            <span class="comment-line"># Extended port mapping must also be explicitly defined in cfg file, not Auto.</span>
            global bpePortWait
            if {0||[info exists bpePortWait]} {
                <span class="comment-line"># _verifyPortMappingPortsActive is set to 60s time limit; </span>
                <span class="comment-line">#       convert bpePortWait value to number of iterations</span>
                set count [expr ($bpePortWait / 60) + 1]
                for {set i 0} {$i &lt; $count} {incr i} {
                    set result [<a name="::::_verifyPortMappingPortsActive(1)"><a href="./SystemSetup.tcl.html#::::_verifyPortMappingPortsActive_2869">::::_verifyPortMappingPortsActive</a></a>]
                    if {$result == 1} {
                        break
                    }
                }
                if {$result != 1} {
                    <a name="::result_error(16)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;All BPE ports are not up after waiting; bpePortWait = $bpePortWait&#34;
                    return 0
                }
            }
        }
    }
    return 1
}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: login_comm</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: internal proc that used to login to a switch through serial com</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       comm_port: come1 or com2</span>
<span class="comment-line">#       fd: a file descriptor for log/debug purpose</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         login_comm $device $fd</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::login_comm_898">proc <a href="login.tcl-annot.html#::::login_comm">::::login_comm</a></a></strong> {comm_port {fd &#34;NULL&#34;} {userid &#34;admin&#34;} {passwd &#34;&#34;} {masterCheck 1}} {
   global spawn_id
   global hostname
   global spawn_ids   
   
  set newConnection 1
  <span class="comment-line">#check for existing connection</span>
  if { [ info exists hostname ] == &#34;1&#34; } {
    foreach name $hostname {
      if { $name == $comm_port } {
        set spawn_id $spawn_ids($name)
        if { $spawn_id != &#34;INVALID&#34; } {
          puts &#34;Login $comm_port - Connection already exists pid=$spawn_id&#34;
          set newConnection 0
        }
      }
    }
    <span class="comment-line">#if brand new connection, add to host name list</span>
    if { [lsearch $hostname $comm_port] == -1 } {
       lappend hostname $comm_port
    }
  } else {
       lappend hostname $comm_port
  }
   <span class="comment-line">#spawn new connection if not exists</span>
   if { $newConnection == 1 } {    
     <span class="comment-line"># s. comm initialization</span>
     set con [open $comm_port RDWR]
     fconfigure $con -buffering none -mode 9600,n,8,1  -blocking 0 \
        -buffersize 8192 -eofchar {} -translation auto
     if [catch &#34;spawn -open $con&#34; reason] {
        send_user &#34;failed to spawn program: $reason\n&#34;
        error &#34;failed to spawn program: $reason\n&#34;
     }
    set spawn_ids($comm_port) $spawn_id
     <a name="::result_debug(46)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Login serial $comm_port,  pid=$spawn_id&#34;
   }
   <span class="comment-line">#initial talking with the switch</span>
   <a name="::try_login_on_switch(3)"><a href="./login.tcl.html#::try_login_on_switch_981">::try_login_on_switch</a></a>  $comm_port $userid $passwd $masterCheck

   <span class="comment-line">#expect &#34;#&#34;  </span>
   expect {
       &#34;#&#34; { 
           return
       }
       &#34;&gt;&#34; {
           return
       }
   }    
}

;<span class="comment-line"># Determine which boot image to use</span>
<strong><a name="::::_whichBootImage_950">proc <a href="login.tcl-annot.html#::::_whichBootImage">::::_whichBootImage</a></a></strong> {{DUTNum 1}} {

    global DUTs_info
   
    set bootNum 2
    if [info exists DUTs_info(DUT$DUTNum,imageBooted)] {

        if [regexp -nocase &#34;primary&#34; $DUTs_info(DUT$DUTNum,imageBooted)] {
            set bootNum 1
        }
    }
   
    return $bootNum
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: try_login_on_switch</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: internal proc that sends login prompt and password slower each char at a time</span>
<span class="comment-line">#              returns error in case got the connection but can not successfully login</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: string : ip address of the DUT</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         try_login_on_switch  $ipAddr</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup	</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::try_login_on_switch_981">proc <a href="login.tcl-annot.html#::::try_login_on_switch">::::try_login_on_switch</a></a></strong> {string {userid &#34;admin&#34;} {passwd &#34;&#34;} {masterCheck &#34;1&#34;} {loginType &#34;telnet&#34;} } {

    global DUTs_info connectionTimeout
    global powerCyclerRetry POWERCYCLE_DUT SKIPPCTOBOOTROMFLAG
    global tempNumberLoginLoops
    global waitBetweenLoginLoops
    global TryToPowerCycle
    global whichDutNow whichMsmNow
    global spawn_id
    global MGMT_REG
    global FAILCOUNT
    global stacking
    global in
    global bcmx430
    global MAIN


    if {![info exists FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))]} {
        set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0
    }
    if {![info exists MAIN(initAdminCheck)]} {
        set MAIN(initAdminCheck) 0
    }
    if {![info exists DUTs_info(DUT$whichDutNow,loginQuick)]} {
        set DUTs_info(DUT$whichDutNow,loginQuick) 0
    }
    if {![info exists DUTs_info(DUT$whichDutNow,qloadInitLogin)]} {
        set DUTs_info(DUT$whichDutNow,qloadInitLogin) 0
    }
    if {![info exists connectionTimeout]} {
        set connectionTimeout 90
    }
    <span class="comment-line">#log_user 2;</span>
    if {[info exist waitBetweenLoginLoops ]} {
        set timeout $waitBetweenLoginLoops
    } elseif {$DUTs_info(DUT$whichDutNow,loginQuick) &gt; 0} {
        set timeout $DUTs_info(DUT$whichDutNow,loginQuick)
    } else {
        set timeout 20
    }
    <span class="comment-line">#  -- Figure out the details of the device being logged into</span>
    set dut 1
    for { set numDUT 1; global DUT${numDUT}_CONNECT DUT${numDUT}_IP } \
      { [info exists DUT${numDUT}_CONNECT] } \
      { incr numDUT ; global DUT${numDUT}_CONNECT DUT${numDUT}_IP} {

        set connect [set DUT${numDUT}_CONNECT]
        set connect_mgmt [set DUT${numDUT}_IP]
        global DUT${numDUT}_CONNECTB
        if {[info exists DUT${numDUT}_CONNECTB]} {
            set connectb [set DUT${numDUT}_CONNECTB]
            if {([string compare $string $connect] == 0) || \
                ([string compare $string $connectb] == 0) || \
                ([string compare $string $connect_mgmt] == 0)} {
            set dut $numDUT
            break
            }
        } else {
            if {[string compare $string $connect]==0 || \
                 [string compare $string $connect_mgmt]==0} {
                set dut $numDUT
                break
            }
        }
    }

    <a name="::result_debug(47)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Try to login to DUT $whichDutNow $whichMsmNow timeout $timeout&#34;

    after 50
    ;<span class="comment-line"># need it to be 10 or else Mariner goes into BOOTLOADER if \r supplied at the wait</span>
    <span class="comment-line">#exp_send &#34;\r&#34;   ;# Initial \r to get enter after terminal server connected</span>
    if {[catch {exp_send &#34;\r&#34;} reason]} {
        if {  [regexp -nocase &#34;not open&#34; $reason] } {
            <a name="::result_print(1)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\nexpec send found spawn id not open \
                : reconnect\n~~~~~&#34;;
            <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
            <a name="::_clearDutConnectionVars(4)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
            global DUT${whichDutNow}_CONNECT
            if {$MGMT_REG(currentConnectionType) == &#34;telnet&#34; &amp;&amp; $MGMT_REG(useTelnetLocalFlag)} {
                <a name="::WriteToMainLog(5)"><a href="./logging.tcl.html#::WriteToMainLog_32">::WriteToMainLog</a></a> &#34;MGMT_REG Telnet Spawn ID not open&#34;
                <span class="comment-line"># Login of the console</span>
                set MGMT_REG(currentConnectionType) console
                set MGMT_REG(telnetNeedsConfig) 0;<span class="comment-line"># don't set yet or Login will reconfig mgmt ip</span>
                set MGMT_REG(useTelnetLocalFlag) 0;<span class="comment-line"># not yet or Login will use telnet ip</span>
                if {[<a name="::Login(10)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational 0 -masterCheck 0]&lt;=0} {
                    <a name="::result_error(17)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after foreign host closed&#34;
                    set timeout $connectionTimeout
                    return &#34;&#34;
                }
                set MGMT_REG(telnetNeedsConfig) 1;<span class="comment-line"># set so next login setup mgmt ip over consonle then telnet over mgmt</span>
                set MGMT_REG(useTelnetLocalFlag) 1;<span class="comment-line"># set so next login will use telnet ip</span>
            } else {
                <a name="::WriteToMainLog(6)"><a href="./logging.tcl.html#::WriteToMainLog_32">::WriteToMainLog</a></a> &#34;Telnet Spawn ID not open in try_login_on_switch&#34;
                if {[<a name="::Login(11)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set string] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                    <a name="::result_error(18)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on [set string] retry after spawn id not open&#34;
                    set timeout $connectionTimeout
                    return &#34;&#34;
                }
            }
        }
    }
    set newLoginSession 0
    set loginLoop 0
    set syncLoop 0
    set tOCounter 0
    set maxReachedCount 1
    if {[info exist tempNumberLoginLoops ]} {
        set numberLoops $tempNumberLoginLoops
    } else {
        set numberLoops 40
    }

    for {set i 0} {$i &lt;= $numberLoops} {incr i} {
        if {[info exists DUTs_info(DUT$whichDutNow,loginQuick)] &amp;&amp; $DUTs_info(DUT$whichDutNow,loginQuick) \
                  &amp;&amp; $i&gt;1 &amp;&amp; $tOCounter&gt;1} {
            if {$DUTs_info(DUT$whichDutNow,qloadInitLogin) &amp;&amp; !$SKIPPCTOBOOTROMFLAG &amp;&amp; \
                               [info exists POWERCYCLE_DUT($whichDutNow)]} {
                if {[<a name="::pcToBootRom(1)"><a href="./bootRomLib.tcl.html#::pcToBootRom_763">::pcToBootRom</a></a> $dut]==&#34;ok&#34;} {
                    <a name="::result_debug(48)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait for 90 secs for rebooted DUT $dut to come up...&#34;
                    <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 90
                }                
            } else {
                if {[info exists POWERCYCLE_DUT($whichDutNow)]} {
                    <a name="::PowerCycleDUT(1)"><a href="./poweroutlet.tcl.html#::PowerCycleDUT_377">::PowerCycleDUT</a></a> $whichDutNow YES false
                }
            }
            set DUTs_info(DUT$whichDutNow,loginQuick) 0
            if {[<a name="::Login(12)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational 0 -masterCheck 0]&lt;=0} {
                    <a name="::result_error(19)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after foreign host closed&#34;
                    set timeout $connectionTimeout
                    return &#34;&#34;
            }
            set DUTs_info(DUT$whichDutNow,qloadInitLogin) 0;<span class="comment-line"># Hail mary to recover switch has ended.</span>
        }
        expect {
            timeout {
                incr tOCounter
                set loginLoop 0
                if {$DUTs_info(DUT$whichDutNow,loginQuick) &gt; 0} {
                    <a name="::result_debug(49)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Try login timeout hit $loginLoop&#34;
                }
                exp_send &#34;\r&#34;
                if { [regexp -nocase &#34;ssh&#34; $loginType] } {
                    <a name="::result_error(20)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;SSH login Failed to the DUT $dut&#34;
                    <a name="::result_debug(50)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Telnet to DUT $dut via console&#34;
                    <a name="::Login(13)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT]
                    set timeout $connectionTimeout
                    return 1
                }
            }
            &#34;firmware update in progress&#34; { ;<span class="comment-line">#SK3/9/07: POE firmware install 12.0.0.3</span>
                set tOCounter 0
                <a name="::exSleep(4)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 90
            }
            -nocase -re &#34;Maximum.*reached&#34; {
                set tOCounter 0
                if {[info exists expect_out(buffer)] &amp;&amp; \
                       [regexp -nocase &#34;ending&#34; $expect_out(buffer)]} {
                    puts &#34;--- Pending hit&#34;
                }
                <a name="::result_debug(51)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT$dut Maximun login attempts - $maxReachedCount&#34;
                global TRYFAILSAFE
                if {[info exists TRYFAILSAFE] &amp;&amp; $TRYFAILSAFE == &#34;true&#34; &amp;&amp; \
                         $maxReachedCount &gt; 2 &amp;&amp; $maxReachedCount &lt;= 4 } {
                    if {![regexp -nocase &#34;$stacking&#34; [<a name="::GetPlatform(7)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] &amp;&amp; \
                                    ![regexp -nocase &#34;$bcmx430&#34; [<a name="::GetPlatform(8)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]]} {
                        <a name="::result_debug(52)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NOT Stacking - Send ALL Failsafe password&#34;
                        <a name="::exSleep(5)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
                        <a name="::LoginWithFailSafe(1)"><a href="./login.tcl.html#::LoginWithFailSafe_2188">::LoginWithFailSafe</a></a> -dut ${whichDutNow}
                    } else {
                        <a name="::result_debug(53)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stacking or x430 platform - DON'T send failsafe&#34;
                    }
                }
                <a name="::exSleep(6)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 20
                exp_send &#34;\r&#34;
                incr loginLoop
                incr maxReachedCount
                continue
            }
            &#34;login:&#34; {
                set tOCounter 0
                if {[regexp -nocase &#34;Maximum.*reached&#34; $expect_out(buffer)]} {
                    <a name="::result_debug(54)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit DUT$dut maximum login attempts&#34;
                    <a name="::exSleep(7)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 10
                    exp_send &#34;\r&#34;
                } else {
                    <a name="::result_debug(55)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Slow Send Admin&#34;
                    <a name="::slow_send(1)"><a href="./SendSwCmd.tcl.html#::slow_send_1567">::slow_send</a></a> &#34;$userid\r&#34;
                }
                if {[regexp -nocase &#34;telnet session t&#34; $expect_out(buffer)]} {   
                    ;<span class="comment-line"># potential issue with DUTX_IP login</span>
                    ;<span class="comment-line"># which may setup the connectType for DUTX_CONNECT</span>
                    ;<span class="comment-line"># to be telnet inadvertently</span>
                    set DUTs_info(DUT$dut,connectType) &#34;telnet&#34;
                } else {
                    set DUTs_info(DUT$dut,connectType) &#34;console&#34;
                }
                set newLoginSession 1
            }
            &#34;Failed to connect to authentication service&#34; {
                set tOCounter 0
                <a name="::exSleep(8)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $timeout 
            }
            &#34;password:&#34; {
                set tOCounter 0
                exp_send &#34;$passwd\r&#34;
                set newLoginSession 1
                incr loginLoop 
                continue
            }
            &#34;password for $userid&#34; {
                set tOCounter 0
                exp_send &#34;$passwd\r&#34;
                set newLoginSession 1
                incr loginLoop
                continue
            }
            -nocase -re {\[y\/n\]:} {
                set tOCounter 0
                exp_send &#34;\r&#34;
                continue
            }
            -nocase -re {\[y\/n\/q\]:} {
                set tOCounter 0
                exp_send &#34;\r&#34;
                continue
            }
            &#34; # &#34; {
                set tOCounter 0
                set loginLoop 0
                <span class="comment-line"># A new login session needs to have clipaging disabled</span>
                if {![info exists DUTs_info(DUT$dut,connectType)]} {
                    set DUTs_info(DUT$dut,connectType) &#34;console&#34;
                }
                if { $newLoginSession == 1 } {
                    after 200
                    <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;dis clipa&#34;
                    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable idle&#34;
                    set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0 
                   <span class="comment-line"># SendACmd &#34;show log messages nvram&#34;</span>
                    <span class="comment-line">#         EnableDebugMode</span>
                    <span class="comment-line">#        SendACmd &#34;!echo dump_stack &gt; /sys/module/watchdog/parameters/watchdog_warn_behavior&#34;</span>
                    <span class="comment-line"># Code Added to enable Ctrl+v+x+b reboot</span>
                    <span class="comment-line">#EnableDebugMode</span>
                    <span class="comment-line">#SendACmd &#34;debug hal configure sysrq 1&#34;</span>
                    <a name="::exSleep(9)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                    <span class="comment-line">#DisableDebugMode</span>
                    <span class="comment-line">#_verifyCFCorruptionStatusOnLogin</span>
                }
                puts &#34;Try login successful&#34;
                set timeout $connectionTimeout
                return 1
            }
            &#34;msmA&gt;&#34; {
                if { $newLoginSession == 1} {
                    <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;\r&#34;
                }
                exp_send &#34;\r&#34;
                set newLoginSession 1
                set loginLoop 0
                set timeout $connectionTimeout
                return 1
            }
            &#34;msmB&gt;&#34; {
                if { $newLoginSession == 1} {
                    <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;\r&#34;
                }
                exp_send &#34;\r&#34;
                set newLoginSession 1
                set loginLoop 0
                set timeout $connectionTimeout
                return 1
            }
            &#34;BOOTLOADER&gt;&#34; {
                ;<span class="comment-line"># Mariner boot prompt</span>
                set loginLoop 0
                set timeout 60
                <a name="::result_warning(1)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Attempting to login while in BOOTLOADER prompt&#34;
                <a name="::result_warning(2)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Send boot command and retry ($i)&#34;
                exp_send &#34;boot [<a name="::_whichBootImage(1)"><a href="./login.tcl.html#::_whichBootImage_950">::_whichBootImage</a></a> $dut]\r&#34;
                continue
            }
            &#34;BootRom &gt;&#34; {
                ;<span class="comment-line"># Aspen/Cougar boot prompt</span>
                set tOCounter 0
                set loginLoop 0
                set timeout 60
                <a name="::result_warning(3)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Attempting to login while in BootRom prompt&#34;
                <a name="::result_warning(4)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Send boot command and retry ($i) - boot [<a name="::_whichBootImage(2)"><a href="./login.tcl.html#::_whichBootImage_950">::_whichBootImage</a></a> $dut]&#34;
                exp_send &#34;boot [<a name="::_whichBootImage(3)"><a href="./login.tcl.html#::_whichBootImage_950">::_whichBootImage</a></a> $dut]\r&#34;
                continue
            }
            &#34;BootStrap &gt;&#34; {
                ;<span class="comment-line"># Cougar goes here first before BootRom prompt</span>
                set tOCounter 0
                set loginLoop 0
                set timeout 60
                <a name="::result_warning(5)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Attempting to login while in BootStrap prompt&#34;
                <a name="::result_warning(6)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Sending boot command and retry ($i)&#34;
                exp_send &#34;boot\r&#34;
                continue
            }
            &#34;~&gt;&#34; {
                ;<span class="comment-line"># Pacman prompt</span>
                set tOCounter 0
                set loginLoop 0
                set timeout 60
                <a name="::result_warning(7)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Attempting to login while in Pacman prompt&#34;
                <a name="::result_warning(8)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Send continue command and retry ($i)&#34;
                exp_send &#34;8a\r&#34;
                    expect {
                       &#34;pacman_autostart=&#34; {
                            exp_send &#34;true\r&#34;
                            expect -re &#34;\~&gt;*&#34;
                            exp_send &#34;s\r&#34;
                            expect -re &#34;\~&gt;*&#34;
                       }
                       timeout {
                            <a name="::result_debug(56)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Could not set autostart&#34;
                       }
                    }
                exp_send &#34;c\r&#34;
                continue
            }
            &#34; &gt; &#34; {
                set tOCounter 0
                set loginLoop 0
                set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0
                ;<span class="comment-line"># Non-admin user or backup</span>
                ;<span class="comment-line"># Check we're not BootRom or BootStrap prompt</span>
                ;<span class="comment-line"># A new login session needs to have clipaging disabled</span>
                if {![info exists DUTs_info(DUT$dut,connectType)]} {
                    set DUTs_info(DUT$dut,connectType) &#34;console&#34;
                }
                if { $newLoginSession == 1 } {
                    <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;dis clipa&#34; 
                    <span class="comment-line">#         EnableDebugMode</span>
                    <span class="comment-line">#         SendACmd &#34;!echo dump_stack &gt; /sys/module/watchdog/parameters/watchdog_warn_behavior&#34;</span>
                    <span class="comment-line">#_verifyCFCorruptionStatusOnLogin </span>
                }
                if {$MAIN(initAdminCheck)} {
                    set MAIN(initAdminCheck) 0
                    <a name="::result_debug(57)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\nEvaluate Admin Account Check&#34;
                    set ubuf [<a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig default ipa&#34;]
                    set userStr &#34;user does not have permissions&#34;
                    if {[regexp -nocase $userStr $ubuf]} {
                        <a name="::result_debug(58)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Non-Admin account login is not allowed when useing the -masterCheck option with Login&#34;
                        <a name="::logout(2)"><a href="./logout.tcl.html#::logout_21">::logout</a></a>
                        <a name="::Login(14)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT${whichMsmNow}]
                    }
                }
                if {$masterCheck} {
                    set backupMsm 0
                    <a name="::result_debug(59)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\nEvaluate Master Check&#34;
                    set buf [<a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig default ipa&#34;]
                    set backupStr &#34;Error: This command can only be executed on Master|This command cannot be executed during configuration load|This command cannot be executed on a standby node&#34;
                    global DUT${dut}_CONNECTB
                    if {[info exist DUT${dut}_CONNECTB] &amp;&amp; [regexp -nocase $backupStr $buf]} {
                        set backupMsm 1
                    }
                    
                    ;<span class="comment-line"># By default, we try to switch to Master if we are on Backup MSM</span>
                    if {$backupMsm} {
                        set buf $expect_out(buffer)
                        set verList &#34;&#34;
                        lappend verList &#34;{XOS version} 1&#34;
                        set xos_version [<a name="::GetKeyValue(3)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show version&#34; $verList]
                        global DUT${dut}_CONNECTB
                        if {$xos_version &lt; &#34;11.2.0&#34;} {
                            if { $xos_version &gt;= &#34;10.2.0&#34; } {
                                set virtualRouter VR-Control
                            } else {
                                set virtualRouter VR-1
                            }
                            ;<span class="comment-line"># Check for backup prompt...if backup we need to failover</span>
                            <a name="::EnableDebugMode(1)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>  ;<span class="comment-line"># needed as 11.1.1.3 requires debug-mode</span>
                            global bcmChassis
                            if {[regexp -nocase $bcmChassis $buf]} {
                                ;<span class="comment-line"># 10.0.&lt;slot&gt;.2  MSMA-slot 11, MSMB-slot 12</span>
                                if {[string compare [set DUT${dut}_CONNECTB] $string]==0} {
                                    <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.11.2&#34;
                                } else {
                                    <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.12.2&#34;
                                }
                            } else {
                                ;<span class="comment-line"># 10.0.&lt;slot&gt;.2  MSMA-slot 9, MSMB-slot 10</span>
                                if {[string compare [set DUT${dut}_CONNECTB] $string]==0} {
                                    <a name="::SendACmd(11)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.9.2&#34;
                                } else {
                                    <a name="::SendACmd(12)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.10.2&#34;
                                }
                            }
                        } else {
                            if {[info exists DUT${dut}_CONNECTB]} {
                                if {[string compare [set DUT${dut}_CONNECTB] $string]==0} {
                                    <span class="comment-line"># SendACmd &#34;telnet msm a&#34;</span>
                                    <a name="::Login(15)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT] -CheckOperational 0
                                } else {
                                    <span class="comment-line">#SendACmd &#34;telnet msm b&#34;</span>
                                    <a name="::Login(16)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECTB] -CheckOperational 0
                                }
                            }
                        }
                        ;<span class="comment-line"># Check that we're In Sync before switchover</span>
                        set msmState &#34;&#34;
                        lappend msmState &#34;{State:} {BACKUP.*In Sync} inLine exists&#34;
                        incr syncLoop
                        if { [<a name="::CheckKeyValue(5)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show switch&#34; \
                                $msmState -time {s: 1 i: 30 d: 90 f: 250 r}] == &#34;ok&#34; } {
                            <a name="::SendACmd(13)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;run msm-failover&#34;
                            <a name="::result_debug(60)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping 50 seconds to give time for MSM to reboot after an msm failover...&#34;
                            <a name="::exSleep(10)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 50
                            global DUT1_Stacking_msma_slot
                            if { [info exists DUT1_Stacking_msma_slot] } {
                                <a name="::result_debug(61)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping additional 60 seconds to give time for stacking reboot&#34;
                                <a name="::exSleep(11)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 60
                            }
                        } else {
                            <a name="::SendACmd(14)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;reboot&#34;
                        }
                        if {[string compare [set DUT${dut}_CONNECTB] $string]==0} {
                            <a name="::Login(17)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECTB]
                        } else {
                            <a name="::Login(18)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT]
                        }
                    }
                }
                set timeout $connectionTimeout
                return 1
            }
            &#34;BCM\.*&gt; &#34; {  
                ;<span class="comment-line"># BCM prompt for Broadcom</span>
                set loginLoop 0
                set timeout $connectionTimeout
                return 1
            }
            &#34;closed&#34; {
                set loginLoop 0
                incr FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))
                <a name="::result_print(2)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\ntry_login_on_switch detects telnet to DUT$whichDutNow Closed Foreign Host\n~~~~~&#34;;
                <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                <a name="::_clearDutConnectionVars(5)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                global DUT${whichDutNow}_CONNECT
                if {[<a name="::Login(19)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set string] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                    <a name="::result_error(21)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry on [set string] after foreign host closed&#34;
                    set timeout $connectionTimeout
                    return -1
                }
            }
            -nocase {\[y/N]:} {
                <span class="comment-line">#to response to questions after a &#34;unconfig sw all&#34; is done.</span>
                set loginLoop 0
                exp_send &#34;\r&#34;
            }
            -re -nocase &#34;\[a-z0-9]+ &#34; {
                puts &#34;Cosole active&#34;
                sleep $timeout
                continue;
            }
            -nocase -re &#34;(\\* )?\[a-z0-9._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                <span class="comment-line"># ExtremeWare and ExtremeWare XOS prompt.</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># The pattern breaks down as follows:</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># (\\* )?        Unsaved config marker</span>
                <span class="comment-line"># \[a-z0-9._-]+  Platform type or SNMP system name</span>
                <span class="comment-line"># (:|\\.)        Name and command ID separator</span>
                <span class="comment-line"># \[0-9]+        Command ID</span>
                <span class="comment-line"># (#|&gt;)          System or user prompt marker</span>
                <span class="comment-line">#</span>
                set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0
                <a name="::result_print(3)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\nReconnect DUT$whichDutNow : Got a known switch prompt\n~~~~~&#34;;
                set timeout $connectionTimeout
                return 1
            }
            eof {
                <a name="::result_print(4)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\ntry_login_on_switch detects telnet to DUT$whichDutNow dropped! Reconnect\n~~~~~&#34;;
                <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                global whichDutNow
                incr FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))
                <a name="::_clearDutConnectionVars(6)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                <a name="::::ClearConsoleDUT(3)"><a href="./termServer.tcl.html#::::ClearConsoleDUT_40">::::ClearConsoleDUT</a></a> $whichDutNow
                global DUT${whichDutNow}_CONNECT
                if {[<a name="::Login(20)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set string] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                    <a name="::result_error(22)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on [set string] retry after foreign host closed&#34;
                    set timeout $connectionTimeout
                    return -1
                }
            }
        }
    }
    if { $loginLoop &gt; 0} {
        set loginLoop 0
        if {[info exists in] &amp;&amp; $in == &#34;download&#34;} {
            <a name="::result_debug(62)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT${whichDutNow} - The Supplied USERID and PASSWORD:\n\
                Combination is not correct - You are in Download - It may recover!&#34;
        } else {
            <a name="::result_error(23)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;DUT${whichDutNow} - The Supplied USERID and PASSWORD combination is not correct&#34;
        }
        set timeout $connectionTimeout
        return 0
    }
    
    if { $syncLoop &gt; 0} {
        set syncLoop 0
        global pioneerPlatform
        global DUTs_info
        global whichDutNow
        <a name="::result_error(24)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;MSM|MM-A and MSM|MM-B are not in sync&#34;
        set timeout $connectionTimeout
        return 0
    }

    <span class="comment-line">#if we get here that means we didn't get the prompt</span>
    <span class="comment-line"># check if we should skip the power cycling phase</span>
    if {[info exists TryToPowerCycle] &amp;&amp; $TryToPowerCycle == &#34;no&#34;} {
        <a name="::result_debug(63)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SKIPPING POWER CYCLING&#34;
        <a name="::result_debug(64)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;We didn't get the prompt...&#34;
        set timeout $connectionTimeout
        return 0
    }

    <span class="comment-line"># Reboot the DUT to find if powercycle helps</span>
    <span class="comment-line"># Currently 8/19/02 nofeep prompt &#34;-&gt;&#34; at login would also power cycle the DUT.</span>
    global DUT${dut}_TYPE
    incr powerCyclerRetry
    if { $powerCyclerRetry &gt; 3 } {
        <a name="::result_debug(65)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Max power cycler retry reached ...$powerCyclerRetry&#34;
        set  powerCyclerRetry 0
        <a name="::result_debug(66)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Could not power cycle DUT $dut...&#34;
        puts &#34;@@@ Could not power cycle DUT @@@&#34;
        return 0
    }
    <a name="::result_debug(67)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Power Cycler retry... $powerCyclerRetry&#34;
    if {[info exists in] &amp;&amp; $in != &#34;main&#34;} {
        if {$in==&#34;download&#34;} {
            if {![info exists DUT${dut}_TYPE]} {
                if {[<a name="::powerCycleToBootRom(1)"><a href="./bootRomLib.tcl.html#::powerCycleToBootRom_912">::powerCycleToBootRom</a></a> $dut]==&#34;ok&#34;} {
                    <a name="::result_debug(68)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait for 30 secs for rebooted DUT to come up...&#34;
                    <a name="::exSleep(12)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 30
                } else {
                    <a name="::result_debug(69)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Could not power cycle DUT $dut...&#34;
                    puts &#34;@@@ Could not power cycle DUT @@@&#34;
                    return 0
                }
            } elseif {[info exists DUT${dut}_TYPE] &amp;&amp; [set DUT${dut}_TYPE]==&#34;PC&#34;} {
                <a name="::PowerCycleDUT(2)"><a href="./poweroutlet.tcl.html#::PowerCycleDUT_377">::PowerCycleDUT</a></a> $dut
            }
            <a name="::result_debug(70)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;login_telnet string -- $string&#34;
            <a name="::login_telnet(2)"><a href="./login.tcl.html#::login_telnet_168">::login_telnet</a></a> $string 
            set output [<a name="::CheckOperational(7)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>]
            if { $output == 0 } {
                <a name="::result_error(25)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Some slots not operational&#34;
                error &#34;Some slots not operational&#34;
            }
            <a name="::SendACmd(15)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;dis clipa&#34;
            <a name="::SendACmd(16)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;con default del port all&#34;
            <span class="comment-line">#         EnableDebugMode</span>
            <span class="comment-line">#         SendACmd &#34;!echo dump_stack &gt; /sys/module/watchdog/parameters/watchdog_warn_behavior&#34;</span>
            return 1
        }
    } elseif {[<a name="::PowerCycleDUT(3)"><a href="./poweroutlet.tcl.html#::PowerCycleDUT_377">::PowerCycleDUT</a></a> $dut]==1} {
        <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully power cycled DUT $dut...&#34;
        <a name="::result_debug(71)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait for 30 secs for rebooted DUT to come up...&#34;
        <a name="::exSleep(13)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 30
        <a name="::login_telnet(3)"><a href="./login.tcl.html#::login_telnet_168">::login_telnet</a></a> $string 
        <a name="::SendACmd(17)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;dis clipa&#34;
        <a name="::SendACmd(18)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;con default del port all&#34;
        <span class="comment-line">#        EnableDebugMode</span>
        <span class="comment-line">#        SendACmd &#34;!echo dump_stack &gt; /sys/module/watchdog/parameters/watchdog_warn_behavior&#34;</span>
        return 1
    } else {
        if {[info exists in] &amp;&amp; $in == &#34;download&#34;} {
            <a name="::result_debug(72)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Could not power cycle DUT $dut...&#34;
            puts &#34;@@@ Could not power cycle DUT @@@&#34;
        } else {
            <a name="::result_error(26)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not power cycle DUT $dut...&#34;
            puts &#34;@@@ Could not power cycle DUT @@@&#34;
        }
        return 0
    }
}


<strong><a name="::::_verifyCFCorruptionStatusOnLogin_1565">proc <a href="login.tcl-annot.html#::::_verifyCFCorruptionStatusOnLogin">::::_verifyCFCorruptionStatusOnLogin</a></a></strong> { } {

    global whichDutNow
    global DUTs_info
    global DUT1_IP
    global regressionAbortReason
    set cf_state &#34;ok&#34;
    <a name="::EnableDebugMode(2)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a> 
<span class="comment-line">#Check if Tool jffs2dump exist on switch else download it from tftp server</span>
    lappend paramList &#34;{jffs2dump} exist&#34;
    if {[<a name="::CheckKeyValue(6)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;ls /usr/local/tmp&#34; $paramList -reportResults 0] != &#34;ok&#34;} {
        <a name="::ConfigGatewayNetwork(2)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
        <a name="::SendACmd(19)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ping vr [<a name="::GetVrString(1)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] 10.210.1.200&#34;
        <a name="::SendACmd(20)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;tftp 10.210.1.200 -v [<a name="::GetVrString(2)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] \
                -g -l jffs2dump -r jffs2dump&#34;
        <a name="::UnconfigGatewayNetwork(3)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
        <a name="::exSleep(14)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
        <a name="::SendACmd(21)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!cp /config/jffs2dump /scratch/intern/jffs2dump&#34;
    }
    unset paramList

<span class="comment-line">#LK various type of CF corruption detection :1</span>
    lappend loginParamList &#34;{Compact Flash exhibiting signs of internal filesystem corruption} notExist&#34;
    lappend loginParamList &#34;{Failed to obtain compact flash status} notExist&#34;
    if {[<a name="::CheckKeyValue(7)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;debug hal show compact-flash&#34; $loginParamList -reportResults 0] != &#34;ok&#34;} {
          set cf_state &#34;corrupted&#34;
    }
    unset loginParamList

<span class="comment-line">#LK various type of CF corruption detection :2</span>
    if {[<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${whichDutNow}] &#34;12.0.3.1&#34;] &gt;= 0} {
         lappend cfbuff &#34;{^1} notExist&#34;
         if {[<a name="::CheckKeyValue(8)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;!cat /proc/jffs2_corruption&#34; $cfbuff -reportResults 0] != &#34;ok&#34;} {
           set cf_state &#34;corrupted&#34;
         }
         unset cfbuff 
    }

<span class="comment-line">#LK various type of CF corruption detection :3</span>
    lappend cfbuff &#34;{Wrong data_crc} notExist&#34;
    lappend cfbuff &#34;{Wrong bitmask} notExist&#34;
    if {[<a name="::CheckKeyValue(9)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;!/scratch/intern/jffs2dump -b -c /dev/hda7 | grep Wrong&#34; $cfbuff -reportResults 0] != &#34;ok&#34;} {
       set cf_state &#34;corrupted&#34;
    }
    unset cfbuff 

<span class="comment-line">#LK various type of CF corruption detection :4</span>
    lappend cfbuff &#34;{output error} notExist&#34;
    if {[<a name="::CheckKeyValue(10)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;ls&#34; $cfbuff -reportResults 0] != &#34;ok&#34;} {
       set cf_state &#34;corrupted&#34;
    }
    unset cfbuff 

<span class="comment-line">#LK if CF is corrupted collect the debug data</span>
    if { $cf_state == &#34;corrupted&#34; } {
           <a name="::SendACmd(22)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!hdparm -i /dev/hda&#34;
           <a name="::SendACmd(23)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;dmesg&#34;
           <a name="::SendACmd(24)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!/scratch/intern/jffs2dump -c -b /dev/hda7 | grep Dirent&#34;
           <a name="::result_error(27)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;CF is corrupted on DUT${whichDutNow} dump CF image for post analysis&#34;
           <a name="::SendACmd(25)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!rm /scratch/intern/config.img*&#34;
           <a name="::exSleep(15)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2;
           <a name="::SendACmd(26)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!dd if=/dev/hda7 of=/scratch/intern/config.img_DUT${whichDutNow}_$DUT1_IP bs=1024 count=16384&#34;
           <a name="::exSleep(16)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2;
           <a name="::SendACmd(27)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!gzip /scratch/intern/config.img*&#34;
           <a name="::ConfigGatewayNetwork(3)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
           <a name="::SendACmd(28)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ping vr [<a name="::GetVrString(3)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] 10.210.1.200&#34;
           <a name="::SendACmd(29)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;tftp put 10.210.1.200 vr [<a name="::GetVrString(4)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] /usr/local/tmp/config.img_DUT${whichDutNow}_$DUT1_IP.gz&#34;
           <a name="::SendACmd(30)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!rm /scratch/intern/config.img*&#34;
           <a name="::UnconfigGatewayNetwork(4)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
           if { [info exist regressionAbortReason] } {
                lappend regressionAbortReason &#34;{fatal} {BAD CF:DUT${whichDutNow}} {CF is corrupted on DUT${whichDutNow}}&#34;
           }
           return &#34;error&#34;
    } else {
           <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;CF is Good on DUT${whichDutNow}&#34;
           return &#34;ok&#34;
    }
    <a name="::DisableDebugMode(1)"><a href="./misc.tcl.html#::DisableDebugMode_2957">::DisableDebugMode</a></a> 
}

<strong><a name="::::login_exos_mariner_1645">proc <a href="login.tcl-annot.html#::::login_exos_mariner">::::login_exos_mariner</a></a></strong> { userid } {
    global spawn_id
    
        set timeout 60
    	send &#34;\r&#34;
<span class="comment-line">#        expect -re &#34;CM.\\\[PRIMARY\\\].\\\[READY\\\]&#34;</span>
    	expect {
    	    &#34;login:&#34; {
        	    send &#34;$userid\r&#34;
        	    expect &#34;password:&#34;
        	    send &#34;\r&#34;
            	expect &#34; #&#34;
        	}
        	&#34;#&#34;
    	}
	return 1
}

<strong><a name="::::login_exos_shell_1663">proc <a href="login.tcl-annot.html#::::login_exos_shell">::::login_exos_shell</a></a></strong> { userid } {
    global spawn_id
    
    sleep 2
    puts &#34;login_exos_shell&#34;
    for {set i 0} {$i &lt; 10} {incr i} {
	send &#34;$userid\r&#34;
	expect {
            &#34;Password:&#34; {
	       send &#34;\r&#34;
            }
            &#34;password:&#34; {
	       send &#34;\r&#34;
            }
        }
	expect {
	    &#34; # &#34; {
	     return 1
	   }
	    &#34; &gt; &#34; {
	     return 1
	   }
	}
   }
   return 0
}

<strong><a name="::::login_exos_i386_1690">proc <a href="login.tcl-annot.html#::::login_exos_i386">::::login_exos_i386</a></a></strong> { mode } {
    global spawn_id
    global downloadFile
    global env
    global PC_Platform_Type    ;<span class="comment-line"># Defined in cfg file</span>
    
    set pcPlatform 2
    if [info exists env(PC_PLATFORM_TYPE)] {
	;<span class="comment-line"># Environment variable takes precedence</span>
	set pcPlatform $env(PC_PLATFORM_TYPE)
    } elseif [info exists PC_Platform_Type] {
	set pcPlatform $PC_Platform_Type
    }

    send &#34;\r&#34;   ;<span class="comment-line"># send a \r to get the login prompt again</span>
    expect &#34;login:&#34;
	foreach letter {e x o s t e s t} {
	    send $letter
	    expect {
		&#34;$letter&#34; {
		    after 10
		}
		timeout {
		    for {set c 0} {$c&lt;10} {incr c} {
			send $letter
			expect {
			    &#34;$letter&#34; {
				break
			    }
			    timeout {
				after 10
			    }
			}
		    }
		}
	    }
	}
	send &#34;\r&#34;
	expect &#34;password:&#34;
	send &#34;exos1234\r&#34;
	expect &#34;\$ &#34; 
	send &#34;su\r&#34;
	expect &#34;password:&#34;
	send &#34;genesis1\r&#34;
	expect &#34;#&#34;
	send &#34;\r&#34;
	expect &#34;#&#34;

	send &#34;mkdir -p /root/hda1/exos\r&#34;
	expect &#34;#&#34;

	send &#34;cd /root/hda1/exos\r&#34;
	expect &#34;#&#34;
	send &#34;pwd\r&#34;
	expect &#34;#&#34;

	sleep 3
	send &#34;cd bin ; touch regression ; rm -f msm.cfg\r&#34;
	expect &#34;#&#34;
	send &#34;./exos stopall\r&#34;
	expect &#34;#&#34;
	sleep 3
	send &#34;cp -f ../config/reg$pcPlatform.cfg msm.cfg\r&#34;
	expect &#34;#&#34;
	send &#34;./exos mknod\r&#34;
	expect &#34;#&#34;
	send &#34;./exos startall\r&#34;
        set timeout 60
        expect -re &#34;CM.\\\[PRIMARY\\\].\\\[READY\\\]&#34;
    	send &#34;\r&#34;
    	expect {
    	    &#34;login:&#34; {
        	    send &#34;admin\r&#34;
        	    expect &#34;password:&#34;
        	    send &#34;\r&#34;
            	expect &#34; #&#34;
        	}
        	&#34;#&#34;
    	}
        set slotUp [<a name="::SendACmd(31)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show slot&#34;]
        set totalCount 1
        while {![regexp -nocase &#34;Operational&#34; $slotUp]&amp;&amp;$totalCount&lt;11} {
            puts &#34;Slot is not up in $totalCount retries. Wait 2 more seconds&#34;
            sleep 2
            set slotUp [<a name="::SendACmd(32)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show slot&#34;]
            incr totalCount
        }
        if {$totalCount&gt;10} {
           return -1
        }
puts &#34;--------------------------a1 ---------&#34;
	send &#34;config default del port all\r&#34;
puts &#34;--------------------------a2 ---------&#34;
	expect {
	    &#34; #&#34; {
	     return 1
	   }
	}
puts &#34;--------------------------a3 ---------&#34;
	return 0

puts &#34;--------------------------a4 ---------&#34;
}

<span class="comment-line">######################################################################</span>
<span class="comment-line"># Login a switch through serial comm. port 1 </span>
<span class="comment-line"># Parameters: fd: a file descriptor for log/debug purpose</span>
<span class="comment-line">######################################################################</span>

<strong><a name="::::login_nt_scom1_1799">proc <a href="login.tcl-annot.html#::::login_nt_scom1">::::login_nt_scom1</a></a></strong> {{fd &#34;NULL&#34;}} {
    global spawn_id
    <span class="comment-line"># s. comm initialization</span>
    set con [open com1 RDWR]
    fconfigure $con -buffering none -mode 9600,n,8,1  -blocking 0 \
	-buffersize 8192 -eofchar {} -translation auto
    if [catch &#34;spawn -open $con&#34; reason] {
	send_user &#34;failed to spawn program: $reason\n&#34;
	exit 1
    }

    <span class="comment-line">#initial talking with the switch</span>
    send &#34;\r&#34;
    expect {
	timeout {
	    <a name="::result_error(28)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Trouble talking with the switch;Check the hardware&#34;
	    exit
	}
	&#34;login:&#34; {
	    send &#34;admin\r&#34;                                    
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;password:&#34; {
	    send &#34;\r&#34;
	    expect &#34;login:&#34;
	    send &#34;admin\r&#34;
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;#&#34; {
	    send &#34;\r&#34;
	}
    }   
    expect &#34;#&#34;
}

<span class="comment-line">######################################################################</span>
<span class="comment-line"># Login a switch through serial comm. port 2 </span>
<span class="comment-line"># Parameters: fd: a file descriptor for log/debug purpose</span>
<span class="comment-line">######################################################################</span>

<strong><a name="::::login_nt_scom2_1839">proc <a href="login.tcl-annot.html#::::login_nt_scom2">::::login_nt_scom2</a></a></strong> {{fd &#34;NULL&#34;}} {
    global spawn_id
    <span class="comment-line"># s. comm initialization</span>
    set con [open com2 RDWR]
    fconfigure $con -buffering none -mode 9600,n,8,1  -blocking 0 \
	-buffersize 8192 -eofchar {} -translation auto
    if [catch &#34;spawn -open $con&#34; reason] {
	send_user &#34;failed to spawn program: $reason\n&#34;
	exit 1
    }

    <span class="comment-line">#initial talking with the switch</span>
    send &#34;\r&#34;
    expect {
	timeout {
	    <a name="::result_error(29)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Trouble talking with the switch; Check the hardware&#34;
	    exit
	}
	&#34;login:&#34; {
	    send &#34;admin\r&#34;                                    
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;password:&#34; {
	    send &#34;\r&#34;
	    expect &#34;login:&#34;
	    send &#34;admin\r&#34;
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;#&#34; {
	    send &#34;\r&#34;
	}
    }   
    expect &#34;#&#34;
}

<span class="comment-line">######################################################################</span>
<span class="comment-line"># Login a switch through serial comm. port 3 </span>
<span class="comment-line"># Parameters: fd: a file descriptor for log/debug purpose</span>
<span class="comment-line">######################################################################</span>

<strong><a name="::::login_nt_scom3_1879">proc <a href="login.tcl-annot.html#::::login_nt_scom3">::::login_nt_scom3</a></a></strong> {{fd &#34;NULL&#34;}} {
    global spawn_id
    <span class="comment-line"># s. comm initialization</span>
    set con [open com3 RDWR]
    fconfigure $con -buffering none -mode 9600,n,8,1  -blocking 0 \
	-buffersize 8192 -eofchar {} -translation auto
    if [catch &#34;spawn -open $con&#34; reason] {
	send_user &#34;failed to spawn program: $reason\n&#34;
	exit 1
    }

    <span class="comment-line">#initial talking with the switch</span>
    send &#34;\r&#34;
    expect {
	timeout {
	    <a name="::result_error(30)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Trouble talking with the switch; Check the hardware&#34;
	    exit
	}
	&#34;login:&#34; {
	    send &#34;admin\r&#34;                                    
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;password:&#34; {
	    send &#34;\r&#34;
	    expect &#34;login:&#34;
	    send &#34;admin\r&#34;
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;#&#34; {
	    send &#34;\r&#34;
	}
    }   
    expect &#34;#&#34;
}

<span class="comment-line">######################################################################</span>
<span class="comment-line"># Login a switch through serial comm. port 4 </span>
<span class="comment-line"># Parameters: fd: a file descriptor for log/debug purpose</span>
<span class="comment-line">######################################################################</span>

<strong><a name="::::login_nt_scom4_1919">proc <a href="login.tcl-annot.html#::::login_nt_scom4">::::login_nt_scom4</a></a></strong> {{fd &#34;NULL&#34;}} {
    global spawn_id
    <span class="comment-line"># s. comm initialization</span>
    set con [open com4 RDWR]
    fconfigure $con -buffering none -mode 9600,n,8,1  -blocking 0 \
	-buffersize 8192 -eofchar {} -translation auto
    if [catch &#34;spawn -open $con&#34; reason] {
	send_user &#34;failed to spawn program: $reason\n&#34;
	exit 1
    }

    <span class="comment-line">#initial talking with the switch</span>
    send &#34;\r&#34;
    expect {
	timeout {
	    <a name="::result_error(31)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Trouble talking with the switch; Check the hardware&#34;
	    exit
	}
	&#34;login:&#34; {
	    send &#34;admin\r&#34;                                    
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;password:&#34; {
	    send &#34;\r&#34;
	    expect &#34;login:&#34;
	    send &#34;admin\r&#34;
	    expect &#34;password:&#34;
	    send &#34;\r&#34;
	} &#34;#&#34; {
	    send &#34;\r&#34;
	}
    }   
    expect &#34;#&#34;
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: _clearDutConnectionVars</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: internal proc that sends clears spawn_ids array entry</span>
<span class="comment-line">#      and removes console ip from hostname list</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: string : dut number</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         _clearDutConnectionVars $whichDutNow</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_clearDutConnectionVars_1969">proc <a href="login.tcl-annot.html#::::_clearDutConnectionVars">::::_clearDutConnectionVars</a></a></strong> {myDUT} {
    global spawn_id spawn_ids
    global hostname
    global DUT${myDUT}_CONNECT
    global DUT${myDUT}_IP
    global MGMT_REG

    if {[info exists hostname]} {
        puts &#34;Pre Clear Hostnames: $hostname&#34;
    }
    <a name="::result_debug(73)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Clear All Sessions and reset global variables to DUT $myDUT&#34;
    <span class="comment-line"># Clear all other spawn_ids for this DUT.</span>
    set sCloseList &#34;&#34;
    set console [set DUT${myDUT}_CONNECT];<span class="comment-line"># console IP for this DUT</span>
    if {[info exists spawn_ids($console)] &amp;&amp; $spawn_ids($console) != &#34;INVALID&#34;} {
        lappend sCloseList $spawn_ids($console)
        catch {close -i $spawn_ids($console)} myr
        catch {wait} myr
        set hostname [<a name="::ldelete(2)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $hostname $console]
        set spawn_ids($console) &#34;INVALID&#34;
    }
    set console_mgmt [set DUT${myDUT}_IP];<span class="comment-line"># mgmt IP for this DUT</span>
    if {[info exists spawn_ids($console_mgmt)] &amp;&amp; $spawn_ids($console_mgmt) != &#34;INVALID&#34;} {
        lappend sCloseList $spawn_ids($console_mgmt)
        catch {close -i $spawn_ids($console_mgmt)} myr
        catch {wait} myr
        set hostname [<a name="::ldelete(3)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $hostname $console_mgmt]
        set spawn_ids($console_mgmt) &#34;INVALID&#34;
    }
    set msmList &#34;B C D E F G H&#34;
    foreach m $msmList {
        global DUT${myDUT}_CONNECT${m}
        if {[info exists DUT${myDUT}_CONNECT${m}]} {
            set mmconsole [set DUT${myDUT}_CONNECT${m}]
            if {[info exists spawn_ids($mmconsole)] &amp;&amp; $spawn_ids($mmconsole) != &#34;INVALID&#34;} {
                lappend sCloseList $spawn_ids($mmconsole)
                catch {close -i $spawn_ids($mmconsole)} myr
                catch {wait} myr
                set hostname [<a name="::ldelete(4)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $hostname $mmconsole]
                set spawn_ids($mmconsole) &#34;INVALID&#34;
            }
        }
    }
    if {[lsearch $sCloseList $spawn_id] &lt; 0} {
        foreach hn $hostname {
            if {[info exists spawn_ids($hn)] &amp;&amp; $spawn_ids($hn) == $spawn_id} {
                puts &#34;Found host $hn missed spawn_id clear&#34;
                set hostname [<a name="::ldelete(5)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $hostname $hn]
                set spawn_ids($hn) &#34;INVALID&#34;
            }
        }
        puts &#34;Missed the current open spawn_id. Close it.&#34;
        catch {close -i $spawn_id} myr
    }
    <span class="comment-line"># -----------------------------------------------------------</span>
    <span class="comment-line">#  Build a regexp to get the telnet proc id</span>
    <span class="comment-line">#        need to match telnet / console ip / console tcp port</span>
    <span class="comment-line"># -----------------------------------------------------------</span>
    set consoleList [split $console &#34; &#34;]
    set newConsoleList &#34;&#34;
    foreach cPart $consoleList {
        if {[string trim $cPart] != &#34;&#34;} {
            <span class="comment-line"># Avoid white space</span>
            lappend newConsoleList [string trim $cPart]
        }
    }
    set consoleRegexp [join $newConsoleList &#34;\.\*&#34;]
    <span class="comment-line"># this should equal to telnet.*consoleIp.*consoleTCPPort or</span>
    <span class="comment-line">#                      telnet.*consoleIp</span>
    set telnetRegexp &#34;telnet\.\*$consoleRegexp&#34;
    <span class="comment-line">#result_debug &#34;\n@@@@@ G E T  C O N S O L E   T E L N E T   S T A T E: $telnetRegexp @@@@@&#34;</span>
    <span class="comment-line"># Get the ps line</span>
    set psLine [catch {exec ps -eafwww | egrep -e &#34;$telnetRegexp&#34; | grep -v grep} psout]
    <span class="comment-line">#result_debug &#34;@@@@@ PS: $psout&#34;</span>
    <span class="comment-line"># If a valid line was returned, there is still a telnet opened that must die.</span>
    if {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
        <a name="::result_debug(74)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Active telnet still open to ${console} !  PID:[lindex $psout 1]  Kill it!&#34;
        catch {exec kill -9 [lindex $psout 1]} retValue
        if {$retValue==1} {
            <a name="::result_debug(75)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Failed to kill the telnet process.  There may be an issue.&#34;
        }
    } else {
        <a name="::result_debug(76)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No active telnet detected&#34;
        <span class="comment-line">#ClearConsoleDUT $myDUT</span>
    }
    <span class="comment-line"># -----------------------------------------------------------</span>
    <span class="comment-line">#  Build a regexp to get the telnet proc id</span>
    <span class="comment-line">#        need to match telnet / console ip / console tcp port</span>
    <span class="comment-line"># -----------------------------------------------------------</span>
    set consoleList [split $console_mgmt &#34; &#34;]
    set newConsoleList &#34;&#34;
    foreach cPart $consoleList {
        if {[string trim $cPart] != &#34;&#34;} {
            <span class="comment-line"># Avoid white space</span>
            lappend newConsoleList [string trim $cPart]
        }
    }
    set consoleRegexp [join $newConsoleList &#34;\.\*&#34;]
    <span class="comment-line"># this should equal to telnet.*consoleIp.*consoleTCPPort or</span>
    <span class="comment-line">#                      telnet.*consoleIp</span>
    set telnetRegexp &#34;telnet\.\*$consoleRegexp&#34;
    <span class="comment-line">#result_debug &#34;\n@@@@@ G E T   MGMT  T E L N E T   S T A T E: $telnetRegexp @@@@@&#34;</span>
    <span class="comment-line"># Get the ps line</span>
    set psLine [catch {exec ps -eafwww | egrep -e &#34;$telnetRegexp&#34; | grep -v grep} psout]
    <span class="comment-line">#result_debug &#34;@@@@@ PS: $psout&#34;</span>
    <span class="comment-line"># If a valid line was returned, there is still a telnet opened that must die.</span>
    if {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
        <a name="::result_debug(77)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Active telnet still open to ${console} !  PID:[lindex $psout 1]  Kill it!&#34;
        catch {exec kill -9 [lindex $psout 1]} retValue
        if {$retValue==1} {
            <a name="::result_debug(78)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Failed to kill the telnet process.  There may be an issue.&#34;
        }
    } else {
        <a name="::result_debug(79)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No active telnet detected&#34;
    }
    puts &#34;Post Clear hostname $hostname&#34;
    <a name="::result_debug(80)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping for 2 seconds before re-trying login&#34;
    <a name="::exSleep(17)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: _printModuleNameOnIOBConsole </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: utility proc that sends a user defined message to IO console </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: string : DUTNum &#34;DUT number&#34;</span>
<span class="comment-line">#                    : reasonString &#34;message user want to send to IO&#34;</span>
<span class="comment-line">#                    : moduleName &#34;currenly running module name&#34; </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#  _printModuleNameOnIOBConsole 1 &#34;Starting&#34; &#34;AnycastRp&#34;</span>
<span class="comment-line">#  _printModuleNameOnIOBConsole 1 &#34;ending&#34; &#34;AnycastRp&#34;</span>
<span class="comment-line">#  _printModuleNameOnIOBConsole 1 &#34;vlanCreate&#34; &#34;AnycastRp&#34;</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::_printModuleNameOnIOBConsole_2106">proc <a href="login.tcl-annot.html#::::_printModuleNameOnIOBConsole">::::_printModuleNameOnIOBConsole</a></a></strong> {DUTNum {reasonString &#34;Starting&#34;} {moduleName &#34;&#34;} } {
    global DUTs_info MAIN
    global currentTestNumber
    if { ![info exists currentTestNumber] } {
        set tempCurrentTestNumber &#34;main&#34;
    } else {
        set currentTestNumber [string trim $currentTestNumber]
        if {[regexp {(.*) *;.*} $currentTestNumber match match1]} {
            set tempCurrentTestNumber $match1
        } else {
            set tempCurrentTestNumber $currentTestNumber
        }
        set tempCurrentTestNumber [string trim $tempCurrentTestNumber]
    }
    if {$moduleName == &#34;NULL&#34; } {
        set moduleName MAIN(feature_directory);
    }
    global DUT${DUTNum}_CONNECT
    <a name="::Login(21)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${DUTNum}_CONNECT]
    set slotNumber 1
    foreach slot $DUTs_info(DUT${DUTNum},hwList) {
        if {[regexp -nocase &#34;Empty&#34; $slot]} {
           incr slotNumber;
           continue;
        }
	<a name="::EnableDebugMode(3)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
        <a name="::SendACmd(33)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!telnet -v 1 10.0.${slotNumber}.2&#34;
        <a name="::SendACmd(34)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;echo \&#34;$reasonString\&#34; &gt; /tmp/testRunningReason.txt&#34;
        <a name="::exSleep(18)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
        <a name="::SendACmd(35)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;echo \&#34;$moduleName\&#34; &gt;/tmp/testRunningModule.txt&#34;
        <a name="::exSleep(19)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
        <a name="::SendACmd(36)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;echo \&#34;$tempCurrentTestNumber\&#34; &gt;/tmp/testRunningTestNumber.txt&#34;
        <a name="::exSleep(20)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
        <a name="::SendACmd(37)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;echo \&#34;$DUTs_info(DUT${DUTNum},version)\&#34; &gt;/tmp/releaseVersion.txt&#34;
         <a name="::exSleep(21)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
         <a name="::SendACmd(38)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;viohaldbg &lt; /tmp/testRunningReason.txt&#34;
         <a name="::exSleep(22)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
         <a name="::SendACmd(39)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;viohaldbg &lt; /tmp/testRunningModule.txt&#34;
         <a name="::exSleep(23)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
         <a name="::SendACmd(40)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;viohaldbg &lt; /tmp/testRunningTestNumber.txt&#34;
         <a name="::exSleep(24)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
         <a name="::SendACmd(41)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;viohaldbg &lt; /tmp/releaseVersion.txt&#34;
         <a name="::exSleep(25)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
         send &#34;exit\r&#34;
         <a name="::exSleep(26)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2 
         send &#34;\r&#34;
         <a name="::SendACmd(42)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;&#34;
         incr slotNumber;
    }

}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: showModuleNameOnAll_DUTs_IOBConsole </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  utility function </span>
<span class="comment-line">#</span>
<span class="comment-line"># Its purpose is to show module name on all DUTs IOB console </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: At present no input argument</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::showModuleNameOnAll_DUTs_IOBConsole_2168">proc <a href="login.tcl-annot.html#::::showModuleNameOnAll_DUTs_IOBConsole">::::showModuleNameOnAll_DUTs_IOBConsole</a></a></strong> { {reasonString &#34;Starting&#34;} {moduleName &#34;&#34;} } {
global numDUT
global pioneerPlatform
    for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
    set platform [<a name="::GetPlatform(9)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT$dut]
	if {[regexp -nocase $pioneerPlatform [<a name="::GetPlatform(10)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT$dut]]} {
           <a name="::_printModuleNameOnIOBConsole(1)"><a href="./login.tcl.html#::_printModuleNameOnIOBConsole_2106">::_printModuleNameOnIOBConsole</a></a> $dut $reasonString $moduleName
        }
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: LoginWithFailSafe</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Clear previous telnet, spawn a telnet session</span>
<span class="comment-line">#               and send failsafe login info</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dut number</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LoginWithFailSafe_2188">proc <a href="login.tcl-annot.html#::::LoginWithFailSafe">::::LoginWithFailSafe</a></a></strong> {args} {
    global TRYFAILSAFE MGMT_REG whichDutNow connectionTimeout
    global spawn_id whichDutNow whichMsmNow FAILCOUNT

    <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> Login $args {
        dut &#34;1&#34;
    }

    if {![info exists FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))]} {
        set FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType)) 0
    }
    incr FAILCOUNT(${whichDutNow}${whichMsmNow},$MGMT_REG(connType))

    global DUT${dut}_CONNECT  DUT${dut}_CONNECTB DUT${dut}_CONNECTC
    global DUT${dut}_CONNECTD DUT${dut}_CONNECTE DUT${dut}_CONNECTF

    if {[info exists whichMsmNow] &amp;&amp; ($whichMsmNow == &#34;B&#34; || \
        $whichMsmNow == &#34;C&#34; || $whichMsmNow == &#34;D&#34; || $whichMsmNow == &#34;E&#34; || \
        $whichMsmNow == &#34;F&#34;)} {
        <a name="::result_debug(81)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Clear the consoles on MSM $whichMsmNow&#34;
        <a name="::_clearDutConnectionVars(7)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> ${dut}_${whichMsmNow}
    } else {
        <a name="::result_debug(82)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Clear the consoles on MSM-A&#34;
        <a name="::_clearDutConnectionVars(8)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $dut
    }
    <span class="comment-line">#exSleep 2</span>

    if {[info exists DUT${dut}_CONNECT${whichMsmNow}]} {
        set cmd &#34;spawn telnet [set DUT${dut}_CONNECT${whichMsmNow}]&#34;
        if [catch &#34;$cmd&#34; reason] {
            <a name="::result_debug(83)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;failed to spawn program: $reason\n&#34;
            <a name="::result_error(32)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;failed to spawn program: $reason\n&#34;
            return;
        }
        <a name="::result_debug(84)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Logged in with spawnid $spawn_id&#34;
        set timeout 3
        <span class="comment-line">#wait for connection</span>
        expect {
            &#34;?onnection refused&#34; {
                <a name="::result_debug(85)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;refused&#34;
                exp_continue;
            }
            &#34;?nable to ?onnect&#34; {
                <a name="::result_debug(86)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;unable to connect&#34;
                exp_continue;
            }
            &#34;?onnected to&#34; {
                <a name="::result_debug(87)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Successful Connection&#34;
            }
        }
        <span class="comment-line">#run the failsafe</span>
        <a name="::FailSafeForceful(1)"><a href="./SendSwCmd.tcl.html#::FailSafeForceful_15">::FailSafeForceful</a></a>
        close -i $spawn_id
        wait
        <a name="::exSleep(27)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 4
    }

    if [info exists connectionTimeout] {
        set timeout $connectionTimeout
    }
    <a name="::Login(22)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT${whichMsmNow}] -CheckOperational 0 -masterCheck 1
}
<span class="comment-line">####################################################################################</span>
<span class="comment-line"># Procedure: CLIConnectMode</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#################################################################################### </span>
<strong><a name="::::CLIConnectMode_2263">proc <a href="login.tcl-annot.html#::::CLIConnectMode">::::CLIConnectMode</a></a></strong>  {args} {
    global MGMT_REG MAIN RemoveMgmtNetwork whichDutNow whichMsmNow
    global hostname 
    global spawn_id
    global spawn_ids

    <a name="::parse_args(5)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CLIConnectMode $args {
        mode    &#34;console&#34;
        action  &#34;setup&#34;
        a       &#34;null&#34;
        loseCfg &#34;no&#34;
        l       &#34;null&#34;
        dut     &#34;null&#34;
        msm     &#34;&#34;
    }
    <span class="comment-line"># set short args</span>
    if {$l != &#34;null&#34;} {
        set loseCfg $l
    }
    if {$a != &#34;null&#34;} {
        set action $a
    }
    if {$dut == &#34;null&#34;} {
        global DUT${whichDutNow}_IP
        global DUT${whichDutNow}_CONNECT DUT${whichDutNow}_CONNECTB
        set initconn [set DUT${whichDutNow}_CONNECT${whichMsmNow}]
        set initip   [set DUT${whichDutNow}_IP]
    } else {
        global DUT${dut}_IP
        global DUT${dut}_CONNECT DUT${dut}_CONNECTB
        set initconn [set DUT${dut}_CONNECT${msm}]
        set initip   [set DUT${dut}_IP]
    }
    if {$action == &#34;setup&#34;} {
        set ll [<a name="::::ProcEvalTree(1)"><a href="./tpbMainLib.tcl.html#::::ProcEvalTree_295">::::ProcEvalTree</a></a>]
        if {[regexp -nocase &#34;executetests&#34; [lindex $ll 0]]} {
            puts &#34;This is a test case level setting.&#34;
            set MGMT_REG(cliConnectLevel) &#34;testcase&#34;;
        } else {
            set MGMT_REG(cliConnectLevel) &#34;harness&#34;;
        }

        if {[regexp -nocase &#34;tel&#34; $mode]} {
            set RemoveMgmtNetwork 0
            if {$MGMT_REG(telnetNeedsConfig) &gt; 0} {
                <a name="::::_ConfigMgmtNetworkAll(2)"><a href="./SystemSetup.tcl.html#::::_ConfigMgmtNetworkAll_3115">::::_ConfigMgmtNetworkAll</a></a>
            }
            set MGMT_REG(useTelnetGlobalFlag) 1; <span class="comment-line"># &lt;&lt; Switch on telnet of mgmt vs console</span>
            set MGMT_REG(useTelnetLocalFlag) 1; <span class="comment-line">#just initializing var</span>
            set MGMT_REG(currentConnectionType) &#34;telnet&#34;
            set MGMT_REG(forceConsole) 0
            puts &#34;Telnet execution mode is selected&#34;
        } else {
            set MGMT_REG(useTelnetGlobalFlag) 0; <span class="comment-line"># &lt;&lt; Switch on telnet of mgmt vs console</span>
            set MGMT_REG(useTelnetLocalFlag) 0; <span class="comment-line">#just initializing var</span>
            set MGMT_REG(forceConsole) 1;
            set MGMT_REG(currentConnectionType) &#34;console&#34;
            puts &#34;Terminal server execution mode is selected&#34;
        }
    } elseif {$action == &#34;disable&#34;} {
        if {$MGMT_REG(useTelnetGlobalFlag) &amp;&amp; $MGMT_REG(useTelnetLocalFlag) &amp;&amp; \
             $MGMT_REG(currentConnectionType) == &#34;telnet&#34; &amp;&amp; \
             $MGMT_REG(cliConnectLevel) == &#34;testcase&#34;} {
            set MGMT_REG(useTelnetGlobalFlag) 0; <span class="comment-line"># &lt;&lt; Switch on telnet of mgmt vs console</span>
            set MGMT_REG(useTelnetLocalFlag) 0; <span class="comment-line">#just initializing var</span>
            set MGMT_REG(forceConsole) 1;
            set MGMT_REG(currentConnectionType) &#34;console&#34;
            puts &#34;Terminal server execution mode is selected&#34;
            <a name="::Login(23)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $initconn  -masterCheck 0 -CheckOperational 0
        }
    } elseif {[regexp -nocase &#34;force&#34; $action]} {
        if {$MGMT_REG(useTelnetGlobalFlag) &amp;&amp; $MGMT_REG(useTelnetLocalFlag) &amp;&amp; \
             $MGMT_REG(currentConnectionType) == &#34;telnet&#34;} {
            set MGMT_REG(useTelnetLocalFlag) 1; <span class="comment-line">#just initializing var</span>
            set MGMT_REG(forceConsole) 1;
            if {[regexp -nocase &#34;y&#34; $loseCfg]} {
                <span class="comment-line">#find out the ipAddr of this session in case this is not a console connection</span>
                <span class="comment-line">#this is the address to use if we need to spawn telnet again after</span>
                <span class="comment-line">#unconfig sw</span>
                set ipAddr NULL
                foreach name $hostname {
                    if { $spawn_id == $spawn_ids($name) } {
                        set ipAddr $name
                    }
                }
                puts &#34;matchy $ipAddr == $initip&#34;
                if {$ipAddr == $initip} {
                    puts &#34;The IP connection is vunerable to clearing with cfg&#34;
                }
                set MGMT_REG(telnetNeedsConfig) 1
                set hostname [<a name="::ldelete(6)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> &#34;$hostname&#34; &#34;$initip&#34;];
            }
            puts &#34;Use Terminal server temporarily&#34;
            <a name="::Login(24)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $initconn  -masterCheck 0 -CheckOperational 0
        }
    } elseif {[regexp -nocase &#34;reconf&#34; $action]} {
        if {$MGMT_REG(useTelnetGlobalFlag) &amp;&amp; $MGMT_REG(useTelnetLocalFlag) &amp;&amp; \
             $MGMT_REG(currentConnectionType) == &#34;telnet&#34; &amp;&amp; $MGMT_REG(forceConsole)} {
            set MGMT_REG(telnetNeedsConfig) 1
            set hostname [<a name="::ldelete(7)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> &#34;$hostname&#34; &#34;$initip&#34;];
            set MGMT_REG(forceConsole) 0
            <a name="::Login(25)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $initconn -masterCheck 0 -CheckOperational 0
        }
    }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
