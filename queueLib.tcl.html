<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>queueLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#queueLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>queueLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="queueLib.tcl-annot.html">annotations</a> | <a href="queueLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: logCaller</span>
<span class="comment-line">#</span>
<span class="comment-line"># Desc: displays the name of the calling procedure</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical: [logCaller]</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::logCaller_12">proc <a href="queueLib.tcl-annot.html#::::logCaller">::::logCaller</a></a></strong> {} {
    set r [catch {info level [expr [info level] - 2]} e]
    if {$r} {
        puts &#34;Called directly by the interpreter (e.g.: .tcl on the partyline).&#34;
    } {
        puts &#34;Called by ${e}.&#34;
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: VerifyPlatformType</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Verifies the platform types from user input</span>
<span class="comment-line">#              takes the default platformTypes from runReg.cfg inside ../Util</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: platform</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             if {[VerifyPlatformType $platformType]==-1} {</span>
<span class="comment-line">#             }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyPlatformType_36">proc <a href="queueLib.tcl-annot.html#::::VerifyPlatformType">::::VerifyPlatformType</a></a></strong> {platform} {
   global DEVREG
   return [lsearch -exact $DEVREG(server,platformsSupported) $platform]
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: FileOpen</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Opens the file with fileMode, locks it for read/write</span>
<span class="comment-line">#              and returns the file descriptor to caller</span>
<span class="comment-line">#              FileName is the absolute file path</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: FileName, fileMode</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             if {[set fd_out [FileOpen $priorityFile a]]==-1} {</span>
<span class="comment-line">#             }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::FileOpen_58">proc <a href="queueLib.tcl-annot.html#::::FileOpen">::::FileOpen</a></a></strong> {fileName fileMode {reason &#34;&#34;}} {
   global DEVREG
   upvar $reason fd_out
   package require Tclx
   if {[catch {open $fileName $fileMode} fd_out]} {
      after 1500  ;<span class="comment-line"># if it hit instance of update, try once again</span>
      if {[catch {open $fileName $fileMode} fd_out]} {
         <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot open $fileName for $fileMode, $fd_out&#34;;
         return -1
      }
   } else {
       <span class="comment-line">#puts &#34;File open fail: $fileName . Exists? [file isfile $fileName]&#34;</span>
   }
   if {$fileMode==&#34;r&#34;} {
      if {[catch {flock -read -nowait $fd_out} why]} {
          puts &#34;Attempted RO flock of $fileName failed - $why&#34;
      }
   } else {
      if {[catch {flock $fd_out} why]} {
          puts &#34;Attempted RW flock of $fileName failed - $why&#34;
      }
   }
   return $fd_out
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: SetPriorityFile</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Opens the priorityFile, appends the id at the end</span>
<span class="comment-line">#              priorityFile is only located in imagesQueued dir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: id</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             SetPriorityFile $queueId</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::SetPriorityFile_98">proc <a href="queueLib.tcl-annot.html#::::SetPriorityFile">::::SetPriorityFile</a></a></strong> {id} {
   global DEVREG

   set id [string trim $id &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
   if {![regexp {[A-Z]{3,3}_[0-9]{6,6}_[0-9]{6,6}} $id]} {
       puts &#34;\n!!!\n!!!\n!!! BAD BAD BAD queueid $id !!!\n!!!\n!!!&#34;
       error &#34;BAD BAD BAD queueid $id&#34;
   }
   if {![file exists $DEVREG(server,priorityFile)]} {
      if {[set fd_out [<a name="::FileOpen(1)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,priorityFile) a]]==-1} {
         return $fd_out
      }
      puts $fd_out &#34;$id&#34;
      funlock $fd_out
      chmod 0777 $DEVREG(server,priorityFile)
   } else {
      if {[set fd_out [<a name="::FileOpen(2)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,priorityFile) a+]]==-1} {
         return $fd_out
      }
      puts $fd_out &#34;$id&#34;
      funlock $fd_out
   }
   close $fd_out   
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: locked</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Checks the lockFile inside regressionDir for </span>
<span class="comment-line">#              existance of cfgFile.</span>
<span class="comment-line">#              If a test bed regServer is locked, it is entered in</span>
<span class="comment-line">#              lockFile.</span>
<span class="comment-line">#              cfgFile is the tail of the cfgFile path</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cfgFile</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             if {[locked $cfgFileTail]} {</span>
<span class="comment-line">#             }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::locked_142">proc <a href="queueLib.tcl-annot.html#::::locked">::::locked</a></a></strong> {cfgFile} {
   global DEVREG
   
   if {[set fd_in [<a name="::FileOpen(3)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) r]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      if {[regexp -nocase $cfgFile $line]} {
         <span class="comment-line">####if [string compare $line $cfgFile]==0</span>
         close $fd_in
         return 1
      }
   }
   funlock $fd_in
   close $fd_in
   return 0
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: autolocked</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Checks the lockFile inside regressionDir for </span>
<span class="comment-line">#              existance of !cfgFile.</span>
<span class="comment-line">#              If a test bed regServer is locked, it is entered in</span>
<span class="comment-line">#              lockFile.</span>
<span class="comment-line">#              cfgFile is the tail of the cfgFile path</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cfgFile</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             if {[autolocked $cfgFileTail]} {</span>
<span class="comment-line">#             }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::autolocked_178">proc <a href="queueLib.tcl-annot.html#::::autolocked">::::autolocked</a></a></strong> {cfgFile} {
   global DEVREG
   
   if {[set fd_in [<a name="::FileOpen(4)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) r]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      if {[regexp -nocase &#34;!$cfgFile&#34; $line]} {
         close $fd_in
         return 1
      }
   }
   funlock $fd_in
   close $fd_in
   return 0
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: runningServers</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: returns the list of regServers currently running</span>
<span class="comment-line">#              on the server. Performs a ps and egrep.</span>
<span class="comment-line">#              1 in case of error.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set unlockTestbeds [runningServers]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::runningServers_210">proc <a href="queueLib.tcl-annot.html#::::runningServers">::::runningServers</a></a></strong> {} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e &#34;regServer.tcl.*cfg&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds &#34;&#34;
      set fd_tmp [<a name="::FileOpen(5)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
<span class="comment-line">#      result_debug &#34;the psLines $psLines&#34;</span>
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         if {[lsearch $unlockTestbeds $fileTail]==-1} {
            lappend unlockTestbeds $fileTail
         }
      }
      return $unlockTestbeds
   } else {
      return $psOut
   }
}

<strong><a name="::::runningServerTypes_237">proc <a href="queueLib.tcl-annot.html#::::runningServerTypes">::::runningServerTypes</a></a></strong> {srvrName} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e &#34;regServer.tcl.*$srvrName&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds &#34;&#34;
      set fd_tmp [<a name="::FileOpen(6)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
<span class="comment-line">#      result_debug &#34;the psLines $psLines&#34;</span>
      foreach psLine $psLines {
      set regTypeIndex [lsearch $psLine &#34;-regressionType&#34;]
      set platTypeIndex [lsearch $psLine &#34;-platformType&#34;]
      set serverRegTypeName [lindex $psLine [expr $regTypeIndex+1]]
      set serverPlatTypeName [lindex $psLine [expr $platTypeIndex+1]]
      }
      return &#34;$serverRegTypeName $serverPlatTypeName&#34;
   } else {
      return $psOut
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::allRunningServerTypes_265">proc <a href="queueLib.tcl-annot.html#::::allRunningServerTypes">::::allRunningServerTypes</a></a></strong> {} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e &#34;regServer.tcl.*&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds &#34;&#34;
      set fd_tmp [<a name="::FileOpen(7)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
<span class="comment-line">#      result_debug &#34;the psLines $psLines&#34;</span>
      foreach psLine $psLines {
          set regTypeIndex [lsearch $psLine &#34;-regressionType&#34;]
          set platTypeIndex [lsearch $psLine &#34;-platformType&#34;]
          set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
          set serverRegTypeName [lindex $psLine [expr $regTypeIndex+1]]
          set serverPlatTypeName [lindex $psLine [expr $platTypeIndex+1]]
          set cfg [lindex $psLine [expr $cfgIndex+1]]
          set cfg [file tail $cfg]
          set RUNREGINFO(platCfg,null,$cfg) &#34;$serverPlatTypeName&#34;
          set RUNREGINFO(typeCfg,null,$cfg) &#34;$serverRegTypeName&#34;
          set RUNREGINFO(platCfgTypeName,$serverRegTypeName,$serverPlatTypeName) &#34;$cfg&#34;
          set RUNREGINFO(platType,$cfg,$serverPlatTypeName) &#34;$serverRegTypeName&#34;
          set RUNREGINFO(platCfgNameType,$serverPlatTypeName,$serverRegTypeName) &#34;$cfg&#34;
      }
      return [array get RUNREGINFO]
   } else {
      return $psOut
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: lockUnlockSetup</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: gets Called by only controlReg utility.</span>
<span class="comment-line">#              only meant to perform lock or unlock test bed servers</span>
<span class="comment-line">#              modifies lockFile based on the user choice.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set  retValue [lockUnlockSetup]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::lockUnlockSetup_313">proc <a href="queueLib.tcl-annot.html#::::lockUnlockSetup">::::lockUnlockSetup</a></a></strong> {} {
   global DEVREG

   while {1} {
      puts &#34;\n&#34;
      puts &#34;(1). Lock an unlocked test bed.&#34;
      puts &#34;(2). Unlock a locked test bed.&#34;
      puts &#34;(3). Lock all unlocked test beds.&#34;
      puts &#34;(4). Unlock all locked test beds.&#34;
      puts -nonewline &#34;Please select one of the above options\[1/2\]:&#34;
      flush stdout;
      gets stdin lockUnlockVal;
      if {[regexp -nocase {(^[1] [0-9a-z]+$)|[1-4]} $lockUnlockVal ach lreg]} {
         break
      }
   }
   set srch 0
   if {[string trim $lreg] != &#34;&#34;} {
       set lregString [lindex $lreg 1]
       set srch 1
       set lockUnlockVal 1
       puts &#34;Searching for $lregString&#34;
   }

   if {$lockUnlockVal==1} {  ;<span class="comment-line"># lock an unlocked test bed</span>
      puts &#34;Currently unlocked test bed server(s):&#34;
      puts &#34;=====================================&#34;
      set unlockTestbeds [<a name="::runningServers(1)"><a href="./queueLib.tcl.html#::runningServers_210">::runningServers</a></a>]
      if {$unlockTestbeds!=1} {
      foreach unlockTestbed $unlockTestbeds {
         if {$srch &amp;&amp; ![regexp -nocase &#34;$lregString&#34; $unlockTestbed]} {continue;}
         if {![<a name="::locked(1)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $unlockTestbed]} {
            puts &#34;$unlockTestbed&#34;
         }
      }
      while {1} {
         puts &#34;\n&#34;
         puts -nonewline &#34;Please enter one of above running test beds to be locked:&#34;
         flush stdout;
         gets stdin lockTestbed
         if {[lsearch -exact $unlockTestbeds $lockTestbed]!=-1} {
            break
         } else {
            <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Test bed: $lockTestbed is not running amongst: $unlockTestbeds&#34;
         }
      }
      <span class="comment-line">### Check if the lockTestbed is already locked</span>
      if {[<a name="::locked(2)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $lockTestbed]} {
         <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;The test bed: $lockTestbed is already locked&#34;
         return -1
      } else {   ;<span class="comment-line"># lock it in $DEVREG(server,lockFile)</span>
         if {[set fd_out [<a name="::FileOpen(8)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
            return $fd_out
         }
         puts $fd_out $lockTestbed
         funlock $fd_out
         close $fd_out
         <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully locked test bed: $lockTestbed&#34;
         return 1
      }
      } else {
         <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No test bed server is currently running&#34;
         return -1
      }
   } elseif {$lockUnlockVal==2} {   ;<span class="comment-line"># unlock an alredy locked test bed</span>
      set lines &#34;&#34;
      puts &#34;Currently locked test bed(s):&#34;
      puts &#34;=============================&#34;
      if {[set fd_in [<a name="::FileOpen(9)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) r]]==-1} {
         return $fd_in
      }
      while {[gets $fd_in line]!=-1} {
         puts &#34;$line&#34;
         lappend lines $line
      }
      funlock $fd_in
      close $fd_in
      if {$lines!=&#34;&#34;} {
      while {1} {
         puts &#34;\n&#34;
         puts -nonewline &#34;Please enter one of above locked test beds:&#34;
         flush stdout;
         gets stdin unlockTestbed;
         if {[lsearch -exact $lines $unlockTestbed]!=-1} {
            break
         } else {
            <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Test bed: $unlockTestbed is not locked amongst: $lines&#34;
         }
      }
      if {[set fd_out [<a name="::FileOpen(10)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) w]]==-1} {
         return $fd_out
      }
      foreach line $lines {
         if {![regexp -nocase $unlockTestbed $line]} {
            <span class="comment-line">#if [string compare $line $unlockTestbed]!=0</span>
            puts $fd_out $line 
         }
      }
      close $fd_out
      <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully unlocked test bed: $unlockTestbed&#34;
      return 1
      } else {
         <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No test bed server is currently locked&#34;
         return -1
      }
   } elseif {$lockUnlockVal==3} {   ;<span class="comment-line"># lock all unlock test beds</span>
      set unlockTestbeds [<a name="::runningServers(2)"><a href="./queueLib.tcl.html#::runningServers_210">::runningServers</a></a>]
      if {$unlockTestbeds==1} {<a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No server running&#34;; return -1&#34;}
      <span class="comment-line">### Check if the lockTestbed is already locked</span>
      foreach unlockTestbed $unlockTestbeds {
         if {[<a name="::locked(3)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $unlockTestbed]} {
            <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The test bed: $unlockTestbed is already locked&#34;
         } else {   ;<span class="comment-line"># lock it in $DEVREG(server,lockFile)</span>
            if {[set fd_out [<a name="::FileOpen(11)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
               return $fd_out
            }
            puts $fd_out $unlockTestbed
            funlock $fd_out
            close $fd_out
            <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully locked test bed: $unlockTestbed&#34;
         }
      }
      return 1
   } elseif {$lockUnlockVal==4} {    ;<span class="comment-line"># Unlock all locked testbeds</span>
      set lines &#34;&#34;
      puts &#34;Currently locked test bed(s):&#34;
      puts &#34;=============================&#34;
      if {[set fd_in [<a name="::FileOpen(12)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) r]]==-1} {
         return $fd_in
      }
      while {[gets $fd_in line]!=-1} {
         puts &#34;$line&#34;
         lappend lines $line
      }
      funlock $fd_in
      close $fd_in
      if {$lines!=&#34;&#34;} {
         if {[set fd_out [<a name="::FileOpen(13)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) w]]==-1} {
            return $fd_out
         }
         close $fd_out
      }
      return 1
   }
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: getStatus</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets Called by only controlReg utility.</span>
<span class="comment-line">#              only meant to show the status of a given test bed server</span>
<span class="comment-line">#              In future, may need to add foll info as well:</span>
<span class="comment-line">#              Which queueId, module is run by server.</span>
<span class="comment-line">#              To achieve above, it requires to glob the imagesRunning dir to</span>
<span class="comment-line">#              look for desired configFile.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: config (tail of the config file path)</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set  retValue [getStatus $cfgFile]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::getStatus_478">proc <a href="queueLib.tcl-annot.html#::::getStatus">::::getStatus</a></a></strong> {config} {
   global DEVREG
   puts &#34;Status of test bed server: $config&#34;
   puts &#34;==========================&#34;
   if {[<a name="::locked(4)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $config]} {   ;<span class="comment-line"># if the config is locked, it means it is running as well</span>
      puts &#34;    RunStatus:   Running&#34;
      puts &#34;    LockStatus:  Locked&#34;
      return 1
   } else {  ;<span class="comment-line"># else check if the config is running and unlocked</span>
      set runningServers [<a name="::runningServers(3)"><a href="./queueLib.tcl.html#::runningServers_210">::runningServers</a></a>]
      if {[lsearch -exact $runningServers $config]!=-1} {
         puts &#34;    RunStatus:   Running&#34;
         puts &#34;    LockStatus:  Unlocked&#34;
         return 1
      }  else {
         <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;The test bed server: $config is not running&#34;
         return -1
      }
   }
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: prioritizeQueueId</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets Called by only controlReg utility.</span>
<span class="comment-line">#              It is meant to repriortize a queueId from imagesQueued</span>
<span class="comment-line">#              A queueId may only be placed on the top of the stack</span>
<span class="comment-line">#              to be picked by regression servers.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set  retValue [prioritizeQueueId]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::prioritizeQueueId_516">proc <a href="queueLib.tcl-annot.html#::::prioritizeQueueId">::::prioritizeQueueId</a></a></strong> {} {
    global DEVREG
    set priorityFile [glob -nocomplain -- &#34;$DEVREG(server,priorityFile)&#34;]
    if {[set fd_pri [<a name="::FileOpen(14)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $priorityFile r]]==-1} {
        return $fd_pri
    } else {
        array set qIds &#34;&#34;
        while {[gets $fd_pri line]!=-1} {
            set queueInfoFile $DEVREG(server,imagesQueuedDir)/$line/info
            <a name="::ReadQueueInfoIntoArray(1)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $queueInfoFile uInput
            if {[info exists uInput(priority:)]} {
                set qIds($line) $uInput(priority:)
            } else {
                set qIds($line) 3
            }
        }
        close $fd_pri
      if {[array names qIds]!=&#34;&#34;} {
         puts &#34;\n&#34;
         puts &#34;Current queueIds in imagesQueued:&#34;
         puts &#34;=================================&#34;
         foreach name [array names qIds] {
            puts &#34;$name\t$qIds($name)&#34;
         }
         while {1} {
            puts -nonewline &#34;Please enter one of the above queueIds to change its priority:&#34;
            flush stdout
            gets stdin inputQId
            if {[lsearch [array names qIds] $inputQId]!=-1} {
               break
            } else {
               <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Queue id: $inputQId does not match any amongst: [array names qIds]&#34;
            }
         }
         while {1} {
            puts -nonewline &#34;Please enter new priority for $inputQId:&#34;
            flush stdout
            gets stdin inputQIdPri
            <span class="comment-line"># Check for priority</span>
            if {$inputQIdPri&lt;1 || $inputQIdPri&gt;5} {
               <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Priority must be between 1 and 5&#34;
            } else {
               set qIds($inputQId) $inputQIdPri
               break
            }
         }
         puts &#34;\n&#34;
         puts &#34;New queueIds in imagesQueued:&#34;
         puts &#34;=============================&#34;
         foreach name [array names qIds] {
            puts &#34;$name\t$qIds($name)&#34;
         }
         puts -nonewline &#34;Hit &lt;Enter&gt; to accept new imagesQueued, any other key to cancel:&#34;
         flush stdout
         gets stdin prioritizeValue
         if {$prioritizeValue==&#34;&#34;} {
            set queueInfoFile $DEVREG(server,imagesQueuedDir)/$inputQId/info
            <a name="::ReadQueueInfoIntoArray(2)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $queueInfoFile uInput
            if {[set fd_inf [<a name="::FileOpen(15)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $queueInfoFile w]]==-1} {
               return $fd_inf
            } else {
               foreach varName [array names uInput] {
                  if {$varName==&#34;priority:&#34;} {
                     puts $fd_inf &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $inputQIdPri]&#34;
                  } else {
                     puts $fd_inf &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $uInput($varName)]&#34;
                  }
               }
               close $fd_inf
               <a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully created new priority file for imagesQueued&#34;
               if {[info exists DEVREG(mysql,UseDb)] &amp;&amp; $DEVREG(mysql,UseDb)} {
                   <a name="::updateRegIdEntry(1)"><a href="./mysqlLib.tcl.html#::updateRegIdEntry_3834">::updateRegIdEntry</a></a> -id_label &#34;$inputQId&#34; -priority &#34;$inputQIdPri&#34;
               }
               return 1
            }
         } else {
            <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;PrioritizeQueue cancelled&#34;
            return -1
         }
      } else {
         <a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No image in imagesQueued to prioritize&#34;
         return -1
      }
   }
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetModuleSubType</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc returns the standard/routing module type(s)</span>
<span class="comment-line">#              from the list of moduleNAmes for a given platform</span>
<span class="comment-line">#              returns &#34;&#34; if invalid moduleName</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           platform: Mariner/Cougar/Aspen/PC</span>
<span class="comment-line">#           moduleNames: RIP L2 L3 qad</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           set moduleType [GetModuleSubType $platformName $featureName $featureType]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetModuleSubType_620">proc <a href="queueLib.tcl-annot.html#::::GetModuleSubType">::::GetModuleSubType</a></a></strong> {platform moduleNames moduleTypes} {
   <span class="comment-line"># platform is only used to get a list of legal platform modules</span>
   <span class="comment-line"># The moduleNames passed in are compared with the legal.</span>
   global DEVREG
   global stdMods rtrMods cit2nodeMods
   global platformList
   set platformList $platform
   set moduleSubTypes &#34;&#34;
   if {![info exists rtrMods]} {
      set $rtrMods &#34;&#34;
   }
   if {![info exists stdMods]} {
      set $stdMods &#34;&#34;
   }
   if {![info exists cit2nodeMods]} {
      set $cit2nodeMods &#34;&#34;
   }
   set j 0
   set highCount [llength $moduleNames]
   set highCount1 [llength $moduleTypes]
   for {set y 0} {$y&lt;$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {$moduleName  == &#34;&#34;} {
         continue;
      }
      if {[lsearch -exact &#34;[<a name="::GetModList(1)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std [lindex $moduleTypes $j] $platform]&#34; $moduleName]==-1 &amp;&amp; \
          [lsearch -exact &#34;[<a name="::GetModList(2)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> rtr [lindex $moduleTypes $j] $platform]&#34; $moduleName]==-1 &amp;&amp; \
          [lsearch -exact &#34;[<a name="::GetModList(3)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> cit2node [lindex $moduleTypes $j] $platform]&#34; $moduleName]==-1} {
            puts &#34;Bailed in module $moduleName&#34;
            return &#34;&#34;
      }
      incr j;
   }
   set j 0
   set highCount [llength $moduleNames]
   for {set y 0} {$y&lt;$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {[lsearch -exact &#34;[<a name="::GetModList(4)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> rtr [lindex $moduleTypes $j] $platform]&#34; $moduleName]!=-1} {   ;<span class="comment-line"># Check if there is any routing module</span>
         lappend moduleSubTypes routingModules
         break
      }
      incr j;
   }
   set j 0
   set highCount [llength $moduleNames]
   for {set y 0} {$y&lt;$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {[lsearch -exact &#34;[<a name="::GetModList(5)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std [lindex $moduleTypes $j] $platform]&#34; $moduleName]!=-1} {   ;<span class="comment-line"># Check if there is any standard module</span>
         lappend moduleSubTypes standardModules 
         break
      }
      incr j;
   }
   set j 0
   set highCount [llength $moduleNames]
   for {set y 0} {$y&lt;$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {[lsearch -exact &#34;[<a name="::GetModList(6)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> cit2node [lindex $moduleTypes $j] $platform]&#34; $moduleName]!=-1} {   ;<span class="comment-line"># Check if there is any cit2node module</span>
         lappend moduleSubTypes cit2nodeModules
         break
      }
      incr j;
   }
   return $moduleSubTypes
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetAModule</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc returns the queue array as out var uInput</span>
<span class="comment-line">#              looks for queued module from imagesQueued dir based</span>
<span class="comment-line">#              on the priority file</span>
<span class="comment-line">#              QueueId is returned as the return value</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           regressionType: Standard/routing so that correct module</span>
<span class="comment-line">#                           may be picked</span>
<span class="comment-line">#           platformType: PC/Mariner so that correct platform </span>
<span class="comment-line">#                         may be picked. For routing, platformType</span>
<span class="comment-line">#                         is ignored.</span>
<span class="comment-line">#           cfgFile: tail of the server config file path</span>
<span class="comment-line"># Output args: uInput: Read queue array</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           set myQueueId [GetAModule $regressionType $platformType uInput $cfgFileTail]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetAModule_709">proc <a href="queueLib.tcl-annot.html#::::GetAModule">::::GetAModule</a></a></strong> {regressionType platformType uInput cfgFile} {
   global modRegType stdMods rtrMods DEVREG MAIN
   upvar uInput userInput
   set runStatus &#34;queued&#34;
   after [expr int(rand()*3000)];
   <span class="comment-line">#</span>
   <span class="comment-line"># The priority file contains all regression IDs in the imagesQueued/Running dir.</span>
   <span class="comment-line">#     Each line will have a regression that is waiting to be run</span>
   if {[set fd_in [<a name="::FileOpen(16)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,priorityFile) r]]==-1} {
      return $fd_in
   }
   set queue 0
   array unset userInput
   while {[gets $fd_in line]!=-1} {
      array unset userInput
      <span class="comment-line">#</span>
      <span class="comment-line"># Priority is a regression id RTP_######_######</span>
      set priority $line
      <span class="comment-line">#      cd $DEVREG(server,imagesQueuedDir)/$priority</span>
      
      <span class="comment-line"># --------------------------------------------------------------</span>
      <span class="comment-line"># The queueInfoFile is created by runReg script. The queueId</span>
      <span class="comment-line">#  SC_######_###### is gathered from the priority file.  The</span>
      <span class="comment-line">#  queueId is the directory which holds all run information in</span>
      <span class="comment-line">#  the imagesQueued, imagesRunning, imagesFinished dir. etc.</span>
      <span class="comment-line"># --------------------------------------------------------------</span>
      set queueInfoFile $DEVREG(server,imagesQueuedDir)/$priority/info
      if {![file exists $queueInfoFile] || [file isdirectory $queueInfoFile]} {   ;<span class="comment-line"># if queueId does not exist</span>
         puts &#34;Hit info file $queueInfoFile - is directory&#34;
         continue
      }
      <span class="comment-line"># --------------------------------------------------------------</span>
      <span class="comment-line"># Open the info file and get the important regression info from</span>
      <span class="comment-line">#   it.</span>
      <span class="comment-line"># --------------------------------------------------------------</span>
      if {[set fd_q [<a name="::FileOpen(17)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $queueInfoFile r+]]==-1} {
         return $fd_q
      }
      <span class="comment-line"># --------------------------------------------------------------</span>
      <span class="comment-line"># Setup the uinput Array from the info file</span>
      <span class="comment-line">#   !!! This is the main set up info for the entire run !!!</span>
      <span class="comment-line"># --------------------------------------------------------------</span>
      set readInfoFile 0
      while {[gets $fd_q infoLine]!=-1} {
         set readInfoFile 1
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]; <span class="comment-line"># info passed between procs</span>
         set DEVREG(userInput,[lindex $infoLine 0]) [lrange $infoLine 1 end]; <span class="comment-line"># global setting of info file</span>
      }
      close $fd_q
      if {!$readInfoFile} {
          <a name="::RemoveQidFromPriority(1)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> $priority
          set catch_resp [catch &#34;file delete -force $queueInfoFile&#34; catch_msg]
          continue
      }
      if {[info exists userInput(lockFile:)] &amp;&amp; ![info exists userInput(platformToRunOn:)]} {
         <span class="comment-line">#</span>
         <span class="comment-line"># IF the info file has a lockFile and NO platform to run on, this is just a lock queue entry.</span>
         <span class="comment-line">#   ie /auto/automation/Util/runReg -lock</span>
         <span class="comment-line">#</span>
         set lockFile $userInput(lockFile:)
         if {[string compare $lockFile $cfgFile]==0} {   ;<span class="comment-line"># lockFile exists for me</span>
            set runStatus &#34;runningOn$cfgFile&#34;
            set userInput(runStatus:) $runStatus
         }
      } else {
         <span class="comment-line">#</span>
         <span class="comment-line"># This regression id is not a locking queue id.  It will have information on what</span>
         <span class="comment-line">#   needs to be run</span>
         <span class="comment-line">#</span>
         <span class="comment-line"># ---------------------------------------------------------------</span>
         <span class="comment-line"># Check for robot run</span>
         <span class="comment-line"># ---------------------------------------------------------------</span>
         set MAIN(RobotJob) 0
         if {[info exists userInput(harness:)] &amp;&amp; ![regexp -nocase &#34;null&#34; $userInput(harness:)]} {
            set MAIN(jobHarness)  $userInput(harness:)
            if {$MAIN(jobHarness) == &#34;robot&#34;} {
                set MAIN(RobotJob) 1
            }
         }
         <span class="comment-line">#</span>
         <span class="comment-line">#  Check to see if the jenkins URL is set.</span>
         <span class="comment-line">#</span>
         set DEVREG(active,jenkins) 0
         if {[info exists userInput(jenkins_url:)] &amp;&amp; ![regexp -nocase &#34;null&#34; $userInput(jenkins_url:)]} {
            set DEVREG(active,jenkins) 1
            set DEVREG(active,jenkins_url) $userInput(jenkins_url:)
         }

         <span class="comment-line"># if runSBox is executing from a different branch we need to grab those modules</span>
         set inRelInfo 0
         if {[info exists userInput(relInfo:)]} {
             if {$userInput(relInfo:) != &#34;&#34; &amp;&amp; [lsearch -exact $DEVREG(server,relInfoList) $userInput(relInfo:)]} {
                 set inRelInfo 1
                 catch {source ../Util/${userInput(relInfo:)}.cfg} oops
             }
         }
         if {$regressionType==&#34;cit2node&#34;} {   ;<span class="comment-line"># Check if there are any Robot modules</span>
             set counter 0
             if {($platformType==$userInput(platformToRunOn:)&amp;&amp;![info exists userInput(lockFile:)]) || \
                       ([info exists userInput(lockFile:)] &amp;&amp; $userInput(lockFile:)==$cfgFile)} {
                 foreach userModule $userInput(moduleNames:) {
                    if {[info exists userInput(moduleTypes:)]} {
                        set myRegType  [lindex $userInput(moduleTypes:) $counter]
                        set modRegType $myRegType
                        set DEVREG(userInput,moduleType) [lindex $userInput(moduleTypes:) $counter]
                    } else {
                        set modRegType robotunit
                        set myRegType robotunit
                        set DEVREG(userInput,moduleType) robotunit
                    }
                    if {$counter == 0} {
                        set cit2Modules [<a name="::_getCfgModuleList(1)"><a href="./runreg.tcl.html#::_getCfgModuleList_8">::_getCfgModuleList</a></a> -cfgType cit2node -regType &#34;robotunit&#34; -swplat $platformType]
                    }
                    if {[lsearch -exact $cit2Modules $userModule]&gt;=0} {
                        set runStatus [lindex $userInput(runStatus:) $counter]
                        if {$runStatus==&#34;queued&#34;} {
                            set runStatus &#34;runningOn$cfgFile&#34;
                            <span class="comment-line"># Set this module as running</span>
                            set userInput(runStatus:) [lreplace $userInput(runStatus:) $counter $counter &#34;runningOn$cfgFile&#34;]
                            <span class="comment-line">#</span>
                            <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
                            <span class="comment-line">#</span>
                            if {$DEVREG(mysql,UseDb)} {
                                set rId [<a name="::getRegIdFromQId(1)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $priority]
                                set ts [clock format [clock seconds] -format &#34;%Y-%m-%d %H:%M:%S&#34;]
                                <a name="::updateRegTestModule(1)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name $userModule \
                                       -status &#34;running&#34; -testbed &#34;$cfgFile&#34; -start_timestamp &#34;$ts&#34;
                                <a name="::updateRegIdStatus(1)"><a href="./mysqlLib.tcl.html#::updateRegIdStatus_3793">::updateRegIdStatus</a></a> -reg_id $rId -status &#34;Running&#34;
                            }
                            break
                        }
                   }
                   incr counter
                 }
             }
         } elseif {$regressionType==&#34;routing&#34;} {   ;<span class="comment-line"># Check if there is any routing module</span>
            set counter 0
            if {($platformType==$userInput(platformToRunOn:)&amp;&amp;![info exists userInput(lockFile:)]) || \
                ([info exists userInput(lockFile:)] &amp;&amp; $userInput(lockFile:)==$cfgFile)} {  ;<span class="comment-line"># matched my platform type</span>
                foreach userModule $userInput(moduleNames:) {
                   <span class="comment-line"># -----------------------------------------------------------</span>
                   <span class="comment-line"># loop through all of the features to be run in the info file</span>
                   <span class="comment-line"># the regtype (functionaltest, snmp, xml, scalable, fit) are stored</span>
                   <span class="comment-line"># in a list with the same count and indexing as the modules</span>
                   <span class="comment-line">#  ACL              diffserv           diffserv</span>
                   <span class="comment-line">#  Functionaltest   Functionaltest     SnmpFunctionaltest</span>
                   <span class="comment-line"># -----------------------------------------------------------</span>
                   if {[info exists userInput(moduleTypes:)]} {
                       set myRegType  [lindex $userInput(moduleTypes:) $counter]
                       set modRegType $myRegType
                       set DEVREG(userInput,moduleType) [lindex $userInput(moduleTypes:) $counter]
                   } else {
                       set modRegType functional
                       set myRegType functional
                       set DEVREG(userInput,moduleType) functional
                   }
                   if {$counter == 0} {
                       set rtrMods($myRegType,$platformType) [<a name="::GetModList(7)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> rtr $myRegType $platformType]
                   }
                   if {![info exists rtrMods($myRegType,$platformType)] || $inRelInfo} {
                       set rtrModules $rtrMods($myRegType,All)
                   } else {
                       set rtrModules $rtrMods($myRegType,$platformType)
                   }
                   if {[lsearch -exact $rtrModules $userModule]&gt;=0} {
                      set runStatus [lindex $userInput(runStatus:) $counter]
                      if {$runStatus==&#34;queued&#34;} {
                         set runStatus &#34;runningOn$cfgFile&#34;
                         <span class="comment-line"># Set this module as running</span>
                         set userInput(runStatus:) [lreplace $userInput(runStatus:) $counter $counter &#34;runningOn$cfgFile&#34;]
                         <span class="comment-line"># -------------------------------------------------------------------------</span>
                         <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
                         <span class="comment-line"># -------------------------------------------------------------------------</span>
                         if {$DEVREG(mysql,UseDb)} {
                             set rId [<a name="::getRegIdFromQId(2)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $priority]
                             set ts [clock format [clock seconds] -format &#34;%Y-%m-%d %H:%M:%S&#34;]
                             <a name="::updateRegTestModule(2)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name $userModule \
                                 -status &#34;running&#34; -testbed &#34;$cfgFile&#34; -start_timestamp &#34;$ts&#34;
                             <a name="::updateRegIdStatus(2)"><a href="./mysqlLib.tcl.html#::updateRegIdStatus_3793">::updateRegIdStatus</a></a> -reg_id $rId -status &#34;Running&#34; 
                         }
                         break
                      }
                   }
                   incr counter
                }
            } else { ;<span class="comment-line"># did not match my platform type, go on to check if lockFile exists else go to next queueid</span>
               continue
            }
         } elseif {$regressionType==&#34;standard&#34;} {  ;<span class="comment-line"># Check if there is any standard module</span>
            set counter 0
            if {($platformType==$userInput(platformToRunOn:)&amp;&amp;![info exists userInput(lockFile:)]) || \
                ([info exists userInput(lockFile:)] &amp;&amp; $userInput(lockFile:)==$cfgFile)} {  ;<span class="comment-line"># matched my platform type</span>
               global dot1xPlatforms dot1xModules tahiPlatforms tahiModules
               foreach userModule $userInput(moduleNames:) {
                  <span class="comment-line"># -----------------------------------------------------------</span>
                  <span class="comment-line"># loop through all of the features to be run in the info file</span>
                  <span class="comment-line"># the regtype (functionaltest, snmp, xml, scalable, fit) are stored</span>
                  <span class="comment-line"># in a list with the same count and indexing as the modules</span>
                  <span class="comment-line">#  ACL              diffserv           diffserv</span>
                  <span class="comment-line">#  Functionaltest   Functionaltest     SnmpFuntionaltest</span>
                  <span class="comment-line"># -----------------------------------------------------------</span>
                  if {[info exists userInput(moduleTypes:)]} {
                      <span class="comment-line">#puts &#34;\n----\nHit the module type exists case\n----&#34;</span>
                      set myRegType  [lindex $userInput(moduleTypes:) $counter]
                      set modRegType $myRegType
                      set DEVREG(userInput,moduleType) [lindex $userInput(moduleTypes:) $counter]
                  } else {
                      set myRegType functional
                      set modRegType functional
                      set DEVREG(userInput,moduleType) functional
                  }
                  if {$counter == 0} {
                      set stdMods($myRegType,$platformType) [<a name="::GetModList(8)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std $myRegType $platformType]
                  }
                  if {![info exists stdMods($myRegType,$platformType)] || $inRelInfo} {
                      set stdModules $stdMods($myRegType,All)
                  } else {
                      set stdModules $stdMods($myRegType,$platformType)
                  }
                  if {[regexp -nocase $DEVREG(server,dot1xModules) $userModule]} {
                     if {![regexp -nocase $DEVREG(server,dot1xPlatforms) $cfgFile]} {
                        incr counter;
                        continue;
                     }
                  }
                  if {[regexp -nocase $DEVREG(server,tahiModules) $userModule]} {
                     if {![regexp -nocase $DEVREG(server,tahiPlatforms) $cfgFile]} {
                        incr counter;
                        continue;
                     }
                  }
                  if {[lsearch -exact $stdModules $userModule]&gt;=0} {
                     set runStatus [lindex $userInput(runStatus:) $counter]
                     if {$runStatus==&#34;queued&#34;} {
                        set runStatus &#34;runningOn$cfgFile&#34;
                        <span class="comment-line"># Set this module as running</span>
                        set userInput(runStatus:) [lreplace $userInput(runStatus:) $counter $counter &#34;runningOn$cfgFile&#34;]
                        <span class="comment-line"># -------------------------------------------------------------------------</span>
                        <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
                        <span class="comment-line"># -------------------------------------------------------------------------</span>
                        if {$DEVREG(mysql,UseDb)} {
                            set rId [<a name="::getRegIdFromQId(3)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $priority]
                            set ts [clock format [clock seconds] -format &#34;%Y-%m-%d %H:%M:%S&#34;]
                            <a name="::updateRegTestModule(3)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name $userModule \
                                -status &#34;running&#34; -testbed &#34;$cfgFile&#34; -start_timestamp &#34;$ts&#34;
                            <a name="::updateRegIdStatus(3)"><a href="./mysqlLib.tcl.html#::updateRegIdStatus_3793">::updateRegIdStatus</a></a> -reg_id $rId -status &#34;Running&#34; 
                        }
                        break
                     }
                  }
                  incr counter;
               }
            } else {  ;<span class="comment-line"># did not match my platform type, go on to check if lockFile exists else go to next queueid</span>
               continue
            }
         } ;<span class="comment-line"># else if standard regression</span>
      } ;<span class="comment-line"># else if lock file doesn't exist</span>
      if {[regexp -nocase &#34;runningOn&#34; $runStatus] &amp;&amp; [file exists $queueInfoFile]} {
         set queue $priority
         break
      }
   }
   
   close $fd_in
   return $queue
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: UpdateImagesRunning</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets called by the regServer to update </span>
<span class="comment-line">#              info file for imagesQueued and imagesRunning.</span>
<span class="comment-line">#              After the module is started, the corresponding entry is</span>
<span class="comment-line">#              changed to takenBy in imagesQueued and runninOn in imagesRunning.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           qId: queueId to work on inside imagesQueued/imagesRunning</span>
<span class="comment-line">#           userIp: User info array as passed by the caller</span>
<span class="comment-line">#           cfgFile: tail of the server config file path</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[UpdateImagesRunning $myQueueId [array get uInput] $cfgFileTail]==-1} {</span>
<span class="comment-line">#            exit -1</span>
<span class="comment-line">#         }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UpdateImagesRunning_999">proc <a href="queueLib.tcl-annot.html#::::UpdateImagesRunning">::::UpdateImagesRunning</a></a></strong> {qId userIp cfgFile} {
   global DEVREG

   set queueInfoFile $DEVREG(server,imagesQueuedDir)/$qId/info
   array set uInput $userIp

   <span class="comment-line"># update the imagesQueued in case a valid module found</span>
   set retCode 1
   if {[set fd_inout [<a name="::FileOpen(18)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $queueInfoFile r+]]==-1} {   ;<span class="comment-line"># open r+ as need to modify, do not write</span>
      return $fd_inout
   } else {
      set count 0
      foreach runStatus $uInput(runStatus:) {
         if {[regexp -nocase &#34;runningOn&#34; $runStatus]} {
            set uInput(runStatus:) [lreplace $uInput(runStatus:) $count $count &#34;takenBy$cfgFile&#34;]
            set runningIndex $count  ;<span class="comment-line"># There should be only one &#34;runningOn&#34; per call to UpdateImagesRunning</span>
            break
         }
         incr count
      }
      if {[lsearch $uInput(runStatus:) &#34;queued&#34;]==-1} {  ;<span class="comment-line"># no more to run on, remove the dir itself</span>
         close $fd_inout;
         if {[file exists $queueInfoFile]} {
             file delete $queueInfoFile;
         }
         if {[set retCode [<a name="::RemoveQidFromPriority(2)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> $qId]]==-1} {
            file delete -force $DEVREG(server,imagesQueuedDir)/$qId   ;<span class="comment-line"># This right here also deletes the .xos image files</span>
            return $retCode
         }
         set retCode 2  ;<span class="comment-line"># This code tells regServer to remove queuedId after downloadImage</span>
      } else {
         foreach varName [array names uInput] {
            puts $fd_inout &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $uInput($varName)]&#34;
         }
         ftruncate $queueInfoFile [tell $fd_inout]
         close $fd_inout
      }
   }

   <span class="comment-line"># update the imagesRunning in case a valid module found</span>
   array set uInput $userIp
   set runningQueueFile &#34;$DEVREG(server,imagesRunningDir)/$qId&#34;
   set value [expr round(rand() * 8999) + 100]
   after $value ;<span class="comment-line"># To avoid race condition sometimes amongst the servers</span>
   if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;<span class="comment-line"># qId is already running</span>
      <span class="comment-line"># Have to be careful writing as other servers might be</span>
      <span class="comment-line"># running as well.</span>
      <span class="comment-line"># At this point, Read the running info file, change the status of module</span>
      <span class="comment-line"># at runningIndex index that was grabbed from queueInfoFile</span>
      if {[set fd_q [<a name="::FileOpen(19)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningQueueFile/info r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
<span class="comment-line">#      result_debug &#34;array runningRegression [parray userInput]&#34;</span>
      seek $fd_q 0 start
      set userInput(runStatus:) [lreplace $userInput(runStatus:) $runningIndex $runningIndex &#34;runningOn$cfgFile&#34;]
      <span class="comment-line"># -------------------------------------------------------------------------</span>
      <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
      <span class="comment-line"># -------------------------------------------------------------------------</span>
      if {$DEVREG(mysql,UseDb)} {
          set rId [<a name="::getRegIdFromQId(4)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
          set ts [clock format [clock seconds] -format &#34;%Y-%m-%d %H:%M:%S&#34;]
          <a name="::updateRegTestModule(4)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $userInput(moduleNames:) $runningIndex] \
              -status &#34;running&#34; -testbed &#34;$cfgFile&#34; -start_timestamp &#34;$ts&#34;
          <a name="::updateRegIdStatus(4)"><a href="./mysqlLib.tcl.html#::updateRegIdStatus_3793">::updateRegIdStatus</a></a> -reg_id $rId -status &#34;Running&#34; 
      }
      foreach varName [array names userInput] {
         puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
      }  
      ftruncate $runningQueueFile/info [tell $fd_q]
      close $fd_q
   } else {  ;<span class="comment-line"># qId is running first time fresh</span>
      if {![file isdirectory $DEVREG(server,imagesRunningDir)]} {
         if {[catch {file mkdir $DEVREG(server,imagesRunningDir)} reason]} {
            <a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create imagesRunningDir dir...$reason&#34;
            return -1
         }
      }
      if {[catch {file mkdir &#34;$runningQueueFile&#34;} reason]} {
         <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $runningQueueFile...$reason&#34;;
         return -1
      }
      if {[set fd_out [<a name="::FileOpen(20)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningQueueFile/info w]]==-1} {
         return $fd_out
      }
      foreach varName [array names uInput] {
         puts $fd_out &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $uInput($varName)]&#34;
      }
      ftruncate $runningQueueFile/info [tell $fd_out]
      close $fd_out
      <span class="comment-line"># -------------------------------------------------------------------------</span>
      <span class="comment-line"># if Use Database is on, update the run_reg with starttime of first mod</span>
      <span class="comment-line"># -------------------------------------------------------------------------</span>
      if {$DEVREG(mysql,UseDb)} {
          set rId [<a name="::getRegIdFromQId(5)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
          set ts [clock format [clock seconds] -format &#34;%Y-%m-%d %H:%M:%S&#34;]
          <a name="::updateRegIdEntry(2)"><a href="./mysqlLib.tcl.html#::updateRegIdEntry_3834">::updateRegIdEntry</a></a> -reg_id $rId -start_timestamp &#34;$ts&#34;
      }
   }
   <span class="comment-line">### Check if lockFile exists, (a).change modes for runReg to unlock, (b). Send email to userid</span>
   if {[info exists uInput(lockFile:)] &amp;&amp; ![info exists uInput(platformToRunOn:)]} {
      chmod 0777 $runningQueueFile/info
      if {[catch {source [pwd]/../main/cfg/$uInput(lockFile:)} reason]} {
          puts &#34;error sourcing cfg file: $reason&#34;
          set conStr &#34;&#34;;
      } else {
          set conStr &#34;D).&#34;
          for {set j 1} {$j &lt;= 5} {incr j} {
              if {[info exists DUT${j}_CONNECT] &amp;&amp; [info exists DUT${j}_IP]} {
                  set conStr [append conStr &#34; DUT$j console: [set DUT${j}_CONNECT]\r&#34;]
                  set conStr [append conStr &#34; DUT$j Mgmt IP: [set DUT${j}_IP]\r&#34;]
              }
          }
      }
      if {[catch {eval ClearTestbedSessions} freason]} {
          puts &#34;error clearing the consoles: $freason&#34;
      }
      if {[info exists uInput(faillock:)] &amp;&amp; $uInput(faillock:) == &#34;yes&#34;} {
          set conStr &#34; You have selected to lock this test bed if a script fails\n\r&#34;
          if {[info exists ixiaCh1]} {
              set conStr [append conStr &#34; The ixia IP is $ixiaCh1 - you should be able to VNC or RDP to the chassis\n\r&#34;]
              set conStr [append conStr &#34; Open IxExplorer, highlight the chassis and push F5 to sync HW to IxExplorer\n\r&#34;]
              if {[info exists startCardNum]} {
                  set conStr [append conStr &#34; The Ixia slot is $startCardNum\n\r&#34;]
              }
          }
      }
      set str [append str [<a name="::PrintUserQueue(1)"><a href="./queueLib.tcl.html#::PrintUserQueue_2538">::PrintUserQueue</a></a> [array get uInput] $qId]]
      set str [append str &#34;To UNLOCK use /auto/automation/Util/runReg -unlock $qId\n\r&#34;]
      set str [append str &#34;If you do not get an unlock email shortly after the command above\n\r    /auto/automation/Util/killReg -q $qId -f yes\n\r&#34;]
      set str [append str &#34;A). ALWAYS DOWNLOAD YOUR TEST SOFTWARE TO THE SECONDARY BANK.\n\r&#34;]
      set str [append str &#34;B). Make sure to leave the DUTs in usable condition\n\r&#34;]
      set str [append str &#34;C). Make sure to leave the console connection to DUTs open\n\r&#34;]
      set str [append str &#34;$conStr\n\r&#34;]
      if {[regexp -nocase &#34;\@&#34; $uInput(userid:)]} {
         set toBeSent &#34;$uInput(userid:).extremenetworks.com&#34;
      } else {
         set toBeSent &#34;$uInput(userid:)@extremenetworks.com&#34;
      }
      exec /bin/mail -s &#34;Queueid:$qId ***locked*** testbed $uInput(lockFile:):&#34; \
           &#34;$toBeSent&#34; \
           -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
   }
   return $retCode
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: UpdateImagesDone</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets called by the regServer to update </span>
<span class="comment-line">#              info file when a module is finished (pass/fail) or</span>
<span class="comment-line">#              LoadImage failed.</span>
<span class="comment-line">#              It creates imagesFinished/qId and moves the log of module/</span>
<span class="comment-line">#              LoadImage into corresponding imagesFinished dir.</span>
<span class="comment-line">#              switches based on the updateStr</span>
<span class="comment-line">#              Performs glob to look for correct dir inside module/LoadImage</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           qId: queueId to work on inside imagesFinished</span>
<span class="comment-line">#           runIndex: Index inside info file for a module for a queueId</span>
<span class="comment-line">#           updateStr: success/failure of the given module</span>
<span class="comment-line"># Output args: dirToReturn: Directory path of the log location</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           UpdateImagesDone $myQueueId $runningIndex PASS targetDir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UpdateImagesDone_1169">proc <a href="queueLib.tcl-annot.html#::::UpdateImagesDone">::::UpdateImagesDone</a></a></strong> {qId runIndex updateStr dirToReturn} {
   global DEVREG
   upvar $dirToReturn targetDir

   <a name="::WriteToQueueDebug(1)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone args&#34; &#34;qId $qId\nrunIndex $runIndex\n\
                      updateStr $updateStr\ndirToReturn $dirToReturn&#34;;

   set runningQueueFile &#34;$DEVREG(server,imagesRunningDir)/$qId&#34;
   set targetDir &#34;&#34;
   set skipUpdate 1
   if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;<span class="comment-line"># qId is already running</span>
      if {[set fd_q [<a name="::FileOpen(21)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningQueueFile/info r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
<span class="comment-line">#      result_debug &#34;array runningRegression [parray userInput]&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Add robot case.  if $userInput(harness:) == &#34;robot&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
      if {[set targetDir [<a name="::MoveReportToQueueFinished(1)"><a href="./queueLib.tcl.html#::MoveReportToQueueFinished_1634">::MoveReportToQueueFinished</a></a> $qId [array get userInput] $runIndex $updateStr]]==-1} {
         set targetDir &#34;Report dir not generated&#34;
      } elseif {$targetDir==137} {  ;<span class="comment-line"># killed signal, no need to process further</span>
         return -1
      }
      if {[regexp -nocase &#34;^PASS&#34; $updateStr]} {
       set testsPassed 0
       set testsFailed 1
       set testsDuration 0
       set swRevNum &#34;&#34;
       set reportFileName &#34;$targetDir/report.txt&#34;
       <span class="comment-line"># EY-02-09-2009: Add &#34;--&#34; to prevent $targetDir from being</span>
       <span class="comment-line"># misinterpreted as a regexp argument.</span>
       if {![regexp -nocase -- &#34;Report dir not generated&#34; $targetDir]} {
           if {[set fd_in [<a name="::FileOpen(22)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $reportFileName r reason]]==-1} {
              return $fd_in
           }
           while {[gets $fd_in line]!=-1} {
              set str [append str &#34;\n&#34; $line]
              if {[regexp -nocase &#34;^number of sub test cases failed&#34; $line]} {
                 set testsFailed [lindex $line [expr [llength $line]-1]]
              }
              if {[regexp -nocase &#34;^number of sub test cases passed&#34; $line]} {
                 set testsPassed [lindex $line [expr [llength $line]-1]]
              }
              if {[regexp -nocase &#34;^Total test time&#34; $line]} {
                 set testsDuration [lindex $line [expr [llength $line]-2]]
              }
              if {[regexp -nocase &#34;^revision number:&#34; $line]} {
                 set swRevNum [lindex $line [expr [llength $line]-1]]
              }
           }
           close $fd_in
       }
       if {$testsFailed&gt;=1} {
          set testsTotal [expr $testsFailed + $testsPassed]
          <a name="::WriteToQueueDebug(2)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone FAILED&#34; &#34;testsTotal $testsTotal\n\
                             testsFailed $testsFailed\ntestsPassed  $testsPassed&#34;;
          <span class="comment-line"># -------------------------------------------------------------------------</span>
          <span class="comment-line"># By default successfully finishing the reg gives a pass.  Since report.txt</span>
          <span class="comment-line">#    analysis shows a fail count regsub FAIL for PASS</span>
          <span class="comment-line"># -------------------------------------------------------------------------</span>
          regsub -all &#34;PASS&#34; $updateStr &#34;FAIL&#34; updateStr   ;<span class="comment-line"># replace pass with fail string as some tests failed</span>
          <span class="comment-line"># -------------------------------------------------------------------------</span>
          <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
          <span class="comment-line"># -------------------------------------------------------------------------</span>
          if {$DEVREG(mysql,UseDb)} {
              set rId [<a name="::getRegIdFromQId(6)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
              if {$DEVREG(active,inrerun)} {
                  <a name="::WriteToQueueDebug(3)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone in PASS/FAIL RERUN&#34; \
                     &#34;[lindex $userInput(moduleNames:) $runIndex] Mod status \
                     = [lindex $userInput(runStatus:) $runIndex]&#34;
                  puts &#34;----\nUpdate test_module status Fail on Rerun \npass $testsPassed fail $testsFailed duration $testsDuration\n----&#34;
                  <a name="::updateRegTestModule(5)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status &#34;Fail&#34; -pass_cnt_1 &#34;$testsPassed&#34; -total_cnt_1 &#34;$testsTotal&#34; \
                      -duration_1 &#34;$testsDuration&#34; -sqa_revision &#34;$swRevNum&#34;
              } else {
                  <a name="::WriteToQueueDebug(4)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone in PASS/FAIL&#34; \
                         &#34;[lindex $userInput(moduleNames:) $runIndex] Mod status = \
                         [lindex $userInput(runStatus:) $runIndex]&#34;
                  puts &#34;----\nUpdate test_module status Fail\npass $testsPassed fail $testsFailed duration $testsDuration\n----&#34;
                  <a name="::updateRegTestModule(6)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status &#34;Fail&#34; -pass_cnt &#34;$testsPassed&#34; -total_cnt &#34;$testsTotal&#34; \
                      -duration &#34;$testsDuration&#34; -sqa_revision &#34;$swRevNum&#34;
              }
          }
       } else {
          set testsTotal [expr $testsFailed + $testsPassed]
          <a name="::WriteToQueueDebug(5)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone PASS&#34; &#34;testsTotal $testsTotal\n\
                             testsFailed $testsFailed\ntestsPassed  $testsPassed&#34;;
          <span class="comment-line"># -------------------------------------------------------------------------</span>
          <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
          <span class="comment-line"># -------------------------------------------------------------------------</span>
          if {$DEVREG(mysql,UseDb)} {
              set rId [<a name="::getRegIdFromQId(7)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
              if {$DEVREG(active,inrerun)} {
                  <a name="::WriteToQueueDebug(6)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone in PASS/FAIL RERUN&#34; \
                         &#34;[lindex $userInput(moduleNames:) $runIndex] Mod status = \
                         [lindex $userInput(runStatus:) $runIndex]&#34;
                  puts &#34;----\nUpdate test_module status Pass on Rerun \npass $testsPassed fail $testsFailed duration $testsDuration\n----&#34;
                  <a name="::updateRegTestModule(7)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status &#34;Pass&#34; -pass_cnt_1 &#34;$testsPassed&#34; -total_cnt_1 &#34;$testsTotal&#34; \
                      -duration_1 &#34;$testsDuration&#34; -sqa_revision &#34;$swRevNum&#34;
              } else {
                  <a name="::WriteToQueueDebug(7)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone in PASS/FAIL&#34; \
                         &#34;[lindex $userInput(moduleNames:) $runIndex] Mod status = \
                         [lindex $userInput(runStatus:) $runIndex]&#34;
                  puts &#34;----\nUpdate test_module status Pass\npass $testsPassed fail $testsFailed duration $testsDuration\n----&#34;
                  <a name="::updateRegTestModule(8)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status &#34;Pass&#34; -pass_cnt &#34;$testsPassed&#34; -total_cnt &#34;$testsTotal&#34; \
                      -duration &#34;$testsDuration&#34; -sqa_revision &#34;$swRevNum&#34;
              }
          }             
       }
      }
      set preRunStat $userInput(runStatus:)
      set userInput(runStatus:) [lreplace $userInput(runStatus:) $runIndex $runIndex &#34;$updateStr&#34;]
      <a name="::WriteToQueueDebug(8)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone replace runStatus with updateStr&#34; \
             &#34;Init status: $preRunStat\nupdateStr: $updateStr\n\
              New userInput(runStatus:): $userInput(runStatus:)&#34;
      <span class="comment-line"># -------------------------------------------------------------------------</span>
      <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
      <span class="comment-line"># -------------------------------------------------------------------------</span>
      if {$DEVREG(mysql,UseDb)} {
          set tmStatus &#34;&#34;
          set rrStatus &#34;&#34;
          set rId [<a name="::getRegIdFromQId(8)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
          <span class="comment-line"># ---------------------------------------------------------------------</span>
          <span class="comment-line"># At this port runStatus has already been replaced to current state</span>
          <span class="comment-line">#   - so just update the db</span>
          <span class="comment-line"># ---------------------------------------------------------------------</span>
          if {[regexp -nocase &#34;mainkill&#34; $updateStr]} {
              puts &#34;Hit mainkill&#34;
              set tmStatus &#34;MainKill&#34;
              set rrStatus &#34;Complete&#34;
          } elseif {[regexp -nocase &#34;mainfail&#34; $updateStr]} {
              puts &#34;Hit MainFail&#34;
              set tmStatus &#34;MainFail&#34;
              set rrStatus &#34;Complete&#34;
              set skipUpdate 0
          } elseif {[regexp -nocase &#34;downloadfail&#34; $updateStr]} {
              puts &#34;Hit DnldFail&#34;
              set tmStatus &#34;DnldFail&#34;
              set rrStatus &#34;Complete&#34;
              set skipUpdate 0
          } elseif {[regexp -nocase &#34;downloadkill&#34; $updateStr]} {
              puts &#34;Hit DnldKill&#34;
              set tmStatus &#34;DnldKill&#34;
              set rrStatus &#34;Complete&#34;
          }  elseif {[regexp -nocase &#34;pass&#34; $updateStr]} {
              puts &#34;Hit Pass&#34;
              set skipUpdate 1
              set rrStatus &#34;Complete&#34;
          } else {
              puts &#34;Hit ELSE mainkill&#34;
              set tmStatus &#34;MainFail&#34;
              set rrStatus &#34;Complete&#34;
          }
          if {!$skipUpdate} {
              puts &#34;Update test_module status $tmStatus&#34;
              <a name="::updateRegTestModule(9)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                  -status &#34;$tmStatus&#34;
          }
      }      
      <span class="comment-line"># no more in queued/running mode, move this queue to $imagesFinishedDir</span>
      if {[lsearch -regexp $userInput(runStatus:) &#34;queued|running|reRunOn&#34;]==-1} {
         <a name="::WriteToQueueDebug(9)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone Run Completed&#34; \
                 &#34;userInput(runStatus:): $userInput(runStatus:)&#34;
         <span class="comment-line"># -------------------------------------------------------------------------</span>
         <span class="comment-line"># if this is a jenkins run, send the jenkins url update</span>
         <span class="comment-line"># -------------------------------------------------------------------------</span>
         if {$DEVREG(active,jenkins)} {
            puts &#34;Jenkins update reg_run rId status $rrStatus&#34;
            if {[regexp -nocase &#34;fail&#34; $userInput(runStatus:)]} {
                <a name="::updateJenkinsRegIdStatus(1)"><a href="./mysqlLib.tcl.html#::updateJenkinsRegIdStatus_4098">::updateJenkinsRegIdStatus</a></a> -q_id $qId -reg_id &#34;$rId&#34; -status ${rrStatus}_Fail -url &#34;$DEVREG(active,jenkins_url)&#34;
            } else {
                <a name="::updateJenkinsRegIdStatus(2)"><a href="./mysqlLib.tcl.html#::updateJenkinsRegIdStatus_4098">::updateJenkinsRegIdStatus</a></a> -q_id $qId -reg_id &#34;$rId&#34; -status ${rrStatus}_Pass -url &#34;$DEVREG(active,jenkins_url)&#34;
            }
         }
         <span class="comment-line"># -------------------------------------------------------------------------</span>
         <span class="comment-line"># if Use Database is on, update the reg_run table entry for this module</span>
         <span class="comment-line"># -------------------------------------------------------------------------</span>
         if {$DEVREG(mysql,UseDb)} {
            puts &#34;Update reg_run rId status $rrStatus&#34;
            <a name="::updateRegIdStatus(5)"><a href="./mysqlLib.tcl.html#::updateRegIdStatus_3793">::updateRegIdStatus</a></a> -reg_id &#34;$rId&#34; -status &#34;$rrStatus&#34;
         }
         if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
            if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
               <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create imagesFinishedDir dir...$reason&#34;
               return -1
            }
         }
         if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId]} {
            if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$qId&#34;} reason]} {
               <a name="::result_error(16)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId...$reason&#34;;
               return -1
            }
         }
         seek $fd_q 0 start
         foreach varName [array names userInput] {
            puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
         }
         ftruncate $runningQueueFile/info [tell $fd_q]
         close $fd_q
         if {[catch {file rename -force $runningQueueFile/info &#34;$DEVREG(server,imagesFinishedDir)/$qId/info&#34;} reason]} {   ;<span class="comment-line"># Force chosen as first run might create it already</span>
            <a name="::result_error(17)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot rename $runningQueueFile/info to $DEVREG(server,imagesFinishedDir)/$qId/info...$reason&#34;;
            return -1
         } else {
            file delete $runningQueueFile
            return 1
         }
      } else {
         seek $fd_q 0 start
         foreach varName [array names userInput] {
            puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
         }
         ftruncate $runningQueueFile/info [tell $fd_q]
         close $fd_q
         return 1
      }
   } else {  ;<span class="comment-line"># qId not Found, an error</span>
      <a name="::WriteToQueueDebug(10)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesDone&#34; \
                 &#34;QID NOT FOUND IN imagesRunning $qId...$queues&#34;
      <a name="::result_error(18)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues&#34;;
      return -1
   }
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: RemoveQidFromPriority</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: As name indicates, this proc deletes a QueueId from the</span>
<span class="comment-line">#              priority file inside imagesQueued.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           QueueId: queueId to work on inside imagesQueued</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::RemoveQidFromPriority_1416">proc <a href="queueLib.tcl-annot.html#::::RemoveQidFromPriority">::::RemoveQidFromPriority</a></a></strong> {QueueId} {
   global DEVREG
   set lines &#34;&#34;
   if {[set fd_in [<a name="::FileOpen(23)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,priorityFile) r+]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      lappend lines $line
   }
   seek $fd_in 0 start   ;<span class="comment-line"># go to the top of the file again</span>
   foreach line $lines {
      if {$line!=$QueueId} {
          set line [string trim $line &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
          set line [string trim $line];
          if {[regexp {[A-Z]{3,3}_[0-9]{6,6}_[0-9]{6,6}} $line]} {
              puts $fd_in $line
          } else {
              puts &#34;\n!!!\n!!!\n!!! BAD BAD BAD queueid $line !!!\n!!!\n!!!&#34;
          }
      }
   }
   ftruncate $DEVREG(server,priorityFile) [tell $fd_in]
   close $fd_in
   return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: ScheduleToKill</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc replaces queued modules to be killed in case</span>
<span class="comment-line">#              user chose to kill a regression whole partial module(s)</span>
<span class="comment-line">#              are running.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           qDir: Absolute path of queueId inside imagesQueued</span>
<span class="comment-line"># Output args: outIp: Returns the constructed info file</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ScheduleToKill_1459">proc <a href="queueLib.tcl-annot.html#::::ScheduleToKill">::::ScheduleToKill</a></a></strong> {qDir outIp} {
   global DEVREG
   upvar outIp userInput

   <span class="comment-line"># The caller will call this proc only if any module is queued and taken</span>
   <span class="comment-line"># in which case, this proc would remove the queue from imagesQueued</span>
   <span class="comment-line"># and update the same queue in imagesRunning for kill</span>
   <span class="comment-line"># Its better to delete all the </span>

   if {[set fd_inout [<a name="::FileOpen(24)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $qDir/info r+]]==-1} {
      return $fd_inout
   }
   while {[gets $fd_inout infoLine]!=-1} {
      set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
   }
   for {set i 0} {$i&lt;[llength $userInput(runStatus:)]} {incr i} {
      set status [lindex $userInput(runStatus:) $i]
      if {$status==&#34;queued&#34;} {
         set userInput(runStatus:) [lreplace $userInput(runStatus:) $i $i &#34;killed&#34;]
      }
   }
   seek $fd_inout 0 start   ;<span class="comment-line"># go to the top of the file again</span>
   foreach varName [array names userInput] {
      puts $fd_inout &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
   }
   ftruncate $qDir/info [tell $fd_inout]
   close $fd_inout
   puts &#34;the arr [parray userInput]&#34;
   return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: UpdateIdle</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc performs the update of a up file</span>
<span class="comment-line">#              to determine the uptime of a server.</span>
<span class="comment-line">#              Though new way has been devised to check for the servers'</span>
<span class="comment-line">#              uptime, this proc is retained (along with callers code) for</span>
<span class="comment-line">#              historical reasons for now.</span>
<span class="comment-line">#              The uptime is updated in terms of clock seconds in cfgFile</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           cfgFile: tail of the cfgFile to update the uptime with</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           UpdateIdle $cfgFileTail</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UpdateIdle_1510">proc <a href="queueLib.tcl-annot.html#::::UpdateIdle">::::UpdateIdle</a></a></strong> {cfgFile} {
   global DEVREG

   set up [<a name="::FileOpen(25)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> &#34;$DEVREG(server,regressionDir)/$cfgFile&#34; &#34;w&#34;]
   puts $up [clock seconds]
   close $up
   after 3000
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: LocateQueueId</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Given a qId, this proc locates the queueId from</span>
<span class="comment-line">#              any of imagesQueued/imagesRunning/imagesFinished dirs</span>
<span class="comment-line">### If some of the module are taken from a queue at a given instance,</span>
<span class="comment-line">### this proc would return the _imagesRunningDir_ location of the queue</span>
<span class="comment-line">### instead of imagesQueuedDir</span>
<span class="comment-line">### In above case, same queue will apear in both the dirs imagesQueuedDir</span>
<span class="comment-line">### and imagesRunningDir</span>
<span class="comment-line">### If it returns imagesRunningDir, it means all the modules in that</span>
<span class="comment-line">### queue are running at that instance</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           cfgFile: tail of the cfgFile to update the uptime with</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           UpdateIdle $cfgFileTail</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LocateQueueId_1542">proc <a href="queueLib.tcl-annot.html#::::LocateQueueId">::::LocateQueueId</a></a></strong> {qId} {
   global DEVREG

   set imageDir -1
   <span class="comment-line">### Check for the qId in imagesRunningDir</span>
   set imageDir [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/$qId]
   if {$imageDir!=&#34;&#34;} {   ;<span class="comment-line"># found match in imagesRunningDir</span>
      return $imageDir
   } else {   ;<span class="comment-line"># did not find match in imagesRunningDir</span>
      <span class="comment-line">### Check for the qId in priorityFile</span>
      set prFile [glob -nocomplain -- $DEVREG(server,priorityFile)]
      if {[set fd_pri [<a name="::FileOpen(26)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $prFile r]]==-1} {
         return $fd_pri
      } else {
         while {[gets $fd_pri line]!=-1} {
            if {$line==$qId} {   ;<span class="comment-line"># found match in imagesQueuedDir</span>
               close $fd_pri
               return &#34;$DEVREG(server,imagesQueuedDir)/$line&#34;
            }
         }
         close $fd_pri  ;<span class="comment-line"># did not find in imagesQueuedDir</span>
      }
      set imageDir [glob -nocomplain -- $DEVREG(server,imagesFinishedDir)/$qId]
      if {$imageDir!=&#34;&#34;} {  ;<span class="comment-line"># found match in imagesFinishedDir</span>
         return $imageDir
      } else {
         set imageDir [glob -nocomplain -- $DEVREG(server,imagesKilledDir)/$qId]
         if {$imageDir!=&#34;&#34;} {  ;<span class="comment-line"># found match in imagesKilled dir</span>
             return $imageDir
         }
         return -1  ;<span class="comment-line"># did not find match anywhere</span>
      }
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: WriteToQueueDebug</span>
<span class="comment-line">#  Queue Debug Proc</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::WriteToQueueDebug_1582">proc <a href="queueLib.tcl-annot.html#::::WriteToQueueDebug">::::WriteToQueueDebug</a></a></strong> {whereAmI text} {
   global DEVREG
   if {[info exists DEVREG(server,enableLogFile)] &amp;&amp; $DEVREG(server,enableLogFile) &amp;&amp; \
       [info exists DEVREG(server,queueLogFileName)]} {
       if {[set fd_out [<a name="::FileOpen(27)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,queueLogFileName) a+]]==-1} {
            return $fd_out
       }
       catch {puts $fd_out &#34;==== $whereAmI ====\n$text&#34;} what
      funlock $fd_out
      close $fd_out
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: CreateQueueDebug</span>
<span class="comment-line">#  Queue Debug Proc</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           CreateQueueDebug</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CreateQueueDebug_1605">proc <a href="queueLib.tcl-annot.html#::::CreateQueueDebug">::::CreateQueueDebug</a></a></strong> { myQueueId runningIndex cfgFileTail } {
   global DEVREG
   if {[info exists DEVREG(server,enableLogFile)] &amp;&amp; $DEVREG(server,enableLogFile)} {
       set DEVREG(server,queueLogFileName) &#34;../main/Log/Q Debug $myQueueId $runningIndex $cfgFileTail.txt&#34;
       puts &#34;\n!!!!!\nQueue System Logging is E N A B L E D\n!!!!!\n&#34;;
   } else {
       puts &#34;\n!!!!!\nQueue System Logging is  N O T  Enabled\n!!!!!\n&#34;;
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: MoveReportToQueueFinished</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc moves determins the correct target dir based on </span>
<span class="comment-line">#              moduleUpdateStr. returns the targetDir to caller</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           queueId: queue id to work on</span>
<span class="comment-line">#           userIp: array of info file as passed  from the caller</span>
<span class="comment-line">#           index: runIndex to locate the desired module on which server worked on</span>
<span class="comment-line">#           moduleUpdateStr: take action appropriately based on moduleUpdateStr</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[set targetDir [MoveReportToQueueFinished $myQueueId \</span>
<span class="comment-line">#                              [array get uInput] $runningIndex downloadPassed]]==-1}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::MoveReportToQueueFinished_1634">proc <a href="queueLib.tcl-annot.html#::::MoveReportToQueueFinished">::::MoveReportToQueueFinished</a></a></strong> {queueId userIp index moduleUpdateStr} {
    global DEVREG
    global routingModules
    global env
    array set uInput $userIp
    global mainRetReRun
    global cfg
    global cfgFileTail
    global BLADES

    set moduleName [lindex $uInput(moduleNames:) $index]
    if {[info exists uInput(moduleTypes:)]} {
        set moduleType [lindex $uInput(moduleTypes:) $index]
        <a name="::WriteToQueueDebug(11)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; \
        &#34;Found moduleTypes index for $moduleName index $index moduleType $moduleType&#34;
    } else {
        set moduleType functional
        <a name="::WriteToQueueDebug(12)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; \
        &#34;Found moduleTypes index for $moduleName index $index moduleType $moduleType&#34;
    }
    set myRegPath  [<a name="::GetModuleFullType(1)"><a href="./queueLib.tcl.html#::GetModuleFullType_4251">::GetModuleFullType</a></a> $moduleType directory] ;<span class="comment-line"># $myRegPath - Functionaltest | XML_API etc.</span>
    set myNewType  [<a name="::GetModuleFullType(2)"><a href="./queueLib.tcl.html#::GetModuleFullType_4251">::GetModuleFullType</a></a> $moduleType runreg]
    set PLATFORM &#34;&#34;
    if {[info exists uInput(lockFile:)] &amp;&amp; ![info exists uInput(platformToRunOn:)]} {
        if {[file isdirectory $DEVREG(server,imagesRunningDir)/$queueId]} {
            if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/$queueId \
                $DEVREG(server,imagesFinishedDir)} reason]} {
                <a name="::WriteToQueueDebug(13)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; \
                &#34;Could not move $DEVREG(server,imagesRunningDir)/$queueId, $reason&#34;;
                <a name="::result_error(19)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not move $DEVREG(server,imagesRunningDir)/$queueId, $reason&#34;
                return -1
            } else {
                <a name="::WriteToQueueDebug(14)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; &#34;No plattoRunOn is set -- Return&#34;;
                return 1
            }
        } else {
            <a name="::WriteToQueueDebug(15)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; \
            &#34;Could not find $DEVREG(server,imagesRunningDir)/$queueId&#34;;
            <a name="::result_error(20)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not find $DEVREG(server,imagesRunningDir)/$queueId&#34;
            return -1
        }
    } else {
        <a name="::WriteToQueueDebug(16)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; \
            &#34;Not a user lock. set platformType $uInput(platformToRunOn:)&#34;;
        set platformType $uInput(platformToRunOn:)
    }
    if {[info exists uInput(relInfo:)]} {
        <a name="::WriteToQueueDebug(17)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; &#34;set releaseInfo $uInput(relInfo:)&#34;;
        set releaseInfo $uInput(relInfo:)
    } else {
        <a name="::WriteToQueueDebug(18)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; \
        &#34;set releaseInfo current B/C no info exist uInput(relInfo)&#34;;
        set releaseInfo &#34;current&#34;
    }
    if {$releaseInfo==&#34;&#34;} {
        <a name="::WriteToQueueDebug(19)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished&#34; &#34;set releaseInfo current B/C releaseInfo=null&#34;;
        set releaseInfo &#34;current&#34;
    }
    <span class="comment-line">#puts &#34;\n&lt;&lt;&lt;\n The releaseInfo $releaseInfo\nThe platformType at this point is $platformType\n &gt;&gt;&gt;\n&#34;</span>
    global env
    global $platformType ; <span class="comment-line">#Wierd. global the platform ex. Aspen later $Aspen will give legal prompt</span>
    global bothAspen bothAspennapa bothOlympic bothJaguar bothNetgear ;<span class="comment-line"># same as above.  For legal prompts</span>
    set none &#34;&#34;
    set cfgFileName [lindex $uInput(runStatus:) $index]
    set cfgFile [string range $cfgFileName 9 end]  ;<span class="comment-line"># get the cfg filename from runningOn$cfgFile</span>
    set targetDir &#34;&#34;
    set Path Path

    <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the moduleUpdateStr $moduleUpdateStr and cfgFile $cfgFile&#34;
    <a name="::WriteToQueueDebug(20)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished CONFIG FILE CHECK:&#34; \
    &#34;cfgFile $cfgFile - cfgFileTail $cfgFileTail - cfg $cfg&#34;

    switch -regexp $moduleUpdateStr {
        &#34;^PASS&#34; {
            <a name="::WriteToQueueDebug(21)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished plat: $platformType $queueId match Glob&#34; \
                &#34;$DEVREG(relInfoPath,$releaseInfo)/../${myRegPath}/$moduleName/Report/*$queueId*&#34;;
            set dirList [glob -nocomplain -- \
              &#34;$DEVREG(relInfoPath,$releaseInfo)/../${myRegPath}/$moduleName/Report/*$queueId*&#34;]
            set count 1
            <a name="::WriteToQueueDebug(22)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished DirList&#34; &#34;$dirList&#34;;
            while {1} {  ;<span class="comment-line"># While I do not know the target report dir</span>
                set reportDir [lindex $dirList [expr [llength $dirList] -$count]]
                if {$reportDir==&#34;&#34;} {
                    break
                }
                <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The report dir = $reportDir&#34;
                <a name="::WriteToQueueDebug(23)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished in While to find dir&#34; \
                  &#34;The report dir = $reportDir&#34;;
                set reportFileName &#34;$reportDir/report.txt&#34;
                if {![file exists $reportFileName]} {
                    <a name="::WriteToQueueDebug(24)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished in While, report.txt does not exist&#34; \
                       &#34;$reportFileName&#34;;
                    <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Report file does not exist: $reportFileName&#34;
                    break;
                }
                if {[set fd_in [<a name="::FileOpen(28)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> &#34;$reportFileName&#34; r]]==-1} {
                    return $fd_in
                }
                set targetDir &#34;&#34;
                while {[gets $fd_in readLine]!=-1} {
                    <span class="comment-line"># Following line works for both runningOn and reRunOn strings</span>
                    <span class="comment-line"># For runningOn, cfgFile is matched</span>
                    <span class="comment-line"># For reRunOn, the queueId is matched</span>
                    <span class="comment-line"># Open the report.txt and look for the config file name</span>
                    if {[regexp -nocase &#34;^Using config file: .*$cfgFile&#34; $readLine]||\
                      [regexp -nocase &#34;^Using config file: .*$queueId&#34; $readLine]} {
                        set targetDir $reportDir
                        break
                    }
                }
                funlock $fd_in
                close $fd_in
                if {$targetDir!=&#34;&#34;} {
                    break
                }
                incr count
            }
            if {[<a name="::GetModuleSubType(1)"><a href="./queueLib.tcl.html#::GetModuleSubType_620">::GetModuleSubType</a></a> $platformType $moduleName $myNewType] == &#34;routingModules&#34;} {
                set regSubType ipRoute1
            } else {
                set regSubType standard
            }
            regsub -all &#34;    &#34; $targetDir &#34; &#34; targetDir2
            regsub -all &#34;   &#34; $targetDir2 &#34; &#34; targetDir2
            regsub -all &#34;  &#34; $targetDir2 &#34; &#34; targetDir2
            set strl [split $targetDir2 &#34; &#34;]

            <span class="comment-line"># Pull platform blade and build info from the report directory.</span>
            set lastm1 [lindex $strl [expr [llength $strl]-2]]
            set lastm2 [lindex $strl [expr [llength $strl]-3]]
            set lastm3 [lindex $strl [expr [llength $strl]-4]]
            set lastm4 [lindex $strl [expr [llength $strl]-5]]
            set lastm5 [lindex $strl [expr [llength $strl]-6]]
            if [regexp {([0-9]+)\.([0-9]+)\.([0-9]+)} $lastm1] {
                set parsedBuild $lastm1
                set parsedBlade $lastm2
                set parsedBlade2 $lastm3
            } elseif [regexp {([0-9]+)\.([0-9]+)\.([0-9]+)} $lastm2] {
                set parsedBuild $lastm2
                set parsedBlade $lastm3
                set parsedBlade2 $lastm4
            } else {
                set parsedBuild $lastm3
                set parsedBlade $lastm4
                set parsedBlade2 $lastm5
            }
            <a name="::WriteToQueueDebug(25)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished: Parse Report Dir to get build and blade&#34; \
            &#34;$targetDir split parsedBuild $parsedBuild parsedBlade2 $parsedBlade2 parsedBlade $parsedBlade&#34;;
            global supportedPlatform
            global userQDir
            set tmpQStr [format  %s_%s $queueId $uInput(platformToRunOn:)]
            set env(WEBSERVERDIR) &#34;$userQDir/$uInput(userid:)/$tmpQStr&#34;
            cd &#34;../main&#34;
            <span class="comment-line">### Do not call mysqlAutomate on rerun as mysqlMain already calls it.</span>
            if {![info exists mainRetReRun]} {
                <a name="::WriteToQueueDebug(26)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished: Calling get_platform_code&#34; &#34;ParsedBlade \
                $parsedBlade ParseBlade2 parsedBlade2 - proc args $myNewType \
                $regSubType &#34;;
                if {[set PLATFORM [<a name="::get_platform_code(1)"><a href="./mysqlLib.tcl.html#::get_platform_code_1748">::get_platform_code</a></a> $myNewType $regSubType depricated $parsedBlade]]!=\
                    &#34;not_found&#34;} {
                    <a name="::WriteToQueueDebug(27)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished &#34; &#34;Calling mysqlAutomate w/ known blade \
                        -regId $queueId, platform $PLATFORM, build $parsedBuild, module $moduleName, \
                        regSubType $regSubType,regType $myNewType \
                        $parsedBlade , targetDir $targetDir&#34;;
                    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;&lt;&lt;&lt;Calling mysqlAutomate w/ known blade -regId $queueId, \n \
                        reportDir = $targetDir, \n \
                        platform $PLATFORM, \n \
                        build $parsedBuild, \n \
                        module $moduleName, \n \
                        regSubType $regSubType,\n \
                        regType $myNewType, \n \
                        sysName \n \
                        blade $parsedBlade&#34;
                    catch {exec $DEVREG(relInfoPath,$releaseInfo)/../main/mysqlAutomate.tcl \
                        -reportDir $targetDir -qId $queueId \
                        -regId $queueId -platform $PLATFORM -build $parsedBuild \
                        -module $moduleName -regType $myNewType \
                        -callLocation &#34;$moduleUpdateStr regServer:&#34; &gt;@stdout} automateRet
                } else {
                    <a name="::WriteToQueueDebug(28)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished &#34; \
                    &#34;Error: no PLATFORM found to submit to database: $PLATFORM&#34;;
                    <a name="::result_error(21)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: no PLATFORM found to submit to database: $PLATFORM&#34;
                }
            }
            unset env(WEBSERVERDIR)
            cd &#34;../Util&#34;

        } &#34;^DownloadPassed&#34; {  
            ;<span class="comment-line"># Not sure if we should move the report/result dir (if any) in case of downloadFailed</span>
            <span class="comment-line"># Since in case of download failed, location to loadimage.txt is sent for tracing purposes</span>
            <span class="comment-line"># For download passed, the report is moved to moduleName/downloadImage/Report dir</span>
            set dirList [recursive_glob &#34;$env(BASE_PATH)/Report/&#34; loadimage.txt]
            <a name="::WriteToQueueDebug(29)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished DownloadPassed&#34; &#34;DirList: $dirList&#34;;
            for {set i [expr [llength $dirList]-1]} {$i&gt;=0} {incr i -1} {
                set dirName [lindex $dirList $i]
                if {[set fd_in [<a name="::FileOpen(29)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> &#34;$dirName&#34; r]]==-1} {
                    return $fd_in
                }
                set targetDir &#34;&#34;
                while {[gets $fd_in readLine]!=-1} {
                    if {[regexp -nocase &#34;^Using config file: .*$cfgFile&#34; $readLine]} {
                        set targetDir [file dirname $dirName]
                        <a name="::WriteToQueueDebug(30)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished DownloadPassed&#34; \
                        &#34;set targetDir [file dirname $dirName]&#34;;
                        break
                    }
                }
                funlock $fd_in
                close $fd_in
                if {$targetDir!=&#34;&#34;} {
                    break
                }
            }
        } &#34;^DownloadFailed&#34; -
        &#34;^MainFailed&#34; {
            <a name="::WriteToQueueDebug(31)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished DownloadFail MainFail&#34; \
            &#34;set targetDir /tmp/Tmp/$queueId[pid]&#34;;
            set targetDir &#34;/tmp/Tmp/$queueId[pid]&#34;
        } &#34;^DownloadKilled&#34; -
        &#34;^MainKilled&#34; {
            <a name="::WriteToQueueDebug(32)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished DownloadKilled MainKilled&#34; \
            &#34;set targetDir empty string&#34;;
            set targetDir &#34;&#34;
        } default {
            <a name="::WriteToQueueDebug(33)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished UNKNOWN STATE&#34; &#34;return a negative 1&#34;;
            <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unknown update str&#34;
            return -1
        }
    }
    <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n ============================================\n\
    ============================================\n\
    targetDir = $targetDir\n \
    Platform  = $PLATFORM\n \
    ============================================\n\
    ============================================&#34;
    <a name="::WriteToQueueDebug(34)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished Target should be set&#34; \
        &#34;the targetDir $targetDir&#34;;
    if {$targetDir!=&#34;&#34;} {
        if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
            if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
                <a name="::WriteToQueueDebug(35)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - make images finished dir &#34; \
                    &#34;Error: Can not create imagesFinishedDir dir...$reason&#34;;
                <a name="::result_error(22)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create imagesFinishedDir dir...$reason&#34;
                return -1
            }
        }
        <a name="::WriteToQueueDebug(36)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished Images finished&#34; \
            &#34;mkdir $DEVREG(server,imagesFinishedDir)&#34;;
        if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$queueId]} {
            if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$queueId&#34;} reason]} {
                <a name="::WriteToQueueDebug(37)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - make images finished dir &#34; \
                    &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$queueId...$reason&#34;;
                <a name="::result_error(23)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$queueId...$reason&#34;;
                return -1
            }
        }
        <a name="::WriteToQueueDebug(38)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished Images finished&#34; \
            &#34;mkdir $DEVREG(server,imagesFinishedDir)/$queueId&#34;;
        if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName&#34;} reason]} {
            <a name="::WriteToQueueDebug(39)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - make images finished dir &#34; \
                &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName...$reason&#34;;
            <a name="::result_error(24)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir \
                $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName...$reason&#34;;
            return -1
        }
        <a name="::WriteToQueueDebug(40)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished Images finished&#34; \
            &#34;mkdir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName&#34;;
        if {[regexp -nocase &#34;download&#34; $moduleUpdateStr] &amp;&amp; \
            ([regexp -nocase &#34;killed&#34; $moduleUpdateStr]!=1)} {
            if {[catch {file mkdir \
                &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage&#34;} reason]} {
                <a name="::WriteToQueueDebug(41)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - download&#34; \
                &#34;Error: Cannot create dir \
                $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage...$reason&#34;;
                <a name="::result_error(25)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir \
                $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage...$reason&#34;;
                return -1
            }
            <a name="::WriteToQueueDebug(42)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished Images Download&#34; \
                &#34;mkdir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage&#34;;
            if {[regexp -nocase &#34;downloadPassed&#34; $moduleUpdateStr]} {
                catch {file rename -force $targetDir \
                    $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report} myR
                if {$PLATFORM==&#34;not_found&#34;} {
                     <a name="::WriteToQueueDebug(43)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - downloadPassed&#34; \
                         &#34;return neg 1&#34;;
                     return -1
                } else {
                    <a name="::WriteToQueueDebug(44)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - downloadPassed&#34; \
                        &#34;return $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report&#34;;
                    return &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report&#34;
                }
            } else {
                catch {file rename -force $targetDir \
                     $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/loadimage.txt} reason
                if {$PLATFORM==&#34;not_found&#34;} {<a name="::WriteToQueueDebug(45)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - make images \
                finished dir &#34; &#34;&#34;; return -1} else {
                    <a name="::WriteToQueueDebug(46)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - not downloadPassed &#34; \
                    &#34;return $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/&#34;;
                    return &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/&#34;
                }
            }
        } else {
            if {[regexp -nocase &#34;mainfailed&#34; $moduleUpdateStr]} {
                if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result&#34;} reason]} {
                    <a name="::WriteToQueueDebug(47)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - Mainfailed &#34; \
                        &#34;Error: Cannot create dir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result...$reason&#34;;
                    <a name="::result_error(26)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result...$reason&#34;;
                    return -1
                }
                catch {file rename -force $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/report.txt} reason
                if {$PLATFORM==&#34;not_found&#34;} {
                    <a name="::WriteToQueueDebug(48)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - mainfaild&#34; \
                        &#34;rename $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/report.txt&#34;;
                    return -1
                } else {
                    <a name="::WriteToQueueDebug(49)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - make images finished dir &#34; \
                        &#34;rename $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/report.txt&#34;;
                    return &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/&#34;
                }
            } else {
                if {[file isdirectory $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report]} {
                    ;<span class="comment-line"># reRun case</span>
                    catch {file rename -force $targetDir \
                          $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report1} reason
                    if {$PLATFORM==&#34;not_found&#34;} {
                        <a name="::WriteToQueueDebug(50)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - Not mainfail \
                        $PLATFORM not found&#34; &#34;&#34;;
                        return -1
                    } else {
                        <a name="::WriteToQueueDebug(51)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - make images finished dir &#34; &#34;rename \
                        $targetDir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report1&#34;;
                        return &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report1&#34;
                    }
                } else {   ;<span class="comment-line"># first run case</span>
                    catch {file rename -force $targetDir \
                           $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report} reason
                    if {$PLATFORM==&#34;not_found&#34;} {
                        <a name="::WriteToQueueDebug(52)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - NOT a dir \
                            $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report]&#34; \
                            &#34;return 1&#34;; 
                        return -1
                    } else {
                        <a name="::WriteToQueueDebug(53)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - not mainfailed&#34; &#34;rename $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report&#34;;
                        return &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report&#34;
                    }
                }
            }
        }
    } else {
        if {[regexp -nocase &#34;killed&#34; $moduleUpdateStr]} {
            <a name="::WriteToQueueDebug(54)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - TargetDir = null Killed&#34; \
            &#34;Return [<a name="::ProcessSrvrQueueKill(1)"><a href="./queueLib.tcl.html#::ProcessSrvrQueueKill_2774">::ProcessSrvrQueueKill</a></a> $queueId]&#34;;
            return [<a name="::ProcessSrvrQueueKill(2)"><a href="./queueLib.tcl.html#::ProcessSrvrQueueKill_2774">::ProcessSrvrQueueKill</a></a> $queueId]   ;<span class="comment-line"># always returns -1 as this is killed signal</span>
        }
        <a name="::WriteToQueueDebug(55)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MoveReportToQueueFinished - TargetDir = null&#34; &#34;Return neg 1&#34;;
        return -1
    }
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: EmailReportFilesMail</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc emails to the desired userId from userIp array</span>
<span class="comment-line">#              based on the state.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           qId: queue id to work on</span>
<span class="comment-line">#           runIndex: runIndex to locate the desired module on which server worked on</span>
<span class="comment-line">#           cfgFile: config file name to be sent to email</span>
<span class="comment-line">#           targetDir: target Dir which has to be sent as a html link in message body</span>
<span class="comment-line">#           state: constists of one of pass/mainfailed/downloadpassed/downloadfailed etc.</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           EmailReportFilesMail $myQueueId [array get uInput] $runningIndex $targetDir PASS</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::EmailReportFilesMail_2020">proc <a href="queueLib.tcl-annot.html#::::EmailReportFilesMail">::::EmailReportFilesMail</a></a></strong> { qId runIndex cfgFile targetDir { state } args} {
    global DEVREG
    global harnessOwners


    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> EmailReportFilesMail $args {
        uip &#34;null&#34;
        mainReturnInfo &#34;&#34;
    }

    if {$uip==&#34;null&#34;} {
        if {[set imageDir [<a name="::LocateQueueId(1)"><a href="./queueLib.tcl.html#::LocateQueueId_1542">::LocateQueueId</a></a> $qId]]==-1} {
            <a name="::result_error(27)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: No queue Id $qId found.&#34;
            return $imageDir
        }
        <a name="::ReadQueueInfoIntoArray(3)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $imageDir/info uInput
    } else {
        array set uInput $uip
    }

    <span class="comment-line"># --- local vars ---</span>
    set shortString &#34;&#34;
    set moduleName [lindex $uInput(moduleNames:) $runIndex]
    set platformChosen $uInput(platformToRunOn:)

    set hostName http://[lindex [split [exec hostname] .] 0]
    <span class="comment-line">#   set s [format \\%s $hostName]</span>
    <span class="comment-line">#   set hostName [format \\%s $s]  ;# Manipulate the hostname to become \\$hostName</span>
    set sharedDir &#34;&#34;
    if {[regsub &#34;$DEVREG(server,regressionDir)&#34; $targetDir &#34;&#34; sharedDir]==0} {
        set sharedDir &#34;&#34;
    }
    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the sharedDir $sharedDir&#34;
    set rm 0
    if {[regexp -nocase &#34;release-manager&#34; $uInput(userid:)]} {
        set rm 1
        puts &#34;Hit RELEASE-MANAGER - sentTo = $uInput(userid:)&#34;
        set toBeSent &#34;&#34;
    } else {
        puts &#34;MISSED RELEASE-MANAGER&#34;
        if {[regexp -nocase &#34;\@&#34; $uInput(userid:)]} {
           set toBeSent &#34;$uInput(userid:).extremenetworks.com&#34;
        } else {
           set toBeSent &#34;$uInput(userid:)@extremenetworks.com&#34;
        }
    }
    set dbHref &#34;http://biltmore.extremenetworks.com/cgi-bin/regdb.cgi?screen=regrun&amp;id_label=${qId}&#34;;
    <span class="comment-line">#set webStr &#34;&lt;a href=\&#34;$dbHref\&#34;&gt;Database Report&lt;/a&gt;&lt;/td&gt;&#34;;</span>
    set str &#34;Report Directory: [format %s/%s/%s $hostName [file tail $DEVREG(server,regressionDir)] $sharedDir]\n\n$mainReturnInfo\n&#34;
    if {$state == &#34;PASS&#34; || $state==&#34;MAINFAILED&#34;} {
       append str &#34;$dbHref\n\n&#34;;
       set str [append str [<a name="::PrintUserQueue(2)"><a href="./queueLib.tcl.html#::PrintUserQueue_2538">::PrintUserQueue</a></a> [array get uInput] $qId]]
       set shortString $str
       set reportFileName &#34;$targetDir/report.txt&#34;
       if {![file exists $targetDir/report.txt]} {
           <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Email report.txt does not exist:&#34;
           <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;TargetDir: $targetDir\nsharedDir $sharedDir&#34;
           <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;report.txt $targetDir/report.txt&#34;
           return $state;
       }
       if {[set fd_in [<a name="::FileOpen(30)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $reportFileName r reason]]==-1} {
          puts &#34;Sending Email to $toBeSent&#34;
          set str [append str &#34;\n&#34; $reason]
          set state FAIL
          if {!$rm} {
              if {[file isfile &#34;/bin/mailx&#34;]} {
                  exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; \
                  -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                  $toBeSent &lt;&lt; &#34;$str&#34; &amp;
              } else {
                  exec /bin/mail -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; $toBeSent &lt;&lt; &#34;$str&#34; &amp;
              }
          }
          <a name="::LogRegRun(1)"><a href="./queueLib.tcl.html#::LogRegRun_2271">::LogRegRun</a></a> $qId 0 1 $runIndex $cfgFile [array get uInput]  ;<span class="comment-line"># log the regression results to regrun.log</span>
          return $fd_in
       }
       set testsPassed 0
       set testsFailed 1
       set swRevNum &#34;&#34;
       while {[gets $fd_in line]!=-1} {
          set str [append str &#34;\n&#34; $line]
          if {[regexp -nocase &#34;^number of sub test cases failed&#34; $line]} {
             set testsFailed [lindex $line [expr [llength $line]-1]]
          }
          if {[regexp -nocase &#34;^number of sub test cases passed&#34; $line]} {
             set testsPassed [lindex $line [expr [llength $line]-1]]
          }
          if {[regexp -nocase &#34;^revision number:&#34; $line]} {
              <span class="comment-line">#Revision Number: 89516</span>
              set swRevNum [lindex $line [expr [llength $line]-1]]
          }
       }
       close $fd_in
       if {$state==&#34;PASS&#34; &amp;&amp; $testsFailed&gt;=1} {
          set state &#34;FAIL&#34;
       }
       if {!$rm} {
           puts &#34;Sending Email to $toBeSent&#34;
           if {$state==&#34;MAINFAILED&#34;} {
              <span class="comment-line"># EY-12-06-2007: Put entire list of recipients in double-quotes to</span>
              <span class="comment-line"># avoid e-mail addresses being separated by &#34;.' characters.</span>
              if {[file isfile &#34;/bin/mailx&#34;]} {
                  exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; -a &#34;$reportFileName&#34; \
                  -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                  &#34;$toBeSent $harnessOwners&#34; &lt;&lt; &#34;$shortString&#34; &amp;
              } else {
                  exec /bin/mail -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                  &#34;$toBeSent $harnessOwners&#34; \
                  -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
              }
           } else {
              if {[file isfile &#34;/bin/mailx&#34;]} {
                  exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; \
                  -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                  &#34;$toBeSent&#34; &lt;&lt; &#34;$str&#34; &amp;
              } else {
                  exec /bin/mail -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                  &#34;$toBeSent&#34; -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
              }
              
           }
       } elseif {$state==&#34;MAINFAILED&#34;} {
            <span class="comment-line"># EY-12-06-2007: Put entire list of recipients in double-quotes to</span>
            <span class="comment-line"># avoid e-mail addresses being separated by &#34;.' characters.</span>
            if {[file isfile &#34;/bin/mailx&#34;]} {
                exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; -a &#34;$reportFileName&#34; \
                -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                &#34;$harnessOwners&#34; &lt;&lt; &#34;$shortString&#34; &amp;
            } else {
                exec /bin/mail -s &#34;$qId\($cfgFile\): $moduleName *$state*&#34; \
                &#34;$harnessOwners&#34; \
                -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
            }
       }
    } elseif {$state==&#34;FAIL&#34;||[regexp -nocase &#34;killed&#34; $state]} {   ;<span class="comment-line"># failed during download</span>
       puts &#34;Sending Email to $toBeSent&#34;
       set testsPassed 0
       set testsFailed 1
       set swRevNum &#34;&#34;
       if {[regexp -nocase &#34;mainKilled&#34; $state]} {
          set str [append str &#34;main regression $state on $cfgFile setup with following queue information:\n&#34;]
       } elseif {[regexp -nocase &#34;downloadkilled&#34; $state]} {
          set str [append str &#34;download image killed via LoadImage.tcl on $cfgFile setup with following queue information:\n&#34;]
       } elseif {[regexp -nocase &#34;FAIL&#34; $state]} {
          set str [append str &#34;download image $state via LoadImage.tcl on $cfgFile setup with following queue information:\n&#34;]
       }
       set str [append str [<a name="::PrintUserQueue(3)"><a href="./queueLib.tcl.html#::PrintUserQueue_2538">::PrintUserQueue</a></a> [array get uInput] $qId]]

       <span class="comment-line"># EY-12-06-2007: Put entire list of recipients in double-quotes to</span>
       <span class="comment-line"># avoid e-mail addresses being separated by &#34;.' characters.</span>
       if {!$rm} {
           puts &#34;NOT RELEASE-MANAGER SEND THE NOTE&#34;
           if {[file isfile &#34;/bin/mailx&#34;]} {
               exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; \
               -s &#34;$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image&#34; \
               &#34;$toBeSent $harnessOwners&#34; &lt;&lt; &#34;$str&#34; &amp;
           } else {
               exec /bin/mail -s &#34;$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image&#34; \
                 &#34;$toBeSent $harnessOwners&#34; -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
           }
       } else {
           if {[file isfile &#34;/bin/mailx&#34;]} {
               exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; \
               -s &#34;$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image&#34; \
               &#34;$harnessOwners&#34; &lt;&lt; &#34;$str&#34; &amp;
           } else {
               exec /bin/mail -s &#34;$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image
&#34; \
                 &#34;$harnessOwners&#34; -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
           }
       }
    } elseif {$state==&#34;AUTOLOCKED&#34;} {
       puts &#34;Sending Email to HARNESS OWNERS&#34;
       set testsPassed 0
       set testsFailed 1
       set swRevNum &#34;&#34;
       set str [append str &#34;This Test Bed ( $cfgFile ) has been Auto Locked:\n&#34;]
       set str [append str [<a name="::PrintUserQueue(4)"><a href="./queueLib.tcl.html#::PrintUserQueue_2538">::PrintUserQueue</a></a> [array get uInput] $qId]];
       if {[file isfile &#34;/bin/mailx&#34;]} {
           exec /bin/mail -r &#34;Sqaautosupport@extremenetworks.com&#34; \
           -s &#34;AUTOLOCKED $qId\($platformChosen\): [lindex $uInput(moduleNames:) $runIndex] ***$state***&#34; \
           $harnessOwners &lt;&lt; &#34;$str&#34; &amp;;
       } else {
           exec /bin/mail -s &#34;AUTOLOCKED $qId\($platformChosen\): [lindex $uInput(moduleNames:) $runIndex] ***$state***&#34; \
            $harnessOwners -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;'
       }
    }
    <a name="::LogRegRun(2)"><a href="./queueLib.tcl.html#::LogRegRun_2271">::LogRegRun</a></a> $qId $testsPassed $testsFailed $runIndex $cfgFile [array get uInput]  ;<span class="comment-line"># log the regression results to regrun.log</span>

   return $state
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: LogRegStart</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc writes the start regression log into regstart.log file</span>
<span class="comment-line">#              This is performed to maintain backward compatibility to runall</span>
<span class="comment-line">#              for tracing user logs.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           queueId: queue id to write</span>
<span class="comment-line">#           runIndex: runIndex to locate the desired module on which server worked on</span>
<span class="comment-line">#           cfgFile: tail of the file to mention based on the server name</span>
<span class="comment-line">#           uInput: queue info array</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           LogRegStart $myQueueId $runningIndex $cfgFileTail [array get uInput]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LogRegStart_2232">proc <a href="queueLib.tcl-annot.html#::::LogRegStart">::::LogRegStart</a></a></strong> {queueId runIndex cfgFile uInput} {
   global DEVREG
   global env
   array set userInput $uInput

   if {[set fd_out [<a name="::FileOpen(31)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> tmp[pid] w]]==-1} {
      return $fd_out
   }
   puts $fd_out &#34;$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $runIndex] [lindex $userInput(moduleNames:) $runIndex]&#34;
   <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $runIndex] [lindex $userInput(moduleNames:) $runIndex]&#34;
   close $fd_out
   <span class="comment-line"># 1/18/05: Needed to append at start of file</span>
   <span class="comment-line"># Write to temp and append original at end of temp, move temp to original</span>
   <a name="::combineTwoFiles(1)"><a href="./queueLib.tcl.html#::combineTwoFiles_3230">::combineTwoFiles</a></a> tmp[pid] $DEVREG(server,regressionDir)/regstart.log
   catch {file rename -force tmp[pid] $DEVREG(server,regressionDir)/regstart.log} myR
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: LogRegRun</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc writes the run regression log into regrun.log file</span>
<span class="comment-line">#              This is performed to maintain backward compatibility to runall</span>
<span class="comment-line">#              for tracing user logs.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           queueId: queue id to write</span>
<span class="comment-line">#           numPassed: number of passed tests</span>
<span class="comment-line">#           numFailed: number of Failed tests</span>
<span class="comment-line">#           index: index for accessing the module in queue info array</span>
<span class="comment-line">#           cfgFile: tail of the file to mention based on the server name</span>
<span class="comment-line">#           userIp: queue info array</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           LogRegRun $qId $testsPassed $testsFailed $runIndex $cfgFile [array get uInput]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LogRegRun_2271">proc <a href="queueLib.tcl-annot.html#::::LogRegRun">::::LogRegRun</a></a></strong> {queueId numPassed numFailed index cfgFile userIp} {
   global DEVREG
   global env
   array set userInput $userIp

   if {[set fd_out [<a name="::FileOpen(32)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> tmp[pid] w]]==-1} {
      return $fd_out
   }
   puts $fd_out &#34;$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $index] [lindex $userInput(moduleNames:) $index] FAIL=$numFailed of [expr $numPassed+$numFailed]&#34;
   <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $index] [lindex $userInput(moduleNames:) $index] FAIL=$numFailed of [expr $numPassed+$numFailed]&#34;
   close $fd_out
   <a name="::combineTwoFiles(2)"><a href="./queueLib.tcl.html#::combineTwoFiles_3230">::combineTwoFiles</a></a> tmp[pid] $DEVREG(server,regressionDir)/regrun.log
   catch {file rename -force tmp[pid] $DEVREG(server,regressionDir)/regrun.log} myR
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: KillImmediately</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc takes the killDir as input dir name,</span>
<span class="comment-line">#              based on the imagesQueued/imagesRunning calls shell ps</span>
<span class="comment-line">#              and setuid killProc to kill the root server's run process.</span>
<span class="comment-line">#              After the kill is performed, an email is sent to the userid</span>
<span class="comment-line">#              as well as necessary move of imagesQueued/imagesRunning to imagesKilled dir.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           killDir: queueId dir of any of imagesQueued/imagesRunning dirs</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[KillImmediately $imageDir]==1} {</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::KillImmediately_2306">proc <a href="queueLib.tcl-annot.html#::::KillImmediately">::::KillImmediately</a></a></strong> {killDir force queueId} {
   global DEVREG

   if {[set fd_q [<a name="::FileOpen(33)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $killDir/info r]]==-1} {
      return $fd_q
   }
   while {[gets $fd_q infoLine]!=-1} {
      set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
   }
   close $fd_q
   if {[info exists userInput(lockFile:)] &amp;&amp; ![info exists userInput(platformToRunOn:)]} {
      <span class="comment-line">### lock queueId, process kill differently</span>
      if {[set retCode [<a name="::UnlockQueuedLock(1)"><a href="./queueLib.tcl.html#::UnlockQueuedLock_2990">::UnlockQueuedLock</a></a> &#34;$killDir&#34; [array get userInput]]]==1} {
         return $retCode
      } else {
         <a name="::result_error(28)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Can not kill a locked testbed queueId&#34;
         return -1
      }
   }
   global env
   if {[regexp -nocase &#34;imagesQueued&#34; $killDir]} {
      set grepStr queued
   } elseif {[regexp -nocase &#34;imagesRunning&#34; $killDir]} {
      set grepStr &#34;runningOn|reRunOn|queued&#34;
   }
   for {set i 0} {$i&lt;[llength $userInput(runStatus:)]} {incr i} {
      set moduleName [lindex $userInput(moduleNames:) $i]
      set status [lindex $userInput(runStatus:) $i]
      if {[regexp -nocase $grepStr $status]} {
         switch -regexp $status {
         &#34;queued&#34; {
            <span class="comment-line">### Check if no module is running</span>
            if {![regexp -nocase &#34;runningOn|reRunOn&#34; $userInput(runStatus:)]} {
                <span class="comment-line">### No module is running, just move imagesRunningDir to imagesKilledDir and rmdir imagesQueuedDir/queueId</span>
                if {[catch {exec $env(BASE_PATH)/mvProc $killDir $DEVREG(server,imagesKilledDir)} reason]} {
                    if {$force != &#34;null&#34;} {
                       <span class="comment-line"># ------------------------------------------------------------</span>
                       <span class="comment-line"># The move did not work.  Just whack the running or queued dir</span>
                       <span class="comment-line"># ------------------------------------------------------------</span>
                       set queueId [file tail $killDir]
                       if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$queueId]} {   ;<span class="comment-line"># delete the queuedDir and only move runningDir</span>
                          if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$queueId} reason]} {
                             <a name="::result_error(29)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $DEVREG(server,imagesQueuedDir)/$queueId, $reason&#34;
                             return 137
                          } else {
                             if {[set retCode [<a name="::RemoveQidFromPriority(3)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> $queueId]]==-1} {
                                return $retCode
                             } else {
                                <a name="::dbKillReg(1)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                                email_qKilled $queueId [array get userInput]
                                <a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully deleted queueId: $queueId from images queued&#34;
                                break;
                             }
                          }
                       }
                    } else {
                        <a name="::result_error(30)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not move $killDir, $reason&#34;
                        return -1
                    }
                } else {
                   <span class="comment-line"># Also remove the imagesQueuedDir/queueId</span>
                   set queueId [file tail $killDir]
                   if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$queueId]} {   ;<span class="comment-line"># delete the queuedDir and only move runningDir</span>
                      if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$queueId} reason]} {
                         <a name="::result_error(31)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $DEVREG(server,imagesQueuedDir)/$queueId, $reason&#34;
                         return 137
                      } else {
                         if {[set retCode [<a name="::RemoveQidFromPriority(4)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> $queueId]]==-1} {
                            return $retCode
                         } else {
                            <a name="::dbKillReg(2)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                            email_qKilled $queueId [array get userInput]
                            <a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully deleted queueId: $queueId from images queued&#34;
                            break;
                         }
                      }
                   }
               }
            } else {
               <span class="comment-line">### Do nothing</span>
            } 
         }
         &#34;^runningOn&#34; -
         &#34;^reRunOn&#34; {
             regsub $grepStr $status &#34;&#34; configFile
             set qIdRunning [<a name="::GetLatestIdRunning(1)"><a href="./queueLib.tcl.html#::GetLatestIdRunning_3210">::GetLatestIdRunning</a></a> $configFile]
             set theCfg [lindex [split $configFile .] 0]
             set psLine [catch {exec ps -eafwww | egrep -e &#34;Load.*$configFile|main.tcl.*$configFile|pybot.*$theCfg&#34; | grep -v grep} psout]
             set psLineitest [catch {exec ps -eafwww | egrep -e &#34;pybot.*$theCfg&#34; | grep -v grep} psoutitest]
             puts &#34;the psLine $psLine and configFile $configFile&#34;
             puts &#34;the pid to kill [lindex $psout 1] from $psout\n $killDir&#34;
             puts &#34;qIdRunning $qIdRunning != killDir [file tail $killDir]&#34;
             if {$qIdRunning!=[file tail $killDir]} {
                puts &#34;NOT EQUAL&#34;
                if {[file isdirectory $DEVREG(server,imagesRunningDir)/[file tail $killDir]]} {
                   if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/[file tail $killDir] $DEVREG(server,imagesKilledDir)} reason]} {
                       if {$force != &#34;null&#34;} {
                          <span class="comment-line"># ------------------------------------------------------------</span>
                          <span class="comment-line"># The move did not work.  Just whack the running or queued dir</span>
                          <span class="comment-line"># ------------------------------------------------------------</span>
                          set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                          foreach fileName $imageQueuedDir {
                             <span class="comment-line">#puts &#34;the filename $fileName\n$env(BASE_PATH)/rmProc -rf $fileName&#34;</span>
                             if {[file tail $fileName]==[file tail $killDir]} {
                                 if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                    <a name="::result_error(32)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $fileName, $reason&#34;
                                    return -1
                                 }
                             }
                          }
                          puts &#34;Now killing qId [file tail $killDir]&#34;
                          <a name="::RemoveQidFromPriority(5)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> [file tail $killDir]
                          <a name="::dbKillReg(3)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                          set retValue 0
                       } else {
                          <a name="::result_error(33)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not move $DEVREG(server,imagesRunningDir)/[file tail $killDir], $reason&#34;
                          set retValue 1
                       }
                   } else {
                      <span class="comment-line"># Specific case of left over queueedDir removal. Notice -rf</span>
                      set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                      foreach fileName $imageQueuedDir {
                         <span class="comment-line">#puts &#34;the filename $fileName\n$env(BASE_PATH)/rmProc -rf $fileName&#34;</span>
                         if {[file tail $fileName]==[file tail $killDir]} {
                             if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                <a name="::result_error(34)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $fileName, $reason&#34;
                                return -1
                             }
                         }
                      }
                      puts &#34;Now killing qId [file tail $killDir]&#34;
                      <a name="::RemoveQidFromPriority(6)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> [file tail $killDir]
                      <a name="::dbKillReg(4)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                      set retValue 0
                   }
                }  
             } elseif {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
                puts &#34;FAILED qIdRunning $qIdRunning!=[file tail $killDir] Found Proc [lindex $psout 1]&#34;
                set retValue [catch {exec $env(BASE_PATH)/killProc [lindex $psout 1]}]
                set cmd1 &#34;wait [lindex $psout 1]&#34;
                set outpid1 [catch &#34;$cmd1&#34; reason1]
                if {$outpid1} {
                    <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Failed to wait for child return: $reason1\n&#34;
                }
                if {$retValue==0} {
                    <a name="::dbKillReg(5)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                }
                if {[regexp -nocase {[0-9]+} [lindex $psoutitest 1]]} {
                    set retValue [catch {exec $env(BASE_PATH)/killProc [lindex $psoutitest 1]}]
                    set cmd1 &#34;wait [lindex $psoutitest 1]&#34;
                    set outpid2 [catch &#34;$cmd1&#34; reason2]
                    if {$outpid2} {
                        <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Failed to wait for child return: $reason2\n&#34;
                    }
                }
             } elseif {$qIdRunning==[file tail $killDir]&amp;&amp;![regexp -nocase {[0-9]+} [lindex $psout 1]]} {
                puts &#34;qIdRunning $qIdRunning == [file tail $killDir] NOT Found Proc [lindex $psout 1]&#34;
                if {[file isdirectory $DEVREG(server,imagesRunningDir)/[file tail $killDir]]} {
                   if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/[file tail $killDir] $DEVREG(server,imagesKilledDir)} reason]} {
                       if {$force != &#34;null&#34;} {
                          <span class="comment-line"># ------------------------------------------------------------</span>
                          <span class="comment-line"># The move did not work.  Just whack the running or queued dir</span>
                          <span class="comment-line"># ------------------------------------------------------------</span>
                          set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                          foreach fileName $imageQueuedDir {
                             if {[file tail $fileName]==[file tail $killDir]} {
                                 puts &#34;Filename match $fileName $env(BASE_PATH)/rmProc -rf $fileName&#34;
                                 if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                    <a name="::result_error(35)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $fileName, $reason&#34;
                                    return -1
                                 }
                             }
                          }
                          puts &#34;Now killing qId [file tail $killDir]&#34;
                          <a name="::RemoveQidFromPriority(7)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> [file tail $killDir]
                          <a name="::dbKillReg(6)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                          set retValue 0
                       } else {
                          <a name="::result_error(36)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not move $DEVREG(server,imagesRunningDir)/[file tail $killDir], $reason&#34;
                          set retValue 1
                       }
                   } else {
                      <span class="comment-line"># Specific case of left over queueedDir removal. Notice -rf</span>
                      set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                      foreach fileName $imageQueuedDir {
                         if {[file tail $fileName]==[file tail $killDir]} {
                             puts &#34;Filename match $fileName $env(BASE_PATH)/rmProc -rf $fileName&#34;
                             if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                <a name="::result_error(37)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $fileName, $reason&#34;
                                return -1
                             }
                         }
                      }
                      puts &#34;Now killing qId [file tail $killDir]&#34;
                      <a name="::RemoveQidFromPriority(8)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> [file tail $killDir]
                      <a name="::dbKillReg(7)"><a href="./mysqlLib.tcl.html#::dbKillReg_4135">::dbKillReg</a></a> $queueId
                      set retValue 0
                   }
                }
                set retValue 0
             } else {
                set retValue 1
             }
             if {$retValue==1} {
                <a name="::result_error(38)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;error in killProc $retValue&#34;
                return -1
             }
         }
         }
      }
   }

   return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: PrintUserQueue</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc prints the queueId's info information,</span>
<span class="comment-line">#              in a presentable way, dumps the moduleNames/moduleLists</span>
<span class="comment-line">#              and runStatus in table for better readibility</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           uInput: queueId info array to be printed</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           PrintUserQueue [array get userInput]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::PrintUserQueue_2538">proc <a href="queueLib.tcl-annot.html#::::PrintUserQueue">::::PrintUserQueue</a></a></strong> {uInput queueId} {
   array set usrInput $uInput
   global DEVREG
   set strToReturn &#34;&#34;
   global RestOfDUTType RestOfIPRDUTType DEVREG

   puts &#34;[format &#34;%-17s %-20s&#34; userid: $usrInput(userid:)]&#34;
   set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-20s&#34; userid: $usrInput(userid:)]]
   if {[info exists usrInput(platformToRunOn:)]} {
      set platformToRunOn $usrInput(platformToRunOn:)
   } else {
      set platformToRunOn &#34;&#34;
   }
   foreach varName [array names usrInput] {
      if {![regexp -nocase &#34;userid|moduleLists|runStatus|moduleNames|moduleTypes&#34; $varName]&amp;&amp;$platformToRunOn!=&#34;&#34;} {
         <span class="comment-line"># do not display disabled efence</span>
         if {[string compare &#34;efence:&#34; $varName]==0 &amp;&amp; $usrInput($varName)!=&#34;enable&#34;} {
            continue
         }
         <span class="comment-line"># do not display release info</span>
         if {[string compare &#34;relInfo:&#34; $varName]==0 &amp;&amp; $usrInput($varName)==&#34;&#34;} {
            continue
         }
         if {![regexp -nocase &#34;[string tolower $RestOfDUTType($platformToRunOn)]Image|[string tolower $RestOfIPRDUTType($platformToRunOn)]Image&#34; $varName]&amp;&amp;\
             [regexp -- &#34;Image&#34; $varName]&amp;&amp;![regexp -nocase &#34;$platformToRunOn&#34; $varName]&amp;&amp;\
             ![regexp -nocase &#34;[string tolower $RestOfDUTType($platformToRunOn)]BL_Image|[string tolower $RestOfIPRDUTType($platformToRunOn)]BL_Image&#34; $varName]} {
             <span class="comment-line"># Baseline case</span>
            continue ;<span class="comment-line"># Do not display unwanted platforms' image</span>
         }
         puts &#34;[format &#34;%-17s %-20s&#34; $varName $usrInput($varName)]&#34;
         set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-20s&#34; $varName $usrInput($varName)]]
      } elseif {$platformToRunOn==&#34;&#34; &amp;&amp; [regexp -nocase &#34;lockFile&#34; $varName]} {
         puts &#34;[format &#34;%-17s %-20s&#34; $varName $usrInput($varName)]&#34;
         set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-20s&#34; $varName $usrInput($varName)]]
      }
   }
   set maxLength 6
   for {set i 0} {$i&lt;[llength $usrInput(runStatus:)]} {incr i} {
      set moduleName [lindex $usrInput(moduleNames:) $i]
      if {[string length $moduleName]&gt;$maxLength} {
         set maxLength [string length $moduleName]
      }
   }
   set dashStr &#34;&#34;
   for {set i 0} {$i&lt;$maxLength} {incr i} {
      set dashStr [append dashStr &#34;-&#34;]
   }
   set maxLength [append maxLength s]
   <span class="comment-line">### Now print module information in a table format</span>
   puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; Modules: module List modType runStatus]&#34;
   set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; Modules: module List modType runStatus]]
   puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $dashStr &#34;-----&#34; &#34;---------------&#34; &#34;--------------------&#34;]&#34;
   set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $dashStr &#34;-----&#34; &#34;-----------------&#34; &#34;------------------&#34;]]
   for {set i 0} {$i&lt;[llength $usrInput(runStatus:)]} {incr i} {
      set moduleName [lindex $usrInput(moduleNames:) $i]
      set moduleList [lindex $usrInput(moduleLists:) $i]
      if {[info exists usrInput(moduleTypes:)]} {
          set moduleType [lindex $usrInput(moduleTypes:) $i]
      } else {
          set moduleType functional
      }
      set moduleRunStat [lindex $usrInput(runStatus:) $i]

      if {[regexp -nocase &#34;^takenBy|^runningOn|^reRunOn&#34; $moduleRunStat]} {
         regexp -nocase &#34;^takenBy|^runningOn(.*)&#34; $moduleRunStat ma cfgStr
         if {[info exists cfgStr]!=1} {
            regexp -nocase &#34;^reRunOn(.*)&#34; $moduleRunStat ma cfgStr   ;<span class="comment-line"># check the reRunOn</span>
         }
         global BASE_PATH
         
         set psLine [catch {exec ps -eafwww | egrep -e &#34;Load.*$cfgStr|main.tcl.*$cfgStr|mysqlMain.tcl.*$moduleName.*$cfgStr&#34; | grep -v grep} psCmdLine]
<span class="comment-line">#puts &#34;the psLine $psLine and psCmdLine $psCmdLine&#34;</span>
         set qIdRunning [<a name="::GetLatestIdRunning(2)"><a href="./queueLib.tcl.html#::GetLatestIdRunning_3210">::GetLatestIdRunning</a></a> $cfgStr]
         if {$qIdRunning!=$queueId} {
            puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $moduleName $moduleList $moduleType $moduleRunStat]&#34;
            set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $moduleName $moduleList $moduleType $moduleRunStat]]
         } else {
 
         set ppid [lindex $psCmdLine 2]
         set psLine [catch {exec ps -eafwww | egrep -e &#34;tee&#34; | grep -v grep | grep $ppid} psout]
         set tailFileTail [lindex $psout [expr [llength $psout]-1]]
<span class="comment-line">#         set cfgName [lindex [split $cfgStr .] 0]</span>
<span class="comment-line">#         set retV [file exists /tmp/$cfgName]</span>
<span class="comment-line">#         if {$retV==1} {</span>
<span class="comment-line">#            set linkTarget [file readlink /tmp/$cfgName]</span>
<span class="comment-line">#            if {$linkTarget!=$tailFilePath} {  ;# symlink is stale, recreate</span>
<span class="comment-line">#               file delete /tmp/$cfgName</span>
<span class="comment-line">#               link -sym $tailFilePath /tmp/$cfgName</span>
<span class="comment-line">#            }</span>
<span class="comment-line">#            set symLinkPath /tmp/$cfgName</span>
<span class="comment-line">#         } elseif {$retV==0} {</span>
<span class="comment-line">#            file delete /tmp/$cfgName</span>
<span class="comment-line">#            link -sym $tailFilePath /tmp/$cfgName</span>
<span class="comment-line">#            set symLinkPath /tmp/$cfgName</span>
<span class="comment-line">#         } else {</span>
<span class="comment-line">#            set symLinkPath $tailFilePath</span>
<span class="comment-line">#         }</span>
          set symLinkPath $tailFileTail

         <span class="comment-line">### Following lines get the duration w.r.t. LoadImage and main.tcl. If inside main.tcl, LoadImage duration is added.</span>
         <span class="comment-line"># LoadImage duration is picked from imagesFinished dir creation for this queueId</span>

         set startTime [lindex $psout 4]
         set curTime [clock seconds]
         set duration [expr $curTime - [clock scan $startTime]]
         set downloadDuration 0
         if {[regexp -nocase &#34;main.tcl.*$cfgStr&#34; $psCmdLine]} { ;<span class="comment-line"># First run main.tcl</span>
            global imagesFinishedDir
            if {[file exists &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt&#34;] &amp;&amp; \
                [file stat &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt&#34; downloadReportStat]==&#34;&#34;} {
<span class="comment-line">#puts &#34;now inside cfgStr $cfgStr, psCmdLine $psCmdLine and duration $duration and $downloadReportStat(ctime)&#34;</span>
               set downloadCreateTime $downloadReportStat(ctime)
               file stat &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/loadimage.txt&#34; loadimageStat
               set downloadDuration [expr $loadimageStat(ctime)-$downloadReportStat(ctime)]
               set duration [expr [clock seconds]-$downloadCreateTime]
            }
         } elseif {[regexp -nocase &#34;mysqlMain.tcl.*$cfgStr&#34; $psCmdLine]} { ;<span class="comment-line"># second run</span>
            if {[file exists &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt&#34;] &amp;&amp; \
                [file stat &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt&#34; downloadReportStat]==&#34;&#34;} {
<span class="comment-line">#puts &#34;now inside cfgStr $cfgStr, psCmdLine $psCmdLine and duration $duration and $downloadReportStat(ctime)&#34;</span>
               set downloadCreateTime $downloadReportStat(ctime)
               file stat &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/loadimage.txt&#34; loadimageStat
               set downloadDuration [expr $loadimageStat(ctime)-$downloadReportStat(ctime)]
               set duration [expr [clock seconds]-$downloadCreateTime]
            } elseif {[file stat &#34;$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report/info.txt&#34; FirstRunStat]==&#34;&#34;} {
               set firstRunTime $FirstRunStat(ctime)
               set duration [expr [clock seconds]-$firstRunTime]
            }
         }
         set totalDuration NULL
         if {![info exists usrInput(platformToRunOn:)]} {
            set usrInput(platformToRunOn:) NULL
         }
         if {[regexp -nocase &#34;Load.*$cfgStr&#34; $psCmdLine]==1} {  ;<span class="comment-line"># means its inside LoadImage right now</span>
            set totalDuration [<a name="::GetTotalDuration(1)"><a href="./queueLib.tcl.html#::GetTotalDuration_3265">::GetTotalDuration</a></a> NULL $moduleName $usrInput(platformToRunOn:) $moduleList $moduleType [array get usrInput]]
         } elseif {$downloadDuration==0} {  ;<span class="comment-line"># means its in main.tcl but no download was done for this module</span>
            set totalDuration [<a name="::GetTotalDuration(2)"><a href="./queueLib.tcl.html#::GetTotalDuration_3265">::GetTotalDuration</a></a> 0 $moduleName $usrInput(platformToRunOn:) $moduleList  $moduleType [array get usrInput]]
         } elseif {$downloadDuration!=0} {
            set totalDuration [<a name="::GetTotalDuration(3)"><a href="./queueLib.tcl.html#::GetTotalDuration_3265">::GetTotalDuration</a></a> $downloadDuration $moduleName $usrInput(platformToRunOn:) $moduleList $moduleType [array get usrInput]]
         }
         if {$totalDuration==&#34;NULL&#34;} {
            set minSecs &#34;[expr $duration/60]/$totalDuration min&#34;
         } else {
            set minSecs &#34;[expr $duration/60]/[expr $totalDuration/60] min&#34;
         }
         <span class="comment-line">###</span>

<span class="comment-line">#         result_debug &#34;the tailFileTail $tailFileTail&#34;</span>
         if {[file exists $tailFileTail]} {
            puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s %-4s&#34; &#34;&#34; $moduleName $moduleList $moduleType &#34;$moduleRunStat (tail -f $tailFileTail)&#34; ($minSecs)]&#34;
            set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s %-4s&#34; &#34;&#34; $moduleName $moduleList $moduleType &#34;$moduleRunStat (tail -f $tailFileTail)&#34; ($minSecs)]]
         } else {
             puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $moduleName $moduleList $moduleType $moduleRunStat]&#34;
             set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $moduleName $moduleList $moduleType $moduleRunStat]]
<span class="comment-line">#            regsub &#34;runningOn|reRunOn&#34; $moduleRunStat  &#34;abortedOn&#34; abortedStr</span>
<span class="comment-line">#            puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s&#34; &#34;&#34; $moduleName $moduleList $abortedStr]&#34;</span>
<span class="comment-line">#            set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s&#34; &#34;&#34; $moduleName $moduleList $abortedStr]]</span>
         }
         }
      } else {
         puts &#34;[format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $moduleName $moduleList $moduleType $moduleRunStat]&#34;
         set strToReturn [append strToReturn &#34;\n&#34; [format &#34;%-17s %-$maxLength|%-5s|%-15s|%-15s&#34; &#34;&#34; $moduleName $moduleList $moduleType $moduleRunStat]]
      }
   }
   set strToReturn [append strToReturn &#34;\n&#34;]
   return $strToReturn
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: ReadQueueInfoIntoArray</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc reads the filePath info into uInput.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           filePath: queueId info file absolute file path</span>
<span class="comment-line"># Output args: uInput: Read queue info array</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[set retCode [ReadQueueInfoIntoArray $imageDir/info uInput]]==-1} {</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ReadQueueInfoIntoArray_2721">proc <a href="queueLib.tcl-annot.html#::::ReadQueueInfoIntoArray">::::ReadQueueInfoIntoArray</a></a></strong> {filePath uInput} {
   upvar uInput userInput
   array unset userInput
   global DEVREG
      if {[set fd_info [<a name="::FileOpen(34)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $filePath r]]==-1} {
         return $fd_info
      } else {
         while {[gets $fd_info infoLine]!=-1} {
            <span class="comment-line"># --------------------------------------------------</span>
            <span class="comment-line"># if there happens to be a set Var Val, trim the set</span>
            <span class="comment-line"># --------------------------------------------------</span>
            regsub -all &#34;^set &#34; $infoLine &#34;&#34; infoLine
            regsub -all &#34;  &#34; $infoLine &#34; &#34; infoLine
            regsub -all &#34;   &#34; $infoLine &#34; &#34; infoLine
            regsub -all &#34;    &#34; $infoLine &#34; &#34; infoLine
            regsub -all {[ ]+} $infoLine &#34; &#34; infoLine
            set infoLine [string trim $infoLine]
            if {$infoLine == &#34;&#34;} {
                continue
            }
            set parsedVarName [string trim [lindex $infoLine 0]]
            set parsedVarName  [string trim $parsedVarName :]
            if {![regexp -nocase &#34;:&#34; $parsedVarName]} {
                set parsedVarName &#34;${parsedVarName}:&#34;
            }
            set userInput($parsedVarName) [lrange $infoLine 1 end]
            set DEVREG(userInput,$parsedVarName) [lrange $infoLine 1 end]
         }
         close $fd_info
      }
    return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: ProcessSrvrQueueKill</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc moves the imagesRunning/imagesQueued dir</span>
<span class="comment-line">#              and their corresponding modules' log into imagesKilled dir.</span>
<span class="comment-line">#              Uses setuid rmProc and mvProc shell utilities.</span>
<span class="comment-line">#              Since this is called inside regression server, the</span>
<span class="comment-line">#              queueId may be in imagesQueued/imagesRunning.</span>
<span class="comment-line">#              It only moves the imagesRunning in this case and removes the imagesQueued</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           queueId: queueId to be moved</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           return [ProcessSrvrQueueKill $queueId]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ProcessSrvrQueueKill_2774">proc <a href="queueLib.tcl-annot.html#::::ProcessSrvrQueueKill">::::ProcessSrvrQueueKill</a></a></strong> {queueId} {
   global DEVREG
   global env
   if {![file isdirectory $DEVREG(server,imagesKilledDir)]} {
      if {[catch {file mkdir $DEVREG(server,imagesKilledDir)} reason]} {
         puts &#34;Error: Can not create imagesKilledDir dir...$reason&#34;
         return 137
      }
   }
   if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$queueId]} {   ;<span class="comment-line"># delete the queuedDir and only move runningDir</span>
      if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$queueId} reason]} {
         <a name="::result_error(39)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $DEVREG(server,imagesQueuedDir)/$queueId, $reason&#34;
         return 137
      } else {
         if {[set retCode [<a name="::RemoveQidFromPriority(9)"><a href="./queueLib.tcl.html#::RemoveQidFromPriority_1416">::RemoveQidFromPriority</a></a> $queueId]]==-1} {
            return 137
         }
      }
   }
   <span class="comment-line"># Since its inside server, the imagesRunningDir may be there or may not be there</span>
   <span class="comment-line"># depending on which server kills it first.</span>
   if {[file isdirectory $DEVREG(server,imagesRunningDir)/$queueId]} {
      if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/$queueId $DEVREG(server,imagesKilledDir)} reason]} {
         <a name="::result_error(40)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not move $DEVREG(server,imagesRunningDir)/$queueId, $reason&#34;
         return 137
      } else {
         return 137
      }
   }
   return 137
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetModList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets the contents of a 2d array</span>
<span class="comment-line">#              but if nothing exists for the 2nd element- plat</span>
<span class="comment-line">#              it subs All</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           plat: platform to run on</span>
<span class="comment-line">#           regtype: Functionaltest, SnmpFunctionaltest, XML_API etc         </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           GetModList $plat $regtype</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetModList_2823">proc <a href="queueLib.tcl-annot.html#::::GetModList">::::GetModList</a></a></strong> {stdrtr regtype plat} {
    global stdMods rtrMods cit2nodeMods
    global DEVREG
    global platformList
    set platformList [regsub &#34;,&#34; $platformList &#34; &#34;]
    set platformList [regsub &#34;, &#34; $platformList &#34; &#34;]
    set platformList [regsub &#34;  &#34; $platformList &#34; &#34;]
    if {$stdrtr == &#34;std&#34;} {
        if {![info exists stdMods($regtype,$plat)]} {
            if {[info exists stdMods($regtype,All)]} {
                set updatedList $stdMods($regtype,All);
                foreach platform $platformList {
                    if {[info exists stdMods($regtype,$platform)]} {
                        set updatedList [concat $updatedList $stdMods($regtype,$platform)]	
                    }
                }
                set finalList [lsort -nocase -unique $updatedList];
                set stdMods($regtype,All) $finalList
                return $finalList;
            } else {
                puts &#34;\n!!!!!\n!!!!!\nERROR NO STD MODULES DEFINED\n!!!!!\n!!!!!&#34;
            }
        } else {
            set updatedList2 $stdMods($regtype,$plat);
            foreach platform $platformList {
                if {[info exists stdMods($regtype,$platform)]} {
                    set updatedList2 [concat $updatedList2 $stdMods($regtype,$platform)]
                }
            }
            set finalList2 [lsort -nocase -unique $updatedList2];
            set stdMods($regtype,$plat) $finalList2
            return $finalList2;
        }
    } elseif {$stdrtr == &#34;rtr&#34;} {
        if {![info exists rtrMods($regtype,$plat)]} {
            if {[info exists rtrMods($regtype,All)]} {
                set updatedListrtr $rtrMods($regtype,All);
                foreach platform $platformList {
                    if {[info exists rtrMods($regtype,$platform)]} {
                        set updatedListrtr [concat $updatedListrtr $rtrMods($regtype,$platform)]
                    }
                }
                set finalListrtr [lsort -nocase -unique $updatedListrtr];
                set rtrMods($regtype,All) $finalListrtr
                return $finalListrtr;
            } else {
                puts &#34;\n!!!!!\n!!!!!\nERROR NO RTR MODULES DEFINED\n!!!!!\n!!!!!&#34;
            }
        } else {
            set updatedListrtr $rtrMods($regtype,$plat);
            foreach platform $platformList {
                if {[info exists rtrMods($regtype,$platform)]} {
                    set updatedListrtr [concat $updatedListrtr $rtrMods($regtype,$platform)]
                }
            }
            set finalListrtr [lsort -nocase -unique $updatedListrtr];

            set rtrMods($regtype,All) $updatedListrtr
            return $finalListrtr;
        }
    } elseif {$stdrtr == &#34;cit2node&#34;} {
        if {![info exists cit2nodeMods($regtype,$plat)]} {
            if {[info exists cit2nodeMods($regtype,All)]} {
                return [lsort -nocase -unique $cit2nodeMods($regtype,All)];
            } else {
                puts &#34;\n!!!!!\n!!!!!\nERROR NO CIT 2node MODULES DEFINED\n!!!!!\n!!!!!&#34;
            }
        } else {
            return [lsort -nocase -unique $cit2nodeMods($regtype,$plat)];
        }
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: PrintModulesSupported</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc prints the modules info in tabular format</span>
<span class="comment-line">#              dividing standard and routing information,</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           platform: platform to run on</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           PrintModulesSupported $userInput(platformToRunOn:)</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::PrintModulesSupported_2911">proc <a href="queueLib.tcl-annot.html#::::PrintModulesSupported">::::PrintModulesSupported</a></a></strong> {plat regtype} {
   global stdMods rtrMods cit2nodeMods
   global DEVREG
   
   set cit2nodeModules &#34;&#34;
   if {[regexp -nocase &#34;.cfg$&#34; $plat]} {  ;<span class="comment-line"># usr cfg specified</span>
      set srvrType [<a name="::runningServerTypes(1)"><a href="./queueLib.tcl.html#::runningServerTypes_237">::runningServerTypes</a></a> $plat]
      set srvrRegType [lindex $srvrType 0]
      set srvrPlatType [lindex $srvrType 1]
      if {$srvrPlatType==&#34;Mariner&#34;} {
         if {$srvrRegType==&#34;standard&#34;} {
            set stdModules [<a name="::GetModList(9)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std $regtype Mariner]
            set routingModules &#34;&#34;
         } else {
            set stdModules &#34;&#34;
            set routingModules [<a name="::GetModList(10)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> rtr $regtype Mariner]
         }
      } elseif {$srvrPlatType==&#34;PC&#34;} {
         if {$srvrRegType==&#34;standard&#34;} {
            set stdModules [<a name="::GetModList(11)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std $regtype PC]
            set routingModules &#34;&#34;
         } else {
            set stdModules &#34;&#34;
            set routingModules &#34;&#34;
         }
      } else {
            if {$srvrRegType==&#34;standard&#34;} {
                set stdModules [<a name="::GetModList(12)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std $regtype $srvrPlatType]
                <span class="comment-line">#set stdModules [expr $[string tolower $srvrPlatType]Modules]</span>
                set routingModules &#34;&#34;
            } elseif {[regexp -nocase &#34;rout&#34; $srvrRegType]} {
                set stdModules &#34;&#34;
                set routingModules [<a name="::GetModList(13)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> rtr $regtype $srvrPlatType]
                <span class="comment-line">#set routingModules  [expr $[string tolower $srvrPlatType]RoutingModules]</span>
            } elseif {[regexp -nocase &#34;cit2node&#34; $srvrRegType]} {
                set stdModules &#34;&#34;
                set routingModules &#34;&#34;
                set cit2nodeModules [<a name="::GetModList(14)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> cit2node $regtype $srvrPlatType]
            }
      }
   } else {
      set stdModules [<a name="::GetModList(15)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> std $regtype $plat]
      set routingModules [<a name="::GetModList(16)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> rtr $regtype $plat]
      set cit2nodeModules [<a name="::GetModList(17)"><a href="./queueLib.tcl.html#::GetModList_2823">::GetModList</a></a> cit2node $regtype $plat] 
   }
   set stdLength [llength $stdModules]
   set rouLength [llength $routingModules]
   set cit2Length [llength $cit2nodeModules]
   if {$cit2Length &gt; 0 &amp;&amp; $stdLength == 0 &amp;&amp; $rouLength == 0} {
        puts &#34;Current modules supported:&#34;
        puts &#34;[format &#34;%-35s&#34; &#34;Cit2Node modules&#34;]&#34;
        puts &#34;[format &#34;%-35s&#34; &#34;--------------------&#34;]&#34;
        foreach module1 $cit2nodeModules {
            puts &#34;[format &#34;%-35s&#34; $module1]&#34;
        }
        return &#34;$cit2nodeModules&#34;
   } else {
        set newList &#34;&#34;
        if {$stdLength&gt;=$rouLength} {
            set limit $stdLength
        } else {
            set limit $rouLength
        }
        for {set i 0} {$i&lt;$limit} {incr i} {
            lappend newList &#34;[lindex $stdModules $i]&#34;
            lappend newList &#34;[lindex $routingModules $i]&#34;
        }

        puts &#34;Current modules supported:&#34;
        puts &#34;[format &#34;%-35s %-35s&#34; &#34;Standard modules&#34; &#34;Routing modules&#34;]&#34;
        puts &#34;[format &#34;%-35s %-35s&#34; &#34;--------------------&#34; &#34;--------------------&#34;]&#34;
        foreach {module1 module2} $newList {
            puts &#34;[format &#34;%-35s %-35s&#34; $module1 $module2]&#34;
        }
        return &#34;$stdModules $routingModules&#34;
   }
   return &#34;$stdModules $routingModules&#34;
}

<strong><a name="::::UnlockQueuedLock_2990">proc <a href="queueLib.tcl-annot.html#::::UnlockQueuedLock">::::UnlockQueuedLock</a></a></strong> {queueDir uinp} {
   global DEVREG
   array set uip $uinp
   if {[set fd_q [<a name="::FileOpen(35)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $queueDir/info r+]]==-1} {
      return $fd_q
   }
   seek $fd_q 0 start
   set uip(runStatus:) [lreplace $uip(runStatus:) 0 0 &#34;done&#34;]

   foreach varName [array names uip] {
      puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $uip($varName)]&#34;
   }
   ftruncate $queueDir/info [tell $fd_q]
   close $fd_q
   return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetLocalImageDir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets the local images dir from user dirs</span>
<span class="comment-line">#              if an input image is not NULL, it checks for valid file path</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           id: queueId to be referred</span>
<span class="comment-line">#           userI386Dir: i386 image dir</span>
<span class="comment-line">#           userMarinerDir: Mariner image dir</span>
<span class="comment-line">#           userAspenDir: Aspen image dir</span>
<span class="comment-line">#           userCougarDir: Cougar image dir</span>
<span class="comment-line"># Output args:</span>
<span class="comment-line">#           localI386 : local i386 image file</span>
<span class="comment-line">#           localMariner : local Mariner image file</span>
<span class="comment-line">#           localAspen : local Aspen image file</span>
<span class="comment-line">#           localCougar : local Cougar image file</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           return [ProcessSrvrQueueKill $queueId]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetLocalImageDir_3031">proc <a href="queueLib.tcl-annot.html#::::GetLocalImageDir">::::GetLocalImageDir</a></a></strong> {args}    {

   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> GetLocalImageDir $args {
      id                &#34;null&#34;
      platformList      &#34;null&#34;
      platformImageList &#34;null&#34;
   }

   global DEVREG

   <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n-----\nVerify platformList: $platformList \nPaths: $platformImageList\n-----&#34;
   set a 0;
   foreach plat $platformList {
      set DEVREG(imageDir,$plat) &#34;$DEVREG(server,imagesQueuedDir)/$id/[file tail [lindex $platformImageList $a]]&#34;
      if {![file isfile &#34;$DEVREG(imageDir,$plat)&#34;]} {
          <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Invalid local $plat file $DEVREG(imageDir,$plat)&#34;
      } else {
          <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$plat image located: $DEVREG(imageDir,$plat)&#34;
      }
      incr a
   }
   return 1;
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: UpdateImagesRerun</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets called by the regServer to update </span>
<span class="comment-line">#              info file for imagesRunning  after a module fails</span>
<span class="comment-line">#              in first run.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           myQ: queueId to work on inside imagesQueued/imagesRunning</span>
<span class="comment-line">#           runInd: index of the module in info file</span>
<span class="comment-line">#           cfgFile: tail of the server config file path</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           if {[UpdateImagesRerun $myQueueId $runIndex $cfgFileTail]==-1} {</span>
<span class="comment-line">#            exit -1</span>
<span class="comment-line">#         }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UpdateImagesRerun_3076">proc <a href="queueLib.tcl-annot.html#::::UpdateImagesRerun">::::UpdateImagesRerun</a></a></strong> {myQ runInd cfgFile} {
   global DEVREG
   <span class="comment-line"># update the imagesRunning in case myQ is still running or already finished. imagesQueued scenario is irrelevant</span>
   set runningQueueFile &#34;$DEVREG(server,imagesRunningDir)/$myQ&#34;
   after 1000  ;<span class="comment-line"># To avoid race condition sometimes amongst the servers</span>
   if {![catch {glob -- $runningQueueFile} queues]} { ;<span class="comment-line"># myQ is running</span>
      <span class="comment-line"># Have to be careful writing as other servers might be</span>
      <span class="comment-line"># running as well.</span>
      <span class="comment-line"># At this point, Read the running info file, change the status of module</span>
      <span class="comment-line"># at runInd that was passed into this proc</span>
      <a name="::ReadQueueInfoIntoArray(4)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $DEVREG(server,imagesRunningDir)/$myQ/info uInput
      if {[set fd_q [<a name="::FileOpen(36)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningQueueFile/info r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
<span class="comment-line">#      result_debug &#34;array runningRegression [parray userInput]&#34;</span>
      seek $fd_q 0 start
      set userInput(runStatus:) [lreplace $userInput(runStatus:) $runInd $runInd &#34;reRunOn$cfgFile&#34;]
      
      foreach varName [array names userInput] {
         puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
      }  
      ftruncate $runningQueueFile/info [tell $fd_q]
      close $fd_q
   } else {  ;<span class="comment-line"># myQ is finished w.r.t. runInd module</span>
      <a name="::ReadQueueInfoIntoArray(5)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $DEVREG(server,imagesFinishedDir)/$myQ/info uInput
      if {![file isdirectory $DEVREG(server,imagesRunningDir)]} {
         if {[catch {file mkdir $DEVREG(server,imagesRunningDir)} reason]} {
            <a name="::result_error(41)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create imagesRunningDir dir...$reason&#34;
            return -1
         }
      }
      if {[catch {file mkdir &#34;$runningQueueFile&#34;} reason]} {
         <a name="::result_error(42)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $runningQueueFile...$reason&#34;;
         return -1
      }
      if {[set fd_out [<a name="::FileOpen(37)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningQueueFile/info w]]==-1} {
         return $fd_out
      }
      set uInput(runStatus:) [lreplace $uInput(runStatus:) $runInd $runInd &#34;reRunOn$cfgFile&#34;]
      foreach varName [array names uInput] {
         puts $fd_out &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $uInput($varName)]&#34;
      }
      ftruncate $runningQueueFile/info [tell $fd_out]
      close $fd_out
   }
   return 1
}



<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: notifyCurrentLockUser</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Check if testbed is actively locked.  If so, email current user</span>
<span class="comment-line">#              that another user is queued, waiting to lock the testbed.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             testbed - testbed that is queued for locking. (i.e. p1_mar_ipr.cfg)</span>
<span class="comment-line">#             user - User Id of person that has queued the lock</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1 - User notified</span>
<span class="comment-line">#              0 - No user notified.  Currently not locked.</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::notifyCurrentLockUser_3143">proc <a href="queueLib.tcl-annot.html#::::notifyCurrentLockUser">::::notifyCurrentLockUser</a></a></strong> { testbed queuedUser } {
    global DEVREG

    ;<span class="comment-line"># cat $images/RunningDir/SC_041112_114831/info </span>
    ;<span class="comment-line">#</span>
    ;<span class="comment-line"># moduleNames:         none                </span>
    ;<span class="comment-line"># userid:              alim                </span>
    ;<span class="comment-line"># runStatus:           runningOnp1_mar_g60t.cfg</span>
    ;<span class="comment-line"># lockFile:            p1_mar_g60t.cfg     </span>
    ;<span class="comment-line"># moduleLists:         none                </span>
    
    set returnVal 0
    set platformInfo &#34;&#34;
    set queues &#34;&#34;
    set currentUser &#34;&#34;

    ;<span class="comment-line"># Create a list of each qId directory</span>
    set queues [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/*]

    ;<span class="comment-line"># Look for any qId that is actively using queued platform</span>
    foreach qIdPath $queues {
        set catchVal [catch {exec egrep -e &#34;lockFile:\ *$testbed&#34; $qIdPath/info} platformInfo]
        if {! $catchVal} {
            set catchVal [catch {exec egrep -e &#34;userid:&#34; $qIdPath/info} userInfo]
            if {! $catchVal} {
                ;<span class="comment-line"># Assuming format is...</span>
                ;<span class="comment-line"># userid:              alim                </span>
                regexp {userid:\ *([A-Za-z0-9_\-\.]+)\ *$} $userInfo ignore currentUser
            }
            break;
        }
    }

    if {$currentUser != &#34;&#34;} {
        set qId &#34;&#34;
        regexp {.*\/(.*)$} $qIdPath ignore qId
        if {! [regexp -nocase &#34;\@&#34; $currentUser]} {
            set toBeSent &#34;$currentUser@extremenetworks.com&#34;
        }
        set subject &#34;Queueid:$qId ***lock request*** testbed $testbed&#34;

        set str &#34;$queuedUser has queued a lock request for testbed $testbed\n&#34;
        append str &#34;Please contact $queuedUser if you DO NOT plan on releasing\n&#34;
        append str &#34;$testbed any time soon.&#34;
        append str &#34;\n\n\n--- CURRENT PLATFORM STATUS ---\nQueueID:\t\t$qId\n[exec cat $qIdPath/info]&#34;
        catch {exec /bin/mail -s &#34;$subject&#34; $toBeSent &lt;&lt; &#34;$str&#34;} mailOut

        <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sending email to $toBeSent indicating you are queued to lock $testbed&#34;

        set returnVal 1
    } 

    return $returnVal
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetLatestIdRunning</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Checks the latest queueId running from imagesRunning dir for a given regServer</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             cfg - regSevrer config file name to match in runningOn str</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: $id - queue Id</span>
<span class="comment-line">#              0 - no cfg file located</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetLatestIdRunning_3210">proc <a href="queueLib.tcl-annot.html#::::GetLatestIdRunning">::::GetLatestIdRunning</a></a></strong> {cfg} {
global DEVREG
set id 0
set runningDirs [glob -nocomplain -- &#34;$DEVREG(server,imagesRunningDir)/*&#34;]
set runningDirs [lsort -decreasing $runningDirs];
foreach runningDir $runningDirs {
   if {[set retCode [<a name="::ReadQueueInfoIntoArray(6)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $runningDir/info uInput]]==-1} {
      return $retCode
   } else {
      if {[info exists uInput(runStatus:)] &amp;&amp; [regexp -nocase &#34;runningon$cfg|rerunon$cfg&#34; $uInput(runStatus:)]} {
<span class="comment-line">#puts &#34;the runningDir $runningDir&#34;</span>
          set id [file tail $runningDir]
          break
      }
   }
}

return $id
}

<strong><a name="::::combineTwoFiles_3230">proc <a href="queueLib.tcl-annot.html#::::combineTwoFiles">::::combineTwoFiles</a></a></strong> {fileName1 fileName2} {
   global DEVREG
   if {[set fd1 [<a name="::FileOpen(38)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $fileName1 a+]]==-1} {
      return $fd1
   }
   if {[set fd2 [<a name="::FileOpen(39)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $fileName2 r]]==-1} {
      return $fd2
   }
<span class="comment-line">#   set fd1 [open $fileName1 a+]</span>
<span class="comment-line">#   set fd2 [open $fileName2]</span>
   set lines [split [read $fd2] &#34;\n&#34;]
   close $fd2
   <span class="comment-line">#fconfigure stdout -buffering full</span>
   for {set i 0} {$i &lt;= [expr {[llength $lines]-2}]} {incr i 1} {
      puts $fd1 [lindex $lines $i]
   }
   close $fd1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetTotalDuration</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc is responsible for computing total duration of a given userInput array</span>
<span class="comment-line">#              gets the times from exosautoweb</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             downloadTime - this is time that is sent by caller if its in main.tcl, 0 otherwise</span>
<span class="comment-line">#             featureName - feature name</span>
<span class="comment-line">#             platformName - platform name cougar/mariner/aspen/i386</span>
<span class="comment-line">#             listName - module list quick/pass/all</span>
<span class="comment-line">#             userInput - array of queueId</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: returns total duration</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetTotalDuration_3265">proc <a href="queueLib.tcl-annot.html#::::GetTotalDuration">::::GetTotalDuration</a></a></strong> {downloadTime featureName platformName listName featureType userInput} {
   global DEVREG IPRTIMEDIR STDTIMEDIR RestOfDUTType RestOfIPRDUTType LoadImageSetupTime DOWNLOADTIME
   array set qInput $userInput

   set totalTimeDuration NULL
   set moduleRunDuration 0
   set durationFile &#34;&#34;
   set cfg 0

   if {$platformName==&#34;NULL&#34;} {
      return $totalTimeDuration
   }

   set moduleSubType [<a name="::GetModuleSubType(2)"><a href="./queueLib.tcl.html#::GetModuleSubType_620">::GetModuleSubType</a></a> $platformName $featureName $featureType]

   if {$moduleSubType==&#34;standardModules&#34;} {
      set durationFile &#34;$STDTIMEDIR($platformName)/$featureName.time.txt&#34;
   } elseif {$moduleSubType==&#34;routingModules&#34;} {
      set durationFile &#34;$IPRTIMEDIR($platformName)/$featureName.time.txt&#34;
   }
   if {[file exists $durationFile]} {
      lappend parameterList &#34;{SETUP:} 1&#34;
      lappend parameterList &#34;{CHK_CONN:} 1&#34;
      lappend parameterList &#34;{QUICK:} 1&#34;
      lappend parameterList &#34;{PASS:} 1&#34;
      lappend parameterList &#34;{ALL:} 1&#34;
      set value [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;$durationFile&#34; $parameterList]
      unset parameterList
      set setup [lindex $value 0]
      set chk_conn [lindex $value 1]
      set quick [lindex $value 2]
      set pass [lindex $value 3]
      set all [lindex $value 4]
      set moduleRunDuration [expr $setup+$chk_conn+$$listName]
<span class="comment-line">#      puts &#34;the moduleRunDuration $moduleRunDuration&#34; </span>
   } else {
      set moduleRunDuration NULL
   }

   if {$downloadTime==&#34;NULL&#34;} {  ;<span class="comment-line"># get default download time duration from cfg file</span>
      set defaultDownloadTime 0
      if {$platformName==&#34;PC&#34;} {
         if {$moduleSubType==&#34;standardModules&#34;} {
            set defaultDownloadTime [expr $LoadImageSetupTime+[expr 2*$DOWNLOADTIME(i386)]]
         } elseif {$moduleSubType==&#34;routingModules&#34;} {
            set defaultDownloadTime [expr $LoadImageSetupTime+[expr 5*$DOWNLOADTIME(i386)]]
         }
      } else {
         if {$moduleSubType==&#34;standardModules&#34;} {
            set otherDutImage $qInput([string tolower $RestOfDUTType($platformName)]Image:)
            if {$otherDutImage==&#34;NULL&#34;} {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)]
            } else {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)+$DOWNLOADTIME($RestOfDUTType($platformName))]
            }
         } elseif {$moduleSubType==&#34;routingModules&#34;} {
            set otherIprDutImage $qInput([string tolower $RestOfIPRDUTType($platformName)]Image:)
            if {$otherIprDutImage==&#34;NULL&#34;} {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)]
            } else {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)+[expr 4*$DOWNLOADTIME($RestOfIPRDUTType($platformName))]]
            }
         }
      }
      set downloadTime $defaultDownloadTime
   } else { ;<span class="comment-line"># add downloadTime into total duration as passed from caller</span>
   }
   if {$moduleRunDuration==&#34;NULL&#34;} {
   } else {
      set totalTimeDuration [expr $downloadTime+$moduleRunDuration]
   }

   return $totalTimeDuration
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: verifyUserInputFile</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc is verifies the user inputs from a runReg -file standpoint</span>
<span class="comment-line">#              Calls GetKeyValue to get all keys, verifies them individually</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             filePath - absolute path of runReg provided input file</span>
<span class="comment-line">#             userInput - array of queueId, inout variable, passes back to caller after filling it</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: returns -1 if error</span>
<span class="comment-line"># Sample input file:</span>
<span class="comment-line">##set userid               skumar</span>
<span class="comment-line">##set platformToRunOn      Mariner </span>
<span class="comment-line">##set aspenImage           NULL</span>
<span class="comment-line">##set aspennapaImage       NULL</span>
<span class="comment-line">##set cougarImage          NULL</span>
<span class="comment-line">##set marinerImage        /tftp/cougar-11.2.0.1-br-HWBeta-6.xos</span>
<span class="comment-line">##set i386Image            NULL</span>
<span class="comment-line">##set jaguarImage          NULL</span>
<span class="comment-line">##set pantherImage         NULL</span>
<span class="comment-line">##set branchAndPD          &#34;nothing specified&#34;</span>
<span class="comment-line">##set moduleNames         &#34;BGP_RFCConform&#34;</span>
<span class="comment-line">##set moduleLists         &#34;pass&#34;</span>
<span class="comment-line">##set SSH_SCP,value       /tftp2/bd10K-11.2.1.1-ssh.xmod</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::verifyUserInputFile_3367">proc <a href="queueLib.tcl-annot.html#::::verifyUserInputFile">::::verifyUserInputFile</a></a></strong> {filePath userInput} {
    global DEVREG
    global platformsSupported moduleArgFeatures
    upvar userInput uInput
    
    if [<a name="::ReadQueueInfoIntoArray(7)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $filePath uInput] {
        if {![info exists uInput(sustaining:)]} { set uInput(sustaining:) 0;}
        if {![info exists uInput(relInfo:)]} {set uInput(relInfo:) &#34;&#34;;}
        if {![info exists uInput(priority:)]} {set uInput(priority:) 3;}
        if {![info exists uInput(rerun:)]} {set uInput(rerun:) 1;}
        if {![info exists uInput(branchAndPD:)]} {set uInput(branchAndPD:) &#34;&#34;;}
        if {![info exists uInput(efence:)]} {set uInput(efence:) &#34;no&#34;;}
        if {![info exists uInput(LocalAAA,value:)]} {set uInput(LocalAAA,value:) &#34;NULL&#34;;}
        if {![info exists uInput(sustaining:)]} {set uInput(sustaining:) 0;}
        if {![info exists uInput(SSH_SCP,value:)]} {set uInput(SSH_SCP,value:) &#34;NULL&#34;;}
        if {![info exists uInput(tag:)]} { set uInput(tag:) &#34;&#34;;}
        if {![info exists uInput(comment:)]} { set uInput(comment:) &#34;&#34;;}
        if {![info exists uInput(xmod:)]} { set uInput(xmod:) NULL;}
        if {![info exists uInput(faillock:)]} { set uInput(faillock:) &#34;no&#34;;}
        if {![info exists uInput(harness:)]} { set uInput(harness:) &#34;all&#34;;}
        regsub -all &#34;\{|\}&#34; $uInput(moduleNames:) &#34;&#34; uInput(moduleNames:)
        set uInput(moduleNames:) [string trim $uInput(moduleNames:)]
        set uInput(moduleNames:) [split $uInput(moduleNames:) &#34; &#34;]

        <span class="comment-line"># check module names is set</span>
        if {![info exists uInput(userid:)]} {
            puts &#34;Error: userid is a required parameter&#34;
            return -1
        }
        if {![info exists uInput(moduleNames:)]} {
            puts &#34;Error: moduleNames is a required parameter&#34;
            return -1
        }
        <span class="comment-line"># check module types is set</span>
        if {![info exists uInput(moduleTypes:)]} {
            puts &#34;!!!!!\n!!!!!\n!!!!!\nYour info file is out of date.\n\
            A new variable \'moduleTypes\' has been added.\n\
            This variable stores a list that matches up with moduleNames\n\
            and moduleLists.  Type refers to functional,snmp,\n\
            scalability or xml test plan types.\n\n\
            In this case it will be assumed that you intended\n\
            to run functional tests and the variable will be \n\
            created for you.\n\n\
            Please correct this issue for future runs.\n!!!!!\n!!!!!\n!!!!!&#34;
            set uInput(moduleTypes:) &#34;&#34;
            foreach fillType $uInput(moduleNames:) {
                lappend uInput(moduleTypes:) &#34;functional&#34;
            }
        }
        <span class="comment-line"># check module lists is set</span>
        if {![info exists uInput(moduleLists:)]} {
            puts &#34;Error: moduleLists is a required parameter&#34;
            return -1
        }
        regsub -all &#34;\{|\}&#34; $uInput(moduleTypes:) &#34;&#34; uInput(moduleTypes:)
        set uInput(moduleTypes:) [string trim $uInput(moduleTypes:)]
        set uInput(moduleTypes:) [split $uInput(moduleTypes:) &#34; &#34;]
        regsub -all &#34;\{|\}&#34; $uInput(moduleLists:) &#34;&#34; uInput(moduleLists:)
        set uInput(moduleLists:) [string trim $uInput(moduleLists:)]
        set uInput(moduleLists:) [split $uInput(moduleLists:) &#34; &#34;]

        <span class="comment-line"># Check if the platform to run on is set</span>
        if {![info exists uInput(platformToRunOn:)]} {
            puts &#34;Error: Platform to run on is not set&#34;
            return -1
        }
        <span class="comment-line"># Check valid platformToRunOn</span>
        set useSshModArg 0
        if {[<a name="::VerifyPlatformType(1)"><a href="./queueLib.tcl.html#::VerifyPlatformType_36">::VerifyPlatformType</a></a> $uInput(platformToRunOn:)]==-1} {
            puts &#34;Error: Unsupported platformToRunOn:$uInput(platformToRunOn:). Valid: $DEVREG(server,platformsSupported)&#34;
            return -1
        } else {
            <span class="comment-line"># Check to see if a version match can be obtained from the plat to run on image.</span>
            set pImgKey &#34;$uInput(platformToRunOn:)Image:&#34;
            if {[info exists uInput($pImgKey)] &amp;&amp; $uInput($pImgKey) != &#34;skip&#34; &amp;&amp; \
                 [string trim $uInput($pImgKey)] != &#34;&#34; &amp;&amp; [file isfile $uInput($pImgKey)] } {
                set iFN [file tail $uInput($pImgKey)]
                if {[regexp -nocase {^[a-zA-Z0-9]+\-([0-9]{2,2}\.[0-9]{1,1})} $iFN ab v]} {
                    set vList [split $v &#34;.&#34;]
                    if {[lindex $vList 0] &lt; 16} {
                        set useSshModArg 1
                    }
                }
            }
        }
        
        foreach moduleName $uInput(moduleNames:) {
            <span class="comment-line">#</span>
            <span class="comment-line">#  Check for debugChoice Yes</span>
            <span class="comment-line">#</span>
            if {[info exists uInput($moduleName,debugChoice:)] &amp;&amp; [regexp -nocase &#34;^Y&#34; $uInput($moduleName,debugChoice:)]} {
                <span class="comment-line"># Check for Debug File</span>
                set infoFile [file tail $filePath]
                set pathLeft [string trimright $filePath $infoFile]
                <span class="comment-line"># Check for Debug File</span>
                if {[file isfile ${pathLeft}${moduleName}.dbg]} {
                    source ${pathLeft}${moduleName}.dbg
                    if {[info exists debugCliList] &amp;&amp; [info exists dutList] &amp;&amp; [info exists debugOverRide]} {
                        puts &#34;   Debug Enabled: Found Debug File ${pathLeft}${moduleName}.dbg&#34;
                        set uInput($moduleName,debugChoice:) &#34;Yes&#34;
                        set uInput($moduleName,dbgFile:) &#34;${pathLeft}${moduleName}.dbg&#34;
                    } else {
                        puts &#34;   Error: Debug file format incorrect!  Format should be&#34;
                        puts &#34;   File: ${pathLeft}${moduleName}.dbg&#34;
                        puts &#34;     ################################################&#34;
                        puts &#34;     set debugOverRide 1&#34;
                        puts &#34;     set dutList {1 2}&#34;
                        puts &#34;     set debugCliList {{show vlan} {show switch} {show fdb}}&#34;
                        puts &#34;     ################################################&#34;
                        return -1
                    }
                    unset debugCliList
                    unset dutList
                    unset debugOverRide
                } else {
                    puts &#34;   Error Debug Not Enabled: No Debug File ${pathLeft}${moduleName}.dbg&#34;
                    puts &#34;    - File Name Format Should Be: modulename.dbg&#34;
                    puts &#34;    - The File should be in the same location as your -file&#34;
                    return -1
                }
            } ;<span class="comment-line"># End of debugChoice</span>
            if {[lsearch -exact $moduleArgFeatures $moduleName]==-1} {
                continue
            } else {
                if {![info exists uInput($moduleName,value:)] &amp;&amp; !$useSshModArg &amp;&amp; [regexp -nocase &#34;ssh|aaa&#34; $moduleName]} {
                    set uInput($moduleName,value:) &#34;NULL&#34;
                }
                if {[info exists uInput($moduleName,value:)] &amp;&amp; $uInput($moduleName,value:) == &#34;NULL&#34;} {
                    continue;
                }
                if {[info exists uInput($moduleName,value:)] &amp;&amp; ![regexp -nocase &#34;^\/&#34; $uInput($moduleName,value:)]} {
                    puts &#34;   Error: $moduleName:value should start from /&#34;
                    return -1
                } else {
                    if {$useSshModArg &amp;&amp; ![file isfile $uInput($moduleName,value:)]} {
                        puts &#34;   Error: $moduleArgVal is invalid file&#34; 
                        return -1
                    }
                }
            }
        }
        <span class="comment-line"># Check for priority</span>
        if {$uInput(priority:)&lt;1 || $uInput(priority:)&gt;5} {
            puts &#34;Error: Priority must be between 1 and 5&#34;
            return -1
        }
        <span class="comment-line"># Check for rerun</span>
        if {$uInput(rerun:)!=1 &amp;&amp; $uInput(rerun:)!=0} {
            puts &#34;Error: Rerun must be either 1 or 0&#34;
            return -1
        }
        if {![info exists uInput(branchAndPD:)]} {
            set uInput(branchAndPD:) &#34;&#34;
        }
        <span class="comment-line"># Check for lockFile</span>
        if {[info exists uInput(lockFile:)]} {
        set runningSrvr [<a name="::runningServers(4)"><a href="./queueLib.tcl.html#::runningServers_210">::runningServers</a></a>]
            if {$runningSrvr!=1} {
                if {[lsearch -exact $runningSrvr $uInput(lockFile:)]!=-1} {
                    set srvrType [<a name="::runningServerTypes(2)"><a href="./queueLib.tcl.html#::runningServerTypes_237">::runningServerTypes</a></a> $uInput(lockFile:)]
                    set uInput(platformToRunOn:) [lindex $srvrType 1]
                } else {
                    <a name="::result_error(43)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Test bed: $uInput(lockFile:) is not running amongst: $runningSrvr&#34;
                    return -1
                }
            } else {
                <a name="::result_error(44)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No server running: $runningSrvr&#34;
                return -1
            }
        }
        if {$uInput(sustaining:)} {
            set susArg &#34;sustaining&#34;
        } else {
            set susArg &#34;normal&#34;
        }
        if {[info exists uInput(moduleTypes:)]} {
           set imageLists [<a name="::constructPlatformImages(1)"><a href="./queueLib.tcl.html#::constructPlatformImages_3656">::constructPlatformImages</a></a> $uInput(platformToRunOn:) $uInput(moduleNames:) $uInput(moduleTypes:) $susArg]
        } else {
           set tCount [llength $uInput(moduleNames:)]
           for {set b 0} {$b&lt;$tCount} {incr b} {
              lappend mtList functional
           }
           set uInput(moduleTypes:) $mtList
           set imageLists [<a name="::constructPlatformImages(2)"><a href="./queueLib.tcl.html#::constructPlatformImages_3656">::constructPlatformImages</a></a> $uInput(platformToRunOn:) $uInput(moduleNames:) $uInput(moduleTypes:) $susArg]
        }
        if {$imageLists==-1} {
            <a name="::result_error(45)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Unavailable testbed $uInput(platformToRunOn:)&#34;
            return -1
        }
        set DEVREG(active,platList) &#34;&#34;
        for {set imageIndex 0} {$imageIndex&lt;[llength $imageLists]} {incr imageIndex} {
            set imageList [lindex $imageLists $imageIndex]
            foreach {imageName imageVar} $imageList {
                set thePlat [string tolower $imageName]
                lappend DEVREG(active,platList) $thePlat
                if {$uInput(platformToRunOn:)==&#34;$imageName&#34;} {
                    if {![info exists uInput(${imageVar}:)]} {
                        puts &#34;   Error: a required image variable is missing -- $imageVar :&#34;
                        return -1
                    }
                    if {![regexp -nocase &#34;^\/&#34; $uInput(${imageVar}:)]&amp;&amp;$uInput(${imageVar}:)!=&#34;skip&#34;} {
                        puts &#34;   Error: $imageName File $uInput(${imageVar}:) should start from /&#34;
                        return -1
                    } else {
                        if {![file isfile $uInput(${imageVar}:)]&amp;&amp;$uInput(${imageVar}:)!=&#34;skip&#34;} {
                            puts &#34;   Error: $imageName File $uInput(${imageVar}:) is invalid file&#34;
                            return -1
                        }
                    }
                    
                } elseif {$uInput(${imageVar}:)!=&#34;NULL&#34; &amp;&amp; $uInput(${imageVar}:)!=&#34;skip&#34;} {
                    if {![info exists uInput(${imageVar}:)]} {
                        puts &#34;   Error: a required image variable is missing -- $imageVar :&#34;
                        return -1
                    }
                    if {![regexp -nocase &#34;^\/&#34; $uInput(${imageVar}:)]} {
                        puts &#34;   Error: $imageName File $uInput(${imageVar}:) should start from /&#34; 
                        return -1
                    } else {
                        if {![file isfile $uInput(${imageVar}:)]} {
                            puts &#34;   Error: $imageName File $uInput(${imageVar}:) is invalid file&#34;
                            return -1
                        }
                    }

                } else {
                    set uInput(${imageVar}:) $uInput($imageVar:)
                }
            }
        }
        if {[info exists uInput(efence:)] &amp;&amp; [regexp -nocase &#34;enable|no&#34; $uInput(efence:)]!=1} {
            puts &#34;   Error: incorrect efence $uInput(efence:)&#34;
            return -1
        } else {
            set uInput(efence:) no
        }
        if {[info exists uInput(relInfo:)] &amp;&amp; [regexp -nocase [string trim $uInput(relInfo:)] $DEVREG(server,relInfoList)]} {
            set uInput(relInfo:) $uInput(relInfo:)
        } elseif {[info exists uInput(relInfo:)] &amp;&amp; ([string trim $uInput(relInfo:)]==&#34;&#34; || [string trim $uInput(relInfo:)]==&#34;NULL&#34;) } {
            set uInput(relInfo:) &#34;&#34;
        } else {
            puts &#34;   Error: The relInfo: value you entered is not allowed: Only - $DEVREG(server,relInfoList)&#34;
            return -1
        }
        
        <span class="comment-line"># Verify correct pair of moduleLists with either quick/pass/all values</span>
        if {[llength $uInput(moduleNames:)]!=[llength $uInput(moduleLists:)] || \
        [llength $uInput(moduleNames:)]!=[llength $uInput(moduleTypes:)] } {
            puts &#34;   Error: # of moduleNames [llength $uInput(moduleNames:)] is unequal to \n\
            the number of moduleLists [llength $uInput(moduleLists:)] or \n\
            moduleTypes [llength $uInput(moduleTypes:)]&#34;
            return -1
        } else {
            set i 0
            foreach moduleList $uInput(moduleLists:) {
                if {[lsearch -exact $DEVREG(server,listsSupported) $moduleList]==-1} {
                    puts &#34;Error: Unsupported moduleList $moduleList for module [lindex $uInput(moduleNames:) $i]&#34;
                    return -1
                }
                    incr i
            }
            set i 0
            foreach moduleType $uInput(moduleTypes:) {
                if {[lsearch -exact $DEVREG(server,regTypeList) $moduleType]==-1} {
                    puts &#34;Error: Unsupported moduleType $moduleType for module [lindex $uInput(moduleNames:) $i]&#34;
                    return -1
                }
                incr i
            }
        }
    } else {
        puts &#34;Error: Could not parse the info file $filePath&#34;
        return -1
    }
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: constructPlatformImages</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc constructs platform images based on what modules</span>
<span class="comment-line">#              Vs. what platform are selected in the test bed config</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             platformName - name of the platform</span>
<span class="comment-line">#             moduleNames - name of the modules to get right image platform images</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: returns imageList on success, -1 if error</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::constructPlatformImages_3656">proc <a href="queueLib.tcl-annot.html#::::constructPlatformImages">::::constructPlatformImages</a></a></strong> {platformName moduleNames moduleTypes sustaining} {
set imageList -1

global RestOfDUTType
global RestOfIPRDUTType
global citDut2ImageType
global DEVREG COMMONIMAGE
global X480EXISTS

set platformHit() &#34;&#34;
set platformN [lindex $platformName 0]
set moduleSubTypes [<a name="::GetModuleSubType(3)"><a href="./queueLib.tcl.html#::GetModuleSubType_620">::GetModuleSubType</a></a> $platformN $moduleNames $moduleTypes]
if {$moduleSubTypes==&#34;&#34;} {
   puts &#34;Error: Incorrect module $moduleNames specified.&#34;
   return $imageList
} else {
   puts &#34;Found: moduleSubTypes $moduleSubTypes&#34;
}
if {$platformN==&#34;PC&#34;} {   ;<span class="comment-line"># potential problem here, if PC is first in coma separated list</span>
   set i386Image &#34;NULL&#34;
   set imageList &#34;i386 i386Image&#34;
   if {$sustaining == &#34;sustaining&#34;} {
       set i386SImage &#34;NULL&#34;
       set imageList &#34;i386 i386Image&#34;
   } else {
       set i386Image &#34;NULL&#34;
       set imageList &#34;i386 i386Image&#34;
   }
} else {
   foreach platformN $platformName {
       if {[info exists platformHit($platformN)] &amp;&amp; $platformHit($platformN)} {
           continue;
       } else {
           set platformHit($platformN) 1
       }
       set platformNameVar [string tolower $platformN]
       set restDut    [string tolower $RestOfDUTType($platformN)]
       set restDutIpr [string tolower $RestOfIPRDUTType($platformN)]
       set restCit2n  [string tolower $citDut2ImageType($platformN)]
       if {$sustaining == &#34;sustaining&#34;} {
           set [set platformNameVar]SImage &#34;NULL&#34;
           set [set restDut]SImage &#34;NULL&#34;
           set [set restDutIpr]SImage &#34;NULL&#34;
           set [set restCit2n]SImage &#34;NULL&#34;
           set imageList &#34;$platformN [set platformNameVar]SImage&#34;
       } else {
           set [set platformNameVar]Image &#34;NULL&#34;
           set [set restDut]Image &#34;NULL&#34;
           set [set restDutIpr]Image &#34;NULL&#34;
           set [set restCit2n]Image &#34;NULL&#34;
           set imageList &#34;$platformN [set platformNameVar]Image&#34;
       }
       <span class="comment-line"># ------------------------------------ </span>
       <span class="comment-line">#  SubTypes are used here to determine</span>
       <span class="comment-line">#  whether or not to use RestOfIpr or</span>
       <span class="comment-line">#  RestOfStd for additional images</span>
       <span class="comment-line"># ------------------------------------</span>
       set addedX480 0
       foreach moduleSubType $moduleSubTypes {
            if {$sustaining == &#34;sustaining&#34;} {
                if {$moduleSubType==&#34;standardModules&#34; &amp;&amp; [regexp -nocase [set restDut] $platformN]!=1 &amp;&amp; [regexp -nocase [set restDut] $imageList]!=1} {
                    set imageList [format &#34;%s %s %s&#34; $imageList $RestOfDUTType($platformN) [set restDut]SImage]
                } elseif {$moduleSubType==&#34;routingModules&#34; &amp;&amp; [regexp -nocase [set restDutIpr] $platformN]!=1 &amp;&amp; [regexp -nocase [set restDutIpr] $imageList]!=1} {
                    set imageList [format &#34;%s %s %s&#34; $imageList $RestOfIPRDUTType($platformN) [set restDutIpr]SImage]
                } elseif {$moduleSubType==&#34;cit2nodeModules&#34; &amp;&amp; [regexp -nocase [set restCit2n] $platformN]!=1 &amp;&amp; [regexp -nocase [set restCit2n] $imageList]!=1} {
                    set imageList [format &#34;%s %s %s&#34; $imageList $citDut2ImageType($platformN) [set restCit2n]SImage]
                }
            } else {
                if {$moduleSubType==&#34;standardModules&#34; &amp;&amp; [regexp -nocase [set restDut] $platformN]!=1 &amp;&amp; [regexp -nocase [set restDut] $imageList]!=1} {
                    set imageList [format &#34;%s %s %s&#34; $imageList $RestOfDUTType($platformN) [set restDut]Image]
                    set hitStd 1
                } elseif {$moduleSubType==&#34;routingModules&#34; &amp;&amp; [regexp -nocase [set restDutIpr] $platformN]!=1 &amp;&amp; [regexp -nocase [set restDutIpr] $imageList]!=1} {
                    set imageList [format &#34;%s %s %s&#34; $imageList $RestOfIPRDUTType($platformN) [set restDutIpr]Image]
                    set hitRtr 1
                } elseif {$moduleSubType==&#34;cit2nodeModules&#34; &amp;&amp; [regexp -nocase [set restCit2n] $platformN]!=1 &amp;&amp; [regexp -nocase [set restCit2n] $imageList]!=1} {
                    set imageList [format &#34;%s %s %s&#34; $imageList $citDut2ImageType($platformN) [set restCit2n]Image]
                    set hitCit2n 1
                }
            }
            if {[info exists X480EXISTS($platformN,routing)] &amp;&amp; !$addedX480 &amp;&amp; \
               $X480EXISTS($platformN,routing) &amp;&amp; $moduleSubType==&#34;routingModules&#34;} {
                 set imageList [format &#34;%s %s %s&#34; $imageList x480 x480Image]
            } elseif {[info exists X480EXISTS($platformN,standard)] &amp;&amp; !$addedX480 &amp;&amp; \
               $X480EXISTS($platformN,standard) &amp;&amp; $moduleSubType==&#34;standardModules&#34;} {
                 set imageList [format &#34;%s %s %s&#34; $imageList x480 x480Image]
            }
       }
       lappend imageListList $imageList
   }
   set imageList $imageListList
}
   return $imageList
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: VerifyCfgTestList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc verifies and returns the testListFile</span>
<span class="comment-line">#              Dumps tests if ? entered</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             platform - name of the platform</span>
<span class="comment-line">#             modName  - name of the feature desired</span>
<span class="comment-line">#             testsList - , separated list of tests</span>
<span class="comment-line">#             testListFile - out arg to return</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: returns testListFile on success, -1 if error</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyCfgTestList_3765">proc <a href="queueLib.tcl-annot.html#::::VerifyCfgTestList">::::VerifyCfgTestList</a></a></strong> {platform modName testsList release testListFile} {
   global BASE_PATH
   global DEVREG
   global MODPATHDEF
   global ITARPATHDEF

   <span class="comment-line"># ----------------------------------------------------------------------</span>
   <span class="comment-line"># The DEVREG(active,regType) is gathered in runReg as the type of reg</span>
   <span class="comment-line">#    to run.  ie snmp or functional. GetModuleFullType formats as needed</span>
   <span class="comment-line"># ----------------------------------------------------------------------</span>
   set myRegPath  [<a name="::GetModuleFullType(3)"><a href="./queueLib.tcl.html#::GetModuleFullType_4251">::GetModuleFullType</a></a> $DEVREG(active,regType) directory]

   set itest_tc [<a name="::get_itest_mod_tests(1)"><a href="./itestrt.tcl.html#::get_itest_mod_tests_219">::get_itest_mod_tests</a></a> -itarPath &#34;$ITARPATHDEF&#34; -modPath &#34;$MODPATHDEF&#34; -module &#34;$modName&#34; \
                      -category [<a name="::get_itest_category(1)"><a href="./itestrt.tcl.html#::get_itest_category_355">::get_itest_category</a></a> -modPath $myRegPath]]

   if {$release==&#34;&#34;} {
      set release &#34;current&#34;
   }
   set Path Path
   set sourceCompleteTestsDir &#34;$DEVREG(relInfoPath,$release)/../$myRegPath/$modName/completetests.lst&#34;
   puts &#34;$sourceCompleteTestsDir&#34;
   upvar $testListFile fileToReturn
   set fileToReturn &#34;./$modName&#34;
   set tmptests [split [string trim $testsList ,] ,]   ;<span class="comment-line"># , separated list of tessts</span>
   foreach tmptest $tmptests {
      lappend tests [string trim $tmptest]
   }

   <span class="comment-line"># Could not copy the completetests.lst return an error</span>
   if {[catch {exec cp -L $sourceCompleteTestsDir ./completetests.lst} reason]} {
      puts &#34;Error: Cannot copy file to ./completetests.lst ...$reason&#34;;
      return -1
   }
   set what [<a name="::::GetCleanTestList(1)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> dev]

   <span class="comment-line"># user passed in illegal value return a reprompt</span>
   if {$testsList==&#34;&#34;||$testsList==&#34;?&#34;} {
      regsub -all &#34; &#34; $what &#34;, &#34; comaSeparated
      puts &#34;$comaSeparated&#34;
      file delete completetests.lst
      return -1
   }
   <span class="comment-line"># File will not open - return</span>
   if {[set fd_out [<a name="::FileOpen(40)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $fileToReturn w]]==-1} {
      file delete completetests.lst
      return $fd_out
   }
   <span class="comment-line"># Get all possible tests from the completetests</span>
   set allCTProcs [<a name="::::GetCleanTestList(2)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> dev]
   if {[llength itest_tc] &gt; 0} {
       set allCTProcs [concat $allCTProcs $itest_tc]
   }
   <span class="comment-line"># Make sure that all of the tests passed in are in the completetests.lst</span>
   foreach inTest $tests {
       if {[lsearch $allCTProcs $inTest] &lt; 0} {
            <span class="comment-line"># Above lsearch does not use -exact intentionally.</span>
            <span class="comment-line"># causes, false invalid tests cuzz of comments of PD, usr cmnts</span>
            <span class="comment-line"># just verify using regexp</span>
            <a name="::result_error(46)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;invalid test for $modName&#34;
            file delete completetests.lst
            close $fd_out
            file delete $fileToReturn
            return -1
       }
   }
   <span class="comment-line"># -----------------------------------------------------</span>
   <span class="comment-line"># Start to build the new smaller completetests.lst</span>
   <span class="comment-line">#</span>
   <span class="comment-line"># </span>
   <span class="comment-line"># -----------------------------------------------------</span>
   puts $fd_out &#34;set tests_to_run(all) \{&#34;
   <span class="comment-line"># -----------------------------------------------------</span>
   <span class="comment-line"># Insert cases to be checked against completetests.lst</span>
   <span class="comment-line"># -----------------------------------------------------</span>
   set hit1Init 0
   if {[lsearch $allCTProcs &#34;1.init&#34;] &gt;= 0} {set hit1Init 1}
   set allCTProcs [<a name="::ldelete(1)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $allCTProcs &#34;1.init&#34;]
   set allCTProcs [concat &#34;1.init&#34; $allCTProcs]
   <span class="comment-line"># Set the end proc for each init so we know how to setup and cleanup</span>
   array set endByInit [<a name="::::GetEndArray(1)"><a href="./tpbMainLib.tcl.html#::::GetEndArray_148">::::GetEndArray</a></a> $allCTProcs]
   <span class="comment-line"># -----------------------------------------------------</span>
   <span class="comment-line"># Set the init and end script for each case proc</span>
   <span class="comment-line">#    initByProc(proc) initfile required for each proc</span>
   <span class="comment-line">#    endByProc([proc) endfile required for each proc</span>
   <span class="comment-line">#    procsByInit(proc.init) all procs for an init file</span>
   <span class="comment-line"># -----------------------------------------------------</span>
   set res [<a name="::::GetTestCaseCTListArrays(1)"><a href="./tpbMainLib.tcl.html#::::GetTestCaseCTListArrays_189">::::GetTestCaseCTListArrays</a></a> $allCTProcs initByProc endByProc procsByInit]
   set tList &#34;&#34;
   set initIndexList [lsearch -all -regexp $allCTProcs init]
   set endIndexList [lsearch -all -regexp $allCTProcs end]
   <span class="comment-line"># ------------------------------------------------------</span>
   <span class="comment-line"># convert proc names passed in to their index in the </span>
   <span class="comment-line">#    list of all tests in the feature</span>
   <span class="comment-line"># ------------------------------------------------------</span>
   <span class="comment-line"># If there is a 1.init file, put that in.</span>
   if {$hit1Init} {
       puts &#34;1.init&#34;
       puts $fd_out &#34;1.init&#34;
   }
   set inIndexList &#34;&#34;
   foreach t $tests {
       set inIndex [lsearch $allCTProcs $t]
       lappend inIndexList $inIndex
   }
   set inIndexList [lsort -integer $inIndexList]
   set top [llength $inIndexList]   
   <span class="comment-line"># loop through the indexes of all of the cases passed in.</span>
   set procsPrinted &#34;&#34;
   set printed &#34;&#34;
   for {set it 0} {$it&lt;$top} {incr it} {
       set printed &#34;&#34;
       <span class="comment-line"># get the real alltests index number for the inProc</span>
       set inIndex [lindex $inIndexList $it]
       <span class="comment-line"># init a variable to to be set if the tests falls b/t an init and end</span>
       set matched 0
       <span class="comment-line"># loop through all of the init indexes</span>
       set ii 0
       foreach i $initIndexList {
           <span class="comment-line"># If the index passed in is inbetween and init and end pair</span>
           if {$inIndex &gt; $i &amp;&amp; $inIndex &lt; $endByInit($i)} {
               <span class="comment-line"># if the in cases is not an end or init proc</span>
               if {[lsearch $endIndexList $inIndex] &lt; 0 &amp;&amp; [lsearch $initIndexList $inIndex] &lt; 0} {
                   set matched 1
                   set initProcName [lindex $allCTProcs $i]
                   set testProcName [lindex $allCTProcs $inIndex]
                   set iPrint 1
                   puts &#34;$initProcName&#34;
                   puts $fd_out &#34;$initProcName&#34;
                   lappend printed $initProcName
                   <span class="comment-line">#puts &#34;$testProcName&#34;</span>
                   while {[lsearch $procsByInit($initProcName) $testProcName] &gt;= 0} {
                       foreach ibp $initByProc($testProcName) {
                           if {[lsearch $printed $ibp] &lt; 0 &amp;&amp; $ibp != &#34;1.init&#34;} {
                               puts &#34;$ibp&#34;
                               puts $fd_out &#34;$ibp&#34;
                               lappend printed $ibp
                           }
                       }
                       if {[lsearch $procsPrinted $testProcName] &lt; 0} {
                           puts &#34;$testProcName&#34;
                           puts $fd_out &#34;$testProcName&#34;
                           lappend procsPrinted $testProcName
                       }
                       set lastTestProc $testProcName
                       incr it
                       set inIndex [lindex $inIndexList $it]
                       set testProcName [lindex $allCTProcs $inIndex]
                   }
                   foreach ebp $endByProc($lastTestProc) {
                       puts &#34;$ebp&#34;
                       puts $fd_out &#34;$ebp&#34;
                   }
                   <span class="comment-line">#puts &#34;End [lindex $allCTProcs $endByInit($i)]&#34;</span>
                   incr it -1
               }
           }
       }
       if {!$matched} {
           puts &#34;[lindex $allCTProcs $inIndex]&#34;
           puts $fd_out &#34;[lindex $allCTProcs $inIndex]&#34;
           lappend procsPrinted [lindex $allCTProcs $inIndex]
       }
   }
   <span class="comment-line"># -----------------------------------------------------</span>
   <span class="comment-line"># Loop through all tests to see what we can drop</span>
   <span class="comment-line"># -----------------------------------------------------</span>
   puts $fd_out &#34;\}&#34;
   file delete completetests.lst
   close $fd_out
   return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CreateDebugFile</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc creates a debug cli file in a tmp location</span>
<span class="comment-line">#              for later relocation to mod directories</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#             modName  - name of the feature desired</span>
<span class="comment-line">#             dutList - a string &#34;set dut dutList&#34;</span>
<span class="comment-line">#             cliList - a string &#34;set cli cliList&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: returns debugFile on success, 0 if error</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CreateDebugFile_3951">proc <a href="queueLib.tcl-annot.html#::::CreateDebugFile">::::CreateDebugFile</a></a></strong> {modName dutString cliString debugFile faillock} {
   global DEVREG
   upvar $debugFile fileToReturn
   set fileToReturn &#34;./$modName.dbg&#34;

   if {[set fd_out [<a name="::FileOpen(41)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $fileToReturn w]]==-1} {
      return 0
   }
   puts $fd_out &#34;set debugOverRide 1&#34;
   puts $fd_out &#34;set faillock $faillock&#34;
   puts $fd_out &#34;# List of DUTs to run these commands on&#34;
   puts $fd_out &#34;$dutString&#34;
   puts $fd_out &#34;# List of commands to send to the duts&#34;
   puts $fd_out &#34;$cliString&#34;
   close $fd_out
   return 1
}

<strong><a name="::::_getMysqlAutomateSubType_3969">proc <a href="queueLib.tcl-annot.html#::::_getMysqlAutomateSubType">::::_getMysqlAutomateSubType</a></a></strong> {platform feature ftype} {
   global DEVREG
   set subType NULL
   set moduleSubType [<a name="::GetModuleSubType(4)"><a href="./queueLib.tcl.html#::GetModuleSubType_620">::GetModuleSubType</a></a> $platform $feature $ftype]
   if {$moduleSubType==&#34;standardModules&#34;} {
      set subType standard
   } elseif {$moduleSubType==&#34;routingModules&#34;} {
      set subType ipRoute1
   }
   return $subType
}

<strong><a name="::::UpdateTimedLockFile_3981">proc <a href="queueLib.tcl-annot.html#::::UpdateTimedLockFile">::::UpdateTimedLockFile</a></a></strong> {cfg lockFlag} {
   global DEVREG
   if {$lockFlag==&#34;lock&#34;} {
      if {[set fd_out [<a name="::FileOpen(42)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,timedLockFile) a+]]==-1} {
        return $fd_out
      }
      puts $fd_out $cfg
      funlock $fd_out
      close $fd_out
      return 1
   } elseif {$lockFlag==&#34;unlock&#34;} {
      set lines &#34;&#34;
      if {[set fd_in [<a name="::FileOpen(43)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,timedLockFile) r]]==-1} {
         return $fd_in
      }
      while {[gets $fd_in line]!=-1} {
         lappend lines $line
      }
      funlock $fd_in
      close $fd_in
      if {$lines!=&#34;&#34;} {
         if {[set fd_out [<a name="::FileOpen(44)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,timedLockFile) w]]==-1} {
            return $fd_out
         }
         foreach line $lines {
            if {[string compare $line $cfg]!=0} {
               puts $fd_out $line
            }
         }
         close $fd_out
      }
      return 1
   }
}

<strong><a name="::::timedLockServers_4016">proc <a href="queueLib.tcl-annot.html#::::timedLockServers">::::timedLockServers</a></a></strong> { } {
   global DEVREG
   set lines &#34;&#34;
   if {[set fd_in [<a name="::FileOpen(45)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,timedLockFile) r]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      lappend lines $line
   }
   funlock $fd_in
   close $fd_in
   return $lines
}

<strong><a name="::::OrderPriorityFile_4030">proc <a href="queueLib.tcl-annot.html#::::OrderPriorityFile">::::OrderPriorityFile</a></a></strong> {} {
   global DEVREG
   set pri1 &#34;&#34;
   set pri2 &#34;&#34;
   set pri3 &#34;&#34;
   set pri4 &#34;&#34;
   set pri5 &#34;&#34;

   if {[set fd_in [<a name="::FileOpen(46)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,priorityFile) r+]]==-1} {
      return $fd_in
   }
   array set priArr &#34;&#34;
   while {[gets $fd_in line]!=-1} {
      set line [string trim $line]
      if {$line == &#34;&#34;} {
          continue
      } elseif {![regexp {[A-Z]{3,3}_[0-9]{6,6}_[0-9]{6,6}} $line]} {
          puts &#34;\n!!!\n!!!\n!!! BAD BAD BAD queueid $line !!!\n!!!\n!!!&#34;
          continue
      }
      set qId $line
      set queueInfoFile $DEVREG(server,imagesQueuedDir)/$qId/info
      if {![file exists $queueInfoFile]} {   ;<span class="comment-line"># if queueId does not exist</span>
         continue
      }
      <span class="comment-line">#puts &#34;QIF - $queueInfoFile&#34;</span>
      if {[file isfile $queueInfoFile]} {
          <a name="::ReadQueueInfoIntoArray(8)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $queueInfoFile uInput
          if {[info exists uInput(priority:)]} {
             lappend pri$uInput(priority:) $qId
          } else {
             lappend pri3 $qId
          }
      } else {
          puts &#34;$queueInfoFile needs cleanup&#34;
      }
   }

<span class="comment-line">#   result_debug &#34;pri1 $pri1, pri2 $pri2, pri3 $pri3, pri4 $pri4, pri5 $pri5&#34;</span>
   set pri1 [lsort $pri1]
   set pri2 [lsort $pri2]
   set pri3 [lsort $pri3]
   set pri4 [lsort $pri4]
   set pri5 [lsort $pri5]

   seek $fd_in 0 start
    
   <span class="comment-line"># After sorting is done, write to temp file</span>
   foreach index $pri1 {
      set id [string trim $index &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
      puts $fd_in $id
   }
   foreach index $pri2 {
      set id [string trim $index &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
      puts $fd_in $id
   }
   foreach index $pri3 {
      set id [string trim $index &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
      puts $fd_in $id
   }
   foreach index $pri4 {
      set id [string trim $index &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
      puts $fd_in $id
   }
   foreach index $pri5 {
      set id [string trim $index &#34;^@&#34;];<span class="comment-line"># Trim odd hex being added from someplace</span>
      puts $fd_in $id
   }
   close $fd_in
   return 1
}
<span class="comment-line">################################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################################</span>
<strong><a name="::::VerifyDUTsForDebug_4108">proc <a href="queueLib.tcl-annot.html#::::VerifyDUTsForDebug">::::VerifyDUTsForDebug</a></a></strong> {{dString 1} debugDutList} {
   global DEVREG
   upvar $debugDutList duts
   set duts NULL;

   set dutList [split $dString ,];
   set state BAD;
   foreach dut $dutList {
      set dut [string trim $dut]
      if {[regexp -nocase {^1$|^2$|^3$|^4$|^5$} $dut]} {
         set state OK;
      } else {
         return 0;
      }
   }
   if {$state==&#34;OK&#34;} {
      <span class="comment-line">#set dutList \{\{1\}\}</span>
      set duts &#34;set dutList \{$dutList\}&#34;;
      return 1;
   } else {
      return 0;
   }
}


<strong><a name="::::timeSortDirList_4133">proc <a href="queueLib.tcl-annot.html#::::timeSortDirList">::::timeSortDirList</a></a></strong> {dirList} {
   global DEVREG
   set mtimeList &#34;&#34;
   foreach d $dirList {
      lappend mtimeList [file mtime $d]
   }
   set sortedmtimeList [lsort -integer $mtimeList]
   set newDirList &#34;&#34;
   foreach mtimeL $sortedmtimeList {
      set index [lsearch $mtimeList $mtimeL]
      if {$index!=-1} {
         lappend newDirList [lindex $dirList $index]
      }
   }

   return $newDirList
}

<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: VerifyRegserverFileSystem</span>
<span class="comment-line">#  Queue Debug Proc</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           VerifyRegserverFileSystem</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyRegserverFileSystem_4162">proc <a href="queueLib.tcl-annot.html#::::VerifyRegserverFileSystem">::::VerifyRegserverFileSystem</a></a></strong> {} {
    global DEVREG

    if {![file isdirectory $DEVREG(server,regressionDir)]} {
        if {[catch {file mkdir $DEVREG(server,regressionDir)} reason]} {
            puts &#34;Error: Can not create regressionDir dir...$reason&#34;
            return -1
        } else {
            puts &#34;Created regressionDir Dir&#34;
        }
    }
    if {![file isdirectory $DEVREG(server,imagesQueuedDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesQueuedDir)} reason]} {
            puts &#34;Error: Can not create imagesQueuedDir dir...$reason&#34;
            return -1
        } else {
            puts &#34;Created imagesQueuedDir Dir&#34;
        }
    }
    if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
            puts &#34;Error: Can not create imagesFinishedDir dir...$reason&#34;
            return -1
        } else {
            puts &#34;Created imagesFinishedDir Dir&#34;
        }
    }
    if {![file isdirectory $DEVREG(server,imagesKilledDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesKilledDir)} reason]} {
            puts &#34;Error: Can not create imagesKilledDir dir...$reason&#34;
            return -1
        } else {
            puts &#34;Created imagesKilledDir Dir&#34;
        }
    }
    if {![file isdirectory $DEVREG(server,imagesRunningDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesRunningDir)} reason]} {
            puts &#34;Error: Can not create imagesRunningDir dir...$reason&#34;
            return -1
        } else {
            puts &#34;Created imagesRunningDir Dir&#34;
        }
    }

    if {![file isfile &#34;$DEVREG(server,priorityFile)&#34;]} {
        puts &#34;Priority File Does Not Exist. Create it&#34;
        if {[set fd1 [<a name="::FileOpen(47)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,priorityFile) a+]]==-1} {
            puts  &#34;Create Priority File Failed&#34;
            close $fd1
            return $fd1
        } else {
            close $fd1
            puts  &#34;$DEVREG(server,priorityFile) Created Successfully&#34;
        }
    }
    if {![file isfile &#34;$DEVREG(server,lockFile)&#34;]} {
        puts &#34;lockFile File Does Not Exist. Create it&#34;
        if {[set fd1 [<a name="::FileOpen(48)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
            puts  &#34;Create lockFile File Failed&#34;
            close $fd1
            return $fd1
        } else {
            close $fd1
            puts  &#34;$DEVREG(server,lockFile) Created Successfully&#34;
        }
    }
    if {![file isfile &#34;$DEVREG(server,timedLockFile)&#34;]} {
        puts &#34;timedLockFile File Does Not Exist. Create it&#34;
        if {[set fd1 [<a name="::FileOpen(49)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,timedLockFile) a+]]==-1} {
            puts  &#34;Create timedLockFile File Failed&#34;
            close $fd1
            return $fd1
        } else {
            close $fd1
            puts  &#34;$DEVREG(server,timedLockFile) Created Successfully&#34;
        }
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: GetModuleFullType</span>
<span class="comment-line">#  Get a full test directory</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           GetModuleFullType</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetModuleFullType_4251">proc <a href="queueLib.tcl-annot.html#::::GetModuleFullType">::::GetModuleFullType</a></a></strong> {modType format} {
   global DEVREG
   switch -regexp $modType {
      &#34;functional&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;functional&#34;
          } else {
              return &#34;Functionaltest&#34;
          }
      }
      &#34;fit&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;fit&#34;
          } else {
              return &#34;FeatureInteraction&#34;
          }
      }
      &#34;snmp&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;snmp&#34;
          } else {
              return &#34;SnmpFunctionaltest&#34;
          }
      }
      &#34;xml&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;xml&#34;
          } else {
              return &#34;XML_API&#34;
          }
      }
      &#34;scal&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;scalability&#34;
          } else {
              return &#34;Scalabilitytest&#34;
          }
      }
      &#34;stess&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;stresstest&#34;
          } else {
              return &#34;Stresstest&#34;
          }
      }
      &#34;perf&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;performance&#34;
          } else {
              return &#34;PerformanceTest&#34;
          }
      }
      &#34;default&#34; {
          if {$format == &#34;runreg&#34;} {
              return &#34;functional&#34;
          } else {
              return &#34;Functionaltest&#34;
          }
      }
   }

}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: partnerInUse</span>
<span class="comment-line">#  - Check to see if this testbeds partner queues are in use</span>
<span class="comment-line">#    specifically by checking to see if loadimage or main is </span>
<span class="comment-line">#    running.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: list of partner cfgs</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           partnerInUse {p1_voy_std.cfg p3_voy_std.cfg}</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::partnerInUse_4325">proc <a href="queueLib.tcl-annot.html#::::partnerInUse">::::partnerInUse</a></a></strong> {{partnerCfgList}} {
    set i 0
    foreach configFile $partnerCfgList {
        set psLine [catch {exec ps -eafwww | egrep -e &#34;mysql.*$configFile|.*phore.*$configFile|Load.*$configFile|main.tcl.*$configFile&#34; | grep -v grep} psout]
        <span class="comment-line">#puts &#34;the psLine $psLine and configFile $configFile&#34;</span>
        if {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
            return $i;
        }
        incr i
    }
    sleep 3
    foreach configFile $partnerCfgList {
        set psLine [catch {exec ps -eafwww | egrep -e &#34;mysql.*$configFile|.*phore.*$configFile|Load.*$configFile|main.tcl.*$configFile&#34; | grep -v grep} psout]
        <span class="comment-line">#puts &#34;the psLine $psLine and configFile $configFile&#34;</span>
        if {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
            return $i;
        }
        incr i
    }
    return -1;
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: aquire_process_lock</span>
<span class="comment-line">#  - </span>
<span class="comment-line">#     </span>
<span class="comment-line">#    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args: </span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           aquire_process_lock $lockid</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::aquire_process_lock_4358">proc <a href="queueLib.tcl-annot.html#::::aquire_process_lock">::::aquire_process_lock</a></a></strong> {LOCKID} {
    global LOCK_SOCKET
    
    set PORT [<a name="::port_process_map(1)"><a href="./queueLib.tcl.html#::port_process_map_4410">::port_process_map</a></a> &#34;$LOCKID&#34;]
    <span class="comment-line"># 'socket already in use' error will be our lock detection mechanism</span>
    
    if { [catch {socket -server dummy_process_accept $PORT} SOCKET] } {
        puts &#34;Could not aquire lock&#34;
        return 0
    }
    
    set LOCK_SOCKET(&#34;$LOCKID&#34;) &#34;$SOCKET&#34;
    
    return 1
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: release_process_lock</span>
<span class="comment-line">#  - </span>
<span class="comment-line">#     </span>
<span class="comment-line">#    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args: </span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           release_process_lock $lockid</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::release_process_lock_4385">proc <a href="queueLib.tcl-annot.html#::::release_process_lock">::::release_process_lock</a></a></strong> {LOCKID} {
    global LOCK_SOCKET
    
    if { [catch {close $LOCK_SOCKET(&#34;$LOCKID&#34;)} ERRORMSG] } {
        puts &#34;Error '$ERRORMSG' on closing socket for lock '$LOCKID'&#34;
        return 0
    }
    
    unset LOCK_SOCKET(&#34;$LOCKID&#34;)
    
    return 1
}

<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: port_process_map</span>
<span class="comment-line">#  - </span>
<span class="comment-line">#     </span>
<span class="comment-line">#    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args: </span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           port_process_map $lockid</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::port_process_map_4410">proc <a href="queueLib.tcl-annot.html#::::port_process_map">::::port_process_map</a></a></strong> {LOCKID} {
    <span class="comment-line"># calculate our 'unique' port number using a hash function.</span>
    <span class="comment-line"># this mapping function comes from dr. KNUTH's art of programming volume 3.</span>
    
    set LEN [string length $LOCKID]
    set HASH $LEN
    
    for {set IDX 0} {$IDX &lt; $LEN} {incr IDX} {
    scan [string index &#34;$LOCKID&#34; $IDX] &#34;%c&#34; ASC
    set HASH [expr (($HASH&lt;&lt;5)^($HASH&gt;&gt;27))^$ASC];
    }
    
    <span class="comment-line"># always use a prime for remainder</span>
    <span class="comment-line"># note that the prime number used here will basicly determine the maximum</span>
    <span class="comment-line"># number of simultaneous locks</span>
    
    return [expr (65535 - ($HASH % 101))]

}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Procedure Name: port_process_map</span>
<span class="comment-line">#  - </span>
<span class="comment-line">#     </span>
<span class="comment-line">#    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args: </span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           dummy_process_accept $newsock $addr $port</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dummy_process_accept_4441">proc <a href="queueLib.tcl-annot.html#::::dummy_process_accept">::::dummy_process_accept</a></a></strong> {newsock addr port} {

}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#  Baseline download proc</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::QueueDownloadBaseline_4449">proc <a href="queueLib.tcl-annot.html#::::QueueDownloadBaseline">::::QueueDownloadBaseline</a></a></strong> {modType platformType myQueueId userArray runningIndex} {

    global RestOfDUTType
    global RestOfIPRDUTType
    global DEVREG COMMONIMAGE
    global skipMysqlAutomate
    global mainPath
    global myRegPathSmall
    global cfg
    global runRegPlatformCode
    
    array set uInput $userArray
    set hitAllNull 0
    set featureSubType [<a name="::_getMysqlAutomateSubType(1)"><a href="./queueLib.tcl.html#::_getMysqlAutomateSubType_3969">::_getMysqlAutomateSubType</a></a> $platformType [lindex $uInput(moduleNames:) $runningIndex] $modType];
    if {[info exists uInput(platformToRunOn:)]} {
        set targetPlatform $uInput(platformToRunOn:)
        set targetPlatformLower [string tolower $targetPlatform]
        <span class="comment-line"># ----- Determine DUT2+ image type ... rtr or std</span>
        if {$featureSubType == &#34;standard&#34; } {
            set restDutLower [string tolower $RestOfDUTType($targetPlatform)]
            if {[info exists uInput(${restDutLower}BL_Image:)]} {
                set dut2Plat $RestOfDUTType($targetPlatform)
                set dut2Image $uInput(${restDutLower}BL_Image:)
            }
        } else {
            set restDutLower [string tolower $RestOfIPRDUTType($targetPlatform)]
            if {[info exists uInput(${restDutLower}BL_Image:)]} {
                set dut2Plat $RestOfIPRDUTType($targetPlatform)
                set dut2Image $uInput(${restDutLower}BL_Image:)
            }
        }
        <span class="comment-line"># --------------------------------------------------------</span>
        <span class="comment-line"># Check the 2 images for NULL</span>
        <span class="comment-line"># --------------------------------------------------------</span>
        if {[info exists uInput(${targetPlatformLower}BL_Image:)] &amp;&amp; \
            $uInput(${targetPlatformLower}BL_Image:)==&#34;NULL&#34; &amp;&amp; \
            $dut2Image==&#34;NULL&#34;} {
                set hitAllNull 1; <span class="comment-line"># Hit null</span>
        }
    }

    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">#  If the platform to run  $uInput(platformToRunOn:) and the</span>
    <span class="comment-line">#  image $uInput(${targetPlatformLower}BL_Image:) is set to skip </span>
    <span class="comment-line">#  then skip download</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>
    
    <span class="comment-line"># Start the download process</span>
    <a name="::WriteToQueueDebug(56)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Regserver Baseline Download&#34; &#34;Normal Baseline Download Start&#34;;
    <span class="comment-line"># ----------------------------------------------------------------------</span>
    <span class="comment-line">#  Get the platformToRunOn and use it to get/link to the DUT1 image</span>
    <span class="comment-line">#     path as well as the DUT2+ paths.</span>
    <span class="comment-line"># ----------------------------------------------------------------------</span>
    set plats &#34;&#34;
    set platImagePaths &#34;&#34;
    <span class="comment-line"># --- targetPlatformLower set above</span>
    if {[info exists uInput(${targetPlatformLower}BL_Image:)] &amp;&amp; \
    $uInput(${targetPlatformLower}BL_Image:)!=&#34;NULL&#34; } {
        <span class="comment-line"># -----------------------------------------------------------</span>
        <span class="comment-line"># Set the image name to the oldest common name</span>
        <span class="comment-line">#   Sonoma -&gt; Aspen</span>
        <span class="comment-line">#   Melange-&gt; Aspen</span>
        <span class="comment-line">#   Torino -&gt; Olympic</span>
        <span class="comment-line">#</span>
        <span class="comment-line"># COMMONIMAGE($targetPlatform) is initialized in runReg.cfg</span>
        <span class="comment-line"># -----------------------------------------------------------</span>
        
        <span class="comment-line"># -----------------------------------------------------------</span>
        <span class="comment-line"># Set image info for DUT1</span>
        <span class="comment-line"># -----------------------------------------------------------</span>
        set commonImageA $COMMONIMAGE($targetPlatform); <span class="comment-line"># $COMMONIMAGE(Sonoma)-&gt;Aspen</span>
        set commonImageALower [string tolower $commonImageA]
        set uInput(${commonImageALower}BL_Image:) $uInput(${targetPlatformLower}BL_Image:)
        lappend plats &#34;$commonImageA&#34;; <span class="comment-line"># List of platforms &#34;Aspen&#34;</span>
        lappend platImagePaths &#34;$uInput(${commonImageALower}BL_Image:)&#34;; <span class="comment-line"># List of full image paths</span>
        <span class="comment-line"># -----------------------------------------------------------</span>
        <span class="comment-line"># Set image info for DUT2</span>
        <span class="comment-line"># -----------------------------------------------------------</span>
        set commonImageB $COMMONIMAGE($dut2Plat); <span class="comment-line"># $COMMONIMAGE(Sonoma)-&gt;Aspen</span>
        set commonImageBLower [string tolower $commonImageB]
        set uInput(${commonImageBLower}BL_Image:) $dut2Image
        if {[string tolower [file tail $uInput(${commonImageBLower}BL_Image:)]] != &#34;null&#34;} {
            puts &#34;NULL not hit: [string tolower [file tail $uInput(${commonImageBLower}BL_Image:)]]&#34;
            lappend plats &#34;$commonImageB&#34;; <span class="comment-line"># List of platforms &#34;Aspen Cougar&#34;</span>
            lappend platImagePaths &#34;$uInput(${commonImageBLower}BL_Image:)&#34;; <span class="comment-line"># List of full image paths</span>
        }
    }
    
    <a name="::GetLocalImageDir(1)"><a href="./queueLib.tcl.html#::GetLocalImageDir_3031">::GetLocalImageDir</a></a> -id $myQueueId -platformList $plats -platformImageList $platImagePaths
    <span class="comment-line">#GetLocalImageDir $myQueueId $uInput(i386Image:) $uInput(marinerImage:) $uInput(aspenImage:) \</span>
    <span class="comment-line">#     $uInput(aspennapaImage:) $uInput(cougarImage:) $uInput(olympicImage:) $uInput(jaguarImage:) \</span>
    <span class="comment-line">#     $uInput(pantherImage:) $uInput(voyagerImage:) i386Image marinerImage aspenImage aspennapaImage \</span>
    <span class="comment-line">#     cougarImage olympicImage jaguarImage pantherImage voyagerImage </span>
    <span class="comment-line"># ----------------------------------------------------------------------</span>
    <span class="comment-line"># Re-create the image path lists from variables set in GetLocalImageDir</span>
    <span class="comment-line"># ----------------------------------------------------------------------</span>
    set platImagePaths &#34;&#34;
    foreach myPlat $plats {
        lappend platImagePaths $DEVREG(imageDir,$myPlat)
    }
    set mydir [pwd]
    cd $mainPath
    <a name="::WriteToQueueDebug(57)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;QLoadImage Baseline call&#34; &#34;QLoadImage.tcl -cfg $cfg \
        -platformList $plats -qId $myQueueId -platformImageList $platImagePaths&#34;;
    catch {exec ./QLoadImage.tcl -cfg $cfg -platformList $plats -qId $myQueueId \
        -platformImageList $platImagePaths  &gt;@stdout | busybox tee /tmp/Tmp/$myQueueId[pid]} resD
    cd $mydir
    <a name="::WriteToQueueDebug(58)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;After Baseline QLoadImage call&#34; &#34;Result = $resD&#34;;
    if {[catch {exec cp /tmp/Tmp/$myQueueId[pid] /tmp/Tmp/BL_DL_$myQueueId} reason]} {
        puts &#34;Error: Cannot cp /tmp/Tmp/$myQueueId[pid] to /tmp/Tmp/BL_DL_$myQueueId ...$reason&#34;;
        return -1
    }
    
    set oldQueueId $myQueueId
    set oldResD $resD
    <a name="::WriteToQueueDebug(59)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;End of Download choices&#34; &#34;oldResD $resD oldQueueId $myQueueId&#34;;
    if {($resD==0)||([regexp -nocase &#34;^0&#34; $resD]==1&amp;&amp;[regexp -nocase &#34;write error&#34; $resD])} {
        <span class="comment-line"># Download image successful, move the report dir to avoid conflict with failed ones</span>
        <span class="comment-line"># Since we do not want to compute the info file here but only move the</span>
        <span class="comment-line"># download report dir</span>
        set DEVREG(active,failcount) 0
        <a name="::WriteToQueueDebug(60)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download image successful&#34; &#34;Call MoveReportToQueueFinished&#34;;
        file delete /tmp/Tmp/$myQueueId[pid]
        if {[set targetDir [<a name="::MoveReportToQueueFinished(2)"><a href="./queueLib.tcl.html#::MoveReportToQueueFinished_1634">::MoveReportToQueueFinished</a></a> $myQueueId [array get uInput] $runningIndex DownloadPassed]]==-1} {
            set targetDir &#34;Baseline Download Report dir not generate&#34;
        }
        puts &#34;!!!!\nTarget Dir\n$targetDir\n!!!!!&#34;
        if {$uInput(platformToRunOn:)==&#34;PC&#34;} {
           set platToRunOn i386
        } else {
           set platToRunOn [string tolower $uInput(platformToRunOn:)]
        }
        if {$uInput([set platToRunOn]BL_Image:)!=&#34;skip&#34;} {
            if {!$skipMysqlAutomate} {
                <a name="::WriteToQueueDebug(61)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download baseline image successful&#34; &#34;mysqlAutomate: -platform $runRegPlatformCode \
                    -regId $myQueueId \
                    -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex]  -qId $myQueueId \
                    -regType $myRegPathSmall -regSubType $featureSubType&#34;;
                catch {exec $mainPath/../main/mysqlAutomate.tcl -regId $myQueueId -platform $runRegPlatformCode \
                    -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex]  -qId $myQueueId \
                    -regType $myRegPathSmall -regSubType $featureSubType -callLocation \
                    &#34;regServer: resD=0 download successful $cfg&#34;&gt;@stdout} automateRet
            }
        }
        return 0
    } else {
        return -1
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: ReQueueModules</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc goes through images running and looks</span>
<span class="comment-line">#              for download fails and mainfails and requeues them</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           qId: queueId to work on inside imagesFinished</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           ReQueueModules $myQueueId</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ReQueueModules_4613">proc <a href="queueLib.tcl-annot.html#::::ReQueueModules">::::ReQueueModules</a></a></strong> {qId {finished no} {features &#34;null&#34;}} {
   global DEVREG

   if {$finished == &#34;yes&#34;} {
      set inFinished 0
      set inRunning 0
      if {[file isfile &#34;$DEVREG(server,imagesFinishedDir)/$qId/info&#34;]} {
         puts &#34;Found info in Finished&#34;
         set fileToUse $DEVREG(server,imagesFinishedDir)/$qId/info
         set inFinished 1
      }
      if {[file isfile &#34;$DEVREG(server,imagesRunningDir)/$qId/info&#34;]} {
         puts &#34;Found info in Running&#34;
         set fileToUse $DEVREG(server,imagesRunningDir)/$qId/info
         set inRunning 1
      }
      if {!$inFinished &amp;&amp; !$inRunning} {
         <a name="::result_error(47)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: no info file available&#34;
         return -1
      }
      if {!$inRunning &amp;&amp; ![file isdirectory $DEVREG(server,imagesRunningDir)/$qId/]} {
         if {[catch {file mkdir $DEVREG(server,imagesRunningDir)/$qId/} reason]} {
            <a name="::result_error(48)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create $DEVREG(server,imagesRunningDir)/$qId/ dir...$reason&#34;
            return -1
         }
      }
      if {![file isdirectory $DEVREG(server,imagesQueuedDir)/$qId/]} {
         if {[catch {file mkdir $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
            <a name="::result_error(49)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create $DEVREG(server,imagesQueuedDir)/$qId/ dir...$reason&#34;
            return -1
         }
      }
      if {$inRunning} {
         if {[catch {exec cp $DEVREG(server,imagesRunningDir)/$qId/info \
            $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
            puts &#34;Error: Cannot cp $DEVREG(server,imagesRunningDir)/$qId/info \
            to $DEVREG(server,imagesQueuedDir)/$qId/ ...$reason&#34;;
            return -1
         }
      } else {
         if {[catch {exec cp $DEVREG(server,imagesFinishedDir)/$qId/info $DEVREG(server,imagesRunningDir)/$qId/} reason]} {
            puts &#34;Error: Cannot cp $DEVREG(server,imagesFinishedDir)/$qId/info to $DEVREG(server,imagesRunningDir)/$qId/ ...$reason&#34;;
            return -1
         }
         if {[catch {exec cp $DEVREG(server,imagesFinishedDir)/$qId/info $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
            puts &#34;Error: Cannot cp $DEVREG(server,imagesFinishedDir)/$qId/info to $DEVREG(server,imagesQueuedDir)/$qId/ ...$reason&#34;;
            return -1
         }
      }
      set runningInfoFile &#34;$DEVREG(server,imagesRunningDir)/$qId/info&#34;
      if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;<span class="comment-line"># qId is already running</span>
         if {[set fd_r [<a name="::FileOpen(50)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningInfoFile r+]]==-1} {
            return $fd_r
         }
         set cpList &#34;&#34;
         while {[gets $fd_r infoLine]!=-1} {
            set runInfo([lindex $infoLine 0]) [lrange $infoLine 1 end]
            if {[string trim [lrange $infoLine 1 end]] != &#34;NULL&#34; &amp;&amp; [regexp &#34;Image&#34; [lindex $infoLine 0]] &amp;&amp; \
                [lsearch $cpList [string trim [lrange $infoLine 1 end]]] &lt; 0} {
               puts &#34;Copy [string trim [lrange $infoLine 1 end]] to $qId&#34;
               if {[catch {exec cp [string trim [lrange $infoLine 1 end]] $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
                  puts &#34;Error: Cannot cp cp [string trim [lrange $infoLine 1 end]] $DEVREG(server,imagesQueuedDir)/$qId/ ...$reason&#34;;
                  if {![regexp &#34;480&#34; [string trim [lrange $infoLine 1 end]]]} {
                      return -1
                  }
               }
               lappend cpList &#34;[string trim [lrange $infoLine 1 end]]&#34; 
            } elseif {[lsearch $cpList [string trim [lrange $infoLine 1 end]]] &gt;= 0} {
                puts &#34;Already copied [string trim [lrange $infoLine 1 end]] to $qId&#34;
            }
         }
      } else {  ;<span class="comment-line"># qId not Found, an error</span>
         <a name="::result_error(50)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues&#34;;
         return -1
      }
      close $fd_r
      <a name="::SetPriorityFile(1)"><a href="./queueLib.tcl.html#::SetPriorityFile_98">::SetPriorityFile</a></a> $qId
   } 

   set runningInfoFile &#34;$DEVREG(server,imagesRunningDir)/$qId/info&#34;
   set queueInfoFile &#34;$DEVREG(server,imagesQueuedDir)/$qId/info&#34;
   if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;<span class="comment-line"># qId is already running</span>
      if {[set fd_r [<a name="::FileOpen(51)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningInfoFile r+]]==-1} {
         return $fd_r
      }
      while {[gets $fd_r infoLine]!=-1} {
         set runInfo([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
   } else {  ;<span class="comment-line"># qId not Found, an error</span>
      <a name="::result_error(51)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues&#34;;
      return -1
   }
   if {![catch {glob -- $DEVREG(server,imagesQueuedDir)/$qId} queues]} { ;<span class="comment-line"># qId is in queued dir</span>
      if {[set fd_q [<a name="::FileOpen(52)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $queueInfoFile r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set queueInfo([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
   } else {  ;<span class="comment-line"># qId not Found, an error</span>
      <a name="::result_error(52)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues&#34;;
      return -1
   }

   if {$features != &#34;null&#34;} {
       set replaceIList &#34;&#34;
       foreach rFeat $features {
           set fIndex [lsearch $queueInfo(moduleNames:) $rFeat]
           lappend replaceIList $fIndex
       }
   } else {
       set replaceIList [lsearch -regexp -all $runInfo(runStatus:) ^Main|^Down]
   }
   foreach r $replaceIList {
       set runInfo(runStatus:) [lreplace $runInfo(runStatus:) $r $r &#34;queued&#34;]
       set queueInfo(runStatus:) [lreplace $queueInfo(runStatus:) $r $r &#34;queued&#34;]
   }
   set replaceIList2 [lsearch -regexp -all $runInfo(runStatus:) ^runn]
   foreach r2 $replaceIList2 {
       set mod [lindex $runInfo(moduleNames:) $r2]
       set cfgList [split [lindex $runInfo(runStatus:) $r2] &#34;On&#34;]
       set cfg [lindex $cfgList 1]
       set psLineitest [catch {exec ps -eafwww | egrep -e &#34;main\.tcl.*-module.*$mod.*$qId&#34; | grep -v grep} psoutmod]
       if {[string trim $psoutmod] == &#34;&#34; || [regexp -nocase &#34;child process exited abnormally&#34; $psoutmod]} {
           puts &#34;$mod is not running on $cfgList $psoutmod &#34;
           lappend replaceIList $r2
           set runInfo(runStatus:) [lreplace $runInfo(runStatus:) $r2 $r2 &#34;queued&#34;]
           set queueInfo(runStatus:) [lreplace $queueInfo(runStatus:) $r2 $r2 &#34;queued&#34;]
       } else {
           puts &#34;$mod is running on $cfgList $psoutmod&#34;
       }
   }
   set replaceIList3 [lsearch -regexp -all $runInfo(runStatus:) ^reRun]
   foreach r2 $replaceIList3 {
       set mod [lindex $runInfo(moduleNames:) $r2]
       set cfgList [split [lindex $runInfo(runStatus:) $r2] &#34;On&#34;]
       set cfg [lindex $cfgList 1]
       set psLineitest [catch {exec ps -eafwww | egrep -e &#34;main\.tcl.*-module.*$mod.*$qId&#34; | grep -v grep} psoutmod]
       if {[string trim $psoutmod] == &#34;&#34; || [regexp -nocase &#34;child process exited abnormally&#34; $psoutmod]} {
           puts &#34;$mod is not reRunning on $cfgList $psoutmod &#34;
           lappend replaceIList $r2
           set runInfo(runStatus:) [lreplace $runInfo(runStatus:) $r2 $r2 &#34;queued&#34;]
           set queueInfo(runStatus:) [lreplace $queueInfo(runStatus:) $r2 $r2 &#34;queued&#34;]
       } else {
           puts &#34;$mod is reRunning on $cfgList $psoutmod&#34;
       }
   }

   <span class="comment-line">#set psLineitest [catch {exec ps -eafwww | egrep -e &#34;main\.tcl.*-module L2&#34; | grep -v grep} psoutitest]</span>
   <span class="comment-line"># -------------------------------------------------------------------------</span>
   <span class="comment-line"># if Use Database is on, update the test module table entry for this module</span>
   <span class="comment-line"># -------------------------------------------------------------------------</span>
   if {$DEVREG(mysql,UseDb)} {
       set rId [<a name="::getRegIdFromQId(9)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
       <span class="comment-line"># Login to rdureg auto db</span>
       set hdl [<a name="::quick_db_connect(1)"><a href="./mysqlLib.tcl.html#::quick_db_connect_149">::quick_db_connect</a></a> rtp-otps devweb_db]
       if {$hdl != &#34;fail&#34;} {
           set autoRegId [<a name="::getRegressionIdDb(1)"><a href="./mysqlLib.tcl.html#::getRegressionIdDb_1941">::getRegressionIdDb</a></a> -hdl $hdl -queue_id $qId]
           puts &#34;autoRegId = $autoRegId&#34;
       }
       foreach r $replaceIList {
           set cfgList [split [lindex $runInfo(runStatus:) $r] &#34;On&#34;]
           <a name="::updateRegTestModule(10)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $rId -name [lindex $runInfo(moduleNames:) $r] \
               -pass_cnt_1 &#34;0&#34; -total_cnt_1 &#34;0&#34; -duration_1 &#34;0&#34; -pass_cnt &#34;0&#34; -total_cnt &#34;0&#34; \
               -duration &#34;0&#34;  -status &#34;queued&#34; -testbed &#34;[lindex $cfgList 1]&#34;

           if {[catch {exec rm -rf $DEVREG(server,imagesFinishedDir)/$qId/[lindex $runInfo(moduleNames:) $r]} reason]} {
                puts &#34;Error: Cannot rm $DEVREG(server,imagesFinishedDir)/$qId/[lindex $runInfo(moduleNames:) $r]&#34;
                puts  &#34;     ..$reason&#34;;
           } else {
                puts &#34;rm -rf $DEVREG(server,imagesFinishedDir)/$qId/[lindex $runInfo(moduleNames:) $r]&#34;
           }

           <span class="comment-line"># delete the results from the auto db.</span>
           if {$hdl != &#34;fail&#34;} {
               <a name="::deleteReportsAndLogsDb(1)"><a href="./mysqlLib.tcl.html#::deleteReportsAndLogsDb_1233">::deleteReportsAndLogsDb</a></a> -hdl $hdl -regression_id $autoRegId \
                  -feature_type [lindex $runInfo(moduleTypes:) $r]  \
                  -feature_directory [lindex $runInfo(moduleNames:) $r]
           }
       }
       if {$hdl != &#34;fail&#34;} {
           mysqlclose $hdl
       }
   }
   seek $fd_q 0 start
   foreach varName [array names queueInfo] {
       puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $queueInfo($varName)]&#34;
   }
   ftruncate $queueInfoFile [tell $fd_q]
   close $fd_q

   seek $fd_r 0 start
   foreach varName [array names runInfo] {
       puts $fd_r &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $runInfo($varName)]&#34;
   }
   ftruncate $runningInfoFile [tell $fd_r]
   close $fd_r
   return 1
}
<span class="comment-line">#############################################################################</span>
<span class="comment-line"># proc to get info about running and queued regressions.  </span>
<span class="comment-line"># </span>
<span class="comment-line"># Return a platform keyed array of usage.</span>
<span class="comment-line">#############################################################################</span>
<strong><a name="::::checkPlatQueued_4817">proc <a href="queueLib.tcl-annot.html#::::checkPlatQueued">::::checkPlatQueued</a></a></strong> {} {
    
    global auto_path
    source /auto/automation/Util/runReg.cfg   ;<span class="comment-line"># need to change it when run from elsewhere</span>
    source /auto/automation/Util/iTest.cfg
    set autoPath &#34;/auto/automation/&#34;
    <span class="comment-line"># Decide which queue_ids will be store on the local server</span>
    set DEVREG(server,HOST)              [exec hostname -s]
    
    if {[regexp -nocase &#34;devreg|rdu&#34; $DEVREG(server,HOST)]} {
        <span class="comment-line"># rdu case -</span>
        set match RTP
    } elseif {[regexp -nocase &#34;sal&#34; $DEVREG(server,HOST)]} {
        set match SALEM
    } else {
        <span class="comment-line">#SC case.. set all of these to Complete</span>
        set match SC
    }
    
    <span class="comment-line">#Get an array aligning cfg files with platforms for all running queues.</span>
    array set RR [<a name="::allRunningServerTypes(1)"><a href="./queueLib.tcl.html#::allRunningServerTypes_265">::allRunningServerTypes</a></a>]
    <span class="comment-line">#parray RR</span>
    
    set myPlat Manhattan10G 
    <span class="comment-line">#set myPlat x480</span>
    set plats [<a name="::getFromRegRunWhere(1)"><a href="./mysqlLib.tcl.html#::getFromRegRunWhere_4078">::getFromRegRunWhere</a></a> &#34;platform, reg_id, id_label&#34; &#34;(status = 'Queued' OR status = 'Running') AND type = 'Private' AND id_label LIKE '${match}%'&#34;]
    set pInfoList(p) &#34;&#34;
    set pList &#34;&#34;
    set ptCount(x,y) &#34;&#34;
    set putLock(p,t) &#34;&#34;
    set patLock(p,t) &#34;&#34;
    set RUNREGINFO(pppppp) &#34;&#34;
    foreach {p v l} $plats {
        <span class="comment-line">#puts &#34;$p $v $l&#34;</span>
        set p2 0
        set p5 0
        set patLock($p,rtr) &#34;&#34;
        set patLock($p,std) &#34;&#34;
        if {![info exists putLock($p,rtr)]} {
            set putLock($p,rtr) &#34;&#34;
        }
        if {![info exists putLock($p,std)]} {
            set putLock($p,std) &#34;&#34;
        }
        lappend pInfoList($p) &#34;$p&#34;
        if {$p == &#34;&#34;} {
            continue;
        } else {
            set mods [<a name="::getValueTestModWhere(1)"><a href="./mysqlLib.tcl.html#::getValueTestModWhere_4058">::getValueTestModWhere</a></a> name &#34;reg_id = '$v' AND (status = 'queued' OR status = 'running')&#34;]
            foreach m $mods {
                <span class="comment-line">#puts &#34;Plat $p Mod $m regid $v $l&#34;</span>
                if {[lsearch $stdMods(functional,All) $m]&gt;=0 || [lsearch $stdMods(functional,$p) $m]&gt;=0 || [lsearch $istdMods(functional,All) $m]&gt;=0} {
                    incr p2
                }
                if {[lsearch $rtrMods(functional,All) $m]&gt;=0 || [lsearch $rtrMods(functional,$p) $m]&gt;=0 || [lsearch $irtrMods(functional,All) $m]&gt;=0} {
                    incr p5
                }
            }
            lappend pList &#34;$p&#34; 
            if {![info exists ptCount($p,std)]} {
                set ptCount($p,std) $p2
            } else {
                set ptCount($p,std) [expr $ptCount($p,std) + $p2]
            }
            if {![info exists ptCount($p,rtr)]} {
                set ptCount($p,rtr) $p5
            } else {
                set ptCount($p,rtr) [expr $ptCount($p,rtr) + $p5]
            }
        }
    }
    <span class="comment-line">#</span>
    <span class="comment-line">#  Get userlock info</span>
    <span class="comment-line">#</span>
    if {1} {
        set queues [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/*]
        ;<span class="comment-line"># Look for any qId that is actively using queued platform</span>
        foreach qIdPath $queues {
            set catchVal [catch {exec egrep -e &#34;lockFile:&#34; $qIdPath/info} userInfo]
            if {! $catchVal} {
                regexp {lockFile:\ *([A-Za-z0-9_\-]+\.cfg)\ *$} $userInfo ignore cCfg
                set tbp $RR(platCfg,null,$cCfg)
                set tbt $RR(platType,$cCfg,$tbp);
                lappend pList $tbp
                if {$tbt == &#34;routing&#34;} {
                    set putLock($tbp,rtr) &#34;rtr(UL)&#34;
                } else {
                    set putLock($tbp,std) &#34;std(UL)&#34;
                }
            } else {
    
            }
        }
        set queues [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
        ;<span class="comment-line"># Look for any qId that is actively using queued platform</span>
        foreach qIdPath $queues {
            set catchVal [catch {exec egrep -e &#34;lockFile:&#34; $qIdPath/info} userInfo]
            if {! $catchVal} {
                regexp {lockFile:\ *([A-Za-z0-9_\-]+\.cfg)\ *$} $userInfo ignore cCfg
                set tbp $RR(platCfg,null,$cCfg)
                set tbt $RR(platType,$cCfg,$tbp);
                puts &#34;$tbp $tbt - UserLocked&#34;
                lappend pList $tbp
                if {$tbt == &#34;routing&#34;} {
                    set putLock($tbp,rtr) &#34;rtr(UL)&#34;
                } else {
                    set putLock($tbp,std) &#34;std(UL)&#34;
                }
                if {![info exists patLock($tbp,rtr)]} {
                    set patLock($tbp,rtr) &#34;&#34;
                }
                if {![info exists patLock($tbp,std)]} {
                    set patLock($tbp,std) &#34;&#34;
                }
            } else {
    
            }
        }
    }
    
    <span class="comment-line">#</span>
    <span class="comment-line">#  Get the admin locked test beds</span>
    <span class="comment-line">#</span>
    set lines &#34;&#34;
    if {[set fd_in [<a name="::FileOpen(53)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) r]]==-1} {
        return $fd_in
    }
    while {[gets $fd_in line]!=-1} {
        set line [string trim $line &#34;!&#34;]
        set tbp $RR(platCfg,null,$line)
        set tbt $RR(platType,$line,$tbp);
        set patLock($tbp,rtr) &#34;&#34;
        set patLock($tbp,std) &#34;&#34;
        if {![info exists putLock($tbp,rtr)]} {
            set putLock($tbp,rtr) &#34;&#34;
        }
        if {![info exists putLock($tbp,std)]} {
            set putLock($tbp,std) &#34;&#34;
        }
        lappend lines $line
    }
    funlock $fd_in
    close $fd_in
    foreach li $lines {
        set tbp $RR(platCfg,null,$li)
        set tbt $RR(platType,$li,$tbp);
        <span class="comment-line">#puts &#34;$tbp $tbt - ADMINLOCKED&#34;;</span>
        lappend pList &#34;$tbp&#34;
        if {$tbt == &#34;routing&#34;} {
            set patLock($tbp,rtr) &#34;rtr(AL)&#34;
        } else {
            set patLock($tbp,std) &#34;std(AL)&#34;
        }
    }
    foreach myP $pList {
        if {[info exists ptCount($myP,std)]} {
            if {$ptCount($myP,std) == 0} {
                set stdtext &#34;&#34;
            } else {
                set stdtext &#34;std($ptCount($myP,std))&#34;
            }
        } else {
            set stdtext &#34;&#34;
        }
        if {[info exists ptCount($myP,rtr)]} {
            if {$ptCount($myP,rtr) == 0} {
                set rtrtext &#34;&#34;
            } else {
                set rtrtext &#34;rtr($ptCount($myP,rtr))&#34;
            }
        } else {
            set rtrtext &#34;&#34;
        }
        if {![info exists putLock($myP,rtr)]} {
            set putLock($myP,rtr) &#34;&#34;
        }
        if {![info exists putLock($myP,std)]} {
            set putLock($myP,std) &#34;&#34;
        }
        if {![info exists patLock($myP,rtr)]} {
            set patLock($myP,rtr) &#34;&#34;
        }
        if {![info exists patLock($myP,std)]} {
            set patLock($myP,std) &#34;&#34;
        }
        <span class="comment-line">#puts &#34;$myP ${stdtext}${rtrtext}$patLock($myP,std)$patLock($myP,rtr)$putLock($myP,std)$putLock($myP,rtr)&#34;</span>
        lappend RUNREGINFO($myP) &#34;${stdtext}${rtrtext}$patLock($myP,std)$patLock($myP,rtr)$putLock($myP,std)$putLock($myP,rtr)&#34;
    }
    return [array get RUNREGINFO]
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetPlatformsWithImageFiles</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc returns a list of platforms that have</span>
<span class="comment-line">#              images associated with it in the info file</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#           uInput: queueId info array</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           GetPlatformsWithImageFiles [array get userInput]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetPlatformsWithImageFiles_5023">proc <a href="queueLib.tcl-annot.html#::::GetPlatformsWithImageFiles">::::GetPlatformsWithImageFiles</a></a></strong> {uInput} {
    array set usrInput $uInput
    global DEVREG
    set strToReturn &#34;&#34;
    global RestOfDUTType RestOfIPRDUTType DEVREG

    <span class="comment-line">#GH 09-08-2014 Added to support passing all platforms with images into QLoadimages</span>
    foreach varName [array names usrInput] {
        if {[regexp -nocase &#34;image:&#34; $varName]} {
            if {[string tolower [file tail $uInput($varName)]] != &#34;null&#34;} {
                regsub &#34;Image:&#34; $varName  &#34;&#34; downloadPlat
                puts &#34;Hit a platform with a valid image to download: $downloadPlat&#34;
                lappend strToReturn &#34;$downloadPlat&#34;; <span class="comment-line"># Add any platform that has a real image in the info file</span>
            }
        }
    }

    return $strToReturn

}
<strong><a name="::::_MyServerIp_5043">proc <a href="queueLib.tcl-annot.html#::::_MyServerIp">::::_MyServerIp</a></a></strong> {} {
    <span class="comment-line"># find out localhost's IP address</span>
    <span class="comment-line"># courtesy David Gravereaux, Heribert Dahms</span>
    set TheServer [socket -server none -myaddr [info hostname] 0]
    set MyIP [lindex [fconfigure $TheServer -sockname] 0]
    close $TheServer
    return $MyIP
}
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<span class="comment-line">#  QueueAUserLock</span>
<span class="comment-line">#</span>
<span class="comment-line">#  A procedure to dynamically create a lock entry for a user</span>
<span class="comment-line">#</span>
<span class="comment-line">#  input args: Array with lock info</span>
<span class="comment-line">#</span>
<span class="comment-line">#  outputs</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<strong><a name="::::QueueAUserLock_5062">proc <a href="queueLib.tcl-annot.html#::::QueueAUserLock">::::QueueAUserLock</a></a></strong> {lInput} {
    global DEVREG mysqlstatus  mysql_handler

    array set userInput $lInput

    set pid [pid]
    <span class="comment-line"># ---  Open the file the will become the info file</span>
    if {[set fd_out [<a name="::FileOpen(54)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> &#34;/tmp/Tmp/$pid&#34; w]]==-1} {
        puts &#34;Could not create auto lock entry&#34;
        return $fd_out
    }

    set submitRequest &#34;&#34;
    sleep 1
    set queueId [format %s_%s $DEVREG(server,location) [clock format [clock seconds] \
        -format %y%m%d_%H%M%S]]  ;<span class="comment-line"># for now this is the queueId</span>
    <span class="comment-line"># ----------------------------------------------------------------------</span>
    <span class="comment-line"># Create the queue dir (RTP_######_######) inside imagesQueuedDir</span>
    <span class="comment-line"># ----------------------------------------------------------------------</span>
    set queueDir &#34;$DEVREG(server,imagesQueuedDir)/$queueId&#34;
    if {[file isdirectory $queueDir]} {
        <span class="comment-line"># --- If the queuedir exists make a new one ---</span>
        set queueId [format %s_%s $DEVREG(server,location) \
        [clock format [clock seconds] -format %y%m%d_%H%M%S]]  ;<span class="comment-line"># for now this is the queueId</span>
        set queueDir &#34;$DEVREG(server,imagesQueuedDir)/$queueId&#34;
    }
    <span class="comment-line"># --- Create the RTP_######_###### dir</span>
    if {[catch {file mkdir $queueDir} reason]} {
        puts &#34;Error: Can not create queueDir dir...$reason&#34;
        exit -1
    }
    chmod 0777 $queueDir
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    <span class="comment-line"># Write entire userInput array to the tmp info file</span>
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    foreach varName [array names userInput] {
        puts $fd_out &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
    }
    close $fd_out
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    <span class="comment-line"># Move info file to the imagesQueued/RTP_######_######/ directory</span>
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    if {[catch {file rename /tmp/Tmp/$pid &#34;$queueDir/info&#34;} reason]} {
        puts &#34;Error: Cannot copy file to $queueDir...$reason&#34;;
        exit -1
    }
    chmod 0777 $queueDir/info

    <span class="comment-line"># set the priority of image in priority file</span>
    <a name="::SetPriorityFile(2)"><a href="./queueLib.tcl.html#::SetPriorityFile_98">::SetPriorityFile</a></a> $queueId
    if {[<a name="::OrderPriorityFile(1)"><a href="./queueLib.tcl.html#::OrderPriorityFile_4030">::OrderPriorityFile</a></a>]!=1} {
        puts &#34;Could not reorder the priority file&#34;
        return -1
    }
    <span class="comment-line"># ---------------------------------------------------------------------------------</span>
    <span class="comment-line"># Post the reg_run entry to the database</span>
    <span class="comment-line"># ---------------------------------------------------------------------------------</span>
    if {$DEVREG(mysql,UseDb)} {
        set bId &#34;&#34;
        set platformName &#34;&#34;
        set bType &#34;&#34;
        set bTag &#34;&#34;
        <a name="::InsertQueueEntry(1)"><a href="./mysqlLib.tcl.html#::InsertQueueEntry_3527">::InsertQueueEntry</a></a> -id_label &#34;$queueId&#34; -build_id &#34;$bId&#34; -reg_server &#34;$DEVREG(server,FULLHOST)&#34; \
            -user &#34;$userInput(userid:)&#34; -platform &#34;$platformName&#34; -type &#34;$bType&#34; -status &#34;Queued&#34; \
            -branch &#34;$bTag&#34;

        set rId [<a name="::getRegIdFromQId(10)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $queueId]
        puts &#34;The reg_id from the database is: $rId&#34;
        <span class="comment-line"># --- Now post each module to the test_module table ---</span>
        set u 0
        foreach mod $userInput(moduleNames:) {
            set myLst [lindex $userInput(moduleLists:) $u]
            <a name="::InsertQModuleEntry(1)"><a href="./mysqlLib.tcl.html#::InsertQModuleEntry_3633">::InsertQModuleEntry</a></a> -reg_id $rId -name $mod -list $myLst -status &#34;queued&#34;
            incr u
        }
    }
    puts &#34;Submitted the lock for $userInput(userid:) with queueId $queueId&#34;
}
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<span class="comment-line"># SetTerminalTitle - use the runReg.cfg plus any cfg override to set xterm title</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<strong><a name="::::SetTerminalTitle_5146">proc <a href="queueLib.tcl-annot.html#::::SetTerminalTitle">::::SetTerminalTitle</a></a></strong> {args} {
    global MAIN

    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> SetTerminalTitle $args {
        title &#34;null&#34;
        add   &#34;null&#34;
    }

    if {![info exists MAIN(XTERMTITLEON)] || !$MAIN(XTERMTITLEON)} {
        return
    }
    if {$title == &#34;null&#34;} {
        set ntext &#34;&#34;
        if {$MAIN(XTERMTITLE) != &#34;null&#34;} {
            append ntext &#34;$MAIN(XTERMTITLE) &#34;
        }
        if {[info exists MAIN(SWDEVXTERM)] &amp;&amp; $MAIN(SWDEVXTERM) != &#34;null&#34;} {
            append ntext &#34;$MAIN(SWDEVXTERM)&#34;
        }
        if {[info exists MAIN(cfg)]} {
            append ntext &#34;$MAIN(cfg) &#34;
        }
        if {[info exists MAIN(feature_directory)] &amp;&amp; $MAIN(feature_directory) != &#34;null&#34;} {
            append ntext &#34;$MAIN(feature_directory) &#34;
        }
        if {[info exists MAIN(CURRENTTESTCASE)] &amp;&amp; $MAIN(CURRENTTESTCASE) != &#34;null&#34;} {
            append ntext &#34;$MAIN(CURRENTTESTCASE)&#34;
        }
        if {$add != &#34;null&#34;} {
            append ntext &#34;$add&#34;
        }
    } else {
        set ntext $title

    }
    set bob &#34;\033]0;$ntext\007&#34;
    puts $bob\n
}
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<span class="comment-line"># Procedure: _update_scm_db_from_report_txt</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<strong><a name="::::_update_scm_db_from_report_txt_5192">proc <a href="queueLib.tcl-annot.html#::::_update_scm_db_from_report_txt">::::_update_scm_db_from_report_txt</a></a></strong> {args} {
    global DEVREG mysqlIP my_db MAIN DEVREG
    set host $mysqlIP
    set db $my_db

    <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _update_scm_db_from_report_txt $args {
        log_pid     &#34;NULL&#34;
        module      &#34;NULL&#34;
        reportDir   &#34;NULL&#34;
        qId         &#34;NULL&#34;
        run         &#34;1&#34;
        scmJob      &#34;0&#34;
    }

    set rp 0;<span class="comment-line"># report pass count</span>
    set rf 0;<span class="comment-line"># fail count</span>
    set sv 0;<span class="comment-line"># subversion rev</span>
    set rd 0;<span class="comment-line"># duration</span>
    set dv &#34;0.0.0.0&#34;;<span class="comment-line"># dut1 sw version</span>
    set rs &#34;Fail&#34;;<span class="comment-line"># status</span>
    set core &#34;null&#34;;
    set cz 0;<span class="comment-line"># core db setting</span>
    if {![info exists DEVREG(mysql,centralserver)]} {
        puts &#34;The SW Dev environment is not defined.  DEVREG vars need to be set&#34;
        return;
    }
    set reportFile ${reportDir}/report.txt
    if {![file exists $reportFile]} {
        if {$log_pid != &#34;NULL&#34;} {
            puts $log_pid &#34;DEVREG DB CANNOT BE UPDATED: $reportFile is not a valid file&#34;
            puts &#34;DEVREG DB CANNOT BE UPDATED: $reportFile is not a valid file&#34;
        } else {
            puts &#34;DEVREG DB CANNOT BE UPDATED: $reportFile is not a valid file&#34;
        }
        return;
    }
    if {$qId == &#34;NULL&#34;} {
        if {$log_pid != &#34;NULL&#34;} {
            puts $log_pid &#34;DEVREG DB CANNOT BE UPDATED: qId not passed in&#34;
            puts &#34;DEVREG DB CANNOT BE UPDATED: qId not passed in&#34;
        } else {
            puts &#34;DEVREG DB CANNOT BE UPDATED: qId not passed in&#34;
        }
        return;        
    } else {
        if {$scmJob==0 || ![regexp -nocase &#34;RTP|CIT&#34; $qId]} {
            if {$log_pid != &#34;NULL&#34;} {
                puts $log_pid &#34;DEVREG DB CANNOT BE UPDATED: scmJob set false or qId no legal. scmJob:$scmJob $qId&#34;
                puts &#34;DEVREG DB CANNOT BE UPDATED: scmJob set false or qId no legal. scmJob:$scmJob $qId&#34;
            } else {
                puts &#34;DEVREG DB CANNOT BE UPDATED: scmJob set false or qId no legal. scmJob:$scmJob $qId&#34;
            }
            return;
        }
    }
    if {$module == &#34;NULL&#34;} {
        if {$log_pid != &#34;NULL&#34;} {
            puts $log_pid &#34;DEVREG DB CANNOT BE UPDATED: module not passed in&#34;
            puts &#34;DEVREG DB CANNOT BE UPDATED: module not passed in&#34;
        } else {
            puts &#34;DEVREG DB CANNOT BE UPDATED: module not passed in&#34;
        }
        return;
    }
    <span class="comment-line"># -- tgz glob check report dir --</span>
    set tgzList  [glob -nocomplain -- ${reportDir}/*.tgz]
    if {$log_pid != &#34;NULL&#34;} {
        puts $log_pid &#34;TGZ FILES: $tgzList&#34;
    }
    set scm_id [<a name="::getFromRegRunWhere(2)"><a href="./mysqlLib.tcl.html#::getFromRegRunWhere_4078">::getFromRegRunWhere</a></a> &#34;reg_id&#34; &#34;id_label = '$qId'&#34;]
    set core [<a name="::_get_report_txt_core_uploaded(1)"><a href="./report.tcl.html#::_get_report_txt_core_uploaded_917">::_get_report_txt_core_uploaded</a></a> \
               -reportFile $reportFile]
    set rp [<a name="::_get_report_txt_subcounts(1)"><a href="./report.tcl.html#::_get_report_txt_subcounts_818">::_get_report_txt_subcounts</a></a> -state pass \
               -reportFile $reportFile]
    set rf [<a name="::_get_report_txt_subcounts(2)"><a href="./report.tcl.html#::_get_report_txt_subcounts_818">::_get_report_txt_subcounts</a></a> -state fail \
               -reportFile $reportFile]
    set sv [<a name="::_get_report_txt_subverion(1)"><a href="./report.tcl.html#::_get_report_txt_subverion_847">::_get_report_txt_subverion</a></a> \
               -reportFile $reportFile]
    set dv [<a name="::_get_report_txt_version(1)"><a href="./report.tcl.html#::_get_report_txt_version_892">::_get_report_txt_version</a></a> \
               -reportFile $reportFile]
    set rd [<a name="::_get_report_txt_duration(1)"><a href="./report.tcl.html#::_get_report_txt_duration_869">::_get_report_txt_duration</a></a> \
               -reportFile $reportFile]
    set rt [expr $rp + $rf]
    if {$rf == 0 &amp;&amp; $rt &gt; 0} {set rs &#34;Pass&#34;}
    if {[llength $tgzList] &gt; 0 &amp;&amp; $core!=&#34;core&#34; &amp;&amp; $core!=&#34;ccov&#34; &amp;&amp; $core!=&#34;both&#34;} {
        set cz 5
    } elseif {[llength $tgzList] &gt; 0 &amp;&amp; $core==&#34;core&#34;} {
        set cz 1
    } elseif {[llength $tgzList] &gt; 0 &amp;&amp; $core==&#34;both&#34;} {
        set cz 2
    } elseif {[llength $tgzList] &gt; 0 &amp;&amp; $core==&#34;ccov&#34;} {
        set cz 3
    } elseif {[llength $tgzList] == 0 &amp;&amp; $core!=&#34;null&#34;} {
        set cz 4
    }

    if {$run == 1} {
        <a name="::updateRegTestModule(11)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $scm_id  -name $module -pass_cnt $rp -total_cnt $rt \
            -duration $rd  -sqa_revision $sv -status $rs -corefiles $cz
        <a name="::updateRegIdEntry(3)"><a href="./mysqlLib.tcl.html#::updateRegIdEntry_3834">::updateRegIdEntry</a></a> -id_label $qId -version $dv
        puts $log_pid &#34;Update BILTMORE: reg_id:$scm_id run1 PASS:$rp FAIL:$rf TOT:$rt Dur:$rd \n\
             Status:$rs SUBVERSION:$sv DUT SW:$dv cores $cz&#34;
    } elseif {$run == 2} {
        <a name="::updateRegTestModule(12)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $scm_id  -name $module -pass_cnt_1 $rp -total_cnt_1 $rt \
            -duration_1 $rd  -sqa_revision $sv -status $rs -corefiles_1 $cz
        puts $log_pid &#34;Update BILTMORE: reg_id:$scm_id run2 PASS:$rp FAIL:$rf TOT:$rt Dur:$rd \n\
             Status:$rs SUBVERSION:$sv DUT SW:$dv cores $cz&#34;
    }
    <span class="comment-line"># reconnect to database to reset mysql_handler</span>
    puts $log_pid &#34;re-connecting to database $db at $host&#34;
    set connStatus [<a name="::conn_to_db(1)"><a href="./mysqlLib.tcl.html#::conn_to_db_8">::conn_to_db</a></a> $host $db]
    puts $log_pid &#34;reconnect database $db at $host - status $connStatus&#34;
    puts &#34;reconnect database $db at $host - status $connStatus&#34;
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
