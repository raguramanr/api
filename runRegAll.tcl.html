<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>runRegAll.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#runRegAll.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>runRegAll.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="runRegAll.tcl-annot.html">annotations</a> | <a href="runRegAll.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>


load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]

source ./runRegAllLocal.tcl

;<span class="comment-line"># We pass regpcList because we need to source the runReg.cfg file before we</span>
;<span class="comment-line"># can determine this, thus we must get that information at run time.</span>
<strong><a name="::::regPrintUsage_10">proc <a href="runRegAll.tcl-annot.html#::::regPrintUsage">::::regPrintUsage</a></a></strong> {{regpcList &#34;&#34;}} {
    puts &#34;\r&#34; 
    puts &#34;usage: runRegAll.tcl  \[-status\] \[-cvsupdate\] \[-cfg &lt;cfgfile&gt;\]&#34;
    puts &#34;       \[-i386ImagePath &lt;imagePath&gt; \[-marinerImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-aspenImagePath &lt;imagePath&gt; \[-cougarImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-download &lt;yes|no&gt;\] \[-mailTo &lt;emailAddress&gt;\]  \[-include \&#34;module list\&#34;]&#34; 
    puts &#34;       \[-exclude \&#34;module list\&#34;] \[-platform &lt;platformName,index&gt;] \[-regpcs \&#34;regpc list\&#34;]&#34; 
    puts &#34;       \[-killxterm &lt;yes&gt;\] \[-obuild &lt;old build version&gt;\]&#34;
    puts &#34;       \[-force\] \[-help\]&#34;
    puts &#34;\r&#34;
    puts &#34;    -cvsupdate:       Execute cvs update on the automation directory of each&#34;
    puts &#34;                      regression PC&#34;
    puts &#34;    -status:          Execute ps on remote machines to see status&#34;
    puts &#34;                      To see status on a subset of regpcs, use&#34;
    puts &#34;                      i.e. -regpcs \&#34;BD1 Alpine\&#34; -status&#34;
<span class="comment-line">#    puts &#34;    -image:           Image to download. Format xxxbzz v711b23, v601b9, etc.&#34;</span>
    puts &#34;    -i386ImagePath    image path to i386 image. Format /tftp/bd10Ki386-11.0.0.16.xos&#34;
    puts &#34;    -marinerImagePath image path to mariner image. Format /tftp/bd10K-11.0.0.16.xos&#34;
    puts &#34;    -aspenImagePath image path to aspen image. Format /tftp/aspen-11.2.0.6.xos&#34;
    puts &#34;    -cougarImagePath image path to cougar image. Format /tftp/cougar-11.2.0.6.xos&#34;
    puts &#34;    -x480ImagePath image path to cougar image. Format /tftp/x480-15.6.1.4.xos&#34;
    puts &#34;    -x870ImagePath image path to onie image. Format /tftp/onie-15.6.1.4.xos&#34;
    puts &#34;    -NWIImagePath image path to cougar image. Format /tftp/NWI-15.6.1.4.xos&#34;
    puts &#34;    -cfg:           Config file to use in place of default runReg.cfg&#34;
    puts &#34;    -regpcs:        Regressions PC to run.  Predefined platforms in runReg.cfg&#34;
    puts &#34;                    i.e. $regpcList&#34;
    puts &#34;    -platform:      Specify a specific platform for a specific regpc.&#34;
    puts &#34;                    i.e. ALPINE,1 or BD1,2  Use -platform ? for valid entries&#34;
    puts &#34;    -exclude:       Modules to be excluded from testing.&#34;
    puts &#34;    -include:       Modules to be tested. The regression will only\
	    run those modules you specified&#34;    
    puts &#34;    -download       yes|no (yes)&#34;
    puts &#34;    -mailTo         Email address to send notification (sqaauto@extremenetworks.com)&#34;
    puts &#34;    -prep           yes|no (yes) Perform unconfig and def delete prior to running&#34;
     puts &#34;    -killxterm     yes|no (no). Kill xterm windows in all the regression PCs. If -regpcs are specified, only xterms running on that pc alone will be killed&#34;
    puts &#34;    -obuild:        Old build version REQUIRED for Upgrade/Downgrade runs (ie. 10.1.2.16)&#34;
    puts &#34;   -force           Kills the DUT sessions with terminal server \
          before staring the regression.&#34;
    puts &#34;    -help:          Prints this screen.&#34;
    puts &#34;\r&#34;
    puts &#34;NOTE: -regpcs and -platform are mutually exclusive as are -status and -cvsupdate&#34;

}


<strong><a name="::::regPrintValidPlatforms_55">proc <a href="runRegAll.tcl-annot.html#::::regPrintValidPlatforms">::::regPrintValidPlatforms</a></a></strong> {} {
    
    global regplatform

    set pList [list]

    if [info exists regplatform] {
	set pList [array names regplatform]
    }
    puts &#34;              VALID PLATFORM ENTRIES:&#34;
    set pList [lsort -ascii $pList]

    set header [format &#34;%-15s {%s}&#34; {PLATFORM ENTRY}  \
	    {platform blade cfg regType regSubType}]

    set sep [format &#34;%-15s %s&#34; {==============}  \
	    {=======================================}]

    puts $header
    puts $sep
    foreach plat $pList {
	set entry [format &#34;%-15s {%s}&#34; $plat $regplatform($plat)]
	puts $entry
    }

}


<span class="comment-line"># Send a mail message to a user</span>
<strong><a name="::::regSendMail_84">proc <a href="runRegAll.tcl-annot.html#::::regSendMail">::::regSendMail</a></a></strong> {user subject message } {

    set tempMsgFile   &#34;/tmp/runRegMsg.txt&#34;

    system &#34;echo $message &gt; $tempMsgFile&#34;
    system  &#34;mail -s \&#34;$subject\&#34; $user &lt; $tempMsgFile&#34;
    system &#34;rm -f $tempMsgFile&#34;
}

<span class="comment-line"># Get status of main.tcl and runall_monitor.tcl on a given machine.</span>
<strong><a name="::::regGetStatus_94">proc <a href="runRegAll.tcl-annot.html#::::regGetStatus">::::regGetStatus</a></a></strong> {} {
    
    global regLogin

    set i 0

    <span class="comment-line"># List all processes</span>
    set cmd &#34;ps -auxww\r&#34;
    send $cmd

    <span class="comment-line"># Keep matching until we hit the prompt. Put results int lineArray()</span>
    while 1 {
	expect {	    
            -re &#34;\[^\r]*\r\n&#34; {
		set lineArray($i) $expect_out(0,string)
		incr i
	    }
	    -re &#34;$regLogin@&#34; break

	    timeout break
	}
    }

    set i 0
    set taskKey &#34;runall_monitor&#34;
    <span class="comment-line"># Look for runall_monitor lines in linkArray()</span>
    while {$i &lt; [array size lineArray]}  {

	if [regexp &#34;(.*)($taskKey)(.*).tcl(.*)\r\n&#34;\
		$lineArray($i) ignore xtermCheck taskKeyMatch ignore param] {

	    <span class="comment-line"># Don't display lines spawned by xterm</span>
	    if { ! [regexp &#34;xterm&#34; $xtermCheck]} {
		puts &#34;$taskKeyMatch:  $param&#34;
	    }
	}
	incr i 1
    }

    set i 0
    set taskKey &#34;main&#34;
    <span class="comment-line"># Look for main lines in linkArray</span>
    while {$i &lt; [array size lineArray]}  {
	
	if [regexp &#34;(.*)($taskKey)(.*).tcl(.*)\r\n&#34;\
		$lineArray($i) ignore ignore taskKeyMatch ignore param] {

	    puts &#34;$taskKeyMatch: $param&#34;
	}
	incr i 1
    }
}

<span class="comment-line">#This is to kill the xterm windows</span>
<strong><a name="::::regKillXtermWindows_148">proc <a href="runRegAll.tcl-annot.html#::::regKillXtermWindows">::::regKillXtermWindows</a></a></strong> {} {

   global regLogin

   set i 0
   send &#34;ps -ef |grep xterm\r&#34;
   while 1 {
      expect {
         -re &#34;\[^\r]*\r\n&#34; {
            set lineArray($i) $expect_out(0,string)
            regexp {([0-9]+) *([0-9]+).*\-T.*} $lineArray($i) out out1 out2
            if { [info exists out2] } {
               puts &#34;killing xterm with pid $out2&#34;
               send &#34;kill -9 $out2\r&#34;
               unset out2
            }
            incr i
         }
         timeout break
      }
   }
   return 1
}




<strong><a name="::::regCvsUpdateAutomationDir_175">proc <a href="runRegAll.tcl-annot.html#::::regCvsUpdateAutomationDir">::::regCvsUpdateAutomationDir</a></a></strong> {} {
    
    global autoPath
    global regLogin

    send &#34;cd $autoPath\r&#34;
    expect &#34;$regLogin@&#34;
    
    ;<span class="comment-line"># NOTE: We update twice because CVS flakiness causes updates to sometimes fail.</span>
    ;<span class="comment-line">#       First update creates new directories and moves out locally modified files.</span>
    ;<span class="comment-line"># Create new dirs(d)/Remove empty dirs(P)/Overwrite locally modified(C)</span>
    send &#34;cvs update -dPC\r&#34;
    expect {
	-re &#34;authorization failed:.*$regLogin@&#34; {
	    return 0
	}
	-re &#34;Updating.*$regLogin@&#34; {
	    return 1
	}
    }
    ;<span class="comment-line"># Second update is a regular update.</span>
    send &#34;cvs update \r&#34;
    expect {
	-re &#34;authorization failed:.*$regLogin@&#34; {
	    return 0
	}
	-re &#34;Updating.*$regLogin@&#34; {
	    return 1
	}
    }
    return 1
}




<strong><a name="::::regValidateReachable_211">proc <a href="runRegAll.tcl-annot.html#::::regValidateReachable">::::regValidateReachable</a></a></strong> { ipaddr } {

    <span class="comment-line"># Validate the machine is reachable</span>
    spawn ping -q -c 2 $ipaddr
    expect {
	-re &#34;0 packets received&#34; {
	    puts &#34;  !!! 0 packets received&#34;
	    return 0
	}
	timeout {
	    puts &#34;  !!! Ping timeout&#34;
	    return 0
	}
    }
    return -1
}



<strong><a name="::::regTelnetLogin_230">proc <a href="runRegAll.tcl-annot.html#::::regTelnetLogin">::::regTelnetLogin</a></a></strong> { ipaddr regLogin regPassword } {

    global spawn_id

    set timeout 60

<span class="comment-line">#    puts &#34;About to telnet to $ipaddr&#34;</span>
    <span class="comment-line"># Telnet into machine and start the specified script.</span>
    spawn telnet $ipaddr

    expect {
	-re &#34;\[L|l]ogin:&#34; {}
	timeout {	    
	    <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Timeout $timeout sec waiting for login prompt.&#34;
	    return 0
	}
    }
    sleep 1
    send   &#34;$regLogin\r&#34;
    expect {
	-re &#34;\[P|p]assword:&#34; {}
	timeout {	    
	    <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Timeout $timeout sec waiting for password prompt.&#34;
	    return 0
	}
    }
    sleep 1
    send   &#34;$regPassword\r&#34;
    expect {
	-re &#34;Login incorrect&#34; {
	    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Login incorrect using $regLogin/$regPassword&#34;
	    return 0
	}
	-re &#34;$regLogin@&#34; {
	    ;<span class="comment-line"># Login successful...</span>
<span class="comment-line">#	    puts &#34;Successful telnet into $ipaddr&#34;</span>
	}   
        -re &#34;\\$ $&#34; {
	    ;<span class="comment-line"># Login successful...</span>
<span class="comment-line">#	    puts &#34;Successful telnet into $ipaddr&#34;</span>
	}   
    }
    
    return 1;
}


<span class="comment-line"># Validates the proper syntax for image name</span>
<span class="comment-line"># Namely xxxby  i.e. 710b34</span>
<strong><a name="::::regValidateImageName_279">proc <a href="runRegAll.tcl-annot.html#::::regValidateImageName">::::regValidateImageName</a></a></strong> {imageName} {

    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; imageName: $imageName &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#34;
    return [regexp {^bd10K[i386|]-[0-9]+.[0-9].[0-9].[0-9]+.xos$} $imageName]

}

<span class="comment-line"># This is to find the type of terminal server</span>
<strong><a name="::::getTermServerType_287">proc <a href="runRegAll.tcl-annot.html#::::getTermServerType">::::getTermServerType</a></a></strong> { <a name="::ip(1)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> } {
   set termType &#34;&#34;
   set pid [spawn telnet &#34;$ip&#34;]   
   send &#34;\r&#34;
   expect {
           -re &#34;login:&#34; { set termType &#34;PC&#34;
                          send &#34;\035&#34; } 
           -re &#34;.*&gt;&#34;    { set termType &#34;Xyplex&#34;
                          send &#34;\035&#34;} 
     }
    exec kill -9 $pid
    return $termType
}

<span class="comment-line"># This is to kill the DUT sessions with terminal server to avoid</span>
<span class="comment-line"># regression aborts due to test beds being left occupied.</span>
<strong><a name="::::clearDUTSessions_303">proc <a href="runRegAll.tcl-annot.html#::::clearDUTSessions">::::clearDUTSessions</a></a></strong> { ipaddress  portList} {
  set termSrvLogin &#34;autotest-sc&#34;
  set termSrvPasswd &#34;system&#34;
  set pcTermSrvLogin &#34;root&#34;
  set pcTermSrvPasswd &#34;extreme&#34;
  set pcTermSrvIp &#34;10.210.1.223&#34; 

  set termServerType [<a name="::getTermServerType(1)"><a href="./runRegAll.tcl.html#::getTermServerType_287">::getTermServerType</a></a> $ipaddress]

  if { $termServerType != &#34;PC&#34; } {
        puts &#34;Telnet to terminal server : $ipaddress&#34;
        puts &#34;Port to be disconneted: $portList&#34;
        set pid [spawn telnet &#34;$ipaddress&#34;]
        send &#34;\r&#34;
        expect -re &#34;.*&gt;&#34; { send &#34;$termSrvLogin\r&#34; }
        expect -re &#34;.*&gt;&#34; { send &#34;set priv 1\r&#34; }
        expect -nocase &#34;Password&gt;&#34; { send &#34;$termSrvPasswd\r&#34; }
        foreach port $portList {
                puts &#34;disconnecting port# $port&#34;
                send &#34;kill $port se 1\r&#34;
                send &#34;\r&#34;
                expect -re &#34;.*&gt;&#34;
        }
        send &#34;logout\r&#34;
        exec kill $pid
   } else { 
        <span class="comment-line">#if it is PC terminal server; the session killing is a different process.</span>
        set timeout 5
        set pid [spawn telnet $pcTermSrvIp]
        expect -re &#34;.*login:&#34; { send &#34;$pcTermSrvLogin\r&#34;}
        expect -nocase &#34;password:&#34; { send &#34;$pcTermSrvPasswd\r&#34; }
	expect &#34;.*&#34;
        foreach port $portList {
        	send &#34;lsof | grep ttyS$port\r&#34;
                while { $expect_out(0,string) !=&#34;&#34; } {
               	    expect {
                        -re &#34;\[^\r]*\r\n&#34; {
                             set line  $expect_out(0,string)
                             set key  &#34;(termnetd) *(\[0-9\]+).*(ttyS$port)&#34;
                             set ret [regexp $key $line out out1 out2]
                             if { $ret == 1 &amp;&amp; [info exists out2] } {
                                puts &#34;killing ttyS$port with pid $out2&#34;
                                send &#34;kill -9 $out2\r&#34;
                                unset out2
                             }
                        }
                        timeout break
                     }
                }
        }
        send &#34;\r&#34;
        send &#34;logout\r&#34;
        exec kill $pid
   }
}


<span class="comment-line">################################ MAIN SCRIPT ##################################</span>

<span class="comment-line"># Turn off user process display to avoid clutter</span>
log_user 1

source ./../Lib/mainLib.tcl

<a name="::::gen_index(1)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;./../Lib&#34;

source ../Lib/parse_args.tcl

set LIB_PATH ../Lib 
lappend auto_path $LIB_PATH


<span class="comment-line"># ------------------------------------------------------------------------------</span>
<span class="comment-line"># These 4 calls are REQUIRED for all sublevel libraries that use </span>
<span class="comment-line"># result_xxxx functions to work.</span>
<span class="comment-line"># TODO: Put all this in an resultLogInit{} routine!</span>
set resultDir &#34;RunRegAll_logs&#34;
if { ! [file isdirectory $resultDir] } {
    ;<span class="comment-line"># Create it!</span>
    file mkdir $resultDir
}
set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set fd_res [<a name="::open_result_file(1)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;runRegAll-[clock format [clock seconds] -format &#34;%I.%M%p&#34;]-[pid]&#34;]
<span class="comment-line"># ------------------------------------------------------------------------------</span>
global staggerDelay

set cvsupdateFlag 0
set statusFlag    0
set staggerDelay  5

set fullRegStart 1
set regpcRegStart 0
set platformRegStart 0
set shastaBuild 0
set forceFlag 0

<a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> runRegAll.tcl $argv {
    help &#34;&#34;
    force &#34;&#34;
    cvsupdate &#34;&#34;
    status &#34;&#34;
    i386ImagePath &#34;&#34;
    marinerImagePath &#34;&#34;
    aspenImagePath &#34;&#34;
    cougarImagePath &#34;&#34;
    x480ImagePath &#34;&#34;
    x870ImagePath &#34;&#34;
    NWIImagePath &#34;&#34;
    cfg &#34;&#34;
    regpcs &#34;&#34;
    platform &#34;&#34;
    include &#34;&#34;
    exclude &#34;&#34;
    download &#34;yes&#34;
    prep &#34;no&#34;
    killxterm &#34;no&#34;
    mailTo &#34;sqaauto@extremenetworks.com&#34;
    obuild &#34;&#34;
}

<span class="comment-line"># Check for minimum required parameter i.e. image name</span>

if { $i386ImagePath == &#34;&#34; &amp;&amp; $marinerImagePath == &#34;&#34; &amp;&amp; \
     $aspenImagePath == &#34;&#34; &amp;&amp; $cougarImagePath &amp;&amp; $x480ImagePath &amp;&amp; $NWIImagePath == &#34;&#34; } {

    <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! At least one image name should be provided !!!&#34;
    <a name="::regPrintUsage(1)"><a href="./runRegAll.tcl.html#::regPrintUsage_10">::regPrintUsage</a></a> [array names regpc]
    exit
    
}


<span class="comment-line">#If any of the following is specified, then it is assumed that it's not </span>
<span class="comment-line">#initial regression start. The DUT session cleanup should be initiated </span>
<span class="comment-line">#only for the initail full regression start.</span>

if { $cfg != &#34;&#34; || $regpcs != &#34;&#34; || $platform != &#34;&#34; || $include != &#34;&#34; \
   || $exclude != &#34;&#34; || $download != &#34;yes&#34; || $status !=&#34;&#34; || $cvsupdate !=&#34;&#34; \
   || $killxterm != &#34;no&#34; || [lsearch $argv &#34;-help&#34;] &gt; -1 } {
   
    set fullRegStart 0
}

if { $platform != &#34;&#34; } {
   set platformRegStart 1
}

if { $regpcs != &#34;&#34; } {
   set regpcRegStart 1
}

if { [lsearch $argv &#34;-force&#34;]  &gt; -1} {
        set forceFlag 1
} else {
        set forceFlag 0
}

<span class="comment-line"># Default config file</span>
set cfgFile ./runReg.cfg

if {$cfg != &#34;&#34;} {
    <span class="comment-line"># User defined cfg file passed from command line.</span>
    set cfgFile $cfg
}


<span class="comment-line"># Source config file that has Regression PC information</span>
if [file exists $cfgFile] {
    <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sourcing $cfgFile now&#34;
    catch {source $cfgFile} reason
} else {
    <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Configuration file $cfgFile not found !!!&#34;
    exit
}

<span class="comment-line"># Display usage if -help is passed</span>
if {[lsearch $argv &#34;-help&#34;]  &gt; -1} {
    <a name="::regPrintUsage(2)"><a href="./runRegAll.tcl.html#::regPrintUsage_10">::regPrintUsage</a></a> [array names regpc]
    exit
}

if {$platform == &#34;?&#34;} {
    <a name="::regPrintValidPlatforms(1)"><a href="./runRegAll.tcl.html#::regPrintValidPlatforms_55">::regPrintValidPlatforms</a></a>  ;<span class="comment-line"># Requires cfgFile be sourced before calling</span>
    exit
}

if {[lsearch $argv &#34;-status&#34;] &gt; -1} {
    set statusFlag 1
    log_user 0
}

if {[lsearch $argv &#34;-cvsupdate&#34;]  &gt; -1} {

    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;*******  EXECUTING CVS UPDATE ONLY  *******&#34;
    <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;CVS Update Target Dir: $autoPath&#34;
    set cvsupdateFlag 1
    log_user 1
}

if {!$cvsupdateFlag &amp;&amp; !$statusFlag} {

    if {$i386ImagePath != &#34;&#34;} {
        if {![file exists $i386ImagePath]} {
            puts &#34;ERROR: i386ImagePath: $i386ImagePath, doesn't exist&#34;
            exit
        }
    }

    if {$marinerImagePath != &#34;&#34;} {
        if {![file exists $marinerImagePath]} {
            puts &#34;ERROR: marinerImagePath: $marinerImagePath, doesn't exist&#34;
            exit
        }
    }

    if { $aspenImagePath != &#34;&#34; } {
        if {![file exists $aspenImagePath]} {
            puts &#34;ERROR: aspenImagePath: $aspenImagePath, doesn't exist&#34;
            exit
        }
    }

    
    if { $cougarImagePath != &#34;&#34; } {
        if {![file exists $cougarImagePath]} {
            puts &#34;ERROR: cougarImagePath: $cougarImagePath, doesn't exist&#34;
            exit
        }
       set shastaBuild 1 
    }

    if { $x480ImagePath != &#34;&#34; } {
        if {![file exists $x480ImagePath]} {
            puts &#34;ERROR: x480ImagePath: $x480ImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $x870ImagePath != &#34;&#34; } {
        if {![file exists $x870ImagePath]} {
            puts &#34;ERROR: x870ImagePath: $x870ImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $NWIImagePath != &#34;&#34; } {
        if {![file exists $NWIImagePath]} {
            puts &#34;ERROR: NWIImagePath: $NWIImagePath, doesn't exist&#34;
            exit
        }
    }

}

;<span class="comment-line"># User specified list of REG-PCs to use</span>
if {($platform == &#34;&#34;) &amp;&amp; ($regpcs != &#34;&#34;)} {
    
    set regpc_list [list]
    set validRegPcs [array names regpc]

    ;<span class="comment-line"># Make sure all entries are valid</span>
    foreach pc $regpcs {
	set pc [string toupper $pc]
	if {[lsearch -exact $validRegPcs $pc] == -1} {
	    <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;regpc: $pc not found.  Valid values are $validRegPcs&#34;
	    exit
	}
	lappend regpc_list regpc($pc)
    }
    ;<span class="comment-line"># All entries are valid. Build regpc_list</span>
    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NEW list: $regpc_list&#34;
}

;<span class="comment-line"># User specified platform</span>
if {$platform != &#34;&#34; } {

    if { $regpcs != &#34;&#34;} {
	<a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;WARNING: Platform $platform specified.  Ignoring -regpc $regpcs parameter.&#34;
    }

    if { ![info exists regplatform($platform)]} {
	<a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;ERROR: Invalid platform specified: $platform&#34;
	<a name="::regPrintValidPlatforms(2)"><a href="./runRegAll.tcl.html#::regPrintValidPlatforms_55">::regPrintValidPlatforms</a></a>
	exit
    }
    ;<span class="comment-line"># Save the specific platform we need</span>
    set regplatformTemp $regplatform($platform)

    ;<span class="comment-line"># Unset all the platforms</span>
    unset regplatform

    ;<span class="comment-line"># Create a single entry for the array</span>
    set regplatform($platform) $regplatformTemp
    
    <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Active Platform: $regplatform($platform)&#34;

    ;<span class="comment-line"># Create a single entry in regpc_list for this platform</span>
    set regplatformIndex [array names regplatform]

    regexp (.*),(.*) $regplatformIndex  ignore regpcName ignore
    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Active regpcName: $regpcName&#34;    

    ;<span class="comment-line"># reset list</span>
    set regpc_list [list]
    lappend regpc_list regpc($regpcName)

    set staggerDelay 0
}

set tempList &#34;&#34;
if { [string tolower $killxterm] == &#34;yes&#34;} {
   foreach pc $regpc_list {
       regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
       if { ! [info exists platformPC] } {
          <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
          continue
       }
       set name      [lindex [set $pc] 0]
       set ipaddr    [lindex [set $pc] 1]
       set display   [lindex [set $pc] 2]


       if { ! [<a name="::regValidateReachable(1)"><a href="./runRegAll.tcl.html#::regValidateReachable_211">::regValidateReachable</a></a> $ipaddr] } {
          <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;  !!! $name at $ipaddr is unreachable.&#34;
          continue;
       }

       if { ! [<a name="::regTelnetLogin(1)"><a href="./runRegAll.tcl.html#::regTelnetLogin_230">::regTelnetLogin</a></a> $ipaddr $regLogin $regPassword ] } {
          <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Failed to login to $name at $ipaddr&#34;
          continue
       }
       if { [lsearch $tempList $ipaddr] != -1 } {
           puts &#34;xterm windows already killed&#34;
           continue
       }
       <span class="comment-line"># Get the PID of the xterm windows and send SIGKILL signal</span>
       <a name="::regKillXtermWindows(1)"><a href="./runRegAll.tcl.html#::regKillXtermWindows_148">::regKillXtermWindows</a></a>
    }
    lappend tempList $ipaddr    
    puts  &#34;Xterm windows are removed&#34;
    exit
}
unset tempList

<span class="comment-line">#Clean up the DUT sessions.</span>

<span class="comment-line">#Check if this is shasta build or greater to start cougar reg.</span>
<span class="comment-line">#Take out the entry for cougar if not shahsta build.</span>
<span class="comment-line">#This will prevent starting cougar reg if the build &lt;shasta build</span>

if { $fullRegStart &amp;&amp; !$shastaBuild } {
    set tempList [list]
    foreach pc $regpc_list {
        if { [regexp -nocase &#34;cougar&#34; $pc] } {
            continue
        }
        lappend tempList $pc
    }
    set regpc_list [list]
    foreach pc $tempList {
      lappend regpc_list $pc
    } 
}

if { $fullRegStart } {
    foreach pc $term_regpc_list {
        if { !$shastaBuild  &amp;&amp; [regexp -nocase &#34;.*cougar.*&#34; $pc] ==1} {
             continue
        }
        set  termInfoList [set $pc]
        set len [llength $termInfoList]
        for {set tIndex 0; set pIndex 1 } { $tIndex &lt; $len &amp;&amp; $pIndex &lt; $len } \
            {incr tIndex 2; incr pIndex 2} {
             set termIp [lindex $termInfoList $tIndex]
             set pList  [lindex $termInfoList $pIndex] 
             <a name="::clearDUTSessions(1)"><a href="./runRegAll.tcl.html#::clearDUTSessions_303">::clearDUTSessions</a></a> $termIp $pList
        }
    }
} elseif { $regpcRegStart &amp;&amp; $forceFlag  } {
   set termInfoList $regpcTermServer($regpcs)
   set len [llength $termInfoList]
   for {set tIndex 0; set pIndex 1 } { $tIndex &lt; $len &amp;&amp; $pIndex &lt; $len } \
       {incr tIndex 2; incr pIndex 2} {
        set termIp [lindex $termInfoList $tIndex]
        set pList  [lindex $termInfoList $pIndex] 
        <a name="::clearDUTSessions(2)"><a href="./runRegAll.tcl.html#::clearDUTSessions_303">::clearDUTSessions</a></a> $termIp $pList
   }
} elseif { $platformRegStart &amp;&amp; $forceFlag } {
   set termInfoList $platformTermServer($platform)
   set len [llength $termInfoList]
   for {set tIndex 0; set pIndex 1 } { $tIndex &lt; $len &amp;&amp; $pIndex &lt; $len } \
       {incr tIndex 2; incr pIndex 2} {
        set termIp [lindex $termInfoList $tIndex]
        set pList  [lindex $termInfoList $pIndex] 
        <a name="::clearDUTSessions(3)"><a href="./runRegAll.tcl.html#::clearDUTSessions_303">::clearDUTSessions</a></a> $termIp $pList
   }
}  


;<span class="comment-line"># Prep for download of images</span>
if {!$cvsupdateFlag &amp;&amp; !$statusFlag } {
 
    if {($download == &#34;yes&#34;) &amp;&amp; ($prep == &#34;yes&#34;)} {
	
	<span class="comment-line"># This is done in 2 loops so we don't have to wait for the reboot from unconfig</span>
	<span class="comment-line"># before going to next platform</span>
	<a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;START UNCONFIG: [exec date]&#34;
	<span class="comment-line"># Go through and unconfig each platform</span>
	foreach pc $regpc_list {
	    regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
	    if { ! [info exists platformPC] } {
		<a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
		continue
	    }

	    <a name="::runRegAllLocalDoCommand(1)"><a href="./mysqlRunRegAllLocal.tcl.html#::runRegAllLocalDoCommand_333">::runRegAllLocalDoCommand</a></a> $platformPC &#34;unconfig&#34;
	}
	<a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;END UNCONFIG DELETE: [exec date]&#34;

	<span class="comment-line"># Wait 60 seconds for unconfig to complete</span>
	<a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 60

	<a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;START DEF DELETE: [exec date]&#34;
	<span class="comment-line"># Go through and def delete port all each platform</span>
	foreach pc $regpc_list {
	    regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
	    if { ! [info exists platformPC] } {
		<a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
		continue
	    }

	    <a name="::runRegAllLocalDoCommand(2)"><a href="./mysqlRunRegAllLocal.tcl.html#::runRegAllLocalDoCommand_333">::runRegAllLocalDoCommand</a></a> $platformPC &#34;defDelete&#34;
	}
	<a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;END DEF DELETE: [exec date]&#34;
   }

}


<span class="comment-line"># Walk through array and display data</span>
foreach pc $regpc_list {

    global autoPath
    global autoScriptPath

    regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
    if { ! [info exists platformPC] } {
	<a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
	continue
    }

    set name      [lindex [set $pc] 0]
    set ipaddr    [lindex [set $pc] 1]
    set display   [lindex [set $pc] 2]

    
    if { ! [<a name="::regValidateReachable(2)"><a href="./runRegAll.tcl.html#::regValidateReachable_211">::regValidateReachable</a></a> $ipaddr] } {
	<a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;  !!! $name at $ipaddr is unreachable.&#34;
	continue;
    }

    if { ! [<a name="::regTelnetLogin(2)"><a href="./runRegAll.tcl.html#::regTelnetLogin_230">::regTelnetLogin</a></a> $ipaddr $regLogin $regPassword ] } {
	<a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Failed to login to $name at $ipaddr&#34;
	continue
    }

    <span class="comment-line"># *Just* get the status on each reg machine.</span>
    if {$statusFlag} {
	puts &#34;\n**** Retrieving STATUS on $name at $ipaddr ****&#34;
	<a name="::regGetStatus(1)"><a href="./runRegAll.tcl.html#::regGetStatus_94">::regGetStatus</a></a>
	continue;
    }

    <span class="comment-line"># *Just* do a CVS Update</span>
    if {$cvsupdateFlag == 1} {
	<a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;**** CVS Update on $name at $ipaddr targetdir: $autoPath ****&#34;
	if {! [<a name="::regCvsUpdateAutomationDir(1)"><a href="./runRegAll.tcl.html#::regCvsUpdateAutomationDir_175">::regCvsUpdateAutomationDir</a></a>]} {
	    <a name="::result_error(16)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! FAILED TO UPDATE !!!&#34;
	}
	continue
    }

    <span class="comment-line"># At this point all commands are directed to telnet window on remote REG PC.</span>

    <span class="comment-line"># Go to directory where local script lives</span>
    send &#34;cd $autoScriptPath\r&#34;
    expect &#34;$regLogin@&#34;

    <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Starting regressions on $name at IP: $ipaddr DISPLAY:$display on [exec date]...&#34;

    if {[catch {flush $fd_res} reason]} {
	<a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR: flush $reason&#34;
    }

    <span class="comment-line"># Based on platform PC start xterms and run regressions</span>
    <a name="::runRegAllLocal(1)"><a href="./runRegAllLocal.tcl.html#::runRegAllLocal_3">::runRegAllLocal</a></a> $platformPC $display $i386ImagePath $marinerImagePath $aspenImagePath $cougarImagePath $x480ImagePath $x870ImagePath $NWIImagePath $include $exclude $download $mailTo $obuild

    sleep 2
    send &#34;logout\r&#34;
}

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
