#################################################################
# $RCSfile: swConf.tcl,v $ - SQA Library
#
# Copyright (c) 1999 by Extreme Networks Inc.
# 
# Revision control history
# ------------------------
# $Header: /export/cvsroot/automation/Lib/swConf.tcl,v 2.51.2.4.4.87.2.3 2010/10/07 08:46:42 umani Exp $
#
# Extreme Networks modification history
# -------------------------------------
# $Log: swConf.tcl,v $
# Revision 2.51.2.4.4.87.2.3  2010/10/07 08:46:42  umani
# proc get_DUTs_info modified for Stack
#
# Revision 2.51.2.4.4.87.2.3  2010/10/07 08:46:42  umani
# proc get_DUTs_info modified for Stack
#
# Revision 2.51.2.4.4.87.2.2  2010/09/29 11:50:10  umani
# Changed platform information to system type
#
# Revision 2.51.2.4.4.87.2.1  2010/09/23 09:52:21  umani
# Modified proc get_DUTs_info
#
# Revision 2.51.2.4.4.87  2010/01/11 10:22:31  nellinivasu
# Merged From Branch 'branch-dev_v12-4-rel1'
#
# Revision 2.51.2.4.4.86  2009/12/16 21:51:29  eyoung
# Fixed typo in GetPortIdInfoStd.
# Cleaned up indentation in GetPortIdInfoStd.
# Removed extra whitespace from file.
#
# Revision 2.51.2.4.4.85  2009/10/09 01:01:16  ghundertmark
# merge from branch add sysType
#
# Revision 2.51.2.4.4.84  2009/08/26 06:19:21  ghundertmark
# Merge from dev4-rel1 branch
#
# Revision 2.51.2.4.4.82.2.2  2009/08/26 06:16:44  ghundertmark
# init duts_info memorycard
#
# Revision 2.51.2.4.4.82.2.1  2009/07/07 22:37:09  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.51.2.4.4.82.2.4  2009/10/08 04:19:12  ghundertmark
# Add sysType variable to DUTs_info
#
# Revision 2.51.2.4.4.82.2.3  2009/10/05 18:33:55  jramarao
# GetPortIdInfoStd fixed for no ixia platform like bcm netlogin web
#
# Revision 2.51.2.4.4.82.2.2  2009/08/26 06:16:44  ghundertmark
# init duts_info memorycard
#
# Revision 2.51.2.4.4.82.2.1  2009/07/07 22:37:09  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.51.2.4.4.82.2.5  2009/12/16 21:57:14  eyoung
# Merge in changes from trunk-exos.
#
# Revision 2.51.2.4.4.86  2009/12/16 21:51:29  eyoung
# Fixed typo in GetPortIdInfoStd.
# Cleaned up indentation in GetPortIdInfoStd.
# Removed extra whitespace from file.
#
# Revision 2.51.2.4.4.85  2009/10/09 01:01:16  ghundertmark
# merge from branch add sysType
#
# Revision 2.51.2.4.4.84  2009/08/26 06:19:21  ghundertmark
# Merge from dev4-rel1 branch
#
# Revision 2.51.2.4.4.82.2.2  2009/08/26 06:16:44  ghundertmark
# init duts_info memorycard
#
# Revision 2.51.2.4.4.82.2.1  2009/07/07 22:37:09  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.51.2.4.4.82.2.4  2009/10/08 04:19:12  ghundertmark
# Add sysType variable to DUTs_info
#
# Revision 2.51.2.4.4.82.2.3  2009/10/05 18:33:55  jramarao
# GetPortIdInfoStd fixed for no ixia platform like bcm netlogin web
#
# Revision 2.51.2.4.4.82.2.2  2009/08/26 06:16:44  ghundertmark
# init duts_info memorycard
#
# Revision 2.51.2.4.4.82.2.1  2009/07/07 22:37:09  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.51.2.4.4.82  2009/07/01 10:55:48  nellinivasu
# Merged From Branch 'branch-dev_v12-1-rel4'
#
# Revision 2.51.2.4.4.81  2009/05/01 18:06:22  lagrawal
# merge from dev
#
# Revision 2.51.2.4.4.80  2009/04/14 00:42:52  lagrawal
# fixed merge issue clear fdb delay was twice
#
# Revision 2.51.2.4.4.79  2009/03/18 21:48:32  jramarao
# From branch-dev_v12-1-rel4
#
# Revision 2.51.2.4.4.78  2008/10/30 03:16:31  ghundertmark
# Add delay for fdb completion on pioneer
#
# Revision 2.51.2.4.4.77.2.3  2009/03/05 03:54:30  lagrawal
# added show version images
#
# Revision 2.51.2.4.4.77.2.2  2009/02/25 22:45:58  lagrawal
# added show fans detail
#
# Revision 2.51.2.4.4.77.2.1  2009/01/30 15:12:01  autotest-sc
# merge from branch-pioneer2_dev-v12-1-rel4
#
# Revision 2.51.2.4.4.77.6.4  2009/01/21 10:57:38  nellinivasu
# Pioneer global delays reduced.
#
# Revision 2.51.2.4.4.77.6.3  2009/01/13 20:34:15  ghundertmark
# Add MM check verse MSM check
#
# Revision 2.51.2.4.4.77.6.2  2009/01/07 22:50:19  jramarao
# show version detail added
#
# Revision 2.51.2.4.4.77.6.1  2008/11/28 05:10:34  jramarao
# merge from branch-pioneer_dev-v12-1-rel4
#
# Revision 2.51.2.4.4.77.2.5  2009/04/03 09:29:31  lagrawal
# merge from branch-pioneer2_dev-v12-1-rel4 to branch-dev_v12-1-rel4
#
# Revision 2.51.2.4.4.77.2.4  2009/03/31 23:36:18  lagrawal
# merge from branch-pioneer_dev-v12-1-rel4
#
# Revision 2.51.2.4.4.77  2008/08/05 03:44:10  lagrawal
# merge from branch-fixes_v12-1-rel0
#
# Revision 2.51.2.4.4.76.4.1  2008/07/25 23:02:01  lagrawal
# merged changes from branch-dev_v12-1-rel2 and trunk-exos. cmd cvs update -dj branch-dev_v12-1-rel2 automation
#
# Revision 2.51.2.4.4.76.8.1  2008/07/02 17:36:29  msubramanian
# Change for option to not reset ixia by setting ixiaNoReset in .cfg file.
#
# Revision 2.51.2.4.4.76  2008/05/15 20:21:23  eyoung
# Clear out parameterList after getting license level in get_DUTs_info.
#
# Revision 2.51.2.4.4.75  2008/04/15 05:09:55  djain
# code added for core with test case number
#
# Revision 2.51.2.4.4.74  2008/03/12 08:50:10  nellinivasu
# Added global forceSerialReboot in proc RunSetupScript
#
# Revision 2.51.2.4.4.73  2008/01/17 23:09:11  dsuk
# efence modifications
#
# Revision 2.51.2.4.4.72  2008/01/11 21:16:29  dsuk
# using SendACmd for efence
#
# Revision 2.51.2.4.4.71  2008/01/09 13:57:33  skumar
# Info exists efence
#
# Revision 2.51.2.4.4.70  2008/01/08 23:32:12  dsuk
# corrected handling of efence parameter
#
# Revision 2.51.2.4.4.69  2008/01/08 21:58:26  dsuk
# added support for ELECTRIC FENCE
#
# Revision 2.51.2.4.4.68  2008/01/07 02:04:28  ghundertmark
# Alter getPortIdInfo to use portmapping lists
#
# Revision 2.51.2.4.4.67  2007/12/19 20:09:26  ghundertmark
# Change OID discovery for slots.  Add force Serial reboot
#
# Revision 2.51.2.4.4.66  2007/12/10 18:39:41  ghundertmark
# Add double check for save mode for getbcominfostd.  For calls not made from main.tcl
#
# Revision 2.51.2.4.4.65  2007/12/07 02:33:34  skumar
# Do not first login if downloadimage to avoid issues w/ corrupted images
#
# Revision 2.51.2.4.4.64  2007/12/04 18:03:58  ghundertmark
# Correct close quote in the fast file
#
# Revision 2.51.2.4.4.63  2007/12/04 15:57:07  ghundertmark
# Add code to save bcom globals to fast
#
# Revision 2.51.2.4.4.62  2007/11/09 21:01:28  jramarao
# changes merged from branch to trunk
#
# Revision 2.51.2.4.4.59.4.2  2007/10/26 12:22:47  pananthasubramanian
# adapted proc get_DUTs_info and added new proc get_DUTs_info_eware to support
# eware duts in the automation infrastructure
#
# Revision 2.51.2.4.4.59.4.1  2007/08/20 22:58:54  djain
# Merged changes from trunk-exos Lib
#
# Revision 2.51.2.4.4.61  2007/07/11 10:43:50  gramkumar
# License information is added to System information
#
# Revision 2.51.2.4.4.60  2007/06/26 03:59:55  pananthasubramanian
# updated proc RunSetupScript to support generic DUT topology
#
# Revision 2.51.2.4.4.59  2007/05/03 17:07:03  ghundertmark
# fix GetPortIdInfoStd to avoid setting none existent portIds
#
# Revision 2.51.2.4.4.58  2007/04/30 19:12:08  ghundertmark
# GetPortIdInfoStd - Adjust rates to ensure randomSize rates can be handled.
#
# Revision 2.51.2.4.4.57  2007/04/30 11:38:10  ghundertmark
# Add GetBcomPortInfoStd to setup PortID_Info global variables
#
# Revision 2.51.2.4.4.56  2007/04/28 00:48:39  igokhale
# added disable clipaging at start of get_DUTs_info
#
# Revision 2.51.2.4.4.55  2007/04/12 01:17:07  schawla
# Modified func DutSlotNumPorts to take the ports usinf show slot for stacking testbed.
#
# Revision 2.51.2.4.4.54  2007/03/30 19:26:09  igokhale
# removed keyword MSM from some checks/messages
#
# Revision 2.51.2.4.4.53  2007/03/29 00:29:18  djain
# Changes made in get_DUTs_info for stacking show version
#
# Revision 2.51.2.4.4.52  2007/03/15 22:10:38  jramarao
# "unconfig sw all" changed to "unconfig sw"
#
# Revision 2.51.2.4.4.51  2007/03/01 18:25:37  igokhale
# removed word MSM from "Error: This command can only be executed on Master MSM" error message
#
# Revision 2.51.2.4.4.50  2007/02/21 01:42:47  achilukuri
# Merging  Q3FY07-11.6-Phase-2
#
# Revision 2.51.2.4.4.49  2007/01/03 22:02:47  skumar
# flock ixTclHal to avoid race condition w/ multiple package req
#
# Revision 2.51.2.4.4.48.2.1  2007/02/15 19:32:56  djain
# Changes made for optimising get_DUTs_info procedure
#
# Revision 2.51.2.4.4.48  2006/12/05 22:51:11  igokhale
# added EnableRegRouterMgmtLinks regardless of whether or not unconfig switch all was done
#
# Revision 2.51.2.4.4.47  2006/11/20 19:17:26  skumar
# Fix generic filename as conflicts when multiple instances running
#
# Revision 2.51.2.4.4.46  2006/11/17 22:49:25  skumar
# Fix the return status of child from parent to stop in case of error
#
# Revision 2.51.2.4.4.45  2006/11/11 00:06:22  skumar
# Stacking testbed support
#
# Revision 2.51.2.4.4.44  2006/10/13 18:05:44  skumar
# Added -nocase for y/N
#
# Revision 2.51.2.4.4.43  2006/06/30 22:35:36  ghundertmark
# Q4FY06 Release commit
#
# Revision 2.51.2.4.4.42  2006/06/15 15:14:32  eyoung
# Added support to get_DUTs_info for new "ExtremeXOS" software name.
#
# Revision 2.51.2.4.4.41  2006/06/09 17:36:22  igokhale
# replaced sleep 2 with puts after logging out of regrouter
#
# Revision 2.51.2.4.4.40  2006/06/09 00:23:25  igokhale
# Corrected login to regrouter errorchecking; added 2s delay when logging out from regrouter; added login to all dut's verification before the disable port on regrouter
#
# Revision 2.51.2.4.4.39  2006/06/06 23:59:07  igokhale
# dont disable regrouter links if not needed (Called from LoadImage or unconfig switch all is not part of setup)
#
# Revision 2.51.2.4.4.38  2006/06/06 21:51:57  igokhale
# renamed all functions to Parallel/Serial(RunSetup), added verify for ports re-enabled
#
# Revision 2.51.2.4.4.37  2006/06/02 01:44:18  igokhale
# Corrections for CLI support
#
# Revision 2.51.2.4.4.36  2006/05/31 20:35:55  igokhale
# simplified 2/5 node setup determination
#
# Revision 2.51.2.4.4.35  2006/05/31 17:58:30  igokhale
# more correction
#
# Revision 2.51.2.4.4.34  2006/05/31 17:56:15  igokhale
# fixed problem with numDUT
#
# Revision 2.51.2.4.4.33  2006/05/31 01:46:58  igokhale
# merged from branch: changes to support parallel unconfig and also CLI, Scalability, IxiaScriptmate regtypes in mysql
#
# Revision 2.51.2.4.4.32.4.3  2006/05/24 18:41:51  igokhale
# changes for cli, scalability, ixia tests
#
# Revision 2.51.2.4.4.32.4.1  2006/05/01 19:20:03  igokhale
# changes for parallel unconfig sw
#
# Revision 2.51.2.4.4.32.4.3  2006/05/24 18:41:51  igokhale
# changes for cli, scalability, ixia tests
#
# Revision 2.51.2.4.4.32.4.1  2006/05/01 19:20:03  igokhale
# changes for parallel unconfig sw
#
# Revision 2.51.2.4.4.32  2005/12/21 22:24:18  smohanty
# Commit for Release 12
#
# Revision 2.51.2.4.4.31  2005/10/08 00:56:46  skumar
# CheckOperational in auto even if no "unc.* sw.* a.*"
#
# Revision 2.51.2.4.4.30.4.2  2005/10/14 01:29:40  agoyal
# added i386Chassis to get the blade number
#
# Revision 2.51.2.4.4.30.4.1  2005/10/05 00:41:34  igokhale
# corrected spacing
#
# Revision 2.51.2.4.4.30  2005/09/09 00:38:59  skumar
# Put condition not to run show slot in stackable
#
# Revision 2.51.2.4.4.29  2005/08/30 03:57:44  ghundertmark
# Fix numSlots. Add DUTSlot funcions
#
# Revision 2.51.2.4.4.28  2005/06/16 01:40:03  skumar
# New product defs at Rel10
#
# Revision 2.51.2.4.4.27  2005/05/04 19:17:23  skumar
# Dump imageSel into init for DUTs_info
#
# Revision 2.51.2.4.4.26  2005/05/02 20:07:37  alim
# Login changes
#
# Revision 2.51.2.4.4.25  2005/03/30 20:32:21  skumar
# Aspen name changes as merged from exos-br-9
#
# Revision 2.51.2.4.4.24.2.1  2005/03/30 18:37:15  skumar
# Aspen name change specific changes
#
# Revision 2.51.2.4.4.24  2005/02/16 01:30:04  skumar
# Added Slot qualifier for slot hw type
#
# Revision 2.51.2.4.4.23  2005/02/14 17:38:46  eyoung
# Fixed references to gloabl variables in clearFdb function.
#
# Revision 2.51.2.4.4.22  2005/02/14 17:36:38  eyoung
# Fixed reference to unkown variable in clearFdb function.
#
# Revision 2.51.2.4.4.21  2005/02/14 17:26:30  eyoung
# Updated "clear fdb" delay checking for SummitX450 platform.
#
# Revision 2.51.2.4.4.20  2005/01/18 21:23:53  skumar
# Commited severe 1 issue after o/p changed on cougar in sh version
#
# Revision 2.51.2.4.4.19  2004/12/20 19:25:14  skumar
# Bootrom based bootup for loadimage
#
# Revision 2.51.2.4.4.18  2004/12/10 00:05:31  skumar
# Check for summit for summitx450
#
# Revision 2.51.2.4.4.17  2004/12/06 21:43:42  skumar
# Added in global, imageBooted in DUTs_info
#
# Revision 2.51.2.4.4.16  2004/11/13 00:03:31  skumar
# Cleanup "show default" and rerundant "show slot"
#
# Revision 2.51.2.4.4.15  2004/10/19 23:21:22  mverma
# Added snmp support
#
# Revision 2.51.2.4.4.14  2004/10/15 18:32:12  skumar
# Put non-default vlan code for checkConnection
#
# Revision 2.51.2.4.4.13  2004/10/15 02:33:43  skumar
# Core file capture, ixiaVlan in checkConnection
#
# Revision 2.51.2.4.4.12.2.1  2004/10/15 00:54:43  skumar
# coredump on memorycard starting 11.1.0.21
#
# Revision 2.51.2.4.4.12  2004/09/01 01:22:20  skumar
# Changes to support patch builds in exos
#
# Revision 2.51.2.4.4.11  2004/05/22 01:13:36  skumar
# Call Login with no CheckOperational in RunSetupScript
#
# Revision 2.51.2.4.4.10  2004/04/26 22:19:32  skumar
# Fix code for MSM issue w.r.t PC
#
# Revision 2.51.2.4.4.9  2004/04/25 20:52:55  skumar
# Fix backup msm issue based on at in RunSetupScript
#
# Revision 2.51.2.4.4.8  2004/04/16 17:56:45  skumar
# Check for master msm or else return error in RunSetupScript
#
# Revision 2.51.2.4.4.7  2004/04/01 21:57:03  skumar
# Commit as part of release5
#
# Revision 2.51.2.4.4.6  2004/03/16 21:00:46  cshaw
# primary version: to primary ver:, same for secondary
#
# Revision 2.51.2.4.4.5  2004/03/11 20:03:19  dchan
# add unconfig switch all support
#
# Revision 2.51.2.4.4.4.2.2  2004/03/15 20:59:52  skumar
# Power cycle the DUT in case of error on unc sw al
#
# Revision 2.51.2.4.4.4.2.1  2004/03/09 06:50:12  vkanagasabapathy
# Support for Unconfig Switch
#
# Revision 2.51.2.4.4.4  2003/12/03 03:48:02  skumar
# Get the correct version, use Login after RunSetupScript.
#
# Revision 2.51.2.4.4.3  2003/11/24 06:02:13  dchan
# trunk-exos release 3
#
# Revision 2.51.2.4.4.2.2.4  2003/11/14 22:37:13  skumar
# Change the relMaster as of b86 to be index 7
#
# Revision 2.51.2.4.4.2.2.3  2003/11/13 21:57:46  skumar
# Add verTime into fast file for dev option in main.tcl
#
# Revision 2.51.2.4.4.2.2.2  2003/11/10 18:40:34  skumar
# Get the correct builtBy info
#
# Revision 2.51.2.4.4.2.2.1  2003/10/28 17:57:31  skumar
# Fill in arrays properly as of b79
#
# Revision 2.51.2.4.4.2  2003/10/06 17:16:20  dchan
# trunk-exos release 2
#
# Revision 2.51.2.4.4.1.2.1  2003/09/24 18:39:22  skumar
# Fixes to support correct reporting for exos versions
#
# Revision 2.51.2.4.2.1  2003/06/23 21:28:46  cshaw
# Merged in EW trunk
#
# Revision 2.67  2003/05/19 21:32:41  eyoung
# Added support for ASMGM2X NP card.  Fixed CVS log macro.
#
# Revision 2.45  2002/05/10 16:25:34  skumar
# Put no merge str for no merge image.
#
# Revision 2.44  2002/05/08 01:04:49  skumar
# Hardware Type check for BT,GZ as well apart from BD, alpine.
#
# Revision 2.43  2002/04/30 19:24:28  skumar
# Avoid cleanup for tcl8.5 discrepency, closes all file handles.
#
# Revision 2.42  2002/04/26 19:55:51  skumar
# Remove MSM from version string, put _ in merge str in DUTs_info
#
# Revision 2.41  2002/04/22 18:00:09  skumar
# Change get_dut_info to include RTP related branch etc. info.
#
# Revision 2.40  2002/04/17 20:54:31  ecooper
# smallIxiaInit:  added IxiaPortsInit and took out a variable not being called.
#
# Revision 2.39  2002/04/11 00:24:07  skumar
# Check slot PXM for sleep 100 secs on bd/bt after unconfig.
#
# Revision 2.38  2002/03/29 20:00:08  skumar
# Put check for ixiaCh1 for cli like modules.
#
# Revision 2.37  2002/03/28 22:40:02  skumar
# Add bladeType into fastInit file in DUTs_info, portMappingList too.
#
# Revision 2.36  2002/03/28 18:20:07  skumar
# Remove EXTREME_PLATFORM, add fast global var.
#
# Revision 2.35  2002/03/27 00:23:28  Autotest
# Put sleep to help BT on "unconf sw all"
#
# Revision 2.34  2002/03/22 20:20:46  tquach
# Change for new cli
#
# Revision 2.33  2002/03/08 00:15:44  aleu
# fix hardwareType checking on Summit48si (should be new_gen)
#
# Revision 2.32  2002/03/07 02:24:00  aleu
# change info.txt filename to be a variable $infoFilename
#
# Revision 2.31  2002/03/05 18:23:05  skumar
# Add BT support, write report dir with BT keyword.
#
# Revision 2.30  2002/02/12 19:03:40  skumar
# Put platform in DUTs_info diff for Gz and BD after same name MSM64.
#
# Revision 2.29  2002/01/17 17:56:18  Autotest
# Account for Non-bd systems
#
# Revision 2.28  2002/01/10 03:22:04  tquach
# New CLI change from Thanh
#
# Revision 2.27  2001/12/27 02:10:03  tquach
# Add blade type
#
# Revision 2.26  2001/07/22 21:22:46  tquach
# Add Alpine platform
#
# Revision 2.25  2001/07/06 01:07:10  aleu
# add priImage & secImage
#
# Revision 2.24  2001/06/15 19:32:16  aleu
# add DUTs_info(DUT$i, RelMaster)
#
# Revision 2.23  2001/04/18 00:55:17  Autotest
# Add godzilla platform
#
# Revision 2.22  2001/03/03 22:20:40  sphomsakha
# Change summit back to 20 second
#
# Revision 2.21  2001/02/16 18:57:57  sphomsakha
# Add Ericsson switch
#
# Revision 2.20  2001/01/12 00:37:19  tnguyen
# Fix so it can detect old and new hardward properly
#
# Revision 2.19  2000/12/07 20:22:36  tnguyen
# Add some wait time for summit platform
#
# Revision 2.18  2000/11/03 20:05:57  tnguyen
# Convert mac to upper case
#
# Revision 2.17  2000/09/12 22:52:28  tnguyen
# Add logic to detect hardware type
#
# Revision 2.16  2000/08/04 22:25:35  tnguyen
# Global change of commonly used funtions to conform with new conventions
#
# Revision 2.15  2000/08/04 15:58:53  tnguyen
# Replace exit with error function so we can catch the errors
#
# Revision 2.14  2000/07/26 18:45:02  tnguyen
# Move open result file so it can save all the interation, instead just the last one
#
# Revision 2.13  2000/06/29 23:04:36  tnguyen
# Just sleep for 60 seconds
#
# Revision 2.12  2000/06/21 16:26:44  tnguyen
# Add 2 minutes delay for BD after reboot to wait for ports
#
# Revision 2.11  2000/05/09 18:43:50  jlequang
# Inc Thanh correction to read image version when MSM-A or B is
# selected
#
# Revision 2.9  2000/04/07 20:47:53  tnguyen
# Remove sleep 20 command after reboot
#
# Revision 2.8  2000/04/07 00:23:49  tnguyen
# Various modifications to the whole project in Lib, L2 and L3.  Commit changes for all these folders at the same time.
#
# Revision 2.7  2000/03/07 17:50:20  jlequang
# Added proc DUT_BootROM_version {} to
# extract BootROM ver. and added it to find_all_DUT_version
# to be printed on the report.
#
# Revision 2.6  2000/02/07 23:52:21  jfan
# Add for global variable "version"
#
# Revision 2.5  2000/01/07 00:03:08  jfan
# Add for report file
#
# Revision 2.4  1999/10/27 21:59:54  jfan
# Replace "Input" dir to "Exp" dir.  Replace "Tmp\in_xxx" to "Tmp_tmp_xxx"
#
# Revision 2.3  1999/09/27 22:31:44  jfan
# Use result_debug, result_ok & result_error for messages
#
# Revision 2.2  1999/08/10 18:18:44  jfan
# Added procedure findDutMac
#
# Revision 2.1  1999/07/23 14:50:32  aedem
# Merge for 2.0
#
# Revision 1.1.1.1.2.2  1999/07/23 18:40:15  aedem
# Updated to use the new result formatting functions
#
# Revision 1.1.1.1.2.1  1999/06/30 15:16:12  aedem
# Updated for Linux and Ixia 2.0 Beta
#
# Revision 1.1.1.1  1999/06/25 17:53:46  jfan
# Initial import.
#
#
##################################################################

#load {expect52.dll}
set auto_path [linsert $auto_path 0 . ]

proc RunSetupScript {{connectList "0.0.0.0"} {setupScriptList ""} {args} } {

    parse_args RunSetupScript $args {
	at "main"  ;# location of script run "download" for download file section 
	dut 1     ;# dut supplied when called from download
    }

    global spawn_id
    global in
    global POWERCYCLE_DUT
    global forceSerialReboot
    global numDUT
    for {set i 1} {$i<=$numDUT} {incr i} {
       global DUT($i)_CONNECT
    }
    global switchPort2DefaultRouter
    global defaultRouter
    global regRouterIPAddr

    set in $at
    for {set i 1} {$i<= $numDUT} {incr i} {
       lappend dutList $i
    }

    if { [info exists forceSerialReboot] && $forceSerialReboot == 1} {
        result_debug "Force serial set in cfg file; Do Serial Setup Script"
        set runSetupRetVal [DoSerialRunSetup $dutList $connectList $setupScriptList $at $dut]
        return $runSetupRetVal
    }

    if { ([regexp -nocase "mgmt" $switchPort2DefaultRouter]) } {
	result_debug "network port is mgmt; run setup script parallely"
	set runSetupRetVal [DoParallelRunSetup $dutList $connectList $setupScriptList $at $dut]
	return $runSetupRetVal
    }

    if { ![info exists regRouterIPAddr] } {
	result_debug "regRouterIPAddr not defined; Do Serial Setup Script"
	set runSetupRetVal [DoSerialRunSetup $dutList $connectList $setupScriptList $at $dut]
	return $runSetupRetVal
    } else {

	# First try to login to each DUT to make sure that its even possible
	# If not possible, no need to proceed further
	# Only "need" this here because this is where we do the disable port on regrouter...
	# We dont want situation where regrouter ports are disabled and scripts abort on login,
	# leaving the ports in disabled state...
	if { [info exists regRouterIPAddr] } {
	    foreach dutnumber $dutList {
		set DUTName [format %s%d DUT $dutnumber]
		global ${DUTName}_CONNECT
		
		if { [Login [set ${DUTName}_CONNECT] -CheckOperational 0 -masterCheck 0] != 1 } {
		    result_error "Could not login to DUT$dutnumber [set ${DUTName}_CONNECT]"
		    return "Error"
		}
	    }
	}

	result_debug "network port is on I/O blade; try to disable switchPort2DefaultRouter links"

	if { $regRouterIPAddr == $defaultRouter } {
	    result_error "FATAL ERROR: regRouterIPAddr cannot be same as defaultRouter IP ($defaultRouter). Check cfg file."
	    return "REGROUTER_FAILED"
	}

	set unconfigSwAllFound 0
	if { [string tolower $at] != "download" } {
	    # Not called from LoadImage
	    # (if it was, there is no need to disable mgmt links, because that does not do unconfig sw all anyway)
	    foreach setupScript $setupScriptList {
		foreach command $setupScript {
		    if  { [string match "unc* sw*" $command] == 1 } {
			# Do the disable/enable port and parallel SetupScript
			set unconfigSwAllFound 1
			break
		    }
		}
		if { $unconfigSwAllFound } {
		    # No need to check any further... disable/enable regRouter ports required.
		    break
		}
	    }
	}
	if { $unconfigSwAllFound } {
	    set portList [DisableRegRouterMgmtLinks]
	} else {
	    set portList "NotNeeded"
	}

	if { $portList == "Error" } {
	    result_debug "Could not disable ports on regRouter; run SetupScript serially"
	    set runSetupRetVal [DoSerialRunSetup $dutList $connectList $setupScriptList $at $dut]
	} elseif { $portList == "NotNeeded" } {
	    result_debug "Disabling regRouter ports not required; run SetupScript parallely"
	    set runSetupRetVal [DoParallelRunSetup $dutList $connectList $setupScriptList $at $dut]
	} else {
	    result_debug "regRouter ports disabled successfully; run SetupScript parallely"
	    set runSetupRetVal [DoParallelRunSetup $dutList $connectList $setupScriptList $at $dut]
	}

	if {0} {
	    if { $unconfigSwAllFound } {
		set retVal [EnableRegRouterMgmtLinks $portList]
	    } else {
		set retVal "NotNeeded"
	    }
	}
	if { $portList == "NotNeeded" } {
	    global regRouterMGMTPorts
	    set portList [join $regRouterMGMTPorts ","]
	}
	set retVal [EnableRegRouterMgmtLinks $portList]

	if { ($portList != "Error") && ($portList != "NotNeeded") && ($retVal == "Error") } {
	    # If disable port was successful and enable port was not successful
	    
	    result_error "FATAL ERROR: Could not re-enable the ports on the RegRouter."
	    return "REGROUTER_FAILED"
	}
    }
    return $runSetupRetVal
}

proc DisableRegRouterMgmtLinks { } {
    global regRouterIPAddr
    global regRouterMGMTPorts
    global regRouterLogin
    global regRouterPassword

    report_start_test "Disable links on Reg Router before unconfig all DUT's"

    if { [Login $regRouterIPAddr -userid $regRouterLogin -passwd $regRouterPassword -CheckOperational 0] != 1 } {
	result_error "Could not login to regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    }

    #In case of any extra whitespace between the portnumbers....
    set portList [split $regRouterMGMTPorts]
    foreach portnum $portList {
	if { $portnum == "" } {
	    continue
	}
	lappend pList $portnum
    }
    set portList [join $pList ","]

    if { [regexp -nocase "illegal" [CheckCmdLegal "disable port $portList"]] } {
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    } else {
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return $portList
    }
}

proc EnableRegRouterMgmtLinks { portList } {
    global regRouterIPAddr
    global regRouterLogin
    global regRouterPassword

    report_start_test "Re-enable links on Reg Router after unconfig all DUT's"

    if { [Login $regRouterIPAddr -userid $regRouterLogin -passwd $regRouterPassword -CheckOperational 0] != 1 } {
	result_error "Could not login to regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    }

    if { [regexp -nocase "illegal" [CheckCmdLegal "enable port $portList"]] } {
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    } else {
	# Verify ports are now in enabled state
	foreach portNum [split $portList ","] {
	    lappend parameterList "{^ *$portNum .*E } exist"
	}
	if { [CheckKeyValue "show port $portList info" $parameterList \
		-comment "Verifying all ports re-enabled on regRouter $regRouterIPAddr"] == "error" } {

	    # Disable port was successful and enable port was not successful
	    
	    logout
	    # --- use it for delay without using sleep
	    puts "Logged out of regrouter $regRouterIPAddr"
	    report_end_test
	    result_error "FATAL ERROR: Could not re-enable the ports on the RegRouter."
	    return "Error"
	}
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return $portList
    }
}

proc DoParallelRunSetup { dutList connectList setupScriptList at dut } {

    set pid [pid]


    package require Tclx

    foreach dutnumber $dutList {
	
	# Need to login once before the child processes are forked, 
	# because spawn_id from parent is used later in get_DUTs_info
	set DUTName [format %s%d DUT $dutnumber]
	global ${DUTName}_CONNECT
	if {![regexp -nocase "download" $at] } {
	   Login [set ${DUTName}_CONNECT] -CheckOperational 0
        }
	set sec [clock seconds]
	lappend childPids [fork]
	after 1000 ;# required to avoid children getting the same tmp file sometimes being too fast
	if {[lindex $childPids [expr $dutnumber-1]]} {
	    if {$dutnumber==[llength $dutList]} {
		set co 1
		foreach childPid $childPids {
		    result_debug "Parent now waiting for child # $co with pid $childPid"
                    set childRetCode  [wait $childPid]
		    if {![regexp -nocase "EXIT 0" $childRetCode]} {    ;# parent waits here for child to complete
                       result_debug "Now child returned with pid $childPid with $childRetCode status"
                       return -1
                    } else {
                       result_debug "Now child returned with pid $childPid"
                       incr co
                    }
		}
	    }
	} else {
	    result_debug "child # $dutnumber enters with pid [pid]"
	    set connect [lindex $connectList [expr $dutnumber-1]]
	    set setupScript [lindex $setupScriptList [expr $dutnumber-1]]
	    
	    if {[RunSetupScript_Single $connect $setupScript -at $at -dut $dutnumber]==-1} {
		return -1
	    }
	    exit   ;# Child exits here, returns back to the waiting parent
	    # end of fork construct
	}
    }
            exSleep 2 ;# needed to avoid race condition in consoles
}

proc DoSerialRunSetup  { dutList connectList setupScriptList at dut } {
    result_debug "Could not disable ports on regRouter; run unconfig sequentially"
    foreach dutnumber $dutList {
	set connect [lindex $connectList [expr $dutnumber-1]]
	set setupScript [lindex $setupScriptList [expr $dutnumber-1]]	
	if {[RunSetupScript_Single $connect $setupScript -at $at -dut $dutnumber]==-1} {
	    if { [regexp -nocase "download" $at] } {
		# called from LoadImage; return dutnum
		return "$dutnumber-1"
	    } else {
		return -1
	    }
	}
    }
}

proc RunSetupScript_Single {{connect "0.0.0.0"} {setupScript ""} {args} } {
    global spawn_id

    parse_args RunSetupScript $args {
	at "main"  ;# location of script run "download" for download file section 
	dut 1     ;# dut supplied when called from download
    }
    global in
    global POWERCYCLE_DUT
    set in $at
    if {$in=="download"} {
	if {[info exists POWERCYCLE_DUT($dut)]} {
	    global DUT${dut}_TYPE
	    if {([info exists DUT${dut}_TYPE] && [set DUT${dut}_TYPE]!="PC") || ![info exists DUT${dut}_TYPE]} {
		
		if {[powerCycleToBootRom $dut]=="ok"} {
		    result_debug "Wait for 60 secs for rebooted DUT to come up..."
		    exSleep 60
		    Login $connect
		    set output [CheckOperational]
		    if { $output == 0 } {
			result_error "Some slots not operational"
			error "Some slots not operational"
		    }
		}
	    }
	}
    }

    # Do not checkOperational as unc first
    if {[Login $connect -CheckOperational 0] != 1} {   
	result_error "login failed " 
	return -1   ;# Error during login
    }

    foreach command $setupScript {
	if { ([string match "unc* sw*" $command] == 1) \
		&& ([string tolower $at] != "download") } {
	    if {[UnconfigSwAll -initial_unconfig yes] == 0 } {
		result_error "Unconfig sw all failed" 
		return -1
	    }
	} elseif { ([string match "unc* sw*" $command] == 1) } {
	    puts "Skipping Unconfig Switch for Download" 
	} else {
	    set buf [SendACmd $command]
	    set backupStr "Error: This command can only be executed on Master"
	    if {[regexp -nocase $backupStr $buf]} {
		if {[string tolower $at] == "download"} {
		    result_debug "Backup encountered"
		} else {
		    result_error "Backup encountered, aborting"
		    return -1
		}
	    }
	}
    }
}


################################################################## 
# Procedure Name: SaveAndReboot
#   
# Description: Performs save/reboot to the current DUT
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              SaveAndReboot
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc SaveAndReboot { } {


   result_debug "****Save and reboot.****"
   send "save\r"
   expect "database?"
   send "y\r"
   expect "#"
   send "reboot\n"
   expect -nocase "(y*n*)"
   send "y\r"
   expect "login:"
   send "admin\r"
   expect "password:"
   send "\r"
   expect "#"


}

################################################################## 
# Procedure Name: clearFdb
#   
# Description: Performs clear fdb on the current DUT, retained for historical reasons
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              clearFdb
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc clearFdb {fd} {
   global DUTs_info;
   global whichDutNow;

   result_debug "--- clear fdb";
   send "clear fdb\r";

   # For Aspen and Cougar platform delay 5 seconds to sync FDB cache on MSM with HW deleted FDBs on IO module.
   global bcmPlatform
   if {[regexp -nocase $bcmPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
      result_debug "Sleeping 5s awaiting clear fdb completion";
      exSleep 5;
   }

   expect "#";

   global pioneerPlatform
   if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
       result_print "Sleeping 15s awaiting PIONEER clear fdb completion....";
       exSleep 15
   } 
}


################################################################## 
# Procedure Name: get_DUTs_info
#   
# Description: creates a DUTs_info array after discovering all DUTs information in the testbed.
#              fills in all elements of DUTs_info array with relevant information.
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              get_DUTs_info
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc get_DUTs_info {{infoFilename "info"} {tmpdir "Tmp"}} {
puts "---Enter into get_DUTs_info"
global spawn_id
global numDUT
global fast
global DUT
global exos

#variable to store all the DUTs interested information
global DUTs_info
global DUTs_Slot_info
global chassis

set pid [pid]

set fd_res [open_result_file "$infoFilename"]
set slotDump 0   
for {set i 1} {$i <= $numDUT} {incr i 1} { 
global eware_dut
   if {([info exists eware_dut]) && ([lsearch $eware_dut $i] > -1 )} {
             global DUT[set i]_CONNECT
             Login [set DUT[set i]_CONNECT]
            get_DUTs_info_eware
   } else {
   global DUT[set i]_CONNECT
   Login [set DUT[set i]_CONNECT]

   ################################################################
   ##  Get Slot info dump if Platform Type is BD or BT or Godzilla etc
   ################################################################
   set fd_in [open "$tmpdir/tmp_info_DUT$i$pid" "w"]

   SendACmd "disable clipaging"
   SendACmd "show version detail"
   SendACmd "show version images"
   SendACmd "show fans detail"
   SendACmd "show switch" $fd_res $fd_in
   SendACmd "show version" $fd_res $fd_in
   close $fd_in

   ################################################################
   ##  Initiallize variables to be gathered.
   ################################################################
   set imageSel "NONE"
   set imageBooted "NONE"
   set priImage "INVALID"
   set secImage "INVALID"
   set version "INVALID"
   set platform "INVALID"
   set sysMAC "INVALID"
   set bootROM "INVALID"
   set relMaster "INVALID"
   set hwList 0
   set numSlots  "0"   
   set verTime   "INVALID"
   set memoryCard "INVALID"
   set dlReqD    "0"
   set showVerVersion ""
   set snmpVersion "2"
   set sysN "INVALID"
   set sysT "INVALID"
   set license "INVALID"

   set DUTs_info(DUT$i,imageSel) $imageSel
   set DUTs_info(DUT$i,imageBooted) $imageBooted
   set DUTs_info(DUT$i,priImage) $priImage
   set DUTs_info(DUT$i,secImage) $secImage
   set DUTs_info(DUT$i,version) $version
   set DUTs_info(DUT$i,verTime)   $verTime   
   set DUTs_info(DUT$i,platform) $platform
   set DUTs_info(DUT$i,sysMAC) $sysMAC
   set DUTs_info(DUT$i,bootROM) $bootROM
   set DUTs_info(DUT$i,numSlots)  $numSlots   
   set DUTs_info(DUT$i,relMaster) $relMaster
   set DUTs_info(DUT$i,hwList) $hwList
   set DUTs_info(DUT$i,dlReqD)   $dlReqD
   set DUTs_info(DUT$i,sysName) $sysN
   set DUTs_info(DUT$i,sysType) $sysT
   set DUTs_info(debugFlag) 1
   set DUTs_info(DUT$i,sVVersion) $showVerVersion
   set DUTs_info(DUT$i,snmpVersion) $snmpVersion
   set DUTs_info(DUT$i,license) $license
   set DUTs_info(DUT$i,memoryCard) NULL

   set bList "NULL"
   set location "NULL"

   set fd_in [open "$tmpdir/tmp_info_DUT$i$pid" "r"]
   while {[gets $fd_in line] != -1} {
      set cookedLine [cookString $line]


#result_debug "----- cookedLine=$cookedLine"
      set aList [split $cookedLine]

      if {$bList != "NULL"} {

# Determine location in file search "show switch, slot or version"
      if { ([lindex $bList 0] == "sysName:") || ([lindex $bList 0] == "SysName:") } {
         set location "switch"
         }

      if { ([lindex $bList 0] == "Chassis:")  || \
           ([lindex $bList 0] == "Chassis")   || \
           ([lindex $bList 0] == "Slot-1")   || \
           ([lindex $bList 0] == "Switch")   || \
           ([lindex $bList 0] == "CPU")   || \
           ([lindex $bList 0] == "Daughtercard:") || \
           ([lindex $bList 0] == "Baseboard:")  } {
         set location "version"
      }

###########   Find image version selected to boot###########################

      if { ([lindex $bList 0] == "Image") &&     \
           ([lindex $bList 1] == "Selected:") &&      \
           ( $location == "switch"        )  && [lindex $aList 2]!=""} {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
      }
      #for 6.2.1
      if { ([lindex $aList 0] == "Image") &&     \
           ([lindex $aList 1] == "Booted:") && [lindex $aList 2]!="" } {
         set imageBooted [lindex $aList 2]
         set imageBooted [string tolower $imageBooted]
      }


############ Find the names of the images load in the 2 MSM spaces.. ###


      #find primary image
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "ver:") } {
         set priImage [lindex $bList 2]
      }
      #find second image
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "secondary") &&   \
           ([string tolower [lindex $bList 1]] == "ver:") } {
         set secImage [lindex $bList 2]
      }
      #find System Name
      if { ([string tolower [lindex $bList 0]] == "sysname:") } {
         #set platform [computeSysName [lindex $bList 1]]
         set sysN [lindex $bList 1]
      }
      #find System Type
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "system") &&   \
           ([string tolower [lindex $bList 1]] == "type:") } {
               set sysT [lindex $bList 2]

               if {[regexp -nocase stack $bList match]} {
                   set platform $match
                }  else {
                   set platform $sysT
                }
       
         }

                      
      
      #find system MAC
      if { ([lindex $bList 0] == "System") &&     \
           ([lindex $bList 1] == "MAC:") } {
         set sysMAC [lindex $bList 2]

      }
      #find release master, time of the build, and the release master
      # EY-06-15-2006: Added elseif clause to handle new "ExtremeXOS"
      # software name.
      if { ( $location == "version" )     && \
           ([lindex $bList 0] == "Image") && \
           ([lindex $bList 3] == "XOS")   && \
           ([lindex $bList 4] == "version")} {

         set version [lindex $bList 5];
         set showVerVersion [lindex $bList 6];
         # Compute the version for patch builds in EXOS
         if {[regexp -nocase "\\-" $showVerVersion]} {
            set patchList [split $showVerVersion "-"];
            foreach str [lrange $patchList 1 end] {
               set version [format %s-%s $version $str];
            }
         }
         set relMaster [lindex $bList 8];
      } elseif { ( $location == "version" )          && \
                 ([lindex $bList 0] == "Image")      && \
                 ([lindex $bList 2] == "ExtremeXOS") && \
                 ([lindex $bList 3] == "version")} {

          set version [lindex $bList 4];
          set showVerVersion [lindex $bList 5];
          # Compute the version for patch builds in EXOS
          if {[regexp -nocase "\\-" $showVerVersion]} {
             set patchList [split $showVerVersion "-"];
             foreach str [lrange $patchList 0 end] {
                set version [format %s-%s $version $str];
             }
          }
          set relMaster [lindex $bList 7];
      }
      if { ( $location == "version" ) &&     \
           ([lindex $bList 0] == "on")} {
         set verTime [lrange $bList 1 6]
      }



      #find BootROM
      if { ([lindex $bList 0] == "BootROM") } {
         set bootROM [lindex $bList 2]

      }      

   }
   set bList $aList;# This sets bList equal to the PREVIOUS line aList
   }  ;# end of file while


   #get slot info to figure out hardware type
   set hardwareType "NEW_GEN"
   set bladeType "NONE"
   global chassis
   global i386Chassis
   if {[regexp -nocase "$chassis|$i386Chassis" $platform]} {
      lappend parameterList "{^Slot-\[0-9\]+} 1"
      set HardwareList [GetKeyValue "show slot" $parameterList]
      unset parameterList
      result_debug "HardwareList: $HardwareList"
      set hwList $HardwareList;
      set k 0;
      foreach hardware $HardwareList {
         if {[lsearch -regexp $bladeType $hardware]==-1} {
            if {$bladeType=="NONE"} {set bladeType ""}
            if {![regexp -nocase "none|Empty" $hardware]} {
               set bladeType "$bladeType$hardware"
            }
         }
         incr k 1;
      }
      # Use foreach loop count to set numSlots
      set numSlots $k;
   } else {
      global stackable i386Stackable
      if { [regexp -nocase "$stackable|$i386Stackable" $platform]} {
         set hardwareType "NEW_GEN"
      }
   }

   ################################################################
   ##  Determine whether memorycard present, fill in memoryCard in DUTs_info
   ################################################################
   global chassis stacking
   if {[regexp -nocase $chassis $platform] && ![regexp -nocase $stacking $platform]} {
      set memBuf [SendACmd "ls memorycard"]
      if {![regexp -nocase "Error: Memorycard is not present" $memBuf]} {
         set memoryCard "present"
      }
   }

   set parameterList ""
   lappend parameterList "{Enabled License Level:} 0 1"
   lappend parameterList "{Enabled License Level:} 1 1"
   set getLicense [GetKeyValue "show license" $parameterList];
   # EY-05-15-2008: Cleared out parameterList before end of loop.
   # This fixes a problem when retrieving slot info on a test bed with
   # more than one chassis or stack DUT.
   unset parameterList;
   if {[lindex [lindex $getLicense 0] 1] != ""} {
      set temp [split [lindex $getLicense 0] " "]
      set currentLicense [concat [lindex $temp 0][lindex $temp 1]]
   } else {
      set temp [split [lindex $getLicense 0] " "]
      set currentLicense [lindex $temp 0]
   }
   set license $currentLicense



   ################################################################

   global _VERSION
   global VERSION
   set _VERSION $version
   set VERSION [string range $_VERSION 0 0]
   set DUTs_info(DUT$i,VERSION) $VERSION
   ################################################################

   puts "####### version $version  ###########################"
   set DUTs_info(DUT$i,imageSel) $imageSel
   set DUTs_info(DUT$i,imageBooted) $imageBooted
   set DUTs_info(DUT$i,priImage) $priImage
   set DUTs_info(DUT$i,secImage) $secImage
   set DUTs_info(DUT$i,version) $version
   set DUTs_info(DUT$i,verTime) $verTime   
   set DUTs_info(DUT$i,platform) $platform
   set DUTs_info(DUT$i,sysName) $sysN
   set DUTs_info(DUT$i,sysType) $sysT
   set DUTs_info(DUT$i,sysMAC) [string toupper $sysMAC]
   set DUTs_info(DUT$i,relMaster) $relMaster
   set DUTs_info(DUT$i,bootROM) $bootROM
   set DUTs_info(DUT$i,numSlots) $numSlots
   set DUTs_info(DUT$i,hwList) $hwList
   set DUTs_info(DUT$i,HardwareType) $hardwareType
   set DUTs_info(DUT$i,bladeType) $bladeType
   set DUTs_info(DUT$i,dlReqD)   $dlReqD
   set DUTs_info(DUT$i,sVVersion) $showVerVersion
   set DUTs_info(DUT$i,memoryCard) $memoryCard
   set DUTs_info(DUT$i,snmpVersion) $snmpVersion
   set DUTs_info(DUT$i,license) [string tolower $license]

   result_debug "****** DUT$i Info ********"
   result_debug "Image Selected = $DUTs_info(DUT$i,imageSel)"
   result_debug "Image Booted = $DUTs_info(DUT$i,imageBooted)"
   result_debug "Image Version = $DUTs_info(DUT$i,version)"
   result_debug "Connect type= $DUTs_info(DUT$i,connectType)"
   result_debug "Running Image Built on $DUTs_info(DUT$i,verTime)"   
   result_debug "Primary Image = $DUTs_info(DUT$i,priImage)"
   result_debug "Secondary Image = $DUTs_info(DUT$i,secImage)"
   result_debug "Platform = $DUTs_info(DUT$i,platform)"
   result_debug "System MAC = $DUTs_info(DUT$i,sysMAC)"
   result_debug "System Type = $DUTs_info(DUT$i,sysType)"
   result_debug "BootROM = $DUTs_info(DUT$i,bootROM)"
   result_debug "Release Master = $DUTs_info(DUT$i,relMaster)"
   result_debug "Slot Card List = $DUTs_info(DUT$i,hwList)"
   result_debug "Number of Slots = $DUTs_info(DUT$i,numSlots)"   
   result_debug "Hardware Type = $DUTs_info(DUT$i,HardwareType)"
   result_debug "Blade Type = $DUTs_info(DUT$i,bladeType)"
   result_debug "Download Flag Init    = $DUTs_info(DUT$i,dlReqD)"
   result_debug "Version from Show Version = $DUTs_info(DUT$i,sVVersion)"
   result_debug "memoryCard status = $DUTs_info(DUT$i,memoryCard)"
   result_debug "SNMP version = $DUTs_info(DUT$i,snmpVersion)"
   result_debug "License = $DUTs_info(DUT$i,license)"
   close $fd_in
   catch {file delete "$tmpdir/tmp_info_DUT$i$pid"}

   if {[info exist fast] && ($fast != "NULL")} {
       puts $fast "set DUTs_info(DUT$i,imageSel) \"$DUTs_info(DUT$i,imageSel)\""
       puts $fast "set DUTs_info(DUT$i,imageBooted) \"$DUTs_info(DUT$i,imageBooted)\""
       puts $fast "set DUTs_info(DUT$i,version) \"$DUTs_info(DUT$i,version)\""
       puts $fast "set DUTs_info(DUT$i,connectType) \"$DUTs_info(DUT$i,connectType)\""
       puts $fast "set DUTs_info(DUT$i,VERSION) \"$DUTs_info(DUT$i,VERSION)\""
       puts $fast "set DUTs_info(DUT$i,priImage) \"$DUTs_info(DUT$i,priImage)\""
       puts $fast "set DUTs_info(DUT$i,secImage) \"$DUTs_info(DUT$i,secImage)\""
       puts $fast "set DUTs_info(DUT$i,platform) \"$DUTs_info(DUT$i,platform)\""
       puts $fast "set DUTs_info(DUT$i,sysMAC) \"$DUTs_info(DUT$i,sysMAC)\""
       puts $fast "set DUTs_info(DUT$i,bootROM) \"$DUTs_info(DUT$i,bootROM)\""
       puts $fast "set DUTs_info(DUT$i,relMaster) \"$DUTs_info(DUT$i,relMaster)\""
       puts $fast "set DUTs_info(DUT$i,verTime) \"$DUTs_info(DUT$i,verTime)\""
       puts $fast "set DUTs_info(DUT$i,hwList) \"$DUTs_info(DUT$i,hwList)\""
       puts $fast "set DUTs_info(DUT$i,numSlots) \"$DUTs_info(DUT$i,numSlots)\""       
       puts $fast "set DUTs_info(DUT$i,HardwareType) \"$DUTs_info(DUT$i,HardwareType)\""
       puts $fast "set DUTs_info(DUT$i,bladeType) \"$DUTs_info(DUT$i,bladeType)\""
       puts $fast "set DUTs_info(DUT$i,dlReqD) \"$DUTs_info(DUT$i,dlReqD)\""
       puts $fast "set DUTs_info(DUT$i,sysName) \"$DUTs_info(DUT$i,sysName)\""
       puts $fast "set DUTs_info(DUT$i,sysType) \"$DUTs_info(DUT$i,sysType)\""
       puts $fast "set DUTs_info(DUT$i,sVVersion) \"$DUTs_info(DUT$i,sVVersion)\""
       puts $fast "set DUTs_info(DUT$i,snmpVersion) \"$DUTs_info(DUT$i,snmpVersion)\""
       puts $fast "set DUTs_info(DUT$i,license) \"$DUTs_info(DUT$i,license)\""
       puts $fast "set DUTs_info(DUT$i,memoryCard) \"$DUTs_info(DUT$i,memoryCard)\""
       puts $fast "set DUTs_info(debugFlag) \"$DUTs_info(debugFlag)\""
       if {[info exists DUTs_info(current_module)]} {
       puts $fast "set DUTs_info(current_module) \"$DUTs_info(current_module)\""
       }
   }
}
}
close_result_file  
# Now get the info from the individual slots if platform matches
     if {$slotDump} {
         get_DUTs_Slot_info $tmpdir
     }
puts "---------------------------- 7 -------------------"
     if {![info exists DUT(LoadImage)]} { ;# Need to turn of when run LoadImage
puts "---------------------------- 8 -------------------"
#         getTECardSpeed
puts "---------------------------- 9 -------------------"
     }
puts "---------------------------- 10 -------------------"
}

################################################################## 
# Procedure Name: DutSlotType
#   
# Description: Return the slot name of a specified DUT and Slot
#     
#
# Input args: DUT number, Slot Number
# Output args: none
# Return value: Return the slot name of a specified DUT and Slot
# Typical usage:
#              DutSlotType 1 1
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc DutSlotType {{dut ""} {slot ""}} {
   global DUTs_info
   if {$DUTs_info(DUT$dut,bladeType) != "NONE"} {
       set cardType [lindex $DUTs_info(DUT${dut},hwList) [expr $slot -1]]
   } else {
       set cardType "NONE"
   }

   return $cardType
}

################################################################## 
# Procedure Name: DutSlotNumPorts
#   
# Description: Return the number of ports on a slot
#     
#
# Input args: DUT number, Slot Number
# Output args: none
# Return value: Return the number of slots on a port
# Typical usage:
#              DutSlotNumPorts 1 1
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc DutSlotNumPorts {{dut ""} {slot ""}} {
   global DUTs_info

   if {$DUTs_info(DUT$dut,bladeType) != "NONE"} {
       set cardType [lindex $DUTs_info(DUT${dut},hwList) [expr $slot -1]]
   } else {
       set cardType "0"
   }

   if {0} {
      if {[regexp -nocase "(\[0-9\]+)" $cardType str]} {
         set numPort $str
      } else {
         set numPort "0"
      }
   } else {
      if {[regexp -nocase "(\[0-9\]+)" $cardType str]} {
          Login $DUTs_info(DUT${dut},connect)
          lappend parameterList "available: 1"
          set numPort [GetKeyValue "show slot $slot" $parameterList]
          unset parameterList
      } else {
         set numPort "0"
      }
   }

   return $numPort
}

################################################################## 
# Procedure Name: DutSlotStateRT
#   
# Description: Return the state of a slot from a real time show slot x
#     
#
# Input args: DUT number, Slot Number
# Output args: none
# Return value: Return the state of the card
# Typical usage:
#              DutSlotStateRT 1 1
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc DutSlotStateRT {{dut ""} {slot ""}} {
    global DUTs_info

    Login $DUTs_info(DUT${dut},connect)

    if {$DUTs_info(DUT$dut,bladeType) != "NONE"} {
        lappend parameterList "State: 1"
        set slotState [GetKeyValue "show slot $slot" $parameterList]
        unset parameterList
    } else {
        set slotState NONE
    }
    return $slotState
}


################################################################## 
# Procedure Name: computeSysName
#   
# Description: determines the platform system name. Run a sh ver and determines platform based on
#              number of slots i.e. whether 16,8 or 4 for GZ, BD or BT respectively.
#
#              
#     
#
# Input args: none
# Output args: none
# Return value: Returns the system name either BD, BT, GODZILLA or Sysname
# Typical usage:
#              computeSysName
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc computeSysName {{sysName ""}} {

   if {[regexp -nocase "MSM" $sysName]} {
      lappend parameterList "{SLOT *16 :} 1"
      set slot16Value [GetKeyValue "show ver" $parameterList]
      unset parameterList
      result_debug "slot16Value: $slot16Value"
      if {[regexp -nocase "KEY_NOT_FOUND" $slot16Value]} {   ;# BD or BT
         lappend parameterList "{SLOT *5 :} 1"
         set slot5Value [GetKeyValue "show ver" $parameterList]
         unset parameterList
         result_debug "slot5Value: $slot5Value"
         if {[regexp -nocase "KEY_NOT_FOUND" $slot5Value]} {   ;# BT
            set platform BT
         } else {
             # no more set BD to MSM64 after ridding of EXTREME_PLATFORM
             #set platform $sysName ;# BD
             set platform BD
         }
      } else {    ;# Godzilla
         set platform GODZILLA
      }
   } else {
      set platform $sysName
   }
   return $platform
}


################################################################## 
# Procedure Name: getTECardSpeed
#   
# Description: determines the test equipment card's speed i.e. 10/100 or 1G
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              getTECardSpeed
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc getTECardSpeed {} {
   global ixiaCh1
   global startCardNum
   global fast

   global cardSpeed
   set cardSpeed 0
  if {[info exists ixiaCh1]} {   
     global env
     if {[set fd_out [FileOpen [file join $env(IXIA_HOME) "lib/ixTcl1.0/ixTclHal.tcl"] r+]]==-1} {
         return $fd_out 
      }
#      package require IxTclHal
      funlock $fd_out 
#      package require Tclx
      package require Tclx
#      package require Mpexpr
      package require Mpexpr
      #clean up any previous mess
   #   cleanUp
#      ixInitialize $ixiaCh1
#      port get 1 $startCardNum 1
#      set cardSpeed [port cget -speed]
      if {[info exist fast] && ($fast != "NULL")} {
#         puts $fast "set cardSpeed $cardSpeed"
      }
   }
   return
}

################################################################## 
# Procedure Name: smallIxiaInit
#   
# Description: This performs a faster ixia init in case of dev mode run.
#
#
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              smallIxiaInit
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc smallIxiaInit {} {
      # ----- Ixia initialization
  global ixiaCh1
if { 0 } {
puts "enter smallIxiaInit----"
  global ixiaCh1
  global ixiaNoReset
  if {[info exists ixiaCh1]} {
     global env
     if {[set fd_out [FileOpen [file join $env(IXIA_HOME) "lib/ixTcl1.0/ixTclHal.tcl"] r+]]==-1} {
         return $fd_out 
      }
puts "enter smallIxiaInit1----"
#      package require IxTclHal
puts "enter smallIxiaInit2----"
      funlock $fd_out 
puts "enter smallIxiaInit3----"
     package require Tclx
puts "enter smallIxiaInit4----"
     package require Mpexpr
     #clean up any previous mess
#     cleanUp
puts "enter into ixInitialize--"
#     ixInitialize $ixiaCh1
     if {![info exists ixiaNoReset]} {
         IxiaPortsInit
     }
  }
}
     package require Tclx
     package require Mpexpr
     ixInitialize $ixiaCh1
}

################################################################## 
# Procedure Name: RunUnCon
#   
# Description: This performs a uncon sw a at a slower speed making sure evey char typed is 
#              is accepted by DUT
#
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              RunUnCon
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc RunUnCon {{connect "0.0.0.0"}      
               {setupScript ""}
               {fd "NULL"}} {
   global spawn_id
   Login $connect
   set timeout 120

   foreach command $setupScript {
      if { [string match "unc* sw*" $command] == 1 } {
         result_debug "Make sure that this is not a direct telnet connection"
         result_debug "Reseting to factory defaults..."
         foreach letter {u n c o n " " s w " " a} {
            send $letter
             expect {
                "$letter" {
                    after 10
                }
                timeout {
                   for {set c 0} {$c<10} {incr c} {
                      send $letter
                      expect {
                         "$letter" {
                            break
                         }
                         timeout {
                            after 10
                         }
                      }
                   }
                }
             }
         }
         send "\r"
         expect -nocase "(y*n*)"
         send "y\r"
         log_user 1
      }     
   }        
#   logout  
}           
##################################################################
# Procedure Name: GetBcomPortInfoStd
# Description: Init Globals for PortId_Info and Trunk_Info 
# portId and Trunk port on a standard regression bed.
#
# Sets globals: 
#
#       PortID_Info($i,portSpeed) $portSpeed
#       PortID_Info($i,showSpeed) 100Mbps|1Gbps|10Gbps - how it is display on show port info det
#       PortID_Info($i,normTxPerc) (lowest portId speed / portSpeed) * 100
#       PortID_Info($j,normTxPercBy100) (lowest portId speed / portSpeed)
#
#       -- These variables are used in test cases where sw forwarding may or may not be used
#          depending on the platform or the port ID
#       PortID_Info($i,txSwHwPercHigh) sw or hw tx perc - applicatin specific;
#       PortID_Info($i,txSwHwPercLow) sw or hw tx perc - applicatin specific;
#       PortID_Info($i,txSwHwPerc) sw or hw tx perc - applicatin specific;
#       PortID_Info($i,txSwHwRateHigh) sw or hw tx frame rate - applicatin specific;
#       PortID_Info($i,txSwHwRateLow) sw or hw tx frame rate - applicatin specific;
#       PortID_Info($i,txSwHwRate) sw or hw tx frame rate - applicatin specific;
#       PortID_Info($i,txSwHwNumFrames) 64k for sw 3M for hw
#       PortID_Info($i,txPath) sw|hw;
#
#       Main_Info(stdIdCount) 8|12
#       Main_Info(portSpeedList) list of all 8|12 speeds "100 100 1000 100 10000 ...."
#
# Input args: none
# Output args: none
# Return value: none
# Typical usage:
#       GetPortIdInfoStd;
# Category: Utility
##################################################################
proc GetPortIdInfoStd {{saveMode 0}} {
    global Trunk_Info;
    global DUTs_info;
    global PortID_Info;
    global Main_Info;
    global chassis;
    global DUT1_CONNECT;
    global DUT2_CONNECT;
    global chassis;
    global whichDutNow;
    global bcmPlatform;
    global bcmJaguar;
    global napaBlade;
    global bcmChassis;
    global stacking;
    global fast;
    global portIDsUsed;

    set saveGlobals 0;
    if {[info exist fast] && ($fast != "NULL") && ($saveMode != "0")} {
        _getPortIdTypeInfo 1;
    } else {
        _getPortIdTypeInfo;
        set saveMode 0;
    }
puts "-------------------------- 7 ------------------------------"
    set portSpeedList "";
    # EY-12-16-2009: Fixed typo and cleaned up indentation.
    if {[info exists portIDsUsed]} {
        foreach portId $portIDsUsed {
            set portSpeed [GetPortIdSpeed $portId];
            lappend portSpeedList $portSpeed;
            set portSpeedArray(portID${portId},speed) $portSpeed;
            set PortID_Info($portId,portSpeed) $portSpeed;
            if {$saveMode} {puts $fast "set PortID_Info($portId,portSpeed) $portSpeed";}
            switch $portSpeed {
                "100"   {set PortID_Info($portId,showSpeed) 100Mbps;}
                "1000"  {set PortID_Info($portId,showSpeed) 1Gbps;}
                "10000" {set PortID_Info($portId,showSpeed) 10Gbps;}
            }
        }
        set Main_Info(portSpeedList) $portSpeedList;
        if {$saveMode} {puts $fast "set Main_Info(portSpeedList) \"$portSpeedList\"";}

        # Sort the port speeds from lowest to highest
        set portSpeedList [lsort -integer $portSpeedList];
        set Main_Info(sortPortSpeedList) $portSpeedList;
        if {$saveMode} {puts $fast "set Main_Info(sortPortSpeedList) \"$portSpeedList\"";}
        set lowestPortSpeed [lindex $portSpeedList 0];
        foreach portUsed $portIDsUsed {
            set PortID_Info($portUsed,normTxPerc) [expr int(double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed)) * 100)];
            if {$saveMode} {
                puts $fast "set PortID_Info($portUsed,normTxPerc) [expr int(double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed)) * 100)]";
            }      
            set PortID_Info($portUsed,normTxPercBy100) [expr double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed))];
            if {$saveMode} {
                puts $fast "set PortID_Info($portUsed,normTxPercBy100) [expr double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed))]";
            }

            set i $portUsed;
            if {$PortID_Info($i,BcomGen) == "NewGen" || $PortID_Info($i,BcomGen) == "Default"} {
                switch [GetPortIdSpeed $i] {
                    "10000" {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 14800000;
                             set PortID_Info($i,txSwHwRateLow) 148000;
                             set PortID_Info($i,txSwHwRate) 148000}
                    "1000"  {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 1480000;
                             set PortID_Info($i,txSwHwRateLow) 14800;
                             set PortID_Info($i,txSwHwRate) 148000}
                    "100"   {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 148000;
                             set PortID_Info($i,txSwHwRateLow) 1480;
                             set PortID_Info($i,txSwHwRate) 14800;}
                    default {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 148000;
                             set PortID_Info($i,txSwHwRateLow) 1480;
                             set PortID_Info($i,txSwHwRate) 14800}
                }; # switch [GetPortIdSpeed $i]
                #result_debug "PortID $i is on a NewGen Broadcom OR Genesis Chassis Blade"
                set PortID_Info($i,txSwHwNumFrames) 3000000;
                set PortID_Info($i,txPath) hw;
            } else {
                switch [GetPortIdSpeed $i] {
                    "10000" {set PortID_Info($i,txSwHwPercHigh) .003;
                             set PortID_Info($i,txSwHwPercLow) .001;
                             set PortID_Info($i,txSwHwPerc) .003;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    "1000"  {set PortID_Info($i,txSwHwPercHigh) .02;
                             set PortID_Info($i,txSwHwPercLow) .01;
                             set PortID_Info($i,txSwHwPerc) .02;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    "100"   {set PortID_Info($i,txSwHwPercHigh) .25;
                             set PortID_Info($i,txSwHwPercLow) .10;
                             set PortID_Info($i,txSwHwPerc) .25;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    default {set PortID_Info($i,txSwHwPercHigh) .25;
                             set PortID_Info($i,txSwHwPercLow) .10;
                             set PortID_Info($i,txSwHwPerc) .25;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                }; # switch [GetPortIdSpeed $i]
                #result_debug "PortID $i is OldGen Broadcom Stackable"
                set PortID_Info($i,txSwHwNumFrames) 64000;
                set PortID_Info($i,txPath) sw;
            }; # else
        }; # foreach portUsed $portIDsUsed
    }; # if {[info exists portIDsUsed]}
}; # proc GetPortIdInfoStd

################################################################## 
# Procedure Name: get_DUTs_Slot_info
#   
# Description: This creates and fills in the array  DUTs_Slot_info with the help of DUTs_info
#              All slot specific necessary information may be obtained from this array. This array
#              may be referred with known information of DUT and slot number
#
#     
#
# Input args: tmpdir
# Output args: none
# Typical usage:
#              get_DUTs_Slot_info
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc get_DUTs_Slot_info {{tmpdir "Tmp"}} {
global spawn_id
global numDUT
global fast 

set numSlots 8

#variable to store all the DUTs interested information
global DUTs_info
global DUTs_Slot_info

set fd_res [open_result_file "slotinfo"]

for {set i 1} {$i <= $numDUT} {incr i 1} {

   global DUT${i}_CONNECT
   set numSlots $DUTs_info(DUT$i,numSlots)
   set hwModType "NULL"
   set confType  "NULL"
   set state     "NULL"
   set npRev     "NULL"
   set npProc1   "NULL"
   set npProc2   "NULL"
   set imageSel  "NULL"
   set priImage  "NULL"
   set secImage  "NULL"
   set version   "NULL"
   set verTime   "NULL"
   set dlReqD    "0"
   set category  "NULL"

   for {set j 1} {$j <= $numSlots} {incr j} {
   # Hardware module type
   set DUTs_Slot_info(DUT$i,slot$j,hwModType) $hwModType
   # Module type set in the configuration
   set DUTs_Slot_info(DUT$i,slot$j,confType)  $confType
   # State of the card (Operational or not)
   set DUTs_Slot_info(DUT$i,slot$j,state)     $state
   # Revision of the C5 Network Processor
   set DUTs_Slot_info(DUT$i,slot$j,npRev)     $npRev
   # Status of each NP on the slot
   set DUTs_Slot_info(DUT$i,slot$j,npProc1)   $npProc1
   # Status of each NP on the slot
   set DUTs_Slot_info(DUT$i,slot$j,npProc2)   $npProc2
   # Image selected to boot from
   set DUTs_Slot_info(DUT$i,slot$j,imageSel)  $imageSel
   # Image in the primary slot
   set DUTs_Slot_info(DUT$i,slot$j,priImage)  $priImage
   # Image in the secondary slot
   set DUTs_Slot_info(DUT$i,slot$j,secImage)  $secImage
   # Image in the slot that is chosen to boot from ASSUMED RUNNING IMAGE
   set DUTs_Slot_info(DUT$i,slot$j,version)   $version
   # Date and Time that the running image was made
   set DUTs_Slot_info(DUT$i,slot$j,verTime)   $verTime
   # For use to determine downloads
   set DUTs_Slot_info(DUT$i,slot$j,dlReqD)    $dlReqD
   # Set category OldGen NewGen NP
   set DUTs_Slot_info(DUT$i,slot$j,category)  $category

   }


   #For the NP Cards we need more than 1 line captured

   set bList "NULL"
   set location "NULL"

   set fd_in [open "$tmpdir/tmp_info_DUT$i" "r"]
   while {[gets $fd_in line] != -1} {
      set cookedLine [cookString $line]


#result_debug "----- cookedLine=$cookedLine"
      set aList [split $cookedLine]

      if {$bList != "NULL"} {

# Determine location in file search "show switch, slot or version"
      if { ([lindex $bList 0] == "sysName:")} {
         set location "switch"
         }
      if { ([lindex $bList 0] == "Chassis:")} {
         set location "version"
         }

######## Loop through slots #########################################
  for {set j 1} {$j <= $numSlots} {incr j} {

        if { ([lindex $bList 0] == "Slot") &&    \
           ([lindex $bList 1] == "$j") &&       \
           ([lindex $bList 2] == "information:") } {
            set location "slot$j"
        }


###########   Find image version selected to boot###########################

      #find image version selected on an NP Card


        if {    ([lindex $bList 0] == "Software") &&     \
                ([lindex $bList 1] == "image") &&        \
                ([lindex $bList 2] == "booted:") &&      \
                ( $location == "slot$j"        )  } {
            set DUTs_Slot_info(DUT$i,slot$j,imageSel) [lindex $bList 3]
            set npImageSel $DUTs_Slot_info(DUT$i,slot$j,imageSel)
            set DUTs_Slot_info(DUT$i,slot$j,imageSel) \
                   [string tolower $DUTs_Slot_info(DUT$i,slot$j,imageSel)]

        }


###########  Find name of image version booted #############################
      #find image version booted name on an NP Card
      set tmp [lindex $bList 0]
      set tmp [string tolower $tmp]

        if {   ($tmp == $DUTs_Slot_info(DUT$i,slot$j,imageSel)) && \
               ([string tolower [lindex $bList 1]] == "software") &&        \
               ([string tolower [lindex $bList 2]] == "version:") &&    \
               ($location == "slot$j") } {
            set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 1] [string trimleft \
                              [lindex $aList 2] "("] [string trimright [lindex $aList 3] ")"] \
                              [lindex $aList 6]"
            if {[lindex $aList 4] == "Prj"} {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 12] [lindex $aList 13] \
                                 [lindex $aList 14] [lindex $aList 15] [lindex $aList 16]"
            }
            if {[lindex $aList 4] == "(Type:"} {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 9] [lindex $aList 10] \
                                 [lindex $aList 11] [lindex $aList 12] [lindex $aList 13]"
            }
            if { ([lindex $aList 0] == "6.2.1")  && \
                 ([lindex $aList 4] == "by")   } {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 7] [lindex $aList 8] \
                                 [lindex $aList 9]"
                set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 0] [string trimleft \
                              [lindex $aList 1] "("] [string trimright [lindex $aList 2] ")"]"
            }                  
            if { ([lindex $aList 0] >= "7.0.0")  && \
                 ([lindex $aList 5] == "by")   } {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 8] [lindex $aList 9] \
                                 [lindex $aList 10]"
                set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 0] [lindex $aList 3]"
            }
            if { ([lindex $aList 0] >= "7.0.0")  && \
                 ([lindex $aList 4] == "by")   } {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 7] [lindex $aList 8] \
                                 [lindex $aList 9]"
                set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 0] b[string trimright \
                                 [lindex $aList 2] ")"]"
            }
        }



############ Find the names of the images load in the 2 spaces.. NP cards###
      #find primary image
      if { ( $location == "slot$j" ) &&     \
           ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set DUTs_Slot_info(DUT$i,slot$j,priImage) "[lindex $aList 1] [string trimleft \
                            [lindex $aList 2] "("] [string trimright [lindex $aList 3] ")"] \
                            [lindex $aList 6]"
         if {[lindex $aList 0] == "6.2.1"} {
             set DUTs_Slot_info(DUT$i,slot$j,priImage) "[lindex $aList 0] [string trimleft \
                           [lindex $aList 1] "("] [string trimright [lindex $aList 2] ")"]"
         }
      }
      #find second image
      if { ( $location == "slot$j" ) &&     \
           ([string tolower [lindex $bList 0]] == "secondary") &&   \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set DUTs_Slot_info(DUT$i,slot$j,secImage) "[lindex $aList 1] [string trimleft \
                            [lindex $aList 2] "("] [string trimright [lindex $aList 3] ")"] \
                            [lindex $aList 6]"
         if {[lindex $aList 0] == "6.2.1"} {
             set DUTs_Slot_info(DUT$i,slot$j,secImage) "[lindex $aList 0] [string trimleft \
                           [lindex $aList 1] "("] [string trimright [lindex $aList 2] ")"]"
         }
      }
      #find Hardware module type
      if { ([lindex $bList 0] == "HW") &&     \
           ([lindex $bList 2] == "Type:") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,hwModType) [lindex $bList 3]

      }

      #find Slot s/w Configured setting
      if { ([lindex $bList 0] == "Configured") &&     \
           ([lindex $bList 1] == "Type:") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,confType) [lindex $bList 2]

      }
      #find find operational state
      if { ([lindex $bList 0] == "State:") &&  \
            ( $location == "slot$j" ) } {
         set DUTs_Slot_info(DUT$i,slot$j,state) [lindex $bList 1]

      }
      #find NP Revision
      if { ([lindex $bList 0] == "NP") &&     \
           ([lindex $bList 1] == "1:") && \
           ([lindex $bList 2] == "Rev") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,npRev) [lindex $bList 3]
      }
      #find NP 1 Proc State
      if { ([lindex $bList 0] == "Network") &&     \
           ([lindex $bList 1] == "Processor") && \
           ([lindex $bList 2] == "1") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,npProc1) [lindex $bList 4]
      }
      #find NP 2 Proc State
      if { ([lindex $bList 0] == "Network") &&     \
           ([lindex $bList 1] == "Processor") && \
           ([lindex $bList 2] == "2") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,npProc2) [lindex $bList 4]
      }

   }
   }
   set bList $aList

}



for {set j 1} {$j <= $numSlots} {incr j} {

    switch $DUTs_Slot_info(DUT$i,slot$j,hwModType) {
        "A3ci"    {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "P3ci"    {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "P12ci"   {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "ARM"     {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "ASMGM2X" {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "MPLS"    {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "SMA"     {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "G8Xi"    {set DUTs_Slot_info(DUT$i,slot$j,category) NEW_GEN}
        "F48Ti"   {set DUTs_Slot_info(DUT$i,slot$j,category) NEW_GEN}
        "G12Xi"   {set DUTs_Slot_info(DUT$i,slot$j,category) NEW_GEN}
        "F32T"    {set DUTs_Slot_info(DUT$i,slot$j,category) OLD_GEN}
        "F24T"    {set DUTs_Slot_info(DUT$i,slot$j,category) OLD_GEN}
    }

   result_debug "*** DUT$i *** Slot$j Info ********"
   result_debug "Hardware Module Type = $DUTs_Slot_info(DUT$i,slot$j,hwModType)"
   result_debug "Module Configured = $DUTs_Slot_info(DUT$i,slot$j,confType)"
   result_debug "Slot State = $DUTs_Slot_info(DUT$i,slot$j,state)"
   result_debug "Network Processor Rev = $DUTs_Slot_info(DUT$i,slot$j,npRev)"
   result_debug "Network Processor 1 Status = $DUTs_Slot_info(DUT$i,slot$j,npProc1)"
   result_debug "Network Processor 2 Status = $DUTs_Slot_info(DUT$i,slot$j,npProc2)"
   result_debug "Image Selected = $DUTs_Slot_info(DUT$i,slot$j,imageSel)"
   result_debug "Booted Version Name = $DUTs_Slot_info(DUT$i,slot$j,version)"
   result_debug "Build Date = $DUTs_Slot_info(DUT$i,slot$j,verTime)"
   result_debug "Primary Image = $DUTs_Slot_info(DUT$i,slot$j,priImage)"
   result_debug "Secondary Image = $DUTs_Slot_info(DUT$i,slot$j,secImage)"
   result_debug "Card Category = $DUTs_Slot_info(DUT$i,slot$j,category)"


      if {[info exist fast] && ($fast != "NULL")} {
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,hwModType) \"$DUTs_Slot_info(DUT$i,slot$j,hwModType)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,confType) \"$DUTs_Slot_info(DUT$i,slot$j,confType)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,state) \"$DUTs_Slot_info(DUT$i,slot$j,state)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,npRev) \"$DUTs_Slot_info(DUT$i,slot$j,npRev)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,npProc1) \"$DUTs_Slot_info(DUT$i,slot$j,npProc1)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,npProc2) \"$DUTs_Slot_info(DUT$i,slot$j,npProc2)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,imageSel) \"$DUTs_Slot_info(DUT$i,slot$j,imageSel)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,version) \"$DUTs_Slot_info(DUT$i,slot$j,version)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,verTime) \"$DUTs_Slot_info(DUT$i,slot$j,verTime)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,priImage) \"$DUTs_Slot_info(DUT$i,slot$j,priImage)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,secImage) \"$DUTs_Slot_info(DUT$i,slot$j,secImage)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,category) \"$DUTs_Slot_info(DUT$i,slot$j,category)\""
       puts $fast "set DUTs_Slot_info(DUT$i,slot$j,dlReqD)   \"$DUTs_Slot_info(DUT$i,slot$j,dlReqD)\""       
      }

}

   close $fd_in                          


}
close_result_file

}



################################################################## 
# Procedure Name: get_DUTs_info_eware
#   
# Description: creates a DUTs_info array after discovering all DUTs information in the testbed.
#              fills in all elements of DUTs_info array with relevant information.
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              get_DUTs_info
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc get_DUTs_info_eware {{infoFilename "info"} {tmpdir "Tmp"}} {
global spawn_id
global numDUT
global fast
global DUT

#variable to store all the DUTs interested information
global DUTs_info
global DUTs_Slot_info
global branch
global pioneerPlatform
global DUTs_info
global whichDutNow

global tmpPath
if [info exists tmpPath] {
    set tmpdir $tmpPath
}

set fd_res [open_result_file "$infoFilename"]
set slotDump 0   
#for {set i 1} {$i <= $numDUT} {incr i 1} {

#   global eware_dut
#   if {[info exists eware_dut]} {
#      if {[lsearch $eware_dut $i] > -1 } {
#         set loopVar 1
 #     } else {
 #        set loopVar 0
 #     }
 #  } else {
 #     set loopVar 0
 #  }

  # if {$loopVar} {
   global whichDutNow
   set i $whichDutNow
   global DUT[set i]_CONNECT
   Login [set DUT[set i]_CONNECT]

   lappend parameterList "{SysName:}   1"
   set sysN [GetKeyValue "show switch" $parameterList]
   unset parameterList

   ################################################################
   ##  Determine Platform Type as BD or BT or Godzilla etc
   ################################################################
   set platFType [computeSysName $sysN]
   set platFType [string tolower $platFType]
   ################################################################
   ##  Get Slot info dump if Platform Type is BD or BT or Godzilla etc
   ################################################################
   set fd_in [open "$tmpdir/tmp_info_DUT$i-[pid]" "w"]
   SendACmd "sh sw" $fd_res $fd_in
   SendACmd "sh ver" $fd_res $fd_in
   SendACmd "sh vlan default" $fd_res $fd_in
   if {([regexp -nocase "bd|bt" $platFType])      || \
       ([regexp -nocase "Alpine*" $platFType])    || \
       ([regexp -nocase "godzilla" $platFType])  } {
      SendACmd "sh slot" $fd_res $fd_in
      set slotDump 1
   }      
   close $fd_in
   ################################################################
   ##  Initiallize variables to be gathered.
   ################################################################
   set imageSel "NONE"
   set priImage "INVALID"
   set secImage "INVALID"
   set version "INVALID"
   set platform "INVALID"
   set techRel   "INVALID"   
   set sysMAC "INVALID"
   set bootROM "INVALID"
   set relMaster "INVALID"
   set numPorts 0
   set merge     "INVALID"
   set numSlots  "0"   
   set version2  "INVALID"
   set verTime   "INVALID"
   set dlReqD    "0"
   set priVer    ""
   set secVer    ""
   set showVerVersion ""
   set snmpVersion "2"

   set DUTs_info(DUT$i,imageSel) $imageSel
   set DUTs_info(DUT$i,priImage) $priImage
   set DUTs_info(DUT$i,secImage) $secImage
   set DUTs_info(DUT$i,version) $version
   set DUTs_info(DUT$i,verTime)   $verTime   
   set DUTs_info(DUT$i,platform) $platform
   set DUTs_info(DUT$i,sysMAC) $sysMAC
   set DUTs_info(DUT$i,bootROM) $bootROM
   set DUTs_info(DUT$i,numSlots)  $numSlots   
   set DUTs_info(DUT$i,relMaster) $relMaster
   set DUTs_info(DUT$i,numPorts) $numPorts
   set DUTs_info(DUT$i,techRel)   $techRel
   set DUTs_info(DUT$i,merge)    $merge
   set DUTs_info(DUT$i,dlReqD)   $dlReqD
   set DUTs_info(DUT$i,sysName) $sysN
   set DUTs_info(debugFlag) 1
   set DUTs_info(DUT$i,sVVersion) $showVerVersion
   set DUTs_info(DUT$i,snmpVersion) $showVerVersion

   set masterOfsset "17"
   set masterEnd "28"
   set isMSM "FALSE"
   set bList "NULL"
   set location "NULL"
   set msmLocation "NULL"
   set msmMaster   "MSM-B"

   set fd_in [open "$tmpdir/tmp_info_DUT$i-[pid]" "r"]
   while {[gets $fd_in line] != -1} {
      set cookedLine [cookString $line]


#result_debug "----- cookedLine=$cookedLine"
      set aList [split $cookedLine]

      if {$bList != "NULL"} {

# Determine location in file search "show switch, slot or version"
      if { ([lindex $bList 0] == "sysName:") || ([lindex $bList 0] == "SysName:") } {
         set location "switch"
         }
    #Determine if you are in an msm image section
      set msmType [string toupper  [lindex $bList 0]]
      switch -exact -- $msmType {
        "MSM-A" { set msmLocation "MSM-A" }    
        "MSM-B" { set msmLocation "MSM-B" }    
        "MSM-C" { set msmLocation "MSM-C" }    
        "MSM-D" { set msmLocation "MSM-D" }   
      }  
      if { ([lindex $bList 0] == "Chassis:")  || \
           ([lindex $bList 0] == "Chassis")   || \
           ([lindex $bList 0] == "CPU")   || \
           ([lindex $bList 0] == "Daughtercard:") || \
           ([lindex $bList 0] == "Baseboard:")  } {
         set location "version"
      }

      if { ([lindex $bList 0] == "Slot") &&    \
           ([lindex $bList 1] == "1") &&       \
           ([lindex $bList 2] == "information:") } {
         set location "slot"
      }
      #6.2.1b10
      if { ([lindex $aList 0] == "Current") &&     \
           ([lindex $aList 1] == "State:") } {

         set masterOffset "29"
         set masterEnd "40"
         set isMSM "TRUE"
         if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
             set msmMaster MM-B
         } else {
             set msmMaster MSM-B
         }
         if {[string tolower [lindex $aList 2]] == "master" } {
             set masterOfsset "17"
             set masterEnd "28"
             set msmMaster MSM-A
             if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
                 set msmMaster MM-A
             } else {
                 set msmMaster MSM-A
             }
         }
      }

  ###########   Find both image versions Fix for 700b37 new Show switch #########
      if { ([string tolower [lindex $aList 0]] == "primary") &&     \
           ([string tolower [lindex $aList 1]] == "ew") &&        \
           ([string tolower [lindex $aList 2]] == "ver:") } {
      set priVer [string tolower [lindex $aList 3]]
      }
          if { ([string tolower [lindex $aList 0]] == "secondary") &&     \
               ([string tolower [lindex $aList 1]] == "ew") &&        \
               ([string tolower [lindex $aList 2]] == "ver:") } {
          set secVer [string tolower [lindex $aList 3]]
          }

  ################   Find image version selected to boot IMAGE RUNNING NOW  #####

      #find image version selected on switch

      if { ([lindex $bList 0] == "Software") &&     \
           ([lindex $bList 1] == "image") &&        \
           ([lindex $bList 2] == "booted:") &&      \
           ( $location == "switch"        )  } {
         set imageSel [lindex $bList 3]
         set imageSel [string tolower $imageSel]
           puts "**$imageSel***from the wrong place 618 code########"
      }
      ###### Fix for ABU new Show Switch 700b44##################################
      if { ([lindex $bList 0] == "Module") &&     \
           ([lindex $bList 1] == "Image") &&        \
           ([lindex $bList 4] == "Booted") &&      \
           ( $location == "switch"        )  } {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
         if {$imageSel == "primary"} {
             set version $priVer
         } elseif {$imageSel == "secondary"} {
             set version $secVer
         }
      }
      ###### Fix for ABU new Show Switch 700b45 and above##################################
      if { ([lindex $bList 0] == "------") &&     \
           ( $location == "switch"        )  } {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
         if {$imageSel == "primary"} {
             set version $priVer
         } elseif {$imageSel == "secondary"} {
             set version $secVer
         }
      }
      if { ([lindex $bList 0] == "Image") &&     \
           ([lindex $bList 1] == "Selected:") &&      \
           ( $location == "switch"        )  } {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
         if {$imageSel == "primary"} {
             set version $priVer
         } elseif {$imageSel == "secondary"} {
             set version $secVer
         }
      puts "** 700 changes for Alpine  ########"
      }
      #for 6.2.1
      if { ([lindex $aList 0] == "Image") &&     \
           ([lindex $aList 1] == "Booted:") } {
         set imageSel [lindex [string range $line $masterOfsset $masterEnd] 0]
         set imageSel [string tolower $imageSel]
 puts "**$imageSel***from 621 code########"
      }


      # Find image version booted name on MSM
      #

      set tmp [lindex $bList 0]
      set tmp [string tolower $tmp]
      if { ($tmp == $imageSel) && ($location == "switch") &&    \
           ([string tolower [lindex $bList 1]] == "software") &&        \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set version [lindex $bList 3]
         set slot [lindex $bList 5]
         if { $slot == "MSM-A" || $slot == "MM-A"} {
            if {$version == "empty"} {
               set version [string tolower "[lindex $bList 6]"]
            } else {
               set version [string tolower "[lindex $bList 3]"]
            }
         }
      }

      #6.2.1b10
      set tmp [lindex $aList 0]
      set tmp [string tolower $tmp]      
      if { ($tmp == $imageSel) &&     \
           ([string tolower [lindex $aList 1]] == "ew") &&        \
           ([string tolower [lindex $aList 2]] == "ver:") &&  \
           ($msmLocation == "NULL")     } {
      set version [string tolower [lindex $aList 3]]
         if { $isMSM == "TRUE" } {
            if {$masterOfsset == "17"} {
               set version [string tolower "[lindex [string range $line $masterOfsset $masterEnd] 0]"]
            } else {
               set version [string tolower "[lindex [string range $line $masterOfsset $masterEnd] 0]"]
            }
         }
      }
      #7.0.0b39 RTPFixes5
      # Primary   EW Ver:   7.3.0.22 branch-4digit_v730b22 [non-ssh] [base] 
      # Secondary EW Ver:   7.1.1b11 branch.PA-0311-01-r2 [non-ssh]      
      set tmp [lindex $bList 0]
      set tmp [string tolower $tmp]      
      if { ($tmp == $imageSel) &&     \
           ([string tolower [lindex $bList 1]] == "ew") &&        \
           ([string tolower [lindex $bList 2]] == "ver:") &&      \
           ($msmMaster == $msmLocation)    } {
         set version [string tolower [lindex $bList 3]]
      }
      set version1 $version

#############################################################################
###               Find the names of the images load in the 2 MSM spaces.. ###
###              SHOW SWITCH                                              ###
#############################################################################

      #find primary image
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set priImage [lindex $bList 3]
      }
      #for 6.2.1
      if { ([string tolower [lindex $aList 0]] == "primary") &&     \
           ([string tolower [lindex $aList 1]] == "ew") &&    \
           ([string tolower [lindex $aList 2]] == "ver:") && \
           ($msmLocation == "NULL")    } {
         set priImage [lindex [string range $line $masterOfsset $masterEnd] 0]
      }
      #for 700b39 rtpfixes on
      if { ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "ew") &&    \
           ([string tolower [lindex $bList 2]] == "ver:") && \
           ($msmMaster == $msmLocation)    } {
           #fix for 701b4
           if {[regexp -nocase "ssh" [lindex $bList 4]]} {
               set priImage "[lindex $bList 3]"
           } else {
               set priImage "[lindex $bList 3] [lindex $bList 4]"
           }

      }
      #find second image
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "secondary") &&   \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set secImage [lindex $bList 3]
      }
        #for 6.2.1
        if { ([string tolower [lindex $aList 0]] == "secondary") &&   \
             ([string tolower [lindex $aList 1]] == "ew") &&    \
             ([string tolower [lindex $aList 2]] == "ver:") &&  \
             ($msmLocation == "NULL")    } {
           set secImage [lindex [string range $line $masterOfsset $masterEnd] 0]
        }
        #for 700b39 rtpfixes5 and on
        if { ([string tolower [lindex $bList 0]] == "secondary") &&   \
             ([string tolower [lindex $bList 1]] == "ew") &&    \
             ([string tolower [lindex $bList 2]] == "ver:") &&  \
             ($msmMaster == $msmLocation)    } {

           #fix for 701b4
           if {[regexp -nocase "ssh" [lindex $bList 4]]} {
               set secImage "[lindex $bList 3]"
           } else {
               set secImage "[lindex $bList 3] [lindex $bList 4]"
           }
        }
      #find System Name
      if { ([string tolower [lindex $bList 0]] == "sysname:") } {
         set platform [computeSysName [lindex $bList 1]]
      }
      #find system MAC
      if { ([lindex $bList 0] == "System") &&     \
           ([lindex $bList 1] == "MAC:") } {
         set sysMAC [lindex $bList 2]

      }
######################################################################################
#    Show version portion of the file 
#
######## find release master, time of the build ######################################
      if { ( $location == "version" ) &&     \
           ([lindex $bList 0] == "Image") &&     \
           ([lindex $bList 2] == "Extremeware") &&  \
           ([lindex $bList 3] == "Version")} {

         #should be able to handle 4 and 3 digit version like:
         #Image : Extremeware  Version 7.3.0.30 [non-ssh] [wlan] by 
         #Build_Master on 05/17/04 17:23:30                 
         #
         #Image  :  Extremeware Version 6.2.2 (Build 156)  by 
         #Release_Master 02/13/04 18:33:39 
         #
         #extract the version 
         regexp -nocase {Version +([^ ]+)} $bList dummy showVerVersion
         #extract the build number if exist
         if [regexp -nocase {Build +([0-9]+)} $bList dummy matchb] {
            set showVerVersion "${showVerVersion}b$matchb"
         }

         # Santa Clara base, Tech Release Code, or branch build??????
         # First Case is for IPSERV code. Adjust build # and BuildMaster
         if {[lindex $bList 8] == "IP_SERV_TECH_REL"} {
            set version2 [lindex $bList 9]
            set relMaster [lindex $bList 11]
            ### Set the build time for this Version of Code 
            ### (for download comparison##
            set verTime \
               "[lindex $bList 12] [lindex $bList 13] [lindex $bList 14]"
         }


         # Second Case is for Santa Clara built  
         if {[lindex $bList 8] != "IP_SERV_TECH_REL"} {
             set relMaster [lindex $bList 8]
             set verTime \
                "[lindex $bList 9] [lindex $bList 10] [lindex $bList 11]"
         }


         ### fix for 6.2.1 build 17 (sandbox)
         if {([lindex $bList 4] == "6.2.1") 
            && ([lindex $bList 10] == "on")} {
             set verTime "[lindex $bList 11] [lindex $bList 12]"
             set relMaster [lindex $bList 9]
             set merge [lindex $bList 7]
             regsub -all {\.} $merge "_" merge
         }

         ### fix for 6.2.1 build 10 (new linux buildmaster)
         if {([lindex $bList 4] == "6.2.1") 
            && ([lindex $bList 10] != "on")} {
             set verTime "[lindex $bList 10] [lindex $bList 11]"
         }



         ###### fix for 7.0.0 on ncbuild1 FINAL BUILD MASTER?
         #should handle the following syntax for various builds:
         #
         #Image : Extremeware  Version 7.3.0.25 [non-ssh] [base] by 
         #Build_Master on 04/01/04 14:06:55                       
         #
         #Image : Extremeware  Version 7.3.0.30 [non-ssh] [wlan] by 
         #Build_Master on 05/17/04 17:23:30                 
         #
         #Image : Extremeware  Version 7.2.0 (Build 25) 
         #branch.PA-720-0404-01-r1 [non-ssh] by Patch_Master on 05/06/04 
         #22:07:46       
         #
         #Image : Extremeware  Version 7.2.0 (Build 24) [non-ssh] by 
         #Release_Master on 03/18/04 00:55:14            
         #
         #Image : Extremeware  Version 7.1.1 (Build 15) 
         #branch.PA-711-0405-1-r1 [non-ssh] by Patch_Master on 05/05/04 
         #18:51:38   
         # 
         #Image : Extremeware  Version 7.1.1 (Build 13) [non-ssh] by 
         #Release_Master on 01/16/04 18:21:29 
         #
         #Image : Extremeware  Version 7.3.0.22 br-4dig_v730b22 [non-ssh] 
         #[wlan] by Build_Master on 03/19/04 19:54:59
         #
         if {[lindex $bList 4] >= "7.0.0"} {
            #extract relMaster and verTime
            regexp -nocase {by +([^ ]+) +.+ +([0-9]+:[0-9]+:[0-9]+)} \
               $bList dummy relMaster verTime
            #extract merge string
            #for 4 digit version the merge string is any non space char 
            #in between version number and a open square bracket, but 
            #don't match anything in bracket like "[non-ssh]"
            #note that in bList any square bracket is preceded by a brace 
            if ![regexp -nocase \
               {\.[0-9a-z]+ +([^ \[]+) +\{?\[} $bList dummy merge] {
               #if not 4 digit version, the merge string is in between
               # ")" and "[". if this doesn't match there is no
               #branch information to extract
               regexp {\) +([^ \[]+) +\{?\[} $bList dummy merge
            }
            regsub -all {\.} $merge "_" merge
         }
      }

#    End Show Version
######################################################################################

      #find BootROM
      if { ([lindex $bList 0] == "BootROM") } {
         set bootROM [lindex $bList 2]

      }      
      if { ([lindex $bList 0] == "snmpVersion") } {
         set snmpVersion [lindex $bList 2]

      }       
      #find total ports
      if { ([lindex $bList 0] == "Ports:") } {
         set numPorts [lindex $bList 1]

      } 
   }
   set bList $aList
   }  ;# end while

   # Add the Technology Release or Merge info to the version
   if {$version2 == "INVALID"} {
       set version "$version1"
   } else {
       set version "$version1 $version2"
   }

   #get slot info to figure out hardware type
   set hardwareType "NEW_GEN"
   set bladeType "NONE"
   if {[regexp -nocase "bd|bt|godzilla|alpine*" $platform]} {
      lappend parameterList "{HW Module Type:} 1"
      set HardwareList [GetKeyValue "show slot" $parameterList]
      unset parameterList
      result_debug "HardwareList: $HardwareList"
      foreach hardware $HardwareList {
         if {[lsearch -regexp $bladeType $hardware]==-1} {
            if {$bladeType=="NONE"} {set bladeType ""}
            if {![regexp -nocase "none|Empty" $hardware]} {
               set bladeType "$bladeType$hardware"
            }
         }
         switch $hardware {
      	   F32T -
      	   F24T {
               	   set hardwareType "OLD_GEN"     		   
      		} 
         }
      }
   } else {
       if {([regexp -nocase {[0-9|s]i} $platform] == 0) && 
             ([regexp -nocase summit\[2-4\]00 $platform] == 0)} {
           set hardwareType "OLD_GEN"
       }
   }
   ################################################################
   ##  Determine number of slots in the chassis
   ################################################################
   switch $platFType {
       bd         {set numSlots 8}
       bt         {set numSlots 4}
       godzilla   {set numSlots 16}
       alpine3808 {set numSlots 8}
       alpine3804 {set numSlots 4}
       alpine3802 {set numSlots 2}
       default    {set numSlots 0}
   }
   puts "####### version $version  ###########################"
   set DUTs_info(DUT$i,imageSel) $imageSel
   set DUTs_info(DUT$i,priImage) $priImage
   set DUTs_info(DUT$i,secImage) $secImage
   set DUTs_info(DUT$i,version) $version
   set DUTs_info(DUT$i,verTime) $verTime   
   set DUTs_info(DUT$i,platform) $platform
   set DUTs_info(DUT$i,sysMAC) [string toupper $sysMAC]
   set DUTs_info(DUT$i,relMaster) $relMaster
   set DUTs_info(DUT$i,bootROM) $bootROM
   set DUTs_info(DUT$i,numSlots)     $numSlots
   set DUTs_info(DUT$i,numPorts) $numPorts
   set DUTs_info(DUT$i,HardwareType) $hardwareType
   set DUTs_info(DUT$i,bladeType) $bladeType
   set DUTs_info(DUT$i,techRel) $version2
   set DUTs_info(DUT$i,merge)   [string tolower $merge]
   set DUTs_info(DUT$i,dlReqD)   $dlReqD
   set DUTs_info(DUT$i,sVVersion) $showVerVersion
   set DUTs_info(DUT$i,snmpVersion) $snmpVersion
 #  global SNMPv3
 #  global SNMPv2

#   #Determine the SNMP version depending upon the version
#   if { [CompareVersion_eware "6.2.2." DUT$i] <= 0 } {
#      set DUTs_info(DUT$i,snmpVersion) $SNMPv3
#   } else {
#      set DUTs_info(DUT$i,snmpVersion) $SNMPv2
#   }

   if { $version2 != "INVALID" } {
       set buildList [split $version2 "."]
       set bNum [lindex $buildList 0]
       set branch "$version1 ipserv[string trimleft $bNum "v"]"
   }  else {
       set branch "$version1"
   }

   global _VERSION
   global VERSION
   set _VERSION $version
   set VERSION [string range $_VERSION 0 0]
   set DUTs_info(DUT$i,VERSION) $VERSION

   result_debug "****** DUT$i Info ********"
   result_debug "Image Selected = $DUTs_info(DUT$i,imageSel)"
   result_debug "Image Version = $DUTs_info(DUT$i,version)"
   result_debug "Running Image Built on $DUTs_info(DUT$i,verTime)"   
   result_debug "Primary Image = $DUTs_info(DUT$i,priImage)"
   result_debug "Secondary Image = $DUTs_info(DUT$i,secImage)"
   result_debug "Platform = $DUTs_info(DUT$i,platform)"
   result_debug "System MAC = $DUTs_info(DUT$i,sysMAC)"
   result_debug "BootROM = $DUTs_info(DUT$i,bootROM)"
   result_debug "Release Master = $DUTs_info(DUT$i,relMaster)"
   result_debug "Total Ports = $DUTs_info(DUT$i,numPorts)"
   result_debug "Number of Slots = $DUTs_info(DUT$i,numSlots)"   
   result_debug "Hardware Type = $DUTs_info(DUT$i,HardwareType)"
   result_debug "Blade Type = $DUTs_info(DUT$i,bladeType)"
   result_debug "Tech Release version = $DUTs_info(DUT$i,techRel)"
   result_debug "Merge Release version = $DUTs_info(DUT$i,merge)"
   result_debug "Download Flag Init    = $DUTs_info(DUT$i,dlReqD)"
   result_debug "Version from Show Version = $DUTs_info(DUT$i,sVVersion)"
 #  result_debug "SNMP version = $DUTs_info(DUT$i,snmpVersion)"
   close $fd_in

   if {[info exist fast] && ($fast != "NULL")} {
       puts $fast "set DUTs_info(DUT$i,imageSel) \"$DUTs_info(DUT$i,imageSel)\""
       puts $fast "set DUTs_info(DUT$i,version) \"$DUTs_info(DUT$i,version)\""
       puts $fast "set DUTs_info(DUT$i,VERSION) \"$DUTs_info(DUT$i,VERSION)\""
       puts $fast "set DUTs_info(DUT$i,priImage) \"$DUTs_info(DUT$i,priImage)\""
       puts $fast "set DUTs_info(DUT$i,secImage) \"$DUTs_info(DUT$i,secImage)\""
       puts $fast "set DUTs_info(DUT$i,platform) \"$DUTs_info(DUT$i,platform)\""
       puts $fast "set DUTs_info(DUT$i,sysMAC) \"$DUTs_info(DUT$i,sysMAC)\""
       puts $fast "set DUTs_info(DUT$i,bootROM) \"$DUTs_info(DUT$i,bootROM)\""
       puts $fast "set DUTs_info(DUT$i,relMaster) \"$DUTs_info(DUT$i,relMaster)\""
       puts $fast "set DUTs_info(DUT$i,numPorts) \"$DUTs_info(DUT$i,numPorts)\""
       puts $fast "set DUTs_info(DUT$i,numSlots) \"$DUTs_info(DUT$i,numSlots)\""       
       puts $fast "set DUTs_info(DUT$i,HardwareType) \"$DUTs_info(DUT$i,HardwareType)\""
       puts $fast "set DUTs_info(DUT$i,bladeType) \"$DUTs_info(DUT$i,bladeType)\""
       puts $fast "set DUTs_info(DUT$i,techRel) \"$DUTs_info(DUT$i,techRel)\""
       puts $fast "set DUTs_info(DUT$i,merge) \"$DUTs_info(DUT$i,merge)\""
       puts $fast "set DUTs_info(DUT$i,dlReqD) \"$DUTs_info(DUT$i,dlReqD)\""
       puts $fast "set DUTs_info(DUT$i,sysName) \"$DUTs_info(DUT$i,sysName)\""
       puts $fast "set DUTs_info(DUT$i,sVVersion) \"$DUTs_info(DUT$i,sVVersion)\""
       puts $fast "set DUTs_info(DUT$i,snmpVersion) \"$DUTs_info(DUT$i,snmpVersion)\""
       puts $fast "set DUTs_info(debugFlag) \"$DUTs_info(debugFlag)\""
       puts $fast "set branch \"$branch\""
   }
#}
#}

close_result_file  
# Now get the info from the individual slots if platform matches
#     if {$slotDump} {
#         get_DUTs_Slot_info $tmpdir
#     }
#     if {![info exists DUT(LoadImage)]} { ;# Need to turn of when run LoadImage
#         getTECardSpeed
#     }

#     for {set i 1} {$i <= $numDUT} {incr i 1} {
#	 file delete "$tmpdir/tmp_info_DUT$i-[pid]"
#     }
}

