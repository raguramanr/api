<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>MBGPSetup.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#MBGPSetup.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>MBGPSetup.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="MBGPSetup.tcl-annot.html">annotations</a> | <a href="MBGPSetup.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: VerifyCorrectMBGPRoutesLearned</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Verify that specific BGP routes are learned on the</span>
<span class="comment-line">#               switch.</span>
<span class="comment-line">#               It uses route attributes in a list along with network ip</span>
<span class="comment-line">#               to verify the learning</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: args</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: VerifySwitchOutput</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyCorrectMBGPRoutesLearned_20">proc <a href="MBGPSetup.tcl-annot.html#::::VerifyCorrectMBGPRoutesLearned">::::VerifyCorrectMBGPRoutesLearned</a></a></strong> {args} {
   <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> VerifyCorrectBGPRoutesLearned $args {
      peerIp &#34;&#34;
      peerAsPath &#34;&#34;
      ipNwList &#34;&#34;
      originList &#34;0&#34;
      routesList &#34;&#34;
      nextHopList &#34;&#34;
      fromPrefixList &#34;&#34;
      bestRouteList &#34;&#34;
      fromPrefixList &#34;&#34;
      thruPrefixList &#34;&#34;
      localPrefList &#34;&#34;
      asTypeList &#34;&#34;
      asPathList &#34;&#34;
      medList &#34;&#34;
      peerType &#34;&#34;
   }

for {set index 0} {$index&lt;[llength $peerIp]} {incr index} {
   set peerIpValue [lindex $peerIp $index]
   set peerAsPathVal [lindex $peerAsPath $index]
   set ipNwListValue [lindex $ipNwList $index]
   set fromPrefixListValue [lindex $fromPrefixList $index]
   set thruPrefixListValue [lindex $thruPrefixList $index]
   set originListValue [lindex $originList $index]
   set nextHopListValue [lindex $nextHopList $index]
   set routesListValue [lindex $routesList $index]
   set medListValue [lindex $medList $index]
   set asPathListValue [lindex $asPathList $index]
   set asTypeListValue [lindex $asTypeList $index]
   set localPrefListValue [lindex $localPrefList $index]
   set bestRouteListValue [lindex $bestRouteList $index]
   set peerTypeValue [lindex $peerType $index]
   set length [llength $ipNwListValue]
   set incompleteRoutesList &#34;&#34;
   set incompleteRoutesList1 &#34;&#34;
   <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;length=$length and asPathListValue $asPathListValue&#34;;

   <span class="comment-line">################################################</span>
   set subTest &#34;Verify correct routes learned from peer $peerIpValue&#34;
   <span class="comment-line">################################################</span>
   result_h2 &#34;$subTest&#34;
   <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$subTest&#34;

   if {[llength $fromPrefixListValue]!=$length || [llength $thruPrefixListValue]!=$length || [llength $routesListValue]!=$length || \
       [llength $nextHopListValue]!=$length} {
      <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error in input args:fromPrefixList,thruPrefixList,routesList,ipNwList,nextHopList should be same length&#34;
      <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
      return -1
   }

   for {set i 0} {$i&lt;$length} {incr i} {
      set ipNetwork [lindex $ipNwListValue $i]
      set fromPrefix [lindex $fromPrefixListValue $i]
      set thruPrefix [lindex $thruPrefixListValue $i]
      set originType [lindex $originListValue $i]
      set nextHop [lindex $nextHopListValue $i]
      set localPref [lindex $localPrefListValue $i]
      set numRoutes [lindex $routesListValue $i]
      set med [lindex $medListValue $i]
      set bestRoute [lindex $bestRouteListValue $i]
      set peerTypeVal [lindex $peerTypeValue $i]

      switch -- $originType \
         &#34;1&#34; {
             set originCode EGP
         } &#34;0&#34; {
             set originCode IGP
         } &#34;2&#34; {
             set originCode Incomplete
         } default {
             set originCode IGP
         }

      if {$peerTypeVal==&#34;i&#34;} {
         set peerAsPathList &#34;&#34;
      } else {
         set peerAsPathList $peerAsPathVal
      }
  if {[llength $asPathListValue]!=0} {
         set aslist [lindex $asPathListValue $i]
         set asSegmentTypes [lindex $asTypeListValue $i]
         if {$aslist!=&#34;&#34;} {
            set indice 0
            foreach asType $asSegmentTypes {
               if {[llength $asSegmentTypes]&gt;1} {
                  lappend peerAsPathList [lindex $aslist $indice]
               } else {
                  if {$asType==1} {
                     set aslist [list $aslist]   ;<span class="comment-line"># in order to properly check the set of AS_SET</span>
                  }
                  foreach asl $aslist {
                     lappend peerAsPathList $asl
                  }
               }
               incr indice
            }
         }
      }
      for {set j 0} {$j&lt;$numRoutes} {incr j} {
         set myIP [<a name="::incrIpField(1)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipNetwork 3 $j]
         scan $myIP %d.%d.%d.%d a b c d
         set myIP [format %d.%d.%d.%d $a $b $c 0]
         if {$localPref!=&#34;&#34;} {
            if {$med!=&#34;&#34;} {
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop, LPref $localPref, MED $med} inLine exist 1&#34;
            } else {
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop, LPref $localPref} inLine exist 1&#34;
            }
         } else {
            if {$med!=&#34;&#34;} {
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop.* MED $med} inLine exist 1&#34;
            } else {
<span class="comment-line">#               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop.*} inLine exist 1&#34;</span>
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop} inLine exist 1&#34;
            }
         }
         if {$bestRoute==1} {
            lappend incompleteRoutesList1 &#34;{Route: $myIP/$fromPrefix, *Peer $peerIpValue, *BEST} {AS-PATH: $peerAsPathList} inLine exist 2&#34;
         } else {
            lappend incompleteRoutesList1 &#34;{Route: $myIP/$fromPrefix, *Peer $peerIpValue} {AS-PATH: $peerAsPathList} inLine exist 2&#34;
         }
      }
   }
   <a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show bgp neighbor $peerIpValue address-family ipv4-multicast received-routes detail all&#34; $incompleteRoutesList \
                 -comment &#34;BGP neighbor incomplete routes&#34;;
   <a name="::CheckKeyValue(2)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show bgp neighbor $peerIpValue address-family ipv4-multicast received-routes detail all&#34; $incompleteRoutesList1 \
                  -comment &#34;BGP neighbor incomplete routes correct AS-PATH&#34;;
   unset incompleteRoutesList
   unset incompleteRoutesList1

   <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: VerifyCorrectMBGPRoutesLearned_12_5</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Verify that specific BGP routes are learned on the</span>
<span class="comment-line">#               switch.</span>
<span class="comment-line">#               It uses route attributes in a list along with network ip</span>
<span class="comment-line">#               to verify the learning</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: args</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: VerifySwitchOutput</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyCorrectMBGPRoutesLearned_12_5_175">proc <a href="MBGPSetup.tcl-annot.html#::::VerifyCorrectMBGPRoutesLearned_12_5">::::VerifyCorrectMBGPRoutesLearned_12_5</a></a></strong> {args} {
   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> VerifyCorrectBGPRoutesLearned_12_5 $args {
      peerIp &#34;&#34;
      peerAsPath &#34;&#34;
      ipNwList &#34;&#34;
      originList &#34;0&#34;
      routesList &#34;&#34;
      nextHopList &#34;&#34;
      fromPrefixList &#34;&#34;
      bestRouteList &#34;&#34;
      fromPrefixList &#34;&#34;
      thruPrefixList &#34;&#34;
      localPrefList &#34;&#34;
      asTypeList &#34;&#34;
      asPathList &#34;&#34;
      medList &#34;&#34;
      peerType &#34;&#34;
   }

for {set index 0} {$index&lt;[llength $peerIp]} {incr index} {
   set peerIpValue [lindex $peerIp $index]
   set peerAsPathVal [lindex $peerAsPath $index]
   set ipNwListValue [lindex $ipNwList $index]
   set fromPrefixListValue [lindex $fromPrefixList $index]
   set thruPrefixListValue [lindex $thruPrefixList $index]
   set originListValue [lindex $originList $index]
   set nextHopListValue [lindex $nextHopList $index]
   set routesListValue [lindex $routesList $index]
   set medListValue [lindex $medList $index]
   set asPathListValue [lindex $asPathList $index]
   set asTypeListValue [lindex $asTypeList $index]
   set localPrefListValue [lindex $localPrefList $index]
   set bestRouteListValue [lindex $bestRouteList $index]
   set peerTypeValue [lindex $peerType $index]
   set length [llength $ipNwListValue]
   set incompleteRoutesList &#34;&#34;
   set incompleteRoutesList1 &#34;&#34;
   <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;length=$length and asPathListValue $asPathListValue&#34;;

   <span class="comment-line">################################################</span>
   set subTest &#34;Verify correct routes learned from peer $peerIpValue&#34;
   <span class="comment-line">################################################</span>
   result_h2 &#34;$subTest&#34;
   <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$subTest&#34;

   if {[llength $fromPrefixListValue]!=$length || [llength $thruPrefixListValue]!=$length || [llength $routesListValue]!=$length || \
       [llength $nextHopListValue]!=$length} {
      <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error in input args:fromPrefixList,thruPrefixList,routesList,ipNwList,nextHopList should be same length&#34;
      <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
      return -1
   }

   for {set i 0} {$i&lt;$length} {incr i} {
      set ipNetwork [lindex $ipNwListValue $i]
      set fromPrefix [lindex $fromPrefixListValue $i]
      set thruPrefix [lindex $thruPrefixListValue $i]
      set originType [lindex $originListValue $i]
      set nextHop [lindex $nextHopListValue $i]
      set localPref [lindex $localPrefListValue $i]
      set numRoutes [lindex $routesListValue $i]
      set med [lindex $medListValue $i]
      set bestRoute [lindex $bestRouteListValue $i]
      set peerTypeVal [lindex $peerTypeValue $i]

      switch -- $originType \
         &#34;1&#34; {
             set originCode EGP
         } &#34;0&#34; {
             set originCode IGP
         } &#34;2&#34; {
             set originCode Incomplete
         } default {
             set originCode IGP
         }

      if {$peerTypeVal==&#34;i&#34;} {
         set peerAsPathList &#34;&#34;
      } else {
         set peerAsPathList $peerAsPathVal
      }
  if {[llength $asPathListValue]!=0} {
         set aslist [lindex $asPathListValue $i]
         set asSegmentTypes [lindex $asTypeListValue $i]
         if {$aslist!=&#34;&#34;} {
            set indice 0
            foreach asType $asSegmentTypes {
               if {[llength $asSegmentTypes]&gt;1} {
                  lappend peerAsPathList [lindex $aslist $indice]
               } else {
                  if {$asType==1} {
                     set aslist [list $aslist]   ;<span class="comment-line"># in order to properly check the set of AS_SET</span>
                  }
                  foreach asl $aslist {
                     lappend peerAsPathList $asl
                  }
               }
               incr indice
            }
         }
      }
      for {set j 0} {$j&lt;$numRoutes} {incr j} {
         set myIP [<a name="::incrIpField(2)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipNetwork 3 $j]
         scan $myIP %d.%d.%d.%d a b c d
         set myIP [format %d.%d.%d.%d $a $b $c 0]
         if {$localPref!=&#34;&#34;} {
            if {$med!=&#34;&#34;} {
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop, LPref $localPref, MED $med} inLine exist 1&#34;
            } else {
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop, LPref $localPref} inLine exist 1&#34;
            }
         } else {
            if {$med!=&#34;&#34;} {
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop.* MED $med} inLine exist 1&#34;
            } else {
<span class="comment-line">#               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop.*} inLine exist 1&#34;</span>
               lappend incompleteRoutesList &#34;{Route: $myIP/$fromPrefix} {Origin $originCode, Next-Hop $nextHop} inLine exist 1&#34;
            }
         }
         if {$bestRoute==1} {
            lappend incompleteRoutesList1 &#34;{Route: $myIP/$fromPrefix, *Peer $peerIpValue, *BEST} {AS-PATH: $peerAsPathList} inLine exist 3&#34;
         } else {
            lappend incompleteRoutesList1 &#34;{Route: $myIP/$fromPrefix, *Peer $peerIpValue} {AS-PATH: $peerAsPathList} inLine exist 3&#34;
         }
      }
   }
   <a name="::CheckKeyValue(3)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show bgp neighbor $peerIpValue address-family ipv4-multicast received-routes detail all&#34; $incompleteRoutesList \
                 -comment &#34;BGP neighbor incomplete routes&#34;;
   <a name="::CheckKeyValue(4)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show bgp neighbor $peerIpValue address-family ipv4-multicast received-routes detail all&#34; $incompleteRoutesList1 \
                  -comment &#34;BGP neighbor incomplete routes correct AS-PATH&#34;;
   unset incompleteRoutesList
   unset incompleteRoutesList1

   <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
