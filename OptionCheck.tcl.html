<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>OptionCheck.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#OptionCheck.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>OptionCheck.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="OptionCheck.tcl-annot.html">annotations</a> | <a href="OptionCheck.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [CheckKeyValue]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Execute a CLI command/take log from the file, checks the key/value pair (combination described below)</span>
<span class="comment-line">#  for existance in the output. This proc takes 2 required args &#34;command&#34; and &#34;parameterList&#34;</span>
<span class="comment-line">#  and other optional args as described below.</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#      - &lt;command&gt; - CLI command to execute</span>
<span class="comment-line">#      - &lt;parameterList&gt; - a list of keys to look for values</span>
<span class="comment-line">#                          Note: only support one key right now (Combination described in usage)</span>
<span class="comment-line">#      - [testNo] - test number to be printed for reference in report.txt</span>
<span class="comment-line">#      - [comment] - text for comment for reference purposes to be put in report.txt</span>
<span class="comment-line">#      - [dut] - dut number (1,2,3,4..) on the command output is to be tested</span>
<span class="comment-line">#      - [time] - time sensitive checkKeyValue </span>
<span class="comment-line">#                sTime seconds denotes wait time initially before starting the checks</span>
<span class="comment-line">#                iTime seconds denotes interval time to wait in between checks</span>
<span class="comment-line">#                dTime seconds denotes expected time that should be passed</span>
<span class="comment-line">#                fTime seconds denotes the max time limit before the check fails</span>
<span class="comment-line">#      - [nofeep] - runs the command in nofeep mode. (0 as default, 1 for nofeep)</span>
<span class="comment-line">#      - [reportResults] - report error if failure, otherwise just return ok or error.</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#      - [time]</span>
<span class="comment-line">#                rTime seconds denotes the time taken by the check for pass/fail.</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns &#34;ok&#34; if success &#34;error&#34; if failure</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#   lappend parameterList &#34;Key1 value&#34; ;value right after key</span>
<span class="comment-line">#   lappend parameterList &#34;Key2&#34; ;key exists</span>
<span class="comment-line">#   lappend parameterList &#34;Key2 notExist&#34;</span>
<span class="comment-line">#   lappend parameterList &#34;Key3 value inLine&#34; ;value somewhere in the line</span>
<span class="comment-line">#   lappend parameterList &#34;Key3 value inLine exist 3&#34; ;value somewhere in the 3th line after key, subject to limitations</span>
<span class="comment-line">#   lappend parameterList &#34;Key3 value inLine notExist&#34;</span>
<span class="comment-line">#   For key with spaces</span>
<span class="comment-line">#   lappend parameterList &#34;{Last Member Query:} 2&#34;</span>
<span class="comment-line">#   CheckKeyValue &#34;show ipconfig&#34; $parameterList</span>
<span class="comment-line">#   lappend parameterList &#34;{AreaId : 0.0.0.0} {Summary Network *10001} inLine exist 6&#34;</span>
<span class="comment-line">#   set result [CheckKeyValue &#34;show ospf ls sta &#34; $parameterList -dut 1 -time {s: 200 i: 8 d: 252 f: 260 r}]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifySwitchOutput</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::CheckKeyValue_47">proc <a href="OptionCheck.tcl-annot.html#::::CheckKeyValue">::::CheckKeyValue</a></a></strong> {command parameterList args} {
   
    global spawn_id FAILSUMMARY MAIN
    global DUTs_info
    global whichDutNow

    if {![info exists FAILSUMMARY]} {
        set FAILSUMMARY 0
    }
    set tmp &#34;Tmp&#34;
    set pwd [pwd]
    set pid _[pid]
    append pid &#34;_&#34;
    set random_number [<a name="::random(1)"><a href="./mysqlLib.tcl.html#::random_1092">::random</a></a> 10000]
    append pid $random_number
    set done 0

    if {[regexp -nocase &#34;clitest&#34; $pwd]} {
        global tmpPath
        set tmp $tmpPath
    }

    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckKeyValue $args {
        testNo  &#34;CheckKeyValue&#34;
        comment &#34;&#34;
        dut     0
        time    0
        nofeep 0
        reportResults 1
        bootrom 0 
        showError &#34;true&#34;
        reportFailAsSkip 0
    }

    if {$dut!=0} {
        set DUTName [format %s%d DUT $dut]
        global ${DUTName}_CONNECT;
        <a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT];
    }
    if {$time != &#34;0&#34;} {
        set sTime [lindex $time 1] ; <span class="comment-line"># time to initally wait before starting</span>
        set iTime [lindex $time 3] ; <span class="comment-line"># interval time to wait between checks</span>
        set dTime [lindex $time 5] ; <span class="comment-line"># expected time that we should pass</span>
        set fTime [lindex $time 7] ; <span class="comment-line"># max time we wait before failing the test</span>
        set rTime [lindex $time 8]
        upvar $rTime retTime      
        <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $sTime
    } else {
        set sTime 2; set iTime 1; set dTime 1; set fTime 1; 
    }
    set ttime     $sTime

    <span class="comment-line"># LK 09/25/2008 common fix to avoid x650 check key value failure due to</span>
    <span class="comment-line"># brackets in prompt e.g X650-24x(SSns) , X650-24x(SS),X650-24x(10G8X)</span>
    <span class="comment-line">#</span>
    <span class="comment-line">########Generic check on parameterList ###############</span>

    if {([regexp {\(SSns\)} $parameterList])} {
        regsub -all {\(SSns\)} $parameterList {\\(SSns\\)} parameterList;
    } elseif {([regexp {\(SS\)} $parameterList])} {
        regsub -all {\(SS\)} $parameterList {\\(SS\\)} parameterList;
    } elseif {([regexp {\(10G8X\)} $parameterList])} {
        regsub -all {\(10G8X\)} $parameterList {\\(10G8X\\)} parameterList;
    } elseif {([regexp {\(40G4X\)} $parameterList])} {
        regsub -all {\(40G4X\)} $parameterList {\\(40G4X\\)} parameterList;
    } elseif {([regexp {\(10G4X\)} $parameterList])} { 
        regsub -all {\(10G4X\)} $parameterList {\\(10G4X\\)} parameterList;
    } elseif {([regexp {\(SS128\)} $parameterList])} {
        regsub -all {\(SS128\)} $parameterList {\\(SS128\\)} parameterList;
    } elseif {([regexp {\(P\)} $parameterList])} {
        regsub -all {\(P\)} $parameterList {\\(P\\)} parameterList;
    }


    if {([info exists DUTs_info(DUT${whichDutNow},platform)] ) } {
        if {([regexp &#34;650&#34; $DUTs_info(DUT${whichDutNow},platform)])} {
            regsub -all {\(SSns\)} $parameterList {\\(SSns\\)} parameterList;
            regsub -all {\(SS\)} $parameterList {\\(SS\\)} parameterList;
            regsub -all {\(10G8X\)} $parameterList {\\(10G8X\\)} parameterList;
            regsub -all {\(40G4X\)} $parameterList {\\(40G4X\\)} parameterList;
        } elseif { ([regexp &#34;480&#34; $DUTs_info(DUT${whichDutNow},platform)]) } {
            regsub -all {\(SS\)} $parameterList {\\(SS\\)} parameterList;
            regsub -all {\(10G4X\)} $parameterList {\\(10G4X\\)} parameterList;
            regsub -all {\(SS128\)} $parameterList {\\(SS128\\)} parameterList;
        }
    } else {
        set pList &#34;&#34;; 
        lappend pList &#34;{^SysName:} 1&#34;;
        set SystemName [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $pList]
        unset pList; 

        set pList &#34;&#34;; 
        lappend pList &#34;{^System Type:} 1&#34;;
        set SystemType [<a name="::GetKeyValue(2)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $pList]
        unset pList;

        if {([regexp &#34;650&#34; $SystemName]) || ([regexp &#34;650&#34; $SystemType])} {
            regsub -all {\(SSns\)} $parameterList {\\(SSns\\)} parameterList;
            regsub -all {\(SS\)} $parameterList {\\(SS\\)} parameterList;
            regsub -all {\(10G8X\)} $parameterList {\\(10G8X\\)} parameterList;      
            regsub -all {\(40G4X\)} $parameterList {\\(40G4X\\)} parameterList; 
        } elseif {([regexp &#34;480&#34; $SystemName]) || ([regexp &#34;480&#34; $SystemType])} {
            regsub -all {\(SS\)} $parameterList {\\(SS\\)} parameterList;
            regsub -all {\(10G4X\)} $parameterList {\\(10G4X\\)} parameterList;
            regsub -all {\(SS128\)} $parameterList {\\(SS128\\)} parameterList;
        }
    }
    if {([regexp -- {[\/]} $command]) &amp;&amp; ([string match {for file operation:*} $comment]) } {
        <span class="comment-line"># Command is passed as a file, read the file instead</span>
        <span class="comment-line"># of running the command</span>
        if {$reportResults == 1 || $reportFailAsSkip} {
            <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Checking parameters $comment&#34;
        }
        <span class="comment-line"># No time feature supported for command passed as file.</span>
        set sTime 2; set iTime 1; set dTime 1; set fTime 1;       
    } else {
        if {$reportResults == 1 || $reportFailAsSkip} {
            <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Checking &lt;$command&gt; parameters $comment&#34;
        }
    }

    set parameterList [<a name="::_EnhancePioneerParameterList(1)"><a href="./OptionCheck.tcl.html#::_EnhancePioneerParameterList_1375">::_EnhancePioneerParameterList</a></a> $parameterList]
    set parameterList [<a name="::_EnhanceStackingParameterList(1)"><a href="./OptionCheck.tcl.html#::_EnhanceStackingParameterList_1345">::_EnhanceStackingParameterList</a></a> $parameterList]
    foreach itemList $parameterList {
        set key [lindex $itemList 0]
        set valueWanted [lindex $itemList 1]
        set dataArray($key,$valueWanted,found) &#34;keyNotFound&#34;  ;<span class="comment-line">#might have the same key</span>
        set dataArray($key,$valueWanted,flag) &#34;exist&#34;
        if {[lindex $itemList 3] == &#34;notExist&#34;} {set dataArray($key,$valueWanted,flag) &#34;notExist&#34;} 
        if {[lindex $itemList 2] == &#34;notExist&#34;} {set dataArray($key,$valueWanted,flag) &#34;notExist&#34;} 
        if {[lindex $itemList 1] == &#34;notExist&#34;} {set dataArray($key,$valueWanted,flag) &#34;notExist&#34;} 

    }
    <span class="comment-line">#</span>
    <span class="comment-line"># Start loop</span>
    <span class="comment-line">#</span>
    while {!$done} {
        if {([regexp -- {[\/]} $command]) &amp;&amp; ([string match {for file operation:*} $comment]) } {
            set fd_in [open &#34;$command&#34; &#34;r&#34;]
        } else {
            if {$showError== &#34;false&#34;} {
                set numSend 1
            } else {
                set numSend 3
            }
            set fd_in [open &#34;$tmp/tmp_$testNo$pid&#34; &#34;w&#34;]
            if {$nofeep} {
                <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;nofeep&#34; NULL $fd_in
                <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in
                <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;shswitch&#34; NULL $fd_in
            } else {
                if {$bootrom == 1} {
                    SendBootRomCmd &#34;$command&#34; NULL $fd_in
                } else {
                    <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in $showError $numSend
                }
            }
            close $fd_in
            set fd_in [open &#34;$tmp/tmp_$testNo$pid&#34; &#34;r&#34;]
        }
        set previousLine &#34;&#34;
        while {[gets $fd_in line] != -1} {
            set nextLineStart [tell $fd_in]
            <span class="comment-line">#   result_debug &#34;----- Line=|$line|&#34;</span>
            foreach itemList $parameterList {
                set key [lindex $itemList 0]
                set valueWanted [lindex $itemList 1]
                if {[regexp -nocase -indices -- $key $line matchedRange] == 1} {
                    <span class="comment-line">#found the key</span>
                    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Key: |$key| line: |$line| matchedRange: |$matchedRange|&#34;
                    set searchOption [lindex $itemList 2]
                    if {$searchOption == &#34;inLine&#34; } {
                        <span class="comment-line">#this is a quick hack, so it might be confusing</span>
                        set lineOption [lindex $itemList 4]
                        if {$lineOption == &#34;&#34; } { set lineOption 0 }
                        if {$lineOption &gt; 0 } {
                            <span class="comment-line">#get the value on some line after the line where the key is found</span>
                            <span class="comment-line">#this won't work if using the same key</span>
                            for { set i 0 } { $i &lt; $lineOption } { incr i } {
                                gets $fd_in tmpLine
                            }
                            <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wanted line ${lineOption} after key: |$tmpLine|&#34; 
                            <span class="comment-line">#got needed line, backtrack so next key search works</span>
                            seek $fd_in $nextLineStart
                        } elseif {$lineOption == -1 } { 
                            <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wanted the line before key: |$line|&#34; 
                            set tmpLine $previousLine 
                        } else {
                            set tmpLine $line
                        }
                        <span class="comment-line">#value can be anywhere in this line</span>
                        if {[regexp -nocase -- $valueWanted $tmpLine] == 1 } {
                            <span class="comment-line">#value looking for found</span>
                            if {$dataArray($key,$valueWanted,found) == $valueWanted } {
                                <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Multiple Key: |$key| valueFound inLine: |$valueWanted|&#34;
                            } else {
                                set dataArray($key,$valueWanted,found) $valueWanted
                                <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Key: |$key| valueFound inLine: |$valueWanted|&#34;
                            }
                        } else {
                            if {$dataArray($key,$valueWanted,found) == &#34;notExist&#34; } {
                                set dataArray($key,$valueWanted,found) &#34;keyFoundValueNotFound&#34;
                                <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Key: |$key| valueFound in Line: |$dataArray($key,$valueWanted,found)|&#34;
                            }
                        }
                    } elseif {$valueWanted == &#34;exist&#34;} {
                        regexp -nocase -- $key $line pattern
                        <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Key: |$key| found with matched pattern |$pattern|&#34;
                        if {$dataArray($key,$valueWanted,found) == &#34;exist&#34;} {
                            <a name="::result_warning(1)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Multiple key found!!&#34;
                        }           
                        set dataArray($key,$valueWanted,found) &#34;exist&#34;             
                    } elseif { $valueWanted == &#34;notExist&#34; } {
                        regexp -nocase -- $key $line pattern
                        <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Key: |$key| found with matched pattern |$pattern|&#34;
                        set dataArray($key,$valueWanted,found) &#34;exist&#34;             
                    } else {
                        <span class="comment-line">#value is right after key</span>
                        set keyEnd [expr [lindex $matchedRange 1] + 1]
                        set lineAfterKey [string range $line $keyEnd end]
                        <span class="comment-line">#result_debug &#34;lineAfterKey: |$lineAfterKey|&#34;</span>
                        set valueFound [lindex $lineAfterKey 0]
                        if { ([string tolower $valueWanted] == [string tolower $valueFound]) } {
                            if {$dataArray($key,$valueWanted,found) == $valueFound } {
                                <a name="::result_warning(2)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Multiple key found!!&#34;
                            }           
                            set dataArray($key,$valueWanted,found) $valueFound
                            <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Key: |$key| valueFound: |$valueFound|&#34;
                        }
                    }
                } 
            }      
            set previousLine $line   
        }   
        close $fd_in
        file delete &#34;$tmp/tmp_$testNo$pid&#34;
        set returnCode &#34;ok&#34;
        foreach itemList $parameterList {
            set key [lindex $itemList 0]
            set valueWanted [lindex $itemList 1]
            set valueFound $dataArray($key,$valueWanted,found)
            set flag $dataArray($key,$valueWanted,flag)
            if {$flag == &#34;exist&#34;} {
                if { ([string tolower $valueWanted] == [string tolower $valueFound])||$valueWanted==&#34;&#34; } {
                    if {$reportResults == 1} {
                        <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt; pass&#34;
                    } else {
                        <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt; pass&#34;
                    }
                } else {
                    if {$ttime &gt; $fTime} {
                        if {$reportResults == 1} {
                            if {$reportFailAsSkip} {
                                result_skip &#34;Chk key &lt;$key&gt; fail. Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                                if {$FAILSUMMARY != 0} {
                                    lappend FAILSUMMARY &#34;Chk key &lt;$key&gt; fail. Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                                }
                            } else { 
                                <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Chk key &lt;$key&gt; fail. Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                                if {$FAILSUMMARY != 0} {
                                    lappend FAILSUMMARY &#34;Chk key &lt;$key&gt; fail. Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                                }
                            }
                        } else {
                            <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Chk key &lt;$key&gt; fail. Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                        }
                        set returnCode &#34;error&#34;
                    } else {
                        set returnCode &#34;error&#34;
                    }
                }
            } elseif {$flag == &#34;notExist&#34;} {
            if { $valueFound == &#34;keyNotFound&#34;  } { 
                if {$reportResults == 1} {
                    <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; pass&#34;
                } else {
                    <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; pass&#34;
                }
            } else {
                if {$ttime &gt; $fTime} {
                    if {$reportResults == 1} {
                        if {$reportFailAsSkip} {
                            result_skip &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; fail. \
                            Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                            if {$FAILSUMMARY != 0} {
                                lappend FAILSUMMARY &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; fail. \
                                Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34; 
                            }
                        } else {
                            <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; fail. \
                            Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                            if {$FAILSUMMARY != 0} {
                                lappend FAILSUMMARY &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; fail. \
                                Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                            }
                        }
                    } else {
                    <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Chk key &lt;$key&gt; with val &lt;$valueWanted&gt;, flag &lt;$flag&gt; fail. Wanted &lt;$valueWanted&gt; BUTGOT &lt;$valueFound&gt;&#34;
                    }
                    set returnCode &#34;error&#34;
                } else {
                set returnCode &#34;error&#34;
                }
            }   
            } else {
            <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Unexpected flag option&#34;
            set returnCode &#34;error&#34;
            }
        }

        <span class="comment-line"># we want to end the testing if</span>
        <span class="comment-line"># 1) no failures</span>
        <span class="comment-line"># 2) we were not timing this test</span>
        <span class="comment-line"># 3) we exceeded the max time allowed</span>
        <span class="comment-line"># otherwise, we want to increment the time</span>
        if {($returnCode == &#34;ok&#34;) || ($time == &#34;0&#34;) || ($ttime &gt; $fTime)} {
            set done 1
        } else {
            <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;sleeping for $iTime secs...&#34;
            <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;CheckKeyValue sleep: time= $ttime out of $fTime seconds&#34;
            <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $iTime
            set ttime [expr $ttime + $iTime]
        }
        foreach itemList $parameterList {
            set key [lindex $itemList 0]
            set valueWanted [lindex $itemList 1]
            set dataArray($key,$valueWanted,found) &#34;keyNotFound&#34;
        }
    }
    set retTime [expr $ttime-$iTime]   ;<span class="comment-line"># decr back last updated ttime for accuracy</span>
    if {$reportResults == 1 || $reportFailAsSkip} {
        <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
    <span class="comment-line"># -- JSON proc creation cli helper file --</span>
    <a name="::AddToJsonHelperFile(1)"><a href="./cli_conv_helper.tcl.html#::AddToJsonHelperFile_7">::AddToJsonHelperFile</a></a> -time $time -dut $dut -comment $comment -status $returnCode \
         -cmd $command  -parameterList $parameterList -type &#34;check&#34; -testNo $testNo
    return $returnCode
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [GetKeyValue]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Execute a CLI command. The function will return a value specified by an</span>
<span class="comment-line">#  index offset relative to the key found in the output. Optionally a line </span>
<span class="comment-line">#  offset can also be specified.</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#      - &lt;command&gt; - CLI command to execute</span>
<span class="comment-line">#      - &lt;parameterList&gt; - a list of keys to look for values</span>
<span class="comment-line">#                          Note: only support one key right now</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#      - none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - return a list of values found, if a key is not found, then</span>
<span class="comment-line">#        this function will return &#34;KEY_NOT_FOUND[clock seconds]&#34;.</span>
<span class="comment-line">#        A timestamp is attached so this will avoid a bad check by</span>
<span class="comment-line">#        the user to compare two KEY_NOT_FOUNDs</span>
<span class="comment-line">#      </span>
<span class="comment-line">#  [Examples]</span>
<span class="comment-line">#  1. Find a pattern </span>
<span class="comment-line">#     lappend parameterList &#34;abc.*xyz 0&#34;</span>
<span class="comment-line">#     set foundPattern [GetKeyValue &#34;show fdb&#34; $parameterList]</span>
<span class="comment-line">#     -&gt; return a pattern matched with the given key</span>
<span class="comment-line">#</span>
<span class="comment-line">#  2. Find a value in the same line</span>
<span class="comment-line">#     lappend parameterList &#34;key 5&#34;</span>
<span class="comment-line">#     set value [GetKeyValue &#34;show whatever&#34; $parameterList]</span>
<span class="comment-line">#     -&gt; return a value 5 words to the right of the found key</span>
<span class="comment-line">#</span>
<span class="comment-line">#  3. Find a value in the same line</span>
<span class="comment-line">#     lappend parameterList &#34;key -2&#34;</span>
<span class="comment-line">#     set value [GetKeyValue &#34;show this&#34; $parameterList]</span>
<span class="comment-line">#     -&gt; return a value 2 words to the left of the found key</span>
<span class="comment-line">#</span>
<span class="comment-line">#  4. Find a value in a different line</span>
<span class="comment-line">#     lappend parameterList &#34;key 0 2&#34;</span>
<span class="comment-line">#     set value [GetKeyValue &#34;show what&#34; $parameterList]</span>
<span class="comment-line">#     -&gt; return a value 1st word in the line, and the line is </span>
<span class="comment-line">#        2 line below the found key</span>
<span class="comment-line">#  5. Find a value in the same line whose position is not fixed</span>
<span class="comment-line">#     lappend parameterList &#34;key 2 0&#34;</span>
<span class="comment-line">#     set value [GetKeyValue &#34;show what&#34; $parameterList]</span>
<span class="comment-line">#     -&gt; return a value 2nd word in the line, and the line is </span>
<span class="comment-line">#        the line in which the key is found</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifySwitchOutput</span>
<span class="comment-line">################################################################</span>

<strong><a name="::::GetKeyValue_438">proc <a href="OptionCheck.tcl-annot.html#::::GetKeyValue">::::GetKeyValue</a></a></strong> {command parameterList {flag 0} {needWholeLine 0}} {

    global spawn_id

    set tmp &#34;Tmp&#34;
    set pwd [pwd]
    if {[regexp -nocase &#34;clitest&#34; $pwd]} {
        global tmpPath
        set tmp $tmpPath
    }
    set pid _[pid]
    append pid &#34;_&#34;
    set random_number [<a name="::random(2)"><a href="./mysqlLib.tcl.html#::random_1092">::random</a></a> 10000]
    append pid $random_number
    if {([regexp -- {[\/]} $command]) &amp;&amp; ($flag == 0)} {
        <span class="comment-line"># Command is passed as a file, read the file instead</span>
        <span class="comment-line"># of running the command</span>
        set fd_in [open &#34;$command&#34; &#34;r&#34;]
        set jsoncmd &#34;null&#34;
    } else {
        set fd_in [open &#34;$tmp/tmp_GetKeyValue$pid&#34; &#34;w&#34;]
        <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in false
        set jsoncmd $command
        close $fd_in
        set fd_in [open &#34;$tmp/tmp_GetKeyValue$pid&#34; &#34;r&#34;]
    }

    set parameterList [<a name="::_EnhanceStackingParameterList(2)"><a href="./OptionCheck.tcl.html#::_EnhanceStackingParameterList_1345">::_EnhanceStackingParameterList</a></a> $parameterList]

    foreach itemList $parameterList {
        set key [lindex $itemList 0]
        set orgKey $key
        set originalKey $orgKey
        if {[regexp -nocase {\\n} $key]} {
            set key [lindex [split $orgKey \\] 0]
        }
        set slashnKey 0
        while {[gets $fd_in line] != -1} {
            <span class="comment-line">#   result_debug &#34;----- Line=|$line| and key |$key|&#34;</span>
            if {[regexp -nocase -indices -- $key $line matchedRange] == 1} {
                if {[regexp -nocase {\\n} $orgKey]} {
                    set key [string trimleft [lindex [split $orgKey \\] 1] n]
                    set orgKey $key
                    set slashnKey 1
                    continue
                }
                <span class="comment-line">#found the key</span>
                set exactLine $line
                set searchOption [lindex $itemList 2]
                <span class="comment-line">#           result_debug &#34;Key: |$key| line: |$line| matchedRange: |$matchedRange|&#34;</span>
                if {$searchOption &gt;= 0 } {
                    <span class="comment-line">#get the value on some line after the line where the key is found</span>
                    for { set i 0 } { $i &lt; $searchOption } { incr i } {
                        gets $fd_in line2bSearched
                    }
                    if {$searchOption==0} {
                        set line2bSearched $line
                    }
                    <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wanted ${searchOption}th line after key: |$key|&#34; 
                    set indexWanted [expr [lindex $itemList 1]]
                } else {
                    if {[lindex $itemList 1] &gt; 0} {
                        set keyEnd [expr [lindex $matchedRange 1] + 1]
                        set line2bSearched [string range $line $keyEnd end]
                        set indexWanted [expr [lindex $itemList 1] - 1]
                        <span class="comment-line">#result_debug &#34;itemlist $itemList, the keyEnd $keyEnd, line2bSearched $line2bSearched, indexWanted $indexWanted&#34;</span>
                    } elseif {[lindex $itemList 1] &lt; 0} {
                        set keyStart [expr [lindex $matchedRange 0] -1]
                        set line2bSearched [string range $line 0 $keyStart]
                        set indexWanted [expr [llength $line2bSearched] + [lindex $itemList 1]]
                    } else {
                        set keyStart [lindex $matchedRange 0]
                        set keyEnd [lindex $matchedRange 1]
                        set line2bSearched [string range $line $keyStart $keyEnd]
                        set indexWanted 0
                    }
                }
                <span class="comment-line">#result_debug &#34;line2bSearched: |$line2bSearched|&#34;</span>
                if {$needWholeLine == 0} {
                    set valueFound [lindex $line2bSearched $indexWanted]
                    lappend foundList($originalKey) $valueFound
                } else {
                    lappend foundList($originalKey) $exactLine
                }
                <span class="comment-line"># result_debug &#34;Key: |$originalKey| valueFound: |$valueFound| and foundList $foundList($originalKey)&#34;</span>
                if {$slashnKey} {
                    break
                }
            }
        }
        seek $fd_in 0
    }
    close $fd_in
    file delete &#34;$tmp/tmp_GetKeyValue$pid&#34;

    set oldKey &#34;&#34;
    foreach item $parameterList {
        set key [lindex $item 0]
        if {$key!=$oldKey} {
            if {[info exists foundList($key)]} {
                if {[llength $parameterList]==1} {
                    set value2BeReturned $foundList($key)
                } else {
                    lappend value2BeReturned $foundList($key)
                }
            } else {
                lappend value2BeReturned &#34;KEY_NOT_FOUND[clock seconds]&#34;
            }
            set oldKey $key
        }
    }

    if {[info exists value2BeReturned] } { 
        set retVal $value2BeReturned 
    } else { 
        set retVal &#34;KEY_NOT_FOUND[clock seconds]&#34; 
    }
    if {$jsoncmd != &#34;null&#34;} {
        <a name="::AddToJsonHelperFile(2)"><a href="./cli_conv_helper.tcl.html#::AddToJsonHelperFile_7">::AddToJsonHelperFile</a></a> -comment &#34;GetKeyValue&#34; -status $retVal \
            -cmd $jsoncmd  -parameterList $parameterList -type &#34;get&#34;
    }
    return $retVal
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [GetColumnValues]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Execute a CLI command. The function will return a value specified by a</span>
<span class="comment-line">#  lilst of start &amp; end indexes found in the output. Mainly meant for table. </span>
<span class="comment-line">#  parses the table for given indexes and return in a list.</span>
<span class="comment-line">#  It starts parsing from the next line after startKey and ends at the line </span>
<span class="comment-line">#  where stop key is encountered</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#      - &lt;command&gt; - CLI command to execute</span>
<span class="comment-line">#      - &lt;parameterList&gt; - a list of start &amp; end indexes</span>
<span class="comment-line">#                         (This way it supports multiple columns too)</span>
<span class="comment-line">#      - &lt;startkey&gt; - Next line after key is the start of the table. Case sensitive.</span>
<span class="comment-line">#      - &lt;endkey&gt;   - the key before which table parsing ends. Case Sensitive.</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#      - none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns a list of values found for each index pair,</span>
<span class="comment-line">#      </span>
<span class="comment-line">#  [Examples]</span>
<span class="comment-line">#     set foundOneColumnValues [GetColumnValues &#34;show fdb&#34; {{2 4}} $startKey $endKey]</span>
<span class="comment-line">#     -&gt; returns a List of values found in 2nd to 4th loc of each line after</span>
<span class="comment-line">#        key is encountered</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: GetSwitchInfo</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::GetColumnValues_593">proc <a href="OptionCheck.tcl-annot.html#::::GetColumnValues">::::GetColumnValues</a></a></strong> {command ColumnList startkey {endkey &#34; # &#34;}} {

   global spawn_id
   
   set tmp &#34;Tmp&#34;
   set pwd [pwd]
   if {[regexp -nocase &#34;clitest&#34; $pwd]} {
       global tmpPath
       set tmp $tmpPath
   }
   
   set pid _[pid]
   if {[regexp -- {[\/]} $command]} {
      <span class="comment-line"># Command is passed as a file, read the file instead</span>
      <span class="comment-line"># of running the command</span>
      set fd_in [open &#34;$command&#34; &#34;r&#34;]
   } else {
      set fd_in [open &#34;$tmp/tmp_GetColumnValues$pid&#34; &#34;w&#34;]
      <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in
      close $fd_in

      set fd_in [open &#34;$tmp/tmp_GetColumnValues$pid&#34; &#34;r&#34;]
   }
   set value &#34;value&#34;
   set i 0
   
   set keyFound 0
   while {[gets $fd_in line] != -1} {
      if {[regexp -- $startkey $line] == 1} {
         set keyFound 1
         break
      }
   }

   if {$keyFound == 0} {close $fd_in; file delete &#34;$tmp/tmp_GetColumnValues$pid&#34;; return &#34;KEY_NOT_FOUND&#34;}
   set valueList &#34;valueList&#34;
   
   while {[gets $fd_in line] != -1} {

      <span class="comment-line"># break as the endkey encountered</span>
      if {[regexp -- $endkey $line]} {
         break
      }
      
      if {([string length $line]==0) || ([regexp -nocase &#34;^\033&#34; $line])} {
         continue
      }
      <span class="comment-line">#result_debug &#34;----- Line=|$line|&#34;</span>
 
      set i 1

      foreach column $ColumnList {
         set value [string range $line [lindex $column 0] [lindex $column 1]]
         set value [string trimleft $value]
         set value [string trimright $value]
         <span class="comment-line">#result_debug &#34;the line:|$line| and vaule:|$value|&#34;</span>
         lappend valueList$i &#34;$value&#34;
         incr i
      }
   }
   close $fd_in
   file delete &#34;$tmp/tmp_GetColumnValues$pid&#34;
   
   set ColumnValues &#34;&#34;
   for {set count 1} {$count &lt;= [llength $ColumnList]} {incr count} {
      if [info exists $valueList$count] {
         lappend ColumnValues [expr $$valueList$count]
      }
   }
   
   if {[info exists ColumnValues] } {
       <a name="::AddToJsonHelperFile(3)"><a href="./cli_conv_helper.tcl.html#::AddToJsonHelperFile_7">::AddToJsonHelperFile</a></a> -comment &#34;GetColumnyValue&#34; -status \&#34;$ColumnValues\&#34; \
           -cmd $command  -parameterList &#34;&#34; -type &#34;get&#34; 

       return $ColumnValues
   } else {
       <a name="::AddToJsonHelperFile(4)"><a href="./cli_conv_helper.tcl.html#::AddToJsonHelperFile_7">::AddToJsonHelperFile</a></a> -comment &#34;GetColumnValue&#34; -status &#34;KEY_NOT_FOUND&#34; \
           -cmd $command  -parameterList &#34;&#34; -type &#34;get&#34;

       return &#34;KEY_NOT_FOUND&#34;
   }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckPortStat</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Get ports statistic - check the packets sent or received</span>
<span class="comment-line">#              from the ports </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              command - ex &#34;sh port 4 util&#34;</span>
<span class="comment-line">#              check list </span>
<span class="comment-line">#              comment</span>
<span class="comment-line">#              factor </span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              [CheckPortStat $command $checklist]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">################################################################## </span>
<strong><a name="::::CheckPortStat_698">proc <a href="OptionCheck.tcl-annot.html#::::CheckPortStat">::::CheckPortStat</a></a></strong> {command checkList args} {

   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckPortStat $args {
      comment &#34;&#34;
      factor &#34;0.01&#34;
   }

   set port [lindex $command 2]
   <a name="::report_start_test(3)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Checking &lt;$command&gt; statistics $comment&#34;

   global spawn_id
   
   set tmp &#34;Tmp&#34;
   set pwd [pwd]
   if {[regexp -nocase &#34;clitest&#34; $pwd]} {
       global tmpPath
       set tmp $tmpPath
   }
   
   set pid _[pid]
   set fd_in [open &#34;$tmp/tmp_CheckPortStat$pid&#34; &#34;w&#34;]
   <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in
   close $fd_in
   
   <span class="comment-line">#get the maxIndex, so to get the last line with this min list length</span>
   set maxIndex 0
   foreach indexItem $checkList {
      set index [lindex $indexItem 0]
      if {$index &gt; $maxIndex} { set maxIndex $index }
   }
   set fd_in [open &#34;$tmp/tmp_CheckPortStat$pid&#34; &#34;r&#34;]   
   set indexFound -1
   while {[gets $fd_in line] != -1} {
      set index1 [lsearch -exact $line &#34;$port&#34;]
      if {$index1 &gt;= 0} {
         set indexFound $index
         set lineFound $line
         break
      }
   }
   close $fd_in
   file delete &#34;$tmp/tmp_CheckPortStat$pid&#34;
   
   if {$indexFound &gt;= 0} {
      <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found Line: |$lineFound|&#34;
      <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;port: [lindex $lineFound $indexFound]&#34;
      foreach item $checkList {
         set index [lindex $item 0]
         set valueWanted [lindex $item 2]
         set compareFlag [lindex $item 1]
         set valueFound [lindex $lineFound $indexFound]
         switch $compareFlag {
            &#34;min&#34; {
               if {$valueWanted &lt;= $valueFound } {
                  <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking minimum value passed at index $index. Is over $valueWanted. Got $valueFound&#34;
               } else {
                  <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking minimum value failed at index $index. Wanted $valueWanted BUTGOT $valueFound&#34;
               }
            }
            &#34;max&#34; {
               if {$valueWanted &gt; $valueFound } {
                  <a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking maximum value passed at index $index. Is under $valueWanted. Got $valueFound&#34;
               } else {
                  <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking maximum value failed at index $index. Wanted $valueWanted BUTGOT $valueFound&#34;
               }
            }
            &#34;range&#34; {
               set tolerance [expr double ($valueWanted) * $factor]
               if {$valueWanted &gt; $valueFound} {
                   set val [expr abs ($valueWanted - $valueFound )];
               } else {
                   set val [expr abs ($valueFound - $valueWanted)];
               }
               if {$val &lt;= $tolerance } {
                  <a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking range value passed at index $index. Is in range $valueWanted +/- $tolerance. Got $valueFound&#34;
               } else {
                  <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking range value failed at index $index. Wanted $valueWanted +/- $tolerance. BUT GOT $valueFound&#34;
               }
            }
            &#34;exact&#34; -
            default {
               if {$valueWanted == $valueFound } {
                  <a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking exact value passed at index $index. Is exactly $valueWanted. Got $valueFound&#34;
               } else {
                  <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking exact value failed at index $index. Wanted $valueWanted BUTGOT $valueFound&#34;
               }
            }
         }
      }            
   } else {
     <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No data found for port $port&#34;
   }
   <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckPortStatAvg</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Get ports statistic - check the packets sent or received</span>
<span class="comment-line">#              from the ports average by sampling intervals</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              command - ex &#34;sh port 4 statistics&#34;</span>
<span class="comment-line">#              check list </span>
<span class="comment-line">#              - [comment] - text for comment for reference purposes to be </span>
<span class="comment-line">#			put in report.txt</span>
<span class="comment-line">#              - [factor] - tolerance, default 0.1</span>
<span class="comment-line">#              - [interval] - sampling period, default 5 secs</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              [CheckPortStat $command $checklist]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifyTraffic</span>
<span class="comment-line">################################################################## </span>
<strong><a name="::::CheckPortStatAvg_816">proc <a href="OptionCheck.tcl-annot.html#::::CheckPortStatAvg">::::CheckPortStatAvg</a></a></strong> {command checkList args} {

   <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckPortStatAvg $args {
      comment &#34;&#34;
      factor &#34;0.1&#34;
      interval  &#34;10&#34;
   }
   <span class="comment-line">#result_debug &#34;the parsed vals comment $comment, factor $factor, interval $interval&#34;</span>

   set port [lindex $command 2]
   <a name="::report_start_test(4)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Checking &lt;$command&gt; statistics $comment&#34;

   global spawn_id
   
   set tmp &#34;Tmp&#34;
   set pwd [pwd]
   set pid _[pid]

   if {[regexp -nocase &#34;clitest&#34; $pwd]} {
       global tmpPath
       set tmp $tmpPath
   }
   
   
   <span class="comment-line">#get the maxIndex, so to get the last line with this min list length</span>
   set maxIndex 0
   foreach indexItem $checkList {
      set index [lindex $indexItem 0]
      if {$index &gt; $maxIndex} { set maxIndex $index }
   }
   set fd_in1 [open &#34;$tmp/tmp_1CheckPortStat$pid&#34; &#34;w&#34;]
   set fd_in2 [open &#34;$tmp/tmp_2CheckPortStat$pid&#34; &#34;w&#34;]
   global whichDutNow
   set majmin [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${whichDutNow} majmin]
   if {$majmin&gt;=11.3} {
      <a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command no-refresh&#34; NULL $fd_in1
   } else {
      <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in1
   }
   <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $interval
   if {$majmin&gt;=11.3} {
      <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command no-refresh&#34; NULL $fd_in2
   } else {
      <a name="::SendACmd(11)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command&#34; NULL $fd_in2
   }
   close $fd_in1
   close $fd_in2

   set fd_in1 [open &#34;$tmp/tmp_1CheckPortStat$pid&#34; &#34;r&#34;]   
   set fd_in2 [open &#34;$tmp/tmp_2CheckPortStat$pid&#34; &#34;r&#34;]   
   set indexFound1 -1
   while {[gets $fd_in1 line] != -1} {
      set index1 [lsearch -exact $line &#34;$port&#34;]
      if {$index1 &gt;= 0} {
         set indexFound1 $index
         set lineFound1 $line
	 break
      }
   }
   close $fd_in1
   set indexFound2 -1
   while {[gets $fd_in2 line] != -1} {
      if {[regexp -nocase &#34;show ports&#34; $line]} {continue};
      set index2 [lsearch -exact $line &#34;$port&#34;]
      if {$index2 &gt;= 0} {
         set indexFound2 $index
         set lineFound2 $line
	 break
      }
   }
   close $fd_in2
   file delete &#34;$tmp/tmp_1CheckPortStat$pid&#34;
   file delete &#34;$tmp/tmp_2CheckPortStat$pid&#34;

   if {$indexFound1 &gt;= 0} {
      <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found1 Line: |$lineFound1|&#34;
      <a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;port1: [lindex $lineFound1 $indexFound1]&#34;
      set valueFound1 [lindex $lineFound1 $indexFound1]
      <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found2 Line: |$lineFound2|&#34;
      <a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;port2: [lindex $lineFound2 $indexFound2]&#34;
      set valueFound2 [lindex $lineFound2 $indexFound2]
      set valueFound [expr ($valueFound2 - $valueFound1) / $interval]
      foreach item $checkList {
         set index [lindex $item 0]
         set valueWanted [lindex $item 2]
         set compareFlag [lindex $item 1]
         switch $compareFlag {
            &#34;min&#34; {
               if {$valueWanted &lt;= $valueFound } {
                  <a name="::result_ok(7)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking minimum value passed at index $index. Is over $valueWanted. Got $valueFound&#34;
               } else {
                  <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking minimum value failed at index $index. Wanted $valueWanted BUTGOT $valueFound&#34;
               }
            }
            &#34;max&#34; {
               if {$valueWanted &gt; $valueFound } {
                  <a name="::result_ok(8)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking maximum value passed at index $index. Is under $valueWanted. Got $valueFound&#34;
               } else {
                  <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking maximum value failed at index $index. Wanted $valueWanted BUTGOT $valueFound&#34;
               }
            }
            &#34;range&#34; {
               set tolerance [expr double ($valueWanted) * $factor]
               if {$valueWanted &gt; $valueFound} {
                   set val [expr abs ($valueWanted - $valueFound )];
               } else {
                   set val [expr abs ($valueFound - $valueWanted)];
               }
               if {$val &lt;= $tolerance } {
                  <a name="::result_ok(9)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking range value passed at index $index. Is in range $valueWanted +/- $tolerance. Got $valueFound&#34;
               } else {
                  <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking range value failed at index $index. Wanted $valueWanted +/- $tolerance. BUT GOT $valueFound&#34;
               }
            }
            &#34;exact&#34; -
            default {
               if {$valueWanted == $valueFound } {
                  <a name="::result_ok(10)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking exact value passed at index $index. Is exactly $valueWanted. Got $valueFound&#34;
               } else {
                  <a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking exact value failed at index $index. Wanted $valueWanted BUTGOT $valueFound&#34;
               }
            }
         }
      }            
   } else {
     <a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No data found for port $port&#34;
   }
   <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckTopStats</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Check tasks information - task name, task id, CPU or etc  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              check list </span>
<span class="comment-line">#              comment</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              [CheckTopStats $checklist]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">################################################################## </span>
<strong><a name="::::CheckTopStats_965">proc <a href="OptionCheck.tcl-annot.html#::::CheckTopStats">::::CheckTopStats</a></a></strong> {checkList {comment &#34;&#34;}} {

   global spawn_id
   set pid _[pid]
   set fd_in [open &#34;Tmp/tmp_CheckTopStat$pid&#34; &#34;w&#34;]
   <a name="::SendACmd(12)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;top&#34; NULL $fd_in
   close $fd_in

   <span class="comment-line">#get the maxIndex, so to get the last line with this min list length</span>
   set maxIndex 0
   set task &#34;&#34;
   foreach indexItem $checkList {
      set task [lindex $indexItem 0]
   }

   set fd_in [open &#34;Tmp/tmp_CheckTopStat$pid&#34; &#34;r&#34;]   
   set indexFound 0
   set valueWanted 0
   set valueFound 0
   set lineFound &#34;&#34;
   while {[gets $fd_in line] != -1} {
      <span class="comment-line">#result_debug &#34;----- Line=|$line|&#34;</span>
      regsub {H} $line {H } line
      set index [lsearch -exact $line &#34;$task&#34;]
      <span class="comment-line">#get the last complete line, a cheap way of doing this</span>
      if {$index!=-1} {
         set indexFound $index
         set lineFound $line
         regsub -all {[^A-Z^a-z^0-9^_^-^5;01H^:]} $lineFound &#34; &#34; lineFound
         break
      } else {
         continue
      }
   }
   close $fd_in
   file delete &#34;Tmp/tmp_CheckTopStat$pid&#34;
<span class="comment-line">#   result_debug &#34;the indexFound $indexFound and task $task&#34;</span>
   
   set index 6
   set low 0
   set high 0
   if {$indexFound &gt;= 0} {
 <span class="comment-line">#     result_debug &#34;Found Line: |$lineFound|&#34;</span>
 <span class="comment-line">#     result_debug &#34;port: [lindex $lineFound $indexFound]&#34;</span>
     foreach item $checkList {
        set task [lindex $item 0]
        set valueWanted [lindex $item 1]
        scan $valueWanted %d-%d low high
        set valueFound [lindex $lineFound [expr $indexFound + $index]]
        if {$valueFound==&#34;PEND&#34;||$valueFound==&#34;&#34;} {
           set valueFound 0
        }
        <a name="::report_start_test(5)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Checking top statistics for $task range $valueWanted&#34;
        <a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the valueFound $valueFound and valueWanted $valueWanted&#34;
        if {$valueFound&gt;=$low&amp;&amp;$valueFound&lt;=$high} {
           <a name="::result_ok(11)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking range of $low and $high for $task is ok. Wanted $valueWanted, Got $valueFound&#34;
        } else {
           <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Checking range of $low and $high for $task is wrong. Wanted $valueWanted, Got $valueFound&#34;
        }
        <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
      }
   } else {
     <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No data found for top&#34;
   }
}


;<span class="comment-line">#################################################################</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># GetTableValues</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Retrieves column values from the table displayed by the</span>
;<span class="comment-line"># specified command.  GetTableValues takes a list of &#34;queries&#34;</span>
;<span class="comment-line"># (described below) used to match rows in the table.  For each</span>
;<span class="comment-line"># matching row, the column values specified in the query are</span>
;<span class="comment-line"># collected and returned.  If a query matches multiple rows,</span>
;<span class="comment-line"># then the column values for each matching row are collected.</span>
;<span class="comment-line"># See below for more details and an example.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Input variables: Variables in []'s are optional.</span>
;<span class="comment-line">#     command: Specifies the command, to be sent to the current</span>
;<span class="comment-line">#              DUT, that will generate the table to be parsed.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#     queryList: A list of TCL array names specifying a series</span>
;<span class="comment-line">#                of queries.  Each query array must have the</span>
;<span class="comment-line">#                following structure.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                query(searchKey) - Contains a regular experesion</span>
;<span class="comment-line">#                that will be applied to each row in the table.</span>
;<span class="comment-line">#                There are no restrictions on the searchKey, so</span>
;<span class="comment-line">#                care should be exercised to retrieve the proper</span>
;<span class="comment-line">#                rows and columns.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                query(columnRanges) - Contains a list of column</span>
;<span class="comment-line">#                ranges to be collected.  Column ranges can take</span>
;<span class="comment-line">#                one of the following forms.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                    X    Just column X.</span>
;<span class="comment-line">#                    X-   All columns from X until the end.</span>
;<span class="comment-line">#                    X-Y  All columns from X to Y inclusive.</span>
;<span class="comment-line">#                    *    All columns from start to end.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                All column indices are zero-based.  The '*' must</span>
;<span class="comment-line">#                be the first, and only range specified in the</span>
;<span class="comment-line">#                list.  Any ranges after the '*' will be ignored</span>
;<span class="comment-line">#                and the '*' will be ignored if it's not the</span>
;<span class="comment-line">#                first in the list.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                Below is a diagram depicting this structure.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                queryList == {query1 query2 ... queryN}</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                query1(searchKey) == &lt;regexp1&gt;</span>
;<span class="comment-line">#                query1(columnRanges) ==</span>
;<span class="comment-line">#                    {q1colRange1 q1colRange2 ... q1colRangeX}</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                query2(searchKey) == &lt;regexp2&gt;</span>
;<span class="comment-line">#                query2(columnRanges) ==</span>
;<span class="comment-line">#                    {q2colRange1 q2colRange2 ... q2colRangeY}</span>
;<span class="comment-line">#                ...</span>
;<span class="comment-line">#                queryN(searchKey) == &lt;regexpN&gt;</span>
;<span class="comment-line">#                queryN(columnRanges) ==</span>
;<span class="comment-line">#                    {qNcolRange1 qNcolRange2 ... qNcolRangeZ}</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                Where N is the number of queries, and X, Y,</span>
;<span class="comment-line">#                and Z are the number of column ranges for each</span>
;<span class="comment-line">#                respective query.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#     [-dutId &lt;dut=1&gt;]: The DUT on which to execute the command.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#     [-skipStart &lt;lineNo=0&gt;]: Tells GetTableValues to skip the</span>
;<span class="comment-line">#                              first lineNo number of lines</span>
;<span class="comment-line">#                              before parsing.  This is useful</span>
;<span class="comment-line">#                              for skipping over table headings.</span>
;<span class="comment-line">#                              If not specified, no lines are</span>
;<span class="comment-line">#                              skipped.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#     [-stopLine &lt;key=&#34;&#34;&gt;]: Causes GetTableValues to stop parsing</span>
;<span class="comment-line">#                           when it finds a line that matches</span>
;<span class="comment-line">#                           key.  key is a regular expression</span>
;<span class="comment-line">#                           that will be applied to each line.</span>
;<span class="comment-line">#                           If not specified, parsing will</span>
;<span class="comment-line">#                           continue until the end of the table.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#     [SendACmd options]: GetTableValues also accepts any options</span>
;<span class="comment-line">#                         handled by SendACmd.  These options</span>
;<span class="comment-line">#                         will be transparently passed along to</span>
;<span class="comment-line">#                         SendACmd.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Output variables:</span>
;<span class="comment-line">#     queryList: A list of TCL array names specifying a series</span>
;<span class="comment-line">#                of queries.  Data is returned by updating each</span>
;<span class="comment-line">#                query array with the following structure.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                query(columnData) - Contains a list of column</span>
;<span class="comment-line">#                results.  Results are organized into sub-lists.</span>
;<span class="comment-line">#                Each sub-list contains the values for one of the</span>
;<span class="comment-line">#                columns specified in query(columnRanges).  The</span>
;<span class="comment-line">#                sub-lists are in the same order as the specified</span>
;<span class="comment-line">#                column indices, one sublist per column.  All</span>
;<span class="comment-line">#                values are taken from rows that match</span>
;<span class="comment-line">#                query(searchKey).</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                Below is a diagram depicting this structure.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                queryList == {query1 query2 ... queryY}</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                query1(columnData) == {list1 list2 ... listN}</span>
;<span class="comment-line">#                list1 == {l1val1 l1val2 ... l1valX}</span>
;<span class="comment-line">#                list2 == {l2val1 l2val2 ... l2valX}</span>
;<span class="comment-line">#                ...</span>
;<span class="comment-line">#                listN == {lNval1 lNval2 ... lNvalX}</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#                Where N is the total number of columns specified</span>
;<span class="comment-line">#                by query(columnRanges) and X is the total</span>
;<span class="comment-line">#                number of rows that match query(searchKey).</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Return value: None.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Example: Assume the command &#34;printThis&#34; creates the following</span>
;<span class="comment-line"># output.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># First  Second  Third            Fourth</span>
;<span class="comment-line"># --------------------------------------</span>
;<span class="comment-line"># 1      --a-X-  4.3.6.251            72</span>
;<span class="comment-line"># 2      --a---  7.1.1.1             242</span>
;<span class="comment-line"># 3      ---L--  12.98.62.35           0</span>
;<span class="comment-line"># 4      r-a---  1.6.7.3              15</span>
;<span class="comment-line"># --------------------------------------</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Then this code snippet:</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># set aflag(searchKey) &#34;a&#34;</span>
;<span class="comment-line"># set aflag(columnRanges) &#34;1 3&#34;</span>
;<span class="comment-line"># set row3(searchKey) &#34;^3&#34;</span>
;<span class="comment-line"># set row3(columnRanges) &#34;2-3&#34;</span>
;<span class="comment-line"># set Xflag(searchKey) &#34;X&#34;</span>
;<span class="comment-line"># set Xflag(columnRanges) &#34;1-&#34;</span>
;<span class="comment-line"># set subnet1.6(searchKey) &#34;1\.6\.[0-9]+\.[0-9]+&#34;</span>
;<span class="comment-line"># set subnet1.6(columnRanges) &#34;*&#34;</span>
;<span class="comment-line"># set qList {aflag row3 Xflag subnet1.6}</span>
;<span class="comment-line"># GetTableValues &#34;printThis&#34; $qList -skipStart 2 -stopLine &#34;^-*&#34;</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Will produce the following results:</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># aflag(columnData) == {{--a-X- --a--- r-a---} {72 242 15}}</span>
;<span class="comment-line"># row3(columnData) == {{12.98.62.35} {0}}</span>
;<span class="comment-line"># Xflag(columnData) == {{--a-X-} {4.3.6.251} {72}}</span>
;<span class="comment-line"># subnet1.6(columnData) == {{4} {r-a---} {1.6.7.3} {15}}</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Note: Even though the pattern for -stopLine matches two lines,</span>
;<span class="comment-line"># the first match will be ignored because that line is skipped</span>
;<span class="comment-line"># by -skipStart.</span>
;<span class="comment-line">#</span>
;<span class="comment-line">#################################################################</span>
<strong><a name="::::GetTableValues_1180">proc <a href="OptionCheck.tcl-annot.html#::::GetTableValues">::::GetTableValues</a></a></strong> {command queryList args} {
    set otherArgs [<a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> -noComplain GetTableValues $args {
        dutId     1
        skipStart 0
        stopLine  &#34;&#34;
    }]

    set skipLine 0

    ;<span class="comment-line"># Create a temporary file to hold the output of the command.</span>
    set tmpName &#34;Tmp/tmp_GetTableRows_[pid]&#34;
    set fd_in [open $tmpName w+]
    
    ;<span class="comment-line"># eval needs to be used to break up $otherArgs into</span>
    ;<span class="comment-line"># separate arguments for SendACmd.  Otherwise, the list</span>
    ;<span class="comment-line"># gets passed as a single argument.  Also, SendACmd and its</span>
    ;<span class="comment-line"># first four arguments are quoted with curly-braces so that</span>
    ;<span class="comment-line"># $command gets passed as a single argument.</span>
    eval {<a name="::SendACmd(13)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> $command NULL $fd_in true} $otherArgs
    flush $fd_in

    ;<span class="comment-line"># Rewind the file and begin reading lines.</span>
    seek $fd_in 0
    set stopped 0
    while {[gets $fd_in rawLine] != -1} {
        ;<span class="comment-line"># Filter out all the screen control escape sequences.</span>
        ;<span class="comment-line"># The ESC[0X;1H sequence moves the cursor to the start</span>
        ;<span class="comment-line"># of line X.  Instead of just filtering these out, we</span>
        ;<span class="comment-line"># substitute newlines, which allows us to split the</span>
        ;<span class="comment-line"># &#34;raw&#34; line down into the real screen lines.</span>
        regsub -all -nocase {\[0[0-9]*;1H} $rawLine \n rawLine
        regsub -all -nocase {\[2J} $rawLine {} rawLine
        regsub -all -nocase {\[K} $rawLine {} rawLine

        ;<span class="comment-line"># Split the raw line into screen lines.  Sometimes,</span>
        ;<span class="comment-line"># the first list element may be blank.  This is not a</span>
        ;<span class="comment-line"># real blank line, just an artifact of the substitutions</span>
        ;<span class="comment-line"># above, so we need to remove it.</span>
        set lineList [split $rawLine \n]
        if {[lindex $lineList 0] == {}} {
            set lineList [lrange $lineList 1 end]
        }

        ;<span class="comment-line"># Process the &#34;cooked&#34; lines.</span>
        foreach line $lineList {
            ;<span class="comment-line"># Skip the first $skipStart lines.</span>
            if {$skipLine &lt; $skipStart} {
                incr skipLine
                continue
            }

            ;<span class="comment-line"># Check if we should stop.</span>
            if {$stopLine != &#34;&#34; &amp;&amp; [regexp -- $stopLine $line]} {
                set stopped 1
                break
            }

            ;<span class="comment-line"># Run the line through all the queries.</span>
            foreach queryName $queryList {
                upvar $queryName query

                ;<span class="comment-line"># Initialize the columnData list.</span>
                if {![info exists query(columnData)]} {
                    set query(columnData) {}
                }

                ;<span class="comment-line"># See if this query matches.</span>
                if {![regexp -- $query(searchKey) $line]} {
                    continue
                }

                ;<span class="comment-line"># It matched, so extract the column values.</span>
                set resultPtr 0
                foreach columnRange $query(columnRanges) {
                    set matched &#34;&#34;
                    set start &#34;&#34;
                    set end &#34;&#34;

                    ;<span class="comment-line"># matched contains the matching string</span>
                    ;<span class="comment-line"># start contains the first number in the range</span>
                    ;<span class="comment-line"># end contains the second number in the range</span>
                    if {![regexp {^([0-9]+)-?([0-9]*)$|^\*$} $columnRange matched start end]} {
                        continue
                    }

                    ;<span class="comment-line"># Look for asterisk.</span>
                    if {$matched == &#34;*&#34;} {
                        ;<span class="comment-line"># Asterisk must be the first column specifier.</span>
                        if {$resultPtr != 0} {
                            continue
                        }
                        set start 0
                    }

                    ;<span class="comment-line"># Check for asterisk or open-ended range.</span>
                    if {$end == &#34;&#34;} {
                        set end [expr [llength $line] - 1]
                    }

                    ;<span class="comment-line"># Collect the column data.</span>
                    for {set i $start} {$i &lt;= $end} {incr i; incr resultPtr} {
                        ;<span class="comment-line"># Get existing column data, if any, and tack next value</span>
                        ;<span class="comment-line"># onto the end.</span>
                        set tmp [lindex $query(columnData) $resultPtr]
                        lappend tmp [lindex $line $i]

                        ;<span class="comment-line"># Are we replacing an existing column value list?</span>
                        if {$resultPtr &lt; [llength $query(columnData)]} {
                            ;<span class="comment-line"># Yes, replace the old list with the new one.</span>
                            set query(columnData) [lreplace $query(columnData) $resultPtr $resultPtr $tmp]
                        } else {
                            ;<span class="comment-line"># No, tack column value list onto the end of the other</span>
                            ;<span class="comment-line"># value lists.</span>
                            lappend query(columnData) $tmp
                        }
                    }

                    ;<span class="comment-line"># If asterisk is found, skip other column specifiers.</span>
                    if {$matched == &#34;*&#34;} {
                        break
                    }
                } ;<span class="comment-line"># foreach columnRange</span>
            } ;<span class="comment-line"># foreach query</span>
        } ;<span class="comment-line"># foreach line</span>
        
        ;<span class="comment-line"># -stopLine matched something, so stop parsing.</span>
        if {$stopped} {
            break
        }
    } ;<span class="comment-line"># while</span>
    close $fd_in
    file delete $tmpName
} ;<span class="comment-line"># GetTableValues</span>


;<span class="comment-line">#################################################################</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># AllZeros</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Determines if all the values in a list are zero.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Input variables: Variables in []'s are optional.</span>
;<span class="comment-line">#     valueList: A list of numerical values.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Output variables: None.</span>
;<span class="comment-line">#</span>
;<span class="comment-line"># Return value:</span>
;<span class="comment-line">#     1 if all values in valueList are zero.</span>
;<span class="comment-line">#     0 otherwise.</span>
;<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
;<span class="comment-line">#################################################################</span>
<strong><a name="::::AllZeros_1334">proc <a href="OptionCheck.tcl-annot.html#::::AllZeros">::::AllZeros</a></a></strong> {valueList} {
    foreach value $valueList {
        if {$value != 0} {
            return 0
        }
    }

    return 1
}


<strong><a name="::::_EnhanceStackingParameterList_1345">proc <a href="OptionCheck.tcl-annot.html#::::_EnhanceStackingParameterList">::::_EnhanceStackingParameterList</a></a></strong> {parameter} {
   global whichDutNow
   global stacking
   if {![info exists whichDutNow]} {
      set whichDutNow 1
   }
   set platform [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]
   set praramToReturn $parameter
   if  {[regexp -nocase $platform &#34;$stacking&#34;]} {
          global DUT${whichDutNow}_Stacking_msmb_slot DUT${whichDutNow}_Stacking_msma_slot
         if {[regexp -nocase &#34;msm-a&#34; $parameter]} {
                if [info exists DUT${whichDutNow}_Stacking_msma_slot] {
                      regsub -all -nocase &#34;msm-a&#34; $parameter &#34;slot-[set DUT${whichDutNow}_Stacking_msma_slot]&#34; praramToReturn
                }
          } 
         if {[regexp -nocase &#34;msm-b&#34; $praramToReturn] } {
                if [info exists DUT${whichDutNow}_Stacking_msmb_slot] {
                      regsub -all -nocase &#34;msm-b&#34; $praramToReturn &#34;slot-[set DUT${whichDutNow}_Stacking_msmb_slot]&#34; praramToReturn
                 }
          }

         if {[regexp -nocase &#34;BACKUP \\.\\*In \\*Sync\\. \\*MASTER&#34; $praramToReturn]} {
                if [info exists DUT${whichDutNow}_Stacking_msma_slot] {
                      regsub -all -nocase &#34;BACKUP \\.\\*In \\*Sync\\. \\*MASTER&#34; $praramToReturn &#34;MASTER \*BACKUP \.\*In \*Sync&#34; praramToReturn
                 }
          }
   }
   return $praramToReturn
}

<strong><a name="::::_EnhancePioneerParameterList_1375">proc <a href="OptionCheck.tcl-annot.html#::::_EnhancePioneerParameterList">::::_EnhancePioneerParameterList</a></a></strong> {parameter} {
   global DUTs_info
   global whichDutNow
   global pioneerPlatform
   set praramToReturn $parameter
   if {([info exists DUTs_info(DUT${whichDutNow},platform)] ) } {
      if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
<span class="comment-line">#do nothing here replacement will be done in the end</span>
      } else {
      return $praramToReturn
      }
   } else {
        set pList &#34;&#34;;
        lappend pList &#34;{^SysName:} 1&#34;;
        set SystemName [<a name="::GetKeyValue(3)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $pList]
        unset pList;

         set pList &#34;&#34;;
         lappend pList &#34;{^System Type:} 1&#34;;
         set SystemType [<a name="::GetKeyValue(4)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $pList]
         unset pList;

       if {([regexp &#34;BD-20808|BD-16808|BD-20804|BD-X8&#34; $SystemName]) || ([regexp &#34;BD-20808|BD-16808|BD-20804|BD-X8&#34; $SystemType])} {
<span class="comment-line">#do nothing here replacement will be done in the end</span>
     } else {
      return $praramToReturn
     }
   }
   if {[regexp -nocase &#34;msm-a&#34; $parameter]} {
         regsub -all -nocase &#34;msm-a&#34; $parameter &#34;mm-a&#34; praramToReturn
   } 
   if {[regexp -nocase &#34;msm-b&#34; $praramToReturn]} {
         regsub -all -nocase &#34;msm-b&#34; $praramToReturn &#34;mm-b&#34; praramToReturn
   }
   return $praramToReturn
}

<span class="comment-line">#################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line"># WaitForValues</span>
<span class="comment-line">#</span>
<span class="comment-line"># Retrieve a value from a command's output using a key-value search pair, and</span>
<span class="comment-line"># polls the output until that value stabilizes or a timer expires.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input variables: Variables in []'s are optional.</span>
<span class="comment-line">#     cmd</span>
<span class="comment-line">#       Command to be executed on the DUT.</span>
<span class="comment-line">#</span>
<span class="comment-line">#     searchList</span>
<span class="comment-line">#       A list of key-value pairs to search for.  See the description for the</span>
<span class="comment-line">#       GetKeyValue function for details on the format of key-value pairs.</span>
<span class="comment-line">#</span>
<span class="comment-line">#     [-comment &lt;text&gt;]</span>
<span class="comment-line">#       Descriptive text to be included in the test transcript.  Default is</span>
<span class="comment-line">#       blank.</span>
<span class="comment-line">#</span>
<span class="comment-line">#     [-dut &lt;num&gt;]</span>
<span class="comment-line">#       DUT on which command should be executed.  Default is DUT 1.</span>
<span class="comment-line">#</span>
<span class="comment-line">#     [-reportResults &lt;bool&gt;]</span>
<span class="comment-line">#       Indicates whether to report results as an official sub-test.  Default</span>
<span class="comment-line">#       is true.</span>
<span class="comment-line">#</span>
<span class="comment-line">#     [-timer &lt;time_struct&gt;]</span>
<span class="comment-line">#       Parameters for controlling initial delay, interval, and time-out.</span>
<span class="comment-line">#       The structure is a TCL list or string with the following format:</span>
<span class="comment-line">#</span>
<span class="comment-line">#           start: &lt;sec&gt; interval: &lt;sec&gt; fail: &lt;sec&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line">#       Where &lt;sec&gt; is a positive integer value measuring seconds.  The fail</span>
<span class="comment-line">#       time must be longer than the start time.</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output variables: None.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value:</span>
<span class="comment-line">#       A list containing the values returned by GetKeyValue.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifySwitchOutput</span>
<span class="comment-line">#################################################################</span>
<strong><a name="::::WaitForValues_1457">proc <a href="OptionCheck.tcl-annot.html#::::WaitForValues">::::WaitForValues</a></a></strong> {cmd searchList args} {
    <span class="comment-line"># Validate the arguments.</span>
    if {$cmd == &#34;&#34;} {
        error &#34;WaitForValues: Invalid format for command $cmd.&#34;;
    }
    if {$searchList == &#34;&#34;} {
        error &#34;WaitForValues: Invalid format for search list $searchList.&#34;;
    }

    <a name="::parse_args(5)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckKeyValue $args {
        comment       &#34;&#34;
        dut           1
        reportResults 1
        timer         &#34;&#34;
    }

    if {![<a name="::IsInteger(1)"><a href="./misc.tcl.html#::IsInteger_2157">::IsInteger</a></a> $dut] || $dut &lt; 1} {
        error &#34;WaitForValues: Invalid format for DUT number, $dut.&#34;;
    }
    if {!([<a name="::IsTrue(1)"><a href="./misc.tcl.html#::IsTrue_2185">::IsTrue</a></a> $reportResults] || [<a name="::IsFalse(1)"><a href="./misc.tcl.html#::IsFalse_2214">::IsFalse</a></a> $reportResults])} {
        error &#34;WaitForValues: Invalid format for result reporting flag, $reportResults.&#34;;
    }

    set startTime 0;
    set interval 1;
    set failTime 1;

    if {[llength $timer] == 6} {
        set startTime [lindex $timer 1];
        set interval [lindex $timer 3];
        set failTime [lindex $timer 5];

        if {![<a name="::IsInteger(2)"><a href="./misc.tcl.html#::IsInteger_2157">::IsInteger</a></a> $startTime] || $startTime &lt; 0} {
            error &#34;WaitForValues: Invalid format for start time, $startTime.&#34;;
        }
        if {![<a name="::IsInteger(3)"><a href="./misc.tcl.html#::IsInteger_2157">::IsInteger</a></a> $interval] || $interval &lt; 0} {
            error &#34;WaitForValues: Invalid format for interval, $interval.&#34;;
        }
        if {![<a name="::IsInteger(4)"><a href="./misc.tcl.html#::IsInteger_2157">::IsInteger</a></a> $failTime] || $failTime &lt; $startTime} {
            error &#34;WaitForValues: Invalid format for failure time, $failTime, or failure time less than start time $startTime.&#34;;
        }
    }

    <span class="comment-line"># Set up the reporting functions.</span>
    if {$reportResults} {
        set rStart report_start_test;
        set rOk result_ok;
        set rFail result_error;
        set rEnd report_end_test;
    } else {
        set rStart result_debug;
        set rOk result_debug;
        set rFail result_debug;
        set rEnd &#34;&#34;;
    }

    $rStart &#34;Waiting for $cmd to stabilize: $comment&#34;;

    <a name="::exSleep(4)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $startTime;

    <span class="comment-line"># Get the initial value set, and then start polling.  Each time through</span>
    <span class="comment-line"># loop, the last iteration's $newValues becomes the current iteration's</span>
    <span class="comment-line"># $values.</span>
    set values &#34;&#34;;
    set newValues [<a name="::GetKeyValue(5)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> $cmd $searchList];
    set timer $startTime;
    while {$values != $newValues} {
        <a name="::exSleep(5)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $interval;

        set values $newValues;
        set newValues [<a name="::GetKeyValue(6)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> $cmd $searchList];

        incr timer $interval;
        if {$timer &gt;= $failTime} {
            break;
        }
    }

    if {$timer &gt;= $failTime} {
        $rFail &#34;Results not stable after $timer seconds.&#34;;
        <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Second to last result = $values&#34;;
        <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Last result = $newValues&#34;;
    } else {
        $rOk &#34;Results stabilized after $timer seconds.&#34;;
        <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stable result = $newValues&#34;;
    }
    if {$rEnd != &#34;&#34;} {
    	  $rEnd;
    }
    return $newValues;
}

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
