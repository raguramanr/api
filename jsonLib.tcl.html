<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>jsonLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#jsonLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>jsonLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="jsonLib.tcl-annot.html">annotations</a> | <a href="jsonLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
package require json::write
package require json
package require base64 ;<span class="comment-line"># tcllib</span>
package forget http 1.0
package require http   ;<span class="comment-line"># tcl</span>
<span class="comment-line">###############################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Function to get json output from a cli command in.</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::json_get_12">proc <a href="jsonLib.tcl-annot.html#::::json_get">::::json_get</a></a></strong> {args} {
    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> json_get $args {
        url  &#34;null&#34;
        username &#34;admin&#34;
        password &#34;&#34;
        ssl &#34;false&#34;
        cmd &#34;show vlan&#34;
        method &#34;cli&#34;
        retval &#34;all&#34;
    }

    set auth &#34;Basic [base64::encode $username:$password]&#34;
    puts $auth
    set headerl [list Authorization $auth]
    puts $headerl
    puts $cmd
    if { $ssl == &#34;true&#34; } {
        package require tls
        ::http::register https 443 ::tls::socket
    }
    set query &#34;\&#34;jsonrpc\&#34;:\&#34;2.0\&#34;,\&#34;method\&#34;:\&#34;$method\&#34;,\&#34;params\&#34;:\[\&#34;$cmd\&#34;\],\&#34;id\&#34;:\&#34;1\&#34;&#34;
    puts &#34;The JSON Query is $query&#34;
    set http_mime &#34;application/json&#34;
    set tok [http::geturl $url -headers $headerl -query \{$query\} -type $http_mime]
    http::wait $tok
    puts $tok
    upvar #0 $tok state
    set res0 [http::data $tok]
    set res1 [::http::code $tok]
    set res2 [::http::error $tok]
    <span class="comment-line">#puts &#34;The Output is  $res0&#34;</span>
    <span class="comment-line">#puts &#34;The HTTP Code Received is $res1&#34;</span>
    <span class="comment-line">#puts &#34;The HTTP Error if any is $res2&#34;</span>
    http::cleanup $tok
    if {$retval == &#34;data&#34;} {
        return $res0
    } elseif {$retval == &#34;code&#34;} {
        return $res1
    } elseif {$retval == &#34;error&#34;} {
        return $res2
    } else {
        return [list $res0 $res1 $res2]
    }
}

<span class="comment-line">#############################################################################</span>
<span class="comment-line"># Procedure Name: CheckJSONKeyValue</span>
<span class="comment-line">#</span>
<span class="comment-line"># Similar to checkKeyValue, but makes a JSONRPC request to the mgmt interface</span>
<span class="comment-line">#   on a switch and checks a parameterList to match expected outputs</span>
<span class="comment-line">#</span>
<span class="comment-line"># Example</span>
<span class="comment-line">#     set parameterList &#34;&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{CLIoutput} exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports 0]  exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports 2]  exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports [expr $num_port - 2]] exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports [expr $num_port - 1]] exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{status} SUCCESS exist&#34;</span>
<span class="comment-line">#     CheckJSONKeyValue -cmd $com -parameterList $parameterList -debugjson &#34;false&#34;</span>
<span class="comment-line">#     unset parameterList</span>
<span class="comment-line">#############################################################################</span>
<strong><a name="::::CheckJSONKeyValue_74">proc <a href="jsonLib.tcl-annot.html#::::CheckJSONKeyValue">::::CheckJSONKeyValue</a></a></strong> {args} {
    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckJSONKeyValue $args {
        cmd &#34;&#34;
        parameterList &#34;&#34;
        username  &#34;admin&#34;
        password  &#34;&#34;
        ssl       &#34;false&#34;
        method    &#34;cli&#34;
        retval    &#34;all&#34;
        debugjson &#34;false&#34;
        debugdict  &#34;false&#34;
    }

    global whichDutNow
    global DUT${whichDutNow}_IP

    set rVal 1
    set ip [set DUT${whichDutNow}_IP]

    set output [<a name="::json_get(1)"><a href="./jsonLib.tcl.html#::json_get_12">::json_get</a></a> -url &#34;http://$ip/jsonrpc/&#34; -cmd $cmd -retval &#34;data&#34; -username $username \
             -password $password -ssl $ssl  -method $method]

    if {$debugjson != &#34;false&#34;} {
        puts &#34;\n\nJSON Returned Output:\n$output\n\n&#34;
    }

    set parsed [json::json2dict $output]
    if {$debugdict != &#34;false&#34;} {
        puts &#34;\n\nJSON to Dictionary:\n$parsed\n\n&#34;
    }    
    if {[catch {dict get $parsed result} psmall]} {
        puts &#34;Error getting dictionary path - $psmall&#34;
    } else {
        foreach para $parameterList {
            <span class="comment-line">#puts &#34;Test $para&#34;</span>
            <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;CheckJsonValue $para&#34;
            set pPass 0
            foreach ele $psmall {
                if {![catch {dict keys $ele} why]} {
                    set keyLen [llength [lindex $para 0]]
                    switch $keyLen {
                    4 {
                        if {[catch {dict get $ele [lindex [lindex $para 0] 0] [lindex [lindex $para 0] 1] [lindex [lindex $para 0] 2] [lindex [lindex $para 0] 3]} outVal]} {
                            <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                        } else {
                            <span class="comment-line">#puts &#34;Found keys 4&#34;</span>
                            if {[lindex $para 1] == $outVal || [lindex $para 1] == &#34;exist&#34;} {
                                <span class="comment-line">#puts &#34;Got plist $portlist&#34;</span>
                                set pPass 1
                            }
                        }
                    }
                    3 {
                        if {[catch {dict get $ele [lindex [lindex $para 0] 0] [lindex [lindex $para 0] 1] [lindex [lindex $para 0] 2]} outVal]} {
                            <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                        } else {
                            <span class="comment-line">#puts &#34;Found keys 3&#34;</span>
                            if {[lindex $para 1] == $outVal || [lindex $para 1] == &#34;exist&#34;} {
                                <span class="comment-line">#puts &#34;Got plist $portlist&#34;</span>
                                set pPass 1
                            }
                        }
                    }
                    2 {
                        if {[catch {dict get $ele [lindex [lindex $para 0] 0] [lindex [lindex $para 0] 1]} outVal]} {
                            <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                        } else {
                            <span class="comment-line">#puts &#34;Found keys 2 $outVal&#34;</span>
                            if {[lindex $para 1] == $outVal || [lindex $para 1] == &#34;exist&#34;} {
                                <span class="comment-line">#puts &#34;Got plist $outVal&#34;</span>
                                set pPass 1
                            }
                        }
                    }
                    1 {
                        if {[catch {dict get $ele [lindex [lindex $para 0] 0]} outVal]} {
                            <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                        } else {
                            <span class="comment-line">#puts &#34;Found keys 1&#34;</span>
                            if {[lindex $para 1] == $outVal || [lindex $para 1] == &#34;exist&#34;} {
                                <span class="comment-line">#puts &#34;Got plist $portlist&#34;</span>
                                set pPass 1
                            }
                        }
                    }
                   }
                }
            }
            if {$pPass &amp;&amp; [lindex $para 2] == &#34;exist&#34;} {
                <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Value [lindex $para 1] exists &#34;
            } elseif {$pPass &amp;&amp; [lindex $para 2] == &#34;notExist&#34;} {
                <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;[lindex $para 1] exists when notExist expected&#34;
                set rVal 0
            } elseif {!$pPass &amp;&amp; [lindex $para 2] == &#34;exist&#34;} {
                <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;[lindex $para 1] not found when expected&#34;
                set rVal 0
            } elseif {!$pPass &amp;&amp; [lindex $para 2] == &#34;exist&#34;} {
                <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;[lindex $para 1] not found as expected&#34;
            } elseif {$pPass &amp;&amp; [lindex $para 1] == &#34;exist&#34;} {
                <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Key [lindex $para 0] exists as expected&#34;
            } elseif {$pPass &amp;&amp; [lindex $para 1] == &#34;notExist&#34;} {
                <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Key [lindex $para 0] exists when notExist expected&#34;
                set rVal 0
            } elseif {!$pPass &amp;&amp; [lindex $para 1] == &#34;notExist&#34;} {
                <a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Key [lindex $para 0] notExist as expected&#34;
            } else {
                <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Not sure what happened&#34;
                set rVal 0
            }
            <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
        }
    }
    return $rVal
}
<span class="comment-line">##</span>
<span class="comment-line">##</span>
<span class="comment-line">##  Below are works in progress</span>
<span class="comment-line">##</span>
<span class="comment-line">##</span>
<strong><a name="::::getDictItem_193">proc <a href="jsonLib.tcl-annot.html#::::getDictItem">::::getDictItem</a></a></strong> {dictVal k v} {
    puts &#34;check exists $k&#34;
    if {[dict exist $dictVal $k]} {
        puts &#34;get value $k&#34;
        set keyVal [dict get $dictVal $k]
        puts &#34;keyVal = $keyVal&#34;
        if {0} {
            return 1
        }
    }
    return 0
}
<strong><a name="::::dumpPairs_205">proc <a href="jsonLib.tcl-annot.html#::::dumpPairs">::::dumpPairs</a></a></strong> {d} {

    set keyPaths &#34;&#34;
    set i 0
    if [catch {dict keys $d} why] {
        puts &#34;This dictionary is a mess. $why&#34;
        return;
    }
    dict for {k v} $d {
        set keyPath &#34;&#34;
        <span class="comment-line">#puts &#34;\nKEY - $k\nVALUE $v&#34;</span>
        set keyPath [<a name="::_printJPath(1)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k $v $keyPath 1]
        if ![catch {dict keys $k} why] {
            dict for {k1 v1} $k {
                <span class="comment-line">#puts &#34;\nKEY - $k1\nVALUE $v1&#34;</span>
                set keyPath [<a name="::_printJPath(2)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k1 $v1 $keyPath 2]
                if ![catch {dict keys $k1} why] {
                    dict for {k2 v2} $k1 {
                        set keyPath [<a name="::_printJPath(3)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k2 $v2 $keyPath 3]
                        <span class="comment-line">#puts &#34;\nKEY - $k2\nVALUE $v2&#34;</span>
                        if ![catch {dict keys $k2} why] {
                            dict for {k3 v3} $k2 {
                                <span class="comment-line">#puts &#34;\nKEY - $k3\nVALUE $v3&#34;</span>
                                set keyPath [<a name="::_printJPath(4)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k3 $v3 $keyPath 4]
                            }
                        }
                        if ![catch {dict keys $v2} why] {
                            dict for {k3 v3} $v2 {
                                <span class="comment-line">#puts &#34;\nVALDICT - $k3\nVALUE $v3&#34;</span>
                                set keyPath [<a name="::_printJPath(5)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k3 $v3 $keyPath 4]
                            }
                        }
                    }
                }
                if ![catch {dict keys $v1} why] {
                    dict for {k2 v2} $v1 {
                        <span class="comment-line">#puts &#34;\nVALDICT - $k2\nVALUE $v2&#34;</span>
                        set keyPath [<a name="::_printJPath(6)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k2 $v2 $keyPath 3]
                        if ![catch {dict keys $k2} why] {
                            dict for {k3 v3} $k2 {
                                set keyPath [<a name="::_printJPath(7)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k3 $v3 $keyPath 4]
                                <span class="comment-line">#puts &#34;\nVALKEY - $k3\nVALUE $v3&#34;</span>
                            }
                        }
                        if ![catch {dict keys $v2} why] {
                            dict for {k3 v3} $v2 {
                                set keyPath [<a name="::_printJPath(8)"><a href="./jsonLib.tcl.html#::_printJPath_261">::_printJPath</a></a> $k3 $v3 $keyPath 4]
                                <span class="comment-line">#puts &#34;\nVAL2DICT - $k3\nVALUE $v3&#34;</span>
                            }
                        }
                    }
                }
            }
        }
    }
}
<strong><a name="::::_printJPath_261">proc <a href="jsonLib.tcl-annot.html#::::_printJPath">::::_printJPath</a></a></strong> {a b keyPath lev} {
    if {[llength $a] == 1} {
        lappend keyPath $a
        if {[llength $b] == 1} {
            puts &#34;Path - $keyPath VALUE: $b&#34;
            if {$lev &lt;= 2} {
                set keyPath &#34;&#34;
            } elseif {$lev == 3} {
                set keyPath &#34;[lindex $keyPath 0]&#34;
            } elseif {$lev == 4} {
                set keyPath &#34;[lindex $keyPath 0] [lindex $keyPath 1]&#34;
            } else {
                set keyPath &#34;&#34;
            }
        }
    }
    return $keyPath
}
<span class="comment-line">#######################################################################</span>
<span class="comment-line"># Procedure: array_dimnames</span>
<span class="comment-line">#</span>
<span class="comment-line"># Utility like array names to return all names from an index in a</span>
<span class="comment-line">#    multi-dimensional array</span>
<span class="comment-line">#</span>
<span class="comment-line">#    set keyList [array_dimnames DUTs_info 1]</span>
<span class="comment-line">#######################################################################</span>
<strong><a name="::::array_dimnames_287">proc <a href="jsonLib.tcl-annot.html#::::array_dimnames">::::array_dimnames</a></a></strong> {array_var dim_index} {
    upvar 1 $array_var array
    set result [list]
    foreach name [lsort -unique -index $dim_index [array names array]] {
        lappend result [lindex $name $dim_index]
    }
    return $result
}
<span class="comment-line">#############################################################################</span>
<span class="comment-line"># Procedure Name: CheckDictValue</span>
<span class="comment-line">#</span>
<span class="comment-line"># Similar to checkKeyValue, but makes a JSONRPC request to the mgmt interface</span>
<span class="comment-line">#   on a switch and checks a parameterList to match expected outputs</span>
<span class="comment-line">#</span>
<span class="comment-line">#     set parameterList &#34;&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{CLIoutput} exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports 0]  exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports 2]  exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports [expr $num_port - 2]] exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{show_ports_info_detail port} [lindex $ports [expr $num_port - 1]] exist&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{status} SUCCESS exist&#34;</span>
<span class="comment-line">#     CheckDictValue -cmd $com -parameterList $parameterList -debugjson &#34;false&#34;</span>
<span class="comment-line">#     unset parameterList</span>
<span class="comment-line">#</span>
<span class="comment-line">#     In this more complex example there are many ls_ports_show dictionaries and we</span>
<span class="comment-line">#       need to find loadShareMaster linkState port all in the same dictionary with</span>
<span class="comment-line">#       the matching values</span>
<span class="comment-line">#</span>
<span class="comment-line">#     set parameterList &#34;&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{ls_ports_show {loadShareMaster linkState port}} {$master 1 [MapDUTPortId 1]}  exist&#34;</span>
<span class="comment-line">#     set res [CheckDictValue -cmd $com -parameterList $parameterList -debugjson &#34;false&#34;]</span>
<span class="comment-line">#############################################################################</span>
<strong><a name="::::CheckDictValue_319">proc <a href="jsonLib.tcl-annot.html#::::CheckDictValue">::::CheckDictValue</a></a></strong> {args} {
    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckJSONKeyValue $args {
        cmd           &#34;&#34;
        parameterList &#34;&#34;
        comment       &#34;hey&#34;
        yesorno       &#34;Yes&#34;
        debugjson     &#34;false&#34;
        debugdict     &#34;false&#34;
        time          &#34;null&#34;
        showfmt       &#34;default&#34;
        testNo        &#34;&#34;
    }

    global whichDutNow connectionTimeout MAIN
    set finished 0;<span class="comment-line"># All parameters passed without iterations</span>
    set failParameters &#34;&#34;;<span class="comment-line"># list of failed parameters. Delete failed results at the beginning of n+1 iteration.</span>
                          <span class="comment-line">#    It may pass and values will be different on the next iteration</span>
                          <span class="comment-line">#    Pass arrays will show the initial first pass values.</span>
    set pOkCounter 0;<span class="comment-line"># Count of parameter entries that have passed.</span>
    set pCount [llength $parameterList];<span class="comment-line"># Number of parameter entries.</span>

    set majmin [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${whichDutNow} majmin]
    if {$majmin&lt;15.6} {
        <a name="::result_warning(1)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;CheckDictValue is not supported in versions less than 15.6&#34;
        return
    }

    <span class="comment-line">#time stuff  -time {s: 0 i: 3 f: 15} change</span>
    set sTime 0
    set it 1
    set expTime 1
    set ftime 1
    set tloop 1
    set retry 0
    set fine 0
    if {$time != &#34;null&#34;} {
        foreach {k v} $time {
            switch $k {
                &#34;s:&#34; {
                    if {$v&gt;0} {
                        set sTime $v
                        <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait $v seconds before checking $cmd&#34;
                        <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $v
                    }
                }
                &#34;i:&#34; {
                    set it $v
                }
                &#34;d:&#34; {
                    set expTime $v
                }
                &#34;f:&#34; {
                    set ftime $v
                }
            }
        }
        if {$sTime == 0 &amp;&amp; $it == 1 &amp;&amp; $expTime == 1 &amp;&amp; $ftime == 1} {
            puts &#34;There may be something wrong with your time vals.  All still defaults&#34;
        }
        if {$it == 0} {
            puts &#34;Interloop wait of zero is not allowed.  Setting to 5&#34;
            set ftime 6
            set it 5
        }
        if {$sTime==1} {set sTime 0;<span class="comment-line">#adjust due to users habit of setting 1 and using round top values.</span>}
        set ttop [expr $ftime - $sTime]
        if {$ttop&lt;1} {
            set ttop 1
        }
        set tloop [expr int(ceil($ttop/$it))];
    }

    set cc 0
    while {$cc &lt; [expr [llength $parameterList] + 5]} {
        set paramChecked($cc) 0
        set pRes($cc) &#34;&#34;
        set fRes($cc) &#34;&#34;
        incr cc
    }

    if {[regexp -nocase {^sh[ow]* *por[ts]*} $cmd]&amp;&amp;![regexp -nocase &#34;clean$|no-refresh$&#34; $cmd] &amp;&amp; \
            ![regexp -nocase &#34;info|redun|shar|util|protocol|buffer|debounce|group|link-scan&#34; $cmd]} {
        if {$majmin&gt;=11.3&amp;&amp;$majmin&lt;21.1} {
            set cmd &#34;$cmd no-refresh&#34;
        }
    } 

    <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;CheckDictValue $cmd&#34;

    for {set q 0} {$q&lt;=$tloop} {incr q} {
        set rVal 1
        if {$q&gt;0} {
            foreach fParmId $failParameters {
                set fRes($fParmId) &#34;&#34;;<span class="comment-line"># This holds the failing info for a parameter on the last loop.  It will</span>
                                      <span class="comment-line"># be replaced with whatever happens on this loop.</span>
            }
        }
        <span class="comment-line">#result_print &#34;--- Send run script cli2json.py -d $cmd&#34;</span>
        <a name="::result_print(1)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;--- Send $cmd&#34;
        set timeout 5
        set exp_out_buf &#34;&#34;
        if {$debugjson != &#34;false&#34;} {
            <a name="::_setShowOutput(1)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
            exp_send &#34;run script cli2json.py -d $cmd\r&#34;
        } else {
            <a name="::_setShowOutput(2)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt off
            exp_send &#34;run script cli2json.py $cmd\r&#34;
        }
        expect {
            &#34;$cmd&#34; {}
            timeout {
                <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timeout waiting for CheckDictValue cli to echo&#34;
                return;
            }
        }
        set timeout $connectionTimeout
        expect {
            -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                <span class="comment-line"># ExtremeWare and ExtremeWare XOS prompt.</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># The pattern breaks down as follows:</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># (\\* )?        Unsaved config marker</span>
                <span class="comment-line"># \[a-z0-9._-]+  Platform type or SNMP system name</span>
                <span class="comment-line"># (:|\\.)        Name and command ID separator</span>
                <span class="comment-line"># \[0-9]+        Command ID</span>
                <span class="comment-line"># (#|&gt;)          System or user prompt marker</span>
                append exp_out_buf $expect_out(buffer)
                regsub -all &#34;\n\r&#34; $exp_out_buf &#34;\n&#34; exp_out_buf
                regsub -all &#34;\t&#34; $exp_out_buf &#34; &#34; exp_out_buf
                <span class="comment-line">#regsub -all -nocase {[ ]+} $exp_out_buf &#34;&#34; exp_out_buf</span>
            }
            &#34;\\?&#34; {
                send &#34;$yesorno\r&#34;
                exp_continue
            }
            timeout {
                <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timeout waiting for CheckDictValue cli to match a prompt&#34;
                <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>;
                return;
            }
        }

        set output [string trim $exp_out_buf]
        <a name="::_setShowOutput(3)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
        if {$debugjson != &#34;false&#34; || ([info exists MAIN(DEBUGJSON)] &amp;&amp; $MAIN(DEBUGJSON))} {
            puts &#34;\n\nReturned Output:\n$output\n\n&#34;
        }

        <span class="comment-line">#set parsed [json::json2dict $output]</span>
        if {[catch {json::json2dict $output} parsed]} {
            <span class="comment-line">#puts &#34;1 Dictionary returned Error: $parsed $output&#34;</span>
            regsub -all -nocase {^.*\[} $output &#34;\[&#34; output
            <span class="comment-line">#dict append output Fix Dummy</span>
            <span class="comment-line">#set k [dict create fee {foo {}}]</span>
            <span class="comment-line">#dict with k fee {append foo &#34; kak&#34;}</span>
            <span class="comment-line">#dict with k fee {append foo &#34; poached&#34;}</span>
            <span class="comment-line">#puts [dict get $k fee foo]</span>
            <span class="comment-line">#regsub -all -nocase &#34;\}&#34; $output &#34;\},\n\{\&#34;hey\&#34;:\&#34;aaa\&#34;\}&#34; output</span>
            if {[catch {json::json2dict $output} parsed]} {
                <span class="comment-line">#puts &#34;2 Dictionary returned Error: $parsed $output&#34;</span>
                <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>;
                return -1
            }
        }
        set vOdd [expr [llength $parsed] % 2]
        if {$vOdd  != 0} {
            lappend parsed {dummy}
        }
        if {$debugdict != &#34;false&#34;} {
            puts &#34;\n\nParsed Dictionary:\n$parsed\n\n&#34;
        }
        if {[catch {dict get $parsed} psmall]} {
            puts &#34;Error getting dictionary path - $psmall&#34;
        } else {
            <a name="::_setShowOutput(4)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
            foreach ele $psmall {
                if {![catch {dict get $ele CLIoutput} tolog]} {
                    if {$showfmt == &#34;default&#34;} {
                        <a name="::result_pre(1)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $tolog
                        puts $tolog
                    }
                } else {
                    if {$showfmt != &#34;default&#34;} {
                        <a name="::result_pre(2)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $ele
                        puts $ele
                    }
                }
            }
            set failParameters &#34;&#34;
            set lock &#34;none&#34;
            set mylock &#34;none&#34;
            set outp($mylock) &#34;&#34;
            set oute($mylock) &#34;&#34;
            set pc -1;
            foreach para $parameterList {
                incr pc
                <span class="comment-line">#puts &#34;Start parm $pc&#34;</span>
                if {$paramChecked($pc)} {
                    <span class="comment-line">#puts &#34;!\n!\n!\nalready matched $pc = $paramChecked($pc) $pRes($pc)\n!\n!\n!&#34;;</span>
                    continue;
                }
                set plLen [llength $para];<span class="comment-line"># length of each line in parameterList</span>
                set typeVal [lindex $para [expr $plLen -1]]
                set typeLen [llength $typeVal]
                set rVal 1
                set outList &#34;&#34;
                set oopsList &#34;&#34;
                set lockList &#34;&#34;;<span class="comment-line"># every same root element inspected by a parameter will have a lock of index 0</span>
                set pPass 0
                set pMiss 0
                set print &#34;all&#34;
                <span class="comment-line"># ----------------  types of paramter checks in checkdictvalue</span>
                <span class="comment-line"># &#34;{rootKey {key1 key2 key3}} {key1value key2value key3value} exist&#34; ;# show output matches key1val</span>
                <span class="comment-line">#              key2value key3value.. all in same rootKey </span>
                <span class="comment-line"># &#34;{rootKey {key1 key2 key3}} {key1value key2value key3value} notExist&#34; ;# show output finds</span>
                <span class="comment-line">#            no key1val key2value key3value.. that match under the same root</span>
                <span class="comment-line"># &#34;{rootKey {key1 key2 key3}} {=key1value &lt;key2value &gt;key3value} range&#34; ;# show output finds</span>
                <span class="comment-line">#       key1 out exact match to key1 para val </span>
                <span class="comment-line">#       key2 out less than key2 para val</span>
                <span class="comment-line">#       key3 out greater than key3 para val</span>
                set pType [lindex $typeVal 0];<span class="comment-line"># should be exist, notExist, range</span>
                if {$pType != &#34;exist&#34; &amp;&amp; $pType != &#34;notExist&#34; &amp;&amp; $pType != &#34;range&#34; &amp;&amp; \
                          $pType != &#34;regexNotExist&#34; &amp;&amp; $pType != &#34;regexExist&#34;} {
                    <a name="::result_warning(2)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;parameterList type must be one of; exist,notExist or range&#34;
                    continue;
                }
                set foList &#34;&#34;
                set fmList &#34;&#34;
                set matchAll 0
                set miss 0
                set f 0
                foreach ele $psmall {
                    set oEPass 0
                    set oEMiss 0
                    set notReq 0
                    <span class="comment-line">#set outList &#34;&#34;</span>
                    <span class="comment-line">#set oopsList &#34;&#34;</span>
                    set missedKeyList &#34;&#34;
                    if {![catch {dict keys $ele} why]} {
                        set keyLen [llength [lindex $para 0]]
                        switch $keyLen {
                        4 {
                            <span class="comment-line">#   keys portion of the parameterList  llength = 3 being rootKey-&gt;nextKey and {keys 1-3} in this case</span>
                            <span class="comment-line"># parameterList format is &#34;{rootKey nextKey {key1 key2 key3}} {key1Want key2Want key3Want} exist&#34;</span>
                            set rootKey [lindex [lindex $para 0] 0];<span class="comment-line"># 3 means rootKey-&gt;nextKey-&gt;keyOfInterest</span>
                            set nextKey1 [lindex [lindex $para 0] 1];<span class="comment-line">#</span>
                            set nextKey2 [lindex [lindex $para 0] 2];<span class="comment-line">#</span>
                            set reqPass [llength [lindex $para 0] 3]];<span class="comment-line"># determine how many must match in same rootKey-&gt;nextKey</span>
                                                            <span class="comment-line">#  ie. key1 key2 key3 must be in the same root-next1-next2 structure</span>
                            set eList [lindex [lindex $para 0] 3];
                            set ePath &#34;$rootKey $nextKey1 $nextKey2&#34;
                        }
                        3 {
                            <span class="comment-line">#   keys portion of the parameterList  llength = 3 being rootKey-&gt;nextKey and {keys 1-3} in this case</span>
                            <span class="comment-line"># parameterList format is &#34;{rootKey nextKey {key1 key2 key3}} {key1Want key2Want key3Want} exist&#34;</span>
                            set rootKey [lindex [lindex $para 0] 0];<span class="comment-line"># 3 means rootKey-&gt;nextKey-&gt;keyOfInterest</span>
                            set nextKey1 [lindex [lindex $para 0] 1];<span class="comment-line">#</span>
                            set reqPass [llength [lindex $para 0] 2]];<span class="comment-line"># determine how many must match in same rootKey-&gt;nextKey</span>
                                                            <span class="comment-line">#  ie. key1 key2 key3 must be in the same root-next1 structure</span>
                            set eList [lindex [lindex $para 0] 2]
                            set ePath &#34;$rootKey $nextKey1&#34;
                        }
                        2 {
                            <span class="comment-line"># goh  keys portion of the parameterList  llength = 2 being rootKey and {keys 1-3} in this case      </span>
                            <span class="comment-line"># parameterList format is &#34;{rootKey {key1 key2 key3}} {key1Want key2Want key3Want} exist&#34;</span>
                            set rootKey [lindex [lindex $para 0] 0];<span class="comment-line"># 2 means rootKey-&gt;keyOfInterest</span>
                            set reqPass [llength [lindex [lindex $para 0] 1]];<span class="comment-line"># determine how many just match in same rootKey</span>
                                                             <span class="comment-line">#  ie. key1 key2 key3 must be in the same rootKey structure</span>
                            set eList [lindex [lindex $para 0] 1]
                            set ePath &#34;$rootKey&#34;
                        }
                        1 {
                            <a name="::result_warning(3)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Don't think just a rootKey is supported - [lindex [lindex $para 0] 0]&#34;
                            set reqPass [llength [lindex [lindex $para 0] 0]]
                            set eList [lindex [lindex $para 0] 0]
                            set ePath &#34;&#34;
                        }
                        };<span class="comment-line"># End switch</span>
                        set i 0;<span class="comment-line"># used to index keyValues ie... key1Want, key2Want etc.</span>
                        set dbg &#34; -&#34;
                        foreach lastEle $eList {
                            if {[catch {dict get $ele $ePath $lastEle} outVal]} {
                                set notReq 1
                                append dbg &#34; keys $rootKey $lastEle not in ele&#34;
                            } else {
                                set kWant1 [lindex [lindex $para 1] $i];<span class="comment-line"># for exist,notExist this is all we need.</span>
                                if {$i==0} {
                                    regsub -all &#34;==|=|&lt;|&gt;|&lt;=|&gt;=&#34; $kWant1 &#34;&#34; mylock
                                    set outp($mylock) &#34;&#34;
                                    set oute($mylock) &#34;&#34;
                                    set nrByLock($mylock) 0
                                    set lock $outVal;<span class="comment-line"># lock for this line</span>
                                    set outp($lock) &#34;&#34;
                                    set oute($lock) &#34;&#34;
                                    if {[lsearch $lockList $lock] &lt; 0} {
                                        lappend lockList $lock
                                    }
                                }
                                append dbg &#34; \[$mylock\]${i}-(${lock})&gt;$outVal&#34;
                                if {$pType == &#34;range&#34;} {
                                    if {[regexp -nocase {^==([a-z0-9_\-\.\:\!]+)} $kWant1 a etVal]} {
                                        if {$outVal == $etVal} {
                                            <span class="comment-line">#first key to lock on.. in case of misses</span>
                                            incr pPass; incr oEPass;
                                            lappend outList &#34;$rootKey -&gt; $lastEle Found KEY $etVal&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle Found KEY $etVal&#34;
                                        } else {
                                            lappend missedKeyList $outVal
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle  $etVal KEY_NOT_FOUND - Got ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle  $etVal KEY_NOT_FOUND - Got ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } elseif {[regexp -nocase {^&lt;([0-9]+)} $kWant1 a ltVal]} {
                                        if {$outVal &lt; $ltVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  ($outVal) less than $ltVal&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  ($outVal) less than $ltVal&#34;
                                            incr pPass; incr oEPass;
                                        } else {
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle WANTED &lt;$ltVal GOT ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle WANTED &lt;$ltVal GOT ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } elseif {[regexp -nocase {^&lt;=([0-9]+)} $kWant1 a ltVal]} {
                                        if {$outVal &lt;= $ltVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  ($outVal) &lt;= $ltVal&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  ($outVal) &lt;= $ltVal&#34;
                                            incr pPass; incr oEPass;
                                        } else {
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle WANTED  &lt;=$ltVal GOT ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle WANTED  &lt;=$ltVal GOT ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } elseif {[regexp -nocase {^&gt;([0-9]+)} $kWant1 a gtVal]} {
                                        if {$outVal &gt; $gtVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  ($outVal) &gt; $gtVal&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  ($outVal) &gt; $gtVal&#34;
                                            incr pPass; incr oEPass;
                                        } else {
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle WANTED &gt;$gtVal GOT ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle WANTED &gt;$gtVal GOT ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } elseif {[regexp -nocase {^&gt;=([0-9]+)} $kWant1 a gteVal]} {
                                        if {$outVal &gt;= $gteVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  ($outVal) &gt;= $gteVal&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  ($outVal) &gt;= $gteVal&#34;
                                            incr pPass; incr oEPass;
                                        } else {
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle WANTED &gt;=$gteVal GOT ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle WANTED &gt;=$gteVal GOT ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } elseif {[regexp -nocase {^=(.*)} $kWant1 a etVal]} {
                                        if {$outVal == $etVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  GOT ($outVal)&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  GOT ($outVal)&#34;
                                            incr pPass; incr oEPass;
                                        } else {
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle WANTED $etVal GOT ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle WANTED $etVal GOT ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } elseif {[regexp -nocase {([0-9]+)\-([0-9]+)} $kWant1 a bottVal topVal]} {
                                        if {$outVal &gt;= $bottVal &amp;&amp; $outVal &lt;= $topVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  $bottVal &lt;= ($outVal) &lt;= $topVal&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  $bottVal &lt;= ($outVal) &lt;= $topVal&#34;
                                            incr pPass; incr oEPass;
                                        } else {
                                            lappend oopsList &#34;$rootKey -&gt; $lastEle WANTED between $bottVal AND $topVal GOT ($outVal)&#34;
                                            lappend oute($lock) &#34;$rootKey -&gt; $lastEle WANTED between $bottVal AND $topVal GOT ($outVal)&#34;
                                            incr pMiss; incr oEMiss;
                                        }
                                    } else {
                                        <a name="::result_warning(4)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Did not find a valid range delimiter in $kWant1&#34;
                                    }
                                } elseif {$pType == &#34;regex&#34;} {
                                    if {[regexp -nocase &#34;$kWant1&#34; $outVal] || [lindex $para 1] == &#34;exist&#34;} {
                                        incr pPass; incr oEPass;
                                        if {[regexp -nocase &#34;$kWant1&#34; $outVal]} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  EXISTS ($outVal)&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  EXISTS ($outVal)&#34;
                                        } else {
                                            lappend outList &#34;$rootKey -&gt; $lastEle EXISTS&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle EXISTS&#34;
                                        }
                                    } else {
                                        lappend oopsList &#34;$rootKey -&gt; $lastEle Incorrect Value ($outVal) WANTED $kWant1&#34;
                                        lappend oute($lock) &#34;$rootKey -&gt; $lastEle Incorrect Value ($outVal) WANTED $kWant1&#34;
                                        incr pMiss; incr oEMiss;
                                    }
                                } elseif {[regexp -nocase &#34;notexist&#34; $pType]} {
                                    if {$kWant1 == $outVal} {
                                        incr pPass; incr oEPass;
                                        if {[regexp -nocase &#34;$kWant1&#34; $outVal]} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle  EXISTS ($outVal)&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle  EXISTS ($outVal)&#34;
                                        } else {
                                            lappend outList &#34;$rootKey -&gt; $lastEle EXISTS&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle EXISTS&#34;
                                        }
                                    } else {
                                        lappend oopsList &#34;$rootKey -&gt; $lastEle  NOTEXIST ($outVal) NOT $kWant1&#34;
                                        lappend oute($lock) &#34;$rootKey -&gt; $lastEle  NOTEXIST ($outVal) NOT $kWant1&#34;
                                        incr pMiss; incr oEMiss;
                                    }
                                } else {
                                    if {$kWant1 == $outVal || [lindex $para 1] == &#34;exist&#34;} {
                                        incr pPass; incr oEPass;
                                        if {$kWant1 == $outVal} {
                                            lappend outList &#34;$rootKey -&gt; $lastEle EXISTS ($outVal)&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle EXISTS ($outVal)&#34;
                                        } else {
                                            lappend outList &#34;$rootKey -&gt; $lastEle EXISTS&#34;
                                            lappend outp($lock) &#34;$rootKey -&gt; $lastEle EXISTS&#34;
                                        }
                                    } else {
                                        lappend oopsList &#34;$rootKey -&gt; $lastEle Incorrect Value ($outVal) WANTED $kWant1&#34;
                                        lappend oute($lock) &#34;$rootKey -&gt; $lastEle Incorrect Value ($outVal) WANTED $kWant1&#34;
                                        incr pMiss; incr oEMiss;
                                    }
                                }
                            }
                            incr i
                        }
                        <span class="comment-line">#puts &#34;----  $para&#34;</span>
                        <span class="comment-line">#puts &#34;reqPass=$reqPass mlp[llength $outp($mylock)] mle[llength $oute($mylock)] pPass=$pPass pMiss=$pMiss oEPass=$oEPass oEMiss=$oEMiss dbg=$dbg&#34;</span>
                        if {[llength $outp($mylock)] &gt;= $reqPass} {
                            set matchAll 1
                            set miss 0
                            set pRes($pc) $outp($mylock)
                            set fRes($pc) $oute($mylock)
                            set print &#34;key&#34;
                            <span class="comment-line">#puts &#34;Match all SET pRes $pc&#34;</span>
                        } elseif {$notReq} {
                            set notReq 0
                            incr nrByLock($mylock)
                            if {[llength $outp($mylock)] &gt; 0 &amp;&amp; [expr [llength $outp($mylock)] + [llength $oute($mylock)] + $nrByLock($mylock)] == $reqPass} {
                                <span class="comment-line">#puts &#34;Hit a key missing from json while locked $nrByLock($mylock) $dbg&#34;</span>
                                set matchAll [llength $outp($mylock)]
                                lappend oute($mylock) &#34;$dbg&#34;
                                set miss [llength $oute($mylock)]
                                set pRes($pc) $outp($mylock)
                                set fRes($pc) $oute($mylock)
                                set print &#34;key&#34;
                                <span class="comment-line">#puts &#34;Lock hit and key missing matchAll $matchAll miss $miss SET pRes $pc&#34;</span>
                            }
                        } elseif {[expr [llength $outp($mylock)] + [llength $oute($mylock)]] == $reqPass} {
                            set matchAll [llength $outp($mylock)]
                            set miss [llength $oute($mylock)]
                            set pRes($pc) $outp($mylock)
                            set fRes($pc) $oute($mylock)
                            lappend failParameters $pc
                            set print &#34;key&#34;
                            <span class="comment-line">#puts &#34;HIT MYLOCK MATCH PLUS MISS SET pRes $pc&#34;</span>
                        } elseif {[expr [llength $outp($lock)] + [llength $oute($lock)]] == $reqPass &amp;&amp; \
                                       [regexp -nocase &#34;notexist&#34; $pType]} {
                            set miss [llength $oute($lock)]
                            set matchAll [llength $outp($lock)]
                            set pRes($pc) $oute($lock);<span class="comment-line">#  Reverse the HIT / MISS Messages as pass and fail</span>
                            set fRes($pc) $outp($lock)
                            lappend failParameters $pc
                            set print &#34;key&#34;
                            <span class="comment-line">#puts &#34;HIT LOCK MATCH PLUS MISS IN NotExist  SET pRes $pc&#34;</span>
                        } elseif {$oEMiss&gt;0 &amp;&amp; [expr $oEPass + $oEMiss] &gt;= $reqPass &amp;&amp; \
                                       [regexp -nocase &#34;notexist&#34; $pType]} {
                            set miss      $oEMiss
                            set matchAll  $oEPass
                            set pRes($pc) $oopsList;<span class="comment-line">#  Reverse the HIT / MISS Messages as pass and fail</span>
                            set fRes($pc) $outList
                            lappend failParameters $pc
                            <span class="comment-line">#puts &#34;HIT oeMiss, but notExist  SET pRes $pc&#34;</span>
                        } elseif {$oEMiss&gt;0 &amp;&amp; [expr $oEPass + $oEMiss] &gt;= $reqPass &amp;&amp; \
                                       [regexp -nocase &#34;range|exist&#34; $pType]} {
                            set miss $oEMiss
                            set matchAll $oEPass
                            set pRes($pc) $outList;<span class="comment-line"># </span>
                            set fRes($pc) $oopsList
                            lappend failParameters $pc
                            <span class="comment-line">#puts &#34;HIT oEMiss req in  SET pRes pCounter $pc&#34;</span>
                        } elseif {$oEMiss==0 &amp;&amp; $oEPass &gt;= $reqPass &amp;&amp; \
                                       [regexp -nocase &#34;range|exist&#34; $pType]} {
                            set miss 0
                            set matchAll $oEPass
                            set pRes($pc) $outList;<span class="comment-line">#</span>
                            set fRes($pc) $oopsList;<span class="comment-line"># should be empty</span>
                            lappend failParameters $pc
                            <span class="comment-line">#puts &#34;HIT oEMiss req in  SET pRes pCounter $pc&#34;</span>
                        } elseif {$reqPass == 1 &amp;&amp; $pMiss&gt;0} {
                            incr miss
                            set print &#34;all&#34;
                            set fRes($pc) $oopsList
                            lappend failParameters $pc
                            <span class="comment-line">#puts &#34;reqPass=1 miss&gt;0 &#34;</span>
                        } elseif {$reqPass == 1 &amp;&amp; $pPass&gt;0} {
                            incr matchAll
                            set print &#34;all&#34;
                            set pRes($pc) $outList
                            <span class="comment-line">#puts &#34;reqPass=1 pass&gt;0&#34;</span>
                        } else {
                            <span class="comment-line">#incr miss</span>
                            <span class="comment-line">#puts &#34;Miss all&#34;</span>
                        }
                    } else {
                        
                    }
                }
                <span class="comment-line"># Decide if the parameter passes or fails for our purposes.. ie Exist or notExist</span>
                if {$matchAll&gt;0 &amp;&amp; $miss==0 &amp;&amp; ([lindex $para 2] == &#34;exist&#34; || [lindex $para 2] == &#34;range&#34; || \
                       [lindex $para 2] == &#34;regexExist&#34;)} {
                    <span class="comment-line">#puts &#34;$print check end 1&#34;</span>
                } elseif {$matchAll&gt;0 &amp;&amp; $miss == 0 &amp;&amp; ([lindex $para 2] == &#34;notExist&#34; || [lindex $para 2] == &#34;regexNotExist&#34;)} {
                    set rVal 0
                    <span class="comment-line">#puts &#34;$print check end 2&#34;</span>
                } elseif {($matchAll==0 || $miss&gt;0) &amp;&amp; ([lindex $para 2] == &#34;exist&#34; || [lindex $para 2] == &#34;range&#34; || \
                       [lindex $para 2] == &#34;regexExist&#34;)} {
                    set rVal 0
                    <span class="comment-line">#puts &#34;$print check end 3&#34;</span>
                } elseif {($matchAll==0 || $miss&gt;0) &amp;&amp; ([lindex $para 2] == &#34;notExist&#34; || [lindex $para 2] == &#34;regexNotExist&#34;)} {
                    <span class="comment-line">#puts &#34;$print check end 4&#34;</span>
                } elseif {$matchAll&gt;0 &amp;&amp; ([lindex $para 1] == &#34;exist&#34; || [lindex $para 1] == &#34;range&#34;) || \
                       [lindex $para 2] == &#34;regexExist&#34;)} {
                    <span class="comment-line">#puts &#34;$print check end 5&#34;</span>
                } elseif {$matchAll&gt;0 &amp;&amp; ([lindex $para 1] == &#34;notExist&#34; || [lindex $para 2] == &#34;regexNotExist&#34;)} {
                    set rVal 0
                    <span class="comment-line">#puts &#34;$print check end 6&#34;</span>
                } elseif {($matchAll==0 || $miss&gt;0) &amp;&amp; ([lindex $para 1] == &#34;notExist&#34; || [lindex $para 2] == &#34;regexNotExist&#34;)} {
                    <span class="comment-line">#puts &#34;$print check end 7&#34;</span>
                } else {
                    set rVal 0
                    <span class="comment-line">#puts &#34;$print check end 8&#34;</span>
                }
                <span class="comment-line"># Store info on a passed parameter</span>
                if {$rVal} {
                    incr pOkCounter
                    set paramChecked($pc) 1;<span class="comment-line"># We have already passed this parameter. Don't check it on future iterations</span>
                    <span class="comment-line">#puts &#34;Setting $para checked = $paramChecked($pc)&#34;</span>
                }
                <span class="comment-line">#If every parameter has passed exit and print result arrays.</span>
                if {$pOkCounter == $pCount} {
                    set finished 1
                }
                <span class="comment-line"># Time has run out.  All iterations have completed.</span>
                if {[expr $tloop - $q] == 0} {
                    set fine 1
                }
            }
        }
        if {$finished} {
            <span class="comment-line"># print the save results</span>
            set i 0
            foreach para $parameterList {
                <a name="::report_start_test(3)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> $para
                foreach o $pRes($i) {
                    <a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;$o&#34;
                }
                foreach f $fRes($i) {
                    <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$f&#34;
                }
                <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
                incr i
            } 
            <a name="::report_end_test(5)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
            return 1
        } elseif {!$fine} {
            set retry 1
            set qp [expr $q + 1]
            <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Check output \&#34;$cmd\&#34;. [expr $sTime + [expr $it * $q]] of [expr $sTime + [expr $it * $tloop]] (Starting $it sec iter. $qp of $tloop)&#34;
            <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $it
        }
    }
    <span class="comment-line"># print the save results</span>
    set i 0
    foreach para $parameterList {
        <a name="::report_start_test(4)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> $para
        foreach o $pRes($i) {
            <a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;$o&#34;
        }
        foreach f $fRes($i) {
            <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$f&#34;
        }
        <a name="::report_end_test(6)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
        incr i
    }
    <a name="::report_end_test(7)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    return $rVal
}
<span class="comment-line">#############################################################################</span>
<span class="comment-line"># Procedure Name: GetDictValue</span>
<span class="comment-line">#</span>
<span class="comment-line"># Similar to GetKeyValue, but makes a JSONRPC request to the mgmt interface</span>
<span class="comment-line">#   on a switch and checks a parameterList to match expected outputs</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#     set parameterList &#34;&#34;</span>
<span class="comment-line">#     lappend parameterList &#34;{vlanProc {name1}}&#34;</span>
<span class="comment-line">#     set res [GetDictValue -cmd $com -parameterList $parameterList -debugjson &#34;false&#34;]</span>
<span class="comment-line">#############################################################################</span>
<strong><a name="::::GetDictValue_917">proc <a href="jsonLib.tcl-annot.html#::::GetDictValue">::::GetDictValue</a></a></strong> {args} {
    <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> GetDictValue $args {
        cmd           &#34;&#34;
        parameterList &#34;&#34;
        comment       &#34;hey&#34;
        yesorno       &#34;Yes&#34;
        debugjson     &#34;false&#34;
        debugdict     &#34;false&#34;
        time          &#34;null&#34;
        showfmt       &#34;default&#34;
        getactioncli  &#34;null&#34;
        testNo        &#34;&#34;
    }

    global whichDutNow connectionTimeout
    set rVal 1

    set majmin [<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${whichDutNow} majmin]
    if {$majmin&lt;15.6} {
        <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;CheckDictValue is not supported in versions less than 15.6&#34;
        return
    }

    <span class="comment-line">#time stuff  -time {s: 0 i: 3 f: 15}</span>
    set it 1
    set ftime 1
    set tloop 1
    set retry 0
    set fine 0
    if {$time != &#34;null&#34;} {
        foreach {k v} $time {
            switch $k {
                &#34;s:&#34; {
                    if {$v&gt;0} {
                        <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait $v seconds before checking $cmd&#34;
                        <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $v
                    }
                }
                &#34;i:&#34; {
                    set it $v
                }
                &#34;f:&#34; {
                    set ftime $v
                }
            }
        }
        set tloop [expr int(ceil($ftime/$it))];
    }


    if {[regexp -nocase {^sh[ow]* *por[ts]*} $cmd]&amp;&amp;![regexp -nocase &#34;clean$|no-refresh$&#34; $cmd] &amp;&amp; \
            ![regexp -nocase &#34;info|redun|shar|util|protocol|buffer|debounce|group|link-scan&#34; $cmd]} {
        if {$majmin&gt;=11.3&amp;&amp;$majmin&lt;21.1} {
            set cmd &#34;$cmd no-refresh&#34;
        }
    }

    <a name="::report_start_test(5)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;GetDictValue &lt;$cmd&gt; $testNo $comment&#34;
    set fList &#34;&#34;
    for {set q 0} {$q&lt;$tloop} {incr q} {
        <a name="::result_print(2)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;--- Send run script cli2json.py -d $cmd&#34;
        set timeout 5
        set exp_out_buf &#34;&#34;
        if {$debugjson != &#34;false&#34;} {
            <a name="::_setShowOutput(5)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
            exp_send &#34;run script cli2json.py -d $cmd\r&#34;
        } else {
            <a name="::_setShowOutput(6)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt off
            exp_send &#34;run script cli2json.py $cmd\r&#34;
        }
        expect {
            &#34;$cmd&#34; {}
            timeout {
                <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timeout waiting for CheckDictValue cli to echo&#34;
                return;
            }
        }
        set timeout $connectionTimeout
        expect {
            -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                <span class="comment-line"># ExtremeWare and ExtremeWare XOS prompt.</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># The pattern breaks down as follows:</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># (\\* )?        Unsaved config marker</span>
                <span class="comment-line"># \[a-z0-9._-]+  Platform type or SNMP system name</span>
                <span class="comment-line"># (:|\\.)        Name and command ID separator</span>
                <span class="comment-line"># \[0-9]+        Command ID</span>
                <span class="comment-line"># (#|&gt;)          System or user prompt marker</span>
                append exp_out_buf $expect_out(buffer)
                regsub -all &#34;\n\r&#34; $exp_out_buf &#34;\n&#34; exp_out_buf
                regsub -all &#34;\t&#34; $exp_out_buf &#34; &#34; exp_out_buf
            }
            &#34;\\?&#34; {
                send &#34;$yesorno\r&#34;
                exp_continue
            }
            timeout {
                <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timeout waiting for CheckDictValue cli to match a prompt&#34;
                return;
            }
        }

        set output $exp_out_buf
        <a name="::_setShowOutput(7)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
        if {$debugjson != &#34;false&#34;} {
            puts &#34;\n\nReturned Output:\n$output\n\n&#34;
        }

        set parsed [json::json2dict $output]
        set vOdd [expr [llength $parsed] % 2]
        if {$vOdd  != 0} {
            lappend parsed {dummy}
        }
        if {$debugdict != &#34;false&#34;} {
            puts &#34;\n\nParsed Dictionary:\n$parsed\n\n&#34;
        }
        if {[catch {dict get $parsed} psmall]} {
            puts &#34;Error getting dictionary path - $psmall&#34;
        } else {
            <a name="::_setShowOutput(8)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
            foreach ele $psmall {
                if {![catch {dict get $ele CLIoutput} tolog]} {
                    if {$showfmt == &#34;default&#34;} {
                        <a name="::result_pre(3)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $tolog
                        puts $tolog
                    }
                } else {
                    if {$showfmt != &#34;default&#34;} {
                        <a name="::result_pre(4)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $ele
                        puts $ele
                    }
                }
            }
            foreach para $parameterList {
                puts &#34;Test $para&#34;
                set outList &#34;&#34;
                set matchAll 0
                foreach ele $psmall {
                    set pPass 0
                    if {![catch {dict keys $ele} why]} {
                        set keyLen [llength [lindex $para 0]]
                        switch $keyLen {
                        4 {
                            set i 0
                            set reqPass [llength [lindex $para 1]]
                            foreach lastEle [lindex [lindex $para 0] 3] {
                                if {[catch {dict get $ele [lindex [lindex $para 0] 0] [lindex [lindex $para 0] 1] [lindex [lindex $para 0] 2] $lastEle} outVal]} {
                                    <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                                } else {
                                    lappend outList $outVal
                                }
                                incr i
                            }
                        }
                        3 {
                            set i 0
                            set reqPass [llength [lindex $para 1]]
                            foreach lastEle [lindex [lindex $para 0] 2] {
                                if {[catch {dict get $ele [lindex [lindex $para 0] 0] [lindex [lindex $para 0] 1] $lastEle} outVal]} {
                                    <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                                } else {
                                    <span class="comment-line">#puts &#34;Found keys 3&#34;</span>
                                    lappend outList $outVal
                                }
                                incr i
                            }
                        }
                        2 {
                            set i 0
                            set reqPass [llength [lindex $para 1]]
                            foreach lastEle [lindex [lindex $para 0] 1] {
                                if {[catch {dict get $ele [lindex [lindex $para 0] 0] $lastEle} outVal]} {
                                    <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                                } else {
                                    lappend outList $outVal
                                }
                                incr i
                            }
                        }
                        1 {
                            set i 0
                            set reqPass [llength [lindex $para 1]]
                            if {[catch {dict get $ele [lindex [lindex $para 0] 0]} outVal]} {
                                <span class="comment-line">#puts &#34;didn't find dictionary $outVal&#34;</span>
                            } else {
                                lappend outList $outVal
                            }
                       }
                       }
                    }
                    <span class="comment-line">#if {$pPass &gt;= $reqPass} {</span>
                    <span class="comment-line">#    set matchAll 1</span>
                    <span class="comment-line">#    break;</span>
                    <span class="comment-line">#}</span>
                }
                if {[llength $outList] &gt; 0} {
                    lappend fList $outList
                }
            }
        }
        <span class="comment-line">#if {$rVal} {</span>
        <span class="comment-line">#    return 1</span>
        <span class="comment-line">#} elseif {!$fine} {</span>
        <span class="comment-line">#    set retry 1</span>
        <span class="comment-line">#    exSleep $it</span>
        <span class="comment-line">#}</span>
    }
    <a name="::report_end_test(8)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    if {[llength $fList] &gt; 0} {
        puts &#34;GetDictValue returning: $fList&#34;
        return $fList
    } else {
        return &#34;&#34;
    }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
