##################################################################
# Procedure Name: logCaller
#
# Desc: displays the name of the calling procedure
#
# Input args: none
# Output args: none
#
# Typical: [logCaller]
#
##################################################################
proc logCaller {} {
    set r [catch {info level [expr [info level] - 2]} e]
    if {$r} {
        puts "Called directly by the interpreter (e.g.: .tcl on the partyline)."
    } {
        puts "Called by ${e}."
    }
}
##################################################################
# Procedure Name: VerifyPlatformType
#
# Description: Verifies the platform types from user input
#              takes the default platformTypes from runReg.cfg inside ../Util
#
# Input args: platform
# Output args: none
# Typical usage:
#             if {[VerifyPlatformType $platformType]==-1} {
#             }
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc VerifyPlatformType {platform} {
   global DEVREG
   return [lsearch -exact $DEVREG(server,platformsSupported) $platform]
}

##################################################################
# Procedure Name: FileOpen
#
# Description: Opens the file with fileMode, locks it for read/write
#              and returns the file descriptor to caller
#              FileName is the absolute file path
#
# Input args: FileName, fileMode
# Output args: none
# Typical usage:
#             if {[set fd_out [FileOpen $priorityFile a]]==-1} {
#             }
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc FileOpen {fileName fileMode {reason ""}} {
   global DEVREG
   upvar $reason fd_out
   package require Tclx
   if {[catch {open $fileName $fileMode} fd_out]} {
      after 1500  ;# if it hit instance of update, try once again
      if {[catch {open $fileName $fileMode} fd_out]} {
         result_error "Error: Cannot open $fileName for $fileMode, $fd_out";
         return -1
      }
   } else {
       #puts "File open fail: $fileName . Exists? [file isfile $fileName]"
   }
   if {$fileMode=="r"} {
      if {[catch {flock -read -nowait $fd_out} why]} {
          puts "Attempted RO flock of $fileName failed - $why"
      }
   } else {
      if {[catch {flock $fd_out} why]} {
          puts "Attempted RW flock of $fileName failed - $why"
      }
   }
   return $fd_out
}

##################################################################
# Procedure Name: SetPriorityFile
#
# Description: Opens the priorityFile, appends the id at the end
#              priorityFile is only located in imagesQueued dir
#
# Input args: id
# Output args: none
# Typical usage:
#             SetPriorityFile $queueId
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc SetPriorityFile {id} {
   global DEVREG

   set id [string trim $id "^@"];# Trim odd hex being added from someplace
   if {![regexp {[A-Z]{3,3}_[0-9]{6,6}_[0-9]{6,6}} $id]} {
       puts "\n!!!\n!!!\n!!! BAD BAD BAD queueid $id !!!\n!!!\n!!!"
       error "BAD BAD BAD queueid $id"
   }
   if {![file exists $DEVREG(server,priorityFile)]} {
      if {[set fd_out [FileOpen $DEVREG(server,priorityFile) a]]==-1} {
         return $fd_out
      }
      puts $fd_out "$id"
      funlock $fd_out
      chmod 0777 $DEVREG(server,priorityFile)
   } else {
      if {[set fd_out [FileOpen $DEVREG(server,priorityFile) a+]]==-1} {
         return $fd_out
      }
      puts $fd_out "$id"
      funlock $fd_out
   }
   close $fd_out   
}

##################################################################
# Procedure Name: locked
#
# Description: Checks the lockFile inside regressionDir for 
#              existance of cfgFile.
#              If a test bed regServer is locked, it is entered in
#              lockFile.
#              cfgFile is the tail of the cfgFile path
#
# Input args: cfgFile
# Output args: none
# Typical usage:
#             if {[locked $cfgFileTail]} {
#             }
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc locked {cfgFile} {
   global DEVREG
   
   if {[set fd_in [FileOpen $DEVREG(server,lockFile) r]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      if {[regexp -nocase $cfgFile $line]} {
         ####if [string compare $line $cfgFile]==0
         close $fd_in
         return 1
      }
   }
   funlock $fd_in
   close $fd_in
   return 0
}
##################################################################
# Procedure Name: autolocked
#
# Description: Checks the lockFile inside regressionDir for 
#              existance of !cfgFile.
#              If a test bed regServer is locked, it is entered in
#              lockFile.
#              cfgFile is the tail of the cfgFile path
#
# Input args: cfgFile
# Output args: none
# Typical usage:
#             if {[autolocked $cfgFileTail]} {
#             }
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc autolocked {cfgFile} {
   global DEVREG
   
   if {[set fd_in [FileOpen $DEVREG(server,lockFile) r]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      if {[regexp -nocase "!$cfgFile" $line]} {
         close $fd_in
         return 1
      }
   }
   funlock $fd_in
   close $fd_in
   return 0
}
##################################################################
# Procedure Name: runningServers
#
# Description: returns the list of regServers currently running
#              on the server. Performs a ps and egrep.
#              1 in case of error.
#
# Input args: none
# Output args: none
# Typical usage:
#             set unlockTestbeds [runningServers]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc runningServers {} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e "regServer.tcl.*cfg" | grep -v grep >& Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds ""
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines ""
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
#      result_debug "the psLines $psLines"
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine "-cfg"]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         if {[lsearch $unlockTestbeds $fileTail]==-1} {
            lappend unlockTestbeds $fileTail
         }
      }
      return $unlockTestbeds
   } else {
      return $psOut
   }
}

proc runningServerTypes {srvrName} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e "regServer.tcl.*$srvrName" | grep -v grep >& Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds ""
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines ""
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
#      result_debug "the psLines $psLines"
      foreach psLine $psLines {
      set regTypeIndex [lsearch $psLine "-regressionType"]
      set platTypeIndex [lsearch $psLine "-platformType"]
      set serverRegTypeName [lindex $psLine [expr $regTypeIndex+1]]
      set serverPlatTypeName [lindex $psLine [expr $platTypeIndex+1]]
      }
      return "$serverRegTypeName $serverPlatTypeName"
   } else {
      return $psOut
   }
}
##################################################################
#
#
##################################################################
proc allRunningServerTypes {} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e "regServer.tcl.*" | grep -v grep >& Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds ""
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines ""
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
#      result_debug "the psLines $psLines"
      foreach psLine $psLines {
          set regTypeIndex [lsearch $psLine "-regressionType"]
          set platTypeIndex [lsearch $psLine "-platformType"]
          set cfgIndex [lsearch $psLine "-cfg"]
          set serverRegTypeName [lindex $psLine [expr $regTypeIndex+1]]
          set serverPlatTypeName [lindex $psLine [expr $platTypeIndex+1]]
          set cfg [lindex $psLine [expr $cfgIndex+1]]
          set cfg [file tail $cfg]
          set RUNREGINFO(platCfg,null,$cfg) "$serverPlatTypeName"
          set RUNREGINFO(typeCfg,null,$cfg) "$serverRegTypeName"
          set RUNREGINFO(platCfgTypeName,$serverRegTypeName,$serverPlatTypeName) "$cfg"
          set RUNREGINFO(platType,$cfg,$serverPlatTypeName) "$serverRegTypeName"
          set RUNREGINFO(platCfgNameType,$serverPlatTypeName,$serverRegTypeName) "$cfg"
      }
      return [array get RUNREGINFO]
   } else {
      return $psOut
   }
}
##################################################################
# Procedure Name: lockUnlockSetup
#
# Description: gets Called by only controlReg utility.
#              only meant to perform lock or unlock test bed servers
#              modifies lockFile based on the user choice.
#
# Input args: none
# Output args: none
# Typical usage:
#             set  retValue [lockUnlockSetup]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc lockUnlockSetup {} {
   global DEVREG

   while {1} {
      puts "\n"
      puts "(1). Lock an unlocked test bed."
      puts "(2). Unlock a locked test bed."
      puts "(3). Lock all unlocked test beds."
      puts "(4). Unlock all locked test beds."
      puts -nonewline "Please select one of the above options\[1/2\]:"
      flush stdout;
      gets stdin lockUnlockVal;
      if {[regexp -nocase {(^[1] [0-9a-z]+$)|[1-4]} $lockUnlockVal ach lreg]} {
         break
      }
   }
   set srch 0
   if {[string trim $lreg] != ""} {
       set lregString [lindex $lreg 1]
       set srch 1
       set lockUnlockVal 1
       puts "Searching for $lregString"
   }

   if {$lockUnlockVal==1} {  ;# lock an unlocked test bed
      puts "Currently unlocked test bed server(s):"
      puts "====================================="
      set unlockTestbeds [runningServers]
      if {$unlockTestbeds!=1} {
      foreach unlockTestbed $unlockTestbeds {
         if {$srch && ![regexp -nocase "$lregString" $unlockTestbed]} {continue;}
         if {![locked $unlockTestbed]} {
            puts "$unlockTestbed"
         }
      }
      while {1} {
         puts "\n"
         puts -nonewline "Please enter one of above running test beds to be locked:"
         flush stdout;
         gets stdin lockTestbed
         if {[lsearch -exact $unlockTestbeds $lockTestbed]!=-1} {
            break
         } else {
            result_error "Test bed: $lockTestbed is not running amongst: $unlockTestbeds"
         }
      }
      ### Check if the lockTestbed is already locked
      if {[locked $lockTestbed]} {
         result_error "The test bed: $lockTestbed is already locked"
         return -1
      } else {   ;# lock it in $DEVREG(server,lockFile)
         if {[set fd_out [FileOpen $DEVREG(server,lockFile) a+]]==-1} {
            return $fd_out
         }
         puts $fd_out $lockTestbed
         funlock $fd_out
         close $fd_out
         result_ok "Successfully locked test bed: $lockTestbed"
         return 1
      }
      } else {
         result_error "No test bed server is currently running"
         return -1
      }
   } elseif {$lockUnlockVal==2} {   ;# unlock an alredy locked test bed
      set lines ""
      puts "Currently locked test bed(s):"
      puts "============================="
      if {[set fd_in [FileOpen $DEVREG(server,lockFile) r]]==-1} {
         return $fd_in
      }
      while {[gets $fd_in line]!=-1} {
         puts "$line"
         lappend lines $line
      }
      funlock $fd_in
      close $fd_in
      if {$lines!=""} {
      while {1} {
         puts "\n"
         puts -nonewline "Please enter one of above locked test beds:"
         flush stdout;
         gets stdin unlockTestbed;
         if {[lsearch -exact $lines $unlockTestbed]!=-1} {
            break
         } else {
            result_error "Test bed: $unlockTestbed is not locked amongst: $lines"
         }
      }
      if {[set fd_out [FileOpen $DEVREG(server,lockFile) w]]==-1} {
         return $fd_out
      }
      foreach line $lines {
         if {![regexp -nocase $unlockTestbed $line]} {
            #if [string compare $line $unlockTestbed]!=0
            puts $fd_out $line 
         }
      }
      close $fd_out
      result_ok "Successfully unlocked test bed: $unlockTestbed"
      return 1
      } else {
         result_error "No test bed server is currently locked"
         return -1
      }
   } elseif {$lockUnlockVal==3} {   ;# lock all unlock test beds
      set unlockTestbeds [runningServers]
      if {$unlockTestbeds==1} {result_error "No server running"; return -1"}
      ### Check if the lockTestbed is already locked
      foreach unlockTestbed $unlockTestbeds {
         if {[locked $unlockTestbed]} {
            result_debug "The test bed: $unlockTestbed is already locked"
         } else {   ;# lock it in $DEVREG(server,lockFile)
            if {[set fd_out [FileOpen $DEVREG(server,lockFile) a+]]==-1} {
               return $fd_out
            }
            puts $fd_out $unlockTestbed
            funlock $fd_out
            close $fd_out
            result_ok "Successfully locked test bed: $unlockTestbed"
         }
      }
      return 1
   } elseif {$lockUnlockVal==4} {    ;# Unlock all locked testbeds
      set lines ""
      puts "Currently locked test bed(s):"
      puts "============================="
      if {[set fd_in [FileOpen $DEVREG(server,lockFile) r]]==-1} {
         return $fd_in
      }
      while {[gets $fd_in line]!=-1} {
         puts "$line"
         lappend lines $line
      }
      funlock $fd_in
      close $fd_in
      if {$lines!=""} {
         if {[set fd_out [FileOpen $DEVREG(server,lockFile) w]]==-1} {
            return $fd_out
         }
         close $fd_out
      }
      return 1
   }
}

##################################################################
# Procedure Name: getStatus
#
# Description: This proc gets Called by only controlReg utility.
#              only meant to show the status of a given test bed server
#              In future, may need to add foll info as well:
#              Which queueId, module is run by server.
#              To achieve above, it requires to glob the imagesRunning dir to
#              look for desired configFile.
#
# Input args: config (tail of the config file path)
# Output args: none
# Typical usage:
#             set  retValue [getStatus $cfgFile]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc getStatus {config} {
   global DEVREG
   puts "Status of test bed server: $config"
   puts "=========================="
   if {[locked $config]} {   ;# if the config is locked, it means it is running as well
      puts "    RunStatus:   Running"
      puts "    LockStatus:  Locked"
      return 1
   } else {  ;# else check if the config is running and unlocked
      set runningServers [runningServers]
      if {[lsearch -exact $runningServers $config]!=-1} {
         puts "    RunStatus:   Running"
         puts "    LockStatus:  Unlocked"
         return 1
      }  else {
         result_error "The test bed server: $config is not running"
         return -1
      }
   }
}

##################################################################
# Procedure Name: prioritizeQueueId
#
# Description: This proc gets Called by only controlReg utility.
#              It is meant to repriortize a queueId from imagesQueued
#              A queueId may only be placed on the top of the stack
#              to be picked by regression servers.
#
# Input args: none
# Output args: none
# Typical usage:
#             set  retValue [prioritizeQueueId]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc prioritizeQueueId {} {
    global DEVREG
    set priorityFile [glob -nocomplain -- "$DEVREG(server,priorityFile)"]
    if {[set fd_pri [FileOpen $priorityFile r]]==-1} {
        return $fd_pri
    } else {
        array set qIds ""
        while {[gets $fd_pri line]!=-1} {
            set queueInfoFile $DEVREG(server,imagesQueuedDir)/$line/info
            ReadQueueInfoIntoArray $queueInfoFile uInput
            if {[info exists uInput(priority:)]} {
                set qIds($line) $uInput(priority:)
            } else {
                set qIds($line) 3
            }
        }
        close $fd_pri
      if {[array names qIds]!=""} {
         puts "\n"
         puts "Current queueIds in imagesQueued:"
         puts "================================="
         foreach name [array names qIds] {
            puts "$name\t$qIds($name)"
         }
         while {1} {
            puts -nonewline "Please enter one of the above queueIds to change its priority:"
            flush stdout
            gets stdin inputQId
            if {[lsearch [array names qIds] $inputQId]!=-1} {
               break
            } else {
               result_error "Queue id: $inputQId does not match any amongst: [array names qIds]"
            }
         }
         while {1} {
            puts -nonewline "Please enter new priority for $inputQId:"
            flush stdout
            gets stdin inputQIdPri
            # Check for priority
            if {$inputQIdPri<1 || $inputQIdPri>5} {
               result_error "Priority must be between 1 and 5"
            } else {
               set qIds($inputQId) $inputQIdPri
               break
            }
         }
         puts "\n"
         puts "New queueIds in imagesQueued:"
         puts "============================="
         foreach name [array names qIds] {
            puts "$name\t$qIds($name)"
         }
         puts -nonewline "Hit <Enter> to accept new imagesQueued, any other key to cancel:"
         flush stdout
         gets stdin prioritizeValue
         if {$prioritizeValue==""} {
            set queueInfoFile $DEVREG(server,imagesQueuedDir)/$inputQId/info
            ReadQueueInfoIntoArray $queueInfoFile uInput
            if {[set fd_inf [FileOpen $queueInfoFile w]]==-1} {
               return $fd_inf
            } else {
               foreach varName [array names uInput] {
                  if {$varName=="priority:"} {
                     puts $fd_inf "[format "%-20s %-20s" "$varName" $inputQIdPri]"
                  } else {
                     puts $fd_inf "[format "%-20s %-20s" "$varName" $uInput($varName)]"
                  }
               }
               close $fd_inf
               result_ok "Successfully created new priority file for imagesQueued"
               if {[info exists DEVREG(mysql,UseDb)] && $DEVREG(mysql,UseDb)} {
                   updateRegIdEntry -id_label "$inputQId" -priority "$inputQIdPri"
               }
               return 1
            }
         } else {
            result_error "PrioritizeQueue cancelled"
            return -1
         }
      } else {
         result_error "No image in imagesQueued to prioritize"
         return -1
      }
   }
}

##################################################################
# Procedure Name: GetModuleSubType
#
# Description: This proc returns the standard/routing module type(s)
#              from the list of moduleNAmes for a given platform
#              returns "" if invalid moduleName
#
# Input args:
#           platform: Mariner/Cougar/Aspen/PC
#           moduleNames: RIP L2 L3 qad
# Output args: none
# Typical usage:
#           set moduleType [GetModuleSubType $platformName $featureName $featureType]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc GetModuleSubType {platform moduleNames moduleTypes} {
   # platform is only used to get a list of legal platform modules
   # The moduleNames passed in are compared with the legal.
   global DEVREG
   global stdMods rtrMods cit2nodeMods
   global platformList
   set platformList $platform
   set moduleSubTypes ""
   if {![info exists rtrMods]} {
      set $rtrMods ""
   }
   if {![info exists stdMods]} {
      set $stdMods ""
   }
   if {![info exists cit2nodeMods]} {
      set $cit2nodeMods ""
   }
   set j 0
   set highCount [llength $moduleNames]
   set highCount1 [llength $moduleTypes]
   for {set y 0} {$y<$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {$moduleName  == ""} {
         continue;
      }
      if {[lsearch -exact "[GetModList std [lindex $moduleTypes $j] $platform]" $moduleName]==-1 && \
          [lsearch -exact "[GetModList rtr [lindex $moduleTypes $j] $platform]" $moduleName]==-1 && \
          [lsearch -exact "[GetModList cit2node [lindex $moduleTypes $j] $platform]" $moduleName]==-1} {
            puts "Bailed in module $moduleName"
            return ""
      }
      incr j;
   }
   set j 0
   set highCount [llength $moduleNames]
   for {set y 0} {$y<$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {[lsearch -exact "[GetModList rtr [lindex $moduleTypes $j] $platform]" $moduleName]!=-1} {   ;# Check if there is any routing module
         lappend moduleSubTypes routingModules
         break
      }
      incr j;
   }
   set j 0
   set highCount [llength $moduleNames]
   for {set y 0} {$y<$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {[lsearch -exact "[GetModList std [lindex $moduleTypes $j] $platform]" $moduleName]!=-1} {   ;# Check if there is any standard module
         lappend moduleSubTypes standardModules 
         break
      }
      incr j;
   }
   set j 0
   set highCount [llength $moduleNames]
   for {set y 0} {$y<$highCount} {incr y} {
      set moduleName [string trim [lindex $moduleNames $y]]
      if {[lsearch -exact "[GetModList cit2node [lindex $moduleTypes $j] $platform]" $moduleName]!=-1} {   ;# Check if there is any cit2node module
         lappend moduleSubTypes cit2nodeModules
         break
      }
      incr j;
   }
   return $moduleSubTypes
}

##################################################################
# Procedure Name: GetAModule
#
# Description: This proc returns the queue array as out var uInput
#              looks for queued module from imagesQueued dir based
#              on the priority file
#              QueueId is returned as the return value
#
# Input args:
#           regressionType: Standard/routing so that correct module
#                           may be picked
#           platformType: PC/Mariner so that correct platform 
#                         may be picked. For routing, platformType
#                         is ignored.
#           cfgFile: tail of the server config file path
# Output args: uInput: Read queue array
# Typical usage:
#           set myQueueId [GetAModule $regressionType $platformType uInput $cfgFileTail]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc GetAModule {regressionType platformType uInput cfgFile} {
   global modRegType stdMods rtrMods DEVREG MAIN
   upvar uInput userInput
   set runStatus "queued"
   after [expr int(rand()*3000)];
   #
   # The priority file contains all regression IDs in the imagesQueued/Running dir.
   #     Each line will have a regression that is waiting to be run
   if {[set fd_in [FileOpen $DEVREG(server,priorityFile) r]]==-1} {
      return $fd_in
   }
   set queue 0
   array unset userInput
   while {[gets $fd_in line]!=-1} {
      array unset userInput
      #
      # Priority is a regression id RTP_######_######
      set priority $line
      #      cd $DEVREG(server,imagesQueuedDir)/$priority
      
      # --------------------------------------------------------------
      # The queueInfoFile is created by runReg script. The queueId
      #  SC_######_###### is gathered from the priority file.  The
      #  queueId is the directory which holds all run information in
      #  the imagesQueued, imagesRunning, imagesFinished dir. etc.
      # --------------------------------------------------------------
      set queueInfoFile $DEVREG(server,imagesQueuedDir)/$priority/info
      if {![file exists $queueInfoFile] || [file isdirectory $queueInfoFile]} {   ;# if queueId does not exist
         puts "Hit info file $queueInfoFile - is directory"
         continue
      }
      # --------------------------------------------------------------
      # Open the info file and get the important regression info from
      #   it.
      # --------------------------------------------------------------
      if {[set fd_q [FileOpen $queueInfoFile r+]]==-1} {
         return $fd_q
      }
      # --------------------------------------------------------------
      # Setup the uinput Array from the info file
      #   !!! This is the main set up info for the entire run !!!
      # --------------------------------------------------------------
      set readInfoFile 0
      while {[gets $fd_q infoLine]!=-1} {
         set readInfoFile 1
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]; # info passed between procs
         set DEVREG(userInput,[lindex $infoLine 0]) [lrange $infoLine 1 end]; # global setting of info file
      }
      close $fd_q
      if {!$readInfoFile} {
          RemoveQidFromPriority $priority
          set catch_resp [catch "file delete -force $queueInfoFile" catch_msg]
          continue
      }
      if {[info exists userInput(lockFile:)] && ![info exists userInput(platformToRunOn:)]} {
         #
         # IF the info file has a lockFile and NO platform to run on, this is just a lock queue entry.
         #   ie /auto/automation/Util/runReg -lock
         #
         set lockFile $userInput(lockFile:)
         if {[string compare $lockFile $cfgFile]==0} {   ;# lockFile exists for me
            set runStatus "runningOn$cfgFile"
            set userInput(runStatus:) $runStatus
         }
      } else {
         #
         # This regression id is not a locking queue id.  It will have information on what
         #   needs to be run
         #
         # ---------------------------------------------------------------
         # Check for robot run
         # ---------------------------------------------------------------
         set MAIN(RobotJob) 0
         if {[info exists userInput(harness:)] && ![regexp -nocase "null" $userInput(harness:)]} {
            set MAIN(jobHarness)  $userInput(harness:)
            if {$MAIN(jobHarness) == "robot"} {
                set MAIN(RobotJob) 1
            }
         }
         #
         #  Check to see if the jenkins URL is set.
         #
         set DEVREG(active,jenkins) 0
         if {[info exists userInput(jenkins_url:)] && ![regexp -nocase "null" $userInput(jenkins_url:)]} {
            set DEVREG(active,jenkins) 1
            set DEVREG(active,jenkins_url) $userInput(jenkins_url:)
         }

         # if runSBox is executing from a different branch we need to grab those modules
         set inRelInfo 0
         if {[info exists userInput(relInfo:)]} {
             if {$userInput(relInfo:) != "" && [lsearch -exact $DEVREG(server,relInfoList) $userInput(relInfo:)]} {
                 set inRelInfo 1
                 catch {source ../Util/${userInput(relInfo:)}.cfg} oops
             }
         }
         if {$regressionType=="cit2node"} {   ;# Check if there are any Robot modules
             set counter 0
             if {($platformType==$userInput(platformToRunOn:)&&![info exists userInput(lockFile:)]) || \
                       ([info exists userInput(lockFile:)] && $userInput(lockFile:)==$cfgFile)} {
                 foreach userModule $userInput(moduleNames:) {
                    if {[info exists userInput(moduleTypes:)]} {
                        set myRegType  [lindex $userInput(moduleTypes:) $counter]
                        set modRegType $myRegType
                        set DEVREG(userInput,moduleType) [lindex $userInput(moduleTypes:) $counter]
                    } else {
                        set modRegType robotunit
                        set myRegType robotunit
                        set DEVREG(userInput,moduleType) robotunit
                    }
                    if {$counter == 0} {
                        set cit2Modules [_getCfgModuleList -cfgType cit2node -regType "robotunit" -swplat $platformType]
                    }
                    if {[lsearch -exact $cit2Modules $userModule]>=0} {
                        set runStatus [lindex $userInput(runStatus:) $counter]
                        if {$runStatus=="queued"} {
                            set runStatus "runningOn$cfgFile"
                            # Set this module as running
                            set userInput(runStatus:) [lreplace $userInput(runStatus:) $counter $counter "runningOn$cfgFile"]
                            #
                            # if Use Database is on, update the test module table entry for this module
                            #
                            if {$DEVREG(mysql,UseDb)} {
                                set rId [getRegIdFromQId $priority]
                                set ts [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
                                updateRegTestModule -reg_id $rId -name $userModule \
                                       -status "running" -testbed "$cfgFile" -start_timestamp "$ts"
                                updateRegIdStatus -reg_id $rId -status "Running"
                            }
                            break
                        }
                   }
                   incr counter
                 }
             }
         } elseif {$regressionType=="routing"} {   ;# Check if there is any routing module
            set counter 0
            if {($platformType==$userInput(platformToRunOn:)&&![info exists userInput(lockFile:)]) || \
                ([info exists userInput(lockFile:)] && $userInput(lockFile:)==$cfgFile)} {  ;# matched my platform type
                foreach userModule $userInput(moduleNames:) {
                   # -----------------------------------------------------------
                   # loop through all of the features to be run in the info file
                   # the regtype (functionaltest, snmp, xml, scalable, fit) are stored
                   # in a list with the same count and indexing as the modules
                   #  ACL              diffserv           diffserv
                   #  Functionaltest   Functionaltest     SnmpFunctionaltest
                   # -----------------------------------------------------------
                   if {[info exists userInput(moduleTypes:)]} {
                       set myRegType  [lindex $userInput(moduleTypes:) $counter]
                       set modRegType $myRegType
                       set DEVREG(userInput,moduleType) [lindex $userInput(moduleTypes:) $counter]
                   } else {
                       set modRegType functional
                       set myRegType functional
                       set DEVREG(userInput,moduleType) functional
                   }
                   if {$counter == 0} {
                       set rtrMods($myRegType,$platformType) [GetModList rtr $myRegType $platformType]
                   }
                   if {![info exists rtrMods($myRegType,$platformType)] || $inRelInfo} {
                       set rtrModules $rtrMods($myRegType,All)
                   } else {
                       set rtrModules $rtrMods($myRegType,$platformType)
                   }
                   if {[lsearch -exact $rtrModules $userModule]>=0} {
                      set runStatus [lindex $userInput(runStatus:) $counter]
                      if {$runStatus=="queued"} {
                         set runStatus "runningOn$cfgFile"
                         # Set this module as running
                         set userInput(runStatus:) [lreplace $userInput(runStatus:) $counter $counter "runningOn$cfgFile"]
                         # -------------------------------------------------------------------------
                         # if Use Database is on, update the test module table entry for this module
                         # -------------------------------------------------------------------------
                         if {$DEVREG(mysql,UseDb)} {
                             set rId [getRegIdFromQId $priority]
                             set ts [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
                             updateRegTestModule -reg_id $rId -name $userModule \
                                 -status "running" -testbed "$cfgFile" -start_timestamp "$ts"
                             updateRegIdStatus -reg_id $rId -status "Running" 
                         }
                         break
                      }
                   }
                   incr counter
                }
            } else { ;# did not match my platform type, go on to check if lockFile exists else go to next queueid
               continue
            }
         } elseif {$regressionType=="standard"} {  ;# Check if there is any standard module
            set counter 0
            if {($platformType==$userInput(platformToRunOn:)&&![info exists userInput(lockFile:)]) || \
                ([info exists userInput(lockFile:)] && $userInput(lockFile:)==$cfgFile)} {  ;# matched my platform type
               global dot1xPlatforms dot1xModules tahiPlatforms tahiModules
               foreach userModule $userInput(moduleNames:) {
                  # -----------------------------------------------------------
                  # loop through all of the features to be run in the info file
                  # the regtype (functionaltest, snmp, xml, scalable, fit) are stored
                  # in a list with the same count and indexing as the modules
                  #  ACL              diffserv           diffserv
                  #  Functionaltest   Functionaltest     SnmpFuntionaltest
                  # -----------------------------------------------------------
                  if {[info exists userInput(moduleTypes:)]} {
                      #puts "\n----\nHit the module type exists case\n----"
                      set myRegType  [lindex $userInput(moduleTypes:) $counter]
                      set modRegType $myRegType
                      set DEVREG(userInput,moduleType) [lindex $userInput(moduleTypes:) $counter]
                  } else {
                      set myRegType functional
                      set modRegType functional
                      set DEVREG(userInput,moduleType) functional
                  }
                  if {$counter == 0} {
                      set stdMods($myRegType,$platformType) [GetModList std $myRegType $platformType]
                  }
                  if {![info exists stdMods($myRegType,$platformType)] || $inRelInfo} {
                      set stdModules $stdMods($myRegType,All)
                  } else {
                      set stdModules $stdMods($myRegType,$platformType)
                  }
                  if {[regexp -nocase $DEVREG(server,dot1xModules) $userModule]} {
                     if {![regexp -nocase $DEVREG(server,dot1xPlatforms) $cfgFile]} {
                        incr counter;
                        continue;
                     }
                  }
                  if {[regexp -nocase $DEVREG(server,tahiModules) $userModule]} {
                     if {![regexp -nocase $DEVREG(server,tahiPlatforms) $cfgFile]} {
                        incr counter;
                        continue;
                     }
                  }
                  if {[lsearch -exact $stdModules $userModule]>=0} {
                     set runStatus [lindex $userInput(runStatus:) $counter]
                     if {$runStatus=="queued"} {
                        set runStatus "runningOn$cfgFile"
                        # Set this module as running
                        set userInput(runStatus:) [lreplace $userInput(runStatus:) $counter $counter "runningOn$cfgFile"]
                        # -------------------------------------------------------------------------
                        # if Use Database is on, update the test module table entry for this module
                        # -------------------------------------------------------------------------
                        if {$DEVREG(mysql,UseDb)} {
                            set rId [getRegIdFromQId $priority]
                            set ts [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
                            updateRegTestModule -reg_id $rId -name $userModule \
                                -status "running" -testbed "$cfgFile" -start_timestamp "$ts"
                            updateRegIdStatus -reg_id $rId -status "Running" 
                        }
                        break
                     }
                  }
                  incr counter;
               }
            } else {  ;# did not match my platform type, go on to check if lockFile exists else go to next queueid
               continue
            }
         } ;# else if standard regression
      } ;# else if lock file doesn't exist
      if {[regexp -nocase "runningOn" $runStatus] && [file exists $queueInfoFile]} {
         set queue $priority
         break
      }
   }
   
   close $fd_in
   return $queue
}


##################################################################
# Procedure Name: UpdateImagesRunning
#
# Description: This proc gets called by the regServer to update 
#              info file for imagesQueued and imagesRunning.
#              After the module is started, the corresponding entry is
#              changed to takenBy in imagesQueued and runninOn in imagesRunning.
#
# Input args:
#           qId: queueId to work on inside imagesQueued/imagesRunning
#           userIp: User info array as passed by the caller
#           cfgFile: tail of the server config file path
# Output args: none
# Typical usage:
#           if {[UpdateImagesRunning $myQueueId [array get uInput] $cfgFileTail]==-1} {
#            exit -1
#         }
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc UpdateImagesRunning {qId userIp cfgFile} {
   global DEVREG

   set queueInfoFile $DEVREG(server,imagesQueuedDir)/$qId/info
   array set uInput $userIp

   # update the imagesQueued in case a valid module found
   set retCode 1
   if {[set fd_inout [FileOpen $queueInfoFile r+]]==-1} {   ;# open r+ as need to modify, do not write
      return $fd_inout
   } else {
      set count 0
      foreach runStatus $uInput(runStatus:) {
         if {[regexp -nocase "runningOn" $runStatus]} {
            set uInput(runStatus:) [lreplace $uInput(runStatus:) $count $count "takenBy$cfgFile"]
            set runningIndex $count  ;# There should be only one "runningOn" per call to UpdateImagesRunning
            break
         }
         incr count
      }
      if {[lsearch $uInput(runStatus:) "queued"]==-1} {  ;# no more to run on, remove the dir itself
         close $fd_inout;
         if {[file exists $queueInfoFile]} {
             file delete $queueInfoFile;
         }
         if {[set retCode [RemoveQidFromPriority $qId]]==-1} {
            file delete -force $DEVREG(server,imagesQueuedDir)/$qId   ;# This right here also deletes the .xos image files
            return $retCode
         }
         set retCode 2  ;# This code tells regServer to remove queuedId after downloadImage
      } else {
         foreach varName [array names uInput] {
            puts $fd_inout "[format "%-20s %-20s" "$varName" $uInput($varName)]"
         }
         ftruncate $queueInfoFile [tell $fd_inout]
         close $fd_inout
      }
   }

   # update the imagesRunning in case a valid module found
   array set uInput $userIp
   set runningQueueFile "$DEVREG(server,imagesRunningDir)/$qId"
   set value [expr round(rand() * 8999) + 100]
   after $value ;# To avoid race condition sometimes amongst the servers
   if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;# qId is already running
      # Have to be careful writing as other servers might be
      # running as well.
      # At this point, Read the running info file, change the status of module
      # at runningIndex index that was grabbed from queueInfoFile
      if {[set fd_q [FileOpen $runningQueueFile/info r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
#      result_debug "array runningRegression [parray userInput]"
      seek $fd_q 0 start
      set userInput(runStatus:) [lreplace $userInput(runStatus:) $runningIndex $runningIndex "runningOn$cfgFile"]
      # -------------------------------------------------------------------------
      # if Use Database is on, update the test module table entry for this module
      # -------------------------------------------------------------------------
      if {$DEVREG(mysql,UseDb)} {
          set rId [getRegIdFromQId $qId]
          set ts [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
          updateRegTestModule -reg_id $rId -name [lindex $userInput(moduleNames:) $runningIndex] \
              -status "running" -testbed "$cfgFile" -start_timestamp "$ts"
          updateRegIdStatus -reg_id $rId -status "Running" 
      }
      foreach varName [array names userInput] {
         puts $fd_q "[format "%-20s %-20s" "$varName" $userInput($varName)]"
      }  
      ftruncate $runningQueueFile/info [tell $fd_q]
      close $fd_q
   } else {  ;# qId is running first time fresh
      if {![file isdirectory $DEVREG(server,imagesRunningDir)]} {
         if {[catch {file mkdir $DEVREG(server,imagesRunningDir)} reason]} {
            result_error "Error: Can not create imagesRunningDir dir...$reason"
            return -1
         }
      }
      if {[catch {file mkdir "$runningQueueFile"} reason]} {
         result_error "Error: Cannot create dir $runningQueueFile...$reason";
         return -1
      }
      if {[set fd_out [FileOpen $runningQueueFile/info w]]==-1} {
         return $fd_out
      }
      foreach varName [array names uInput] {
         puts $fd_out "[format "%-20s %-20s" "$varName" $uInput($varName)]"
      }
      ftruncate $runningQueueFile/info [tell $fd_out]
      close $fd_out
      # -------------------------------------------------------------------------
      # if Use Database is on, update the run_reg with starttime of first mod
      # -------------------------------------------------------------------------
      if {$DEVREG(mysql,UseDb)} {
          set rId [getRegIdFromQId $qId]
          set ts [clock format [clock seconds] -format "%Y-%m-%d %H:%M:%S"]
          updateRegIdEntry -reg_id $rId -start_timestamp "$ts"
      }
   }
   ### Check if lockFile exists, (a).change modes for runReg to unlock, (b). Send email to userid
   if {[info exists uInput(lockFile:)] && ![info exists uInput(platformToRunOn:)]} {
      chmod 0777 $runningQueueFile/info
      if {[catch {source [pwd]/../main/cfg/$uInput(lockFile:)} reason]} {
          puts "error sourcing cfg file: $reason"
          set conStr "";
      } else {
          set conStr "D)."
          for {set j 1} {$j <= 5} {incr j} {
              if {[info exists DUT${j}_CONNECT] && [info exists DUT${j}_IP]} {
                  set conStr [append conStr " DUT$j console: [set DUT${j}_CONNECT]\r"]
                  set conStr [append conStr " DUT$j Mgmt IP: [set DUT${j}_IP]\r"]
              }
          }
      }
      if {[catch {eval ClearTestbedSessions} freason]} {
          puts "error clearing the consoles: $freason"
      }
      if {[info exists uInput(faillock:)] && $uInput(faillock:) == "yes"} {
          set conStr " You have selected to lock this test bed if a script fails\n\r"
          if {[info exists ixiaCh1]} {
              set conStr [append conStr " The ixia IP is $ixiaCh1 - you should be able to VNC or RDP to the chassis\n\r"]
              set conStr [append conStr " Open IxExplorer, highlight the chassis and push F5 to sync HW to IxExplorer\n\r"]
              if {[info exists startCardNum]} {
                  set conStr [append conStr " The Ixia slot is $startCardNum\n\r"]
              }
          }
      }
      set str [append str [PrintUserQueue [array get uInput] $qId]]
      set str [append str "To UNLOCK use /auto/automation/Util/runReg -unlock $qId\n\r"]
      set str [append str "If you do not get an unlock email shortly after the command above\n\r    /auto/automation/Util/killReg -q $qId -f yes\n\r"]
      set str [append str "A). ALWAYS DOWNLOAD YOUR TEST SOFTWARE TO THE SECONDARY BANK.\n\r"]
      set str [append str "B). Make sure to leave the DUTs in usable condition\n\r"]
      set str [append str "C). Make sure to leave the console connection to DUTs open\n\r"]
      set str [append str "$conStr\n\r"]
      if {[regexp -nocase "\@" $uInput(userid:)]} {
         set toBeSent "$uInput(userid:).extremenetworks.com"
      } else {
         set toBeSent "$uInput(userid:)@extremenetworks.com"
      }
      exec /bin/mail -s "Queueid:$qId ***locked*** testbed $uInput(lockFile:):" \
           "$toBeSent" \
           -- -r "Sqaautosupport@extremenetworks.com" << "$str" &
   }
   return $retCode
}
##################################################################
# Procedure Name: UpdateImagesDone
#
# Description: This proc gets called by the regServer to update 
#              info file when a module is finished (pass/fail) or
#              LoadImage failed.
#              It creates imagesFinished/qId and moves the log of module/
#              LoadImage into corresponding imagesFinished dir.
#              switches based on the updateStr
#              Performs glob to look for correct dir inside module/LoadImage
#
# Input args:
#           qId: queueId to work on inside imagesFinished
#           runIndex: Index inside info file for a module for a queueId
#           updateStr: success/failure of the given module
# Output args: dirToReturn: Directory path of the log location
# Typical usage:
#           UpdateImagesDone $myQueueId $runningIndex PASS targetDir
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc UpdateImagesDone {qId runIndex updateStr dirToReturn} {
   global DEVREG
   upvar $dirToReturn targetDir

   WriteToQueueDebug "UpdateImagesDone args" "qId $qId\nrunIndex $runIndex\n\
                      updateStr $updateStr\ndirToReturn $dirToReturn";

   set runningQueueFile "$DEVREG(server,imagesRunningDir)/$qId"
   set targetDir ""
   set skipUpdate 1
   if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;# qId is already running
      if {[set fd_q [FileOpen $runningQueueFile/info r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
#      result_debug "array runningRegression [parray userInput]"
#
# Add robot case.  if $userInput(harness:) == "robot"
#
#
      if {[set targetDir [MoveReportToQueueFinished $qId [array get userInput] $runIndex $updateStr]]==-1} {
         set targetDir "Report dir not generated"
      } elseif {$targetDir==137} {  ;# killed signal, no need to process further
         return -1
      }
      if {[regexp -nocase "^PASS" $updateStr]} {
       set testsPassed 0
       set testsFailed 1
       set testsDuration 0
       set swRevNum ""
       set reportFileName "$targetDir/report.txt"
       # EY-02-09-2009: Add "--" to prevent $targetDir from being
       # misinterpreted as a regexp argument.
       if {![regexp -nocase -- "Report dir not generated" $targetDir]} {
           if {[set fd_in [FileOpen $reportFileName r reason]]==-1} {
              return $fd_in
           }
           while {[gets $fd_in line]!=-1} {
              set str [append str "\n" $line]
              if {[regexp -nocase "^number of sub test cases failed" $line]} {
                 set testsFailed [lindex $line [expr [llength $line]-1]]
              }
              if {[regexp -nocase "^number of sub test cases passed" $line]} {
                 set testsPassed [lindex $line [expr [llength $line]-1]]
              }
              if {[regexp -nocase "^Total test time" $line]} {
                 set testsDuration [lindex $line [expr [llength $line]-2]]
              }
              if {[regexp -nocase "^revision number:" $line]} {
                 set swRevNum [lindex $line [expr [llength $line]-1]]
              }
           }
           close $fd_in
       }
       if {$testsFailed>=1} {
          set testsTotal [expr $testsFailed + $testsPassed]
          WriteToQueueDebug "UpdateImagesDone FAILED" "testsTotal $testsTotal\n\
                             testsFailed $testsFailed\ntestsPassed  $testsPassed";
          # -------------------------------------------------------------------------
          # By default successfully finishing the reg gives a pass.  Since report.txt
          #    analysis shows a fail count regsub FAIL for PASS
          # -------------------------------------------------------------------------
          regsub -all "PASS" $updateStr "FAIL" updateStr   ;# replace pass with fail string as some tests failed
          # -------------------------------------------------------------------------
          # if Use Database is on, update the test module table entry for this module
          # -------------------------------------------------------------------------
          if {$DEVREG(mysql,UseDb)} {
              set rId [getRegIdFromQId $qId]
              if {$DEVREG(active,inrerun)} {
                  WriteToQueueDebug "UpdateImagesDone in PASS/FAIL RERUN" \
                     "[lindex $userInput(moduleNames:) $runIndex] Mod status \
                     = [lindex $userInput(runStatus:) $runIndex]"
                  puts "----\nUpdate test_module status Fail on Rerun \npass $testsPassed fail $testsFailed duration $testsDuration\n----"
                  updateRegTestModule -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status "Fail" -pass_cnt_1 "$testsPassed" -total_cnt_1 "$testsTotal" \
                      -duration_1 "$testsDuration" -sqa_revision "$swRevNum"
              } else {
                  WriteToQueueDebug "UpdateImagesDone in PASS/FAIL" \
                         "[lindex $userInput(moduleNames:) $runIndex] Mod status = \
                         [lindex $userInput(runStatus:) $runIndex]"
                  puts "----\nUpdate test_module status Fail\npass $testsPassed fail $testsFailed duration $testsDuration\n----"
                  updateRegTestModule -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status "Fail" -pass_cnt "$testsPassed" -total_cnt "$testsTotal" \
                      -duration "$testsDuration" -sqa_revision "$swRevNum"
              }
          }
       } else {
          set testsTotal [expr $testsFailed + $testsPassed]
          WriteToQueueDebug "UpdateImagesDone PASS" "testsTotal $testsTotal\n\
                             testsFailed $testsFailed\ntestsPassed  $testsPassed";
          # -------------------------------------------------------------------------
          # if Use Database is on, update the test module table entry for this module
          # -------------------------------------------------------------------------
          if {$DEVREG(mysql,UseDb)} {
              set rId [getRegIdFromQId $qId]
              if {$DEVREG(active,inrerun)} {
                  WriteToQueueDebug "UpdateImagesDone in PASS/FAIL RERUN" \
                         "[lindex $userInput(moduleNames:) $runIndex] Mod status = \
                         [lindex $userInput(runStatus:) $runIndex]"
                  puts "----\nUpdate test_module status Pass on Rerun \npass $testsPassed fail $testsFailed duration $testsDuration\n----"
                  updateRegTestModule -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status "Pass" -pass_cnt_1 "$testsPassed" -total_cnt_1 "$testsTotal" \
                      -duration_1 "$testsDuration" -sqa_revision "$swRevNum"
              } else {
                  WriteToQueueDebug "UpdateImagesDone in PASS/FAIL" \
                         "[lindex $userInput(moduleNames:) $runIndex] Mod status = \
                         [lindex $userInput(runStatus:) $runIndex]"
                  puts "----\nUpdate test_module status Pass\npass $testsPassed fail $testsFailed duration $testsDuration\n----"
                  updateRegTestModule -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                      -status "Pass" -pass_cnt "$testsPassed" -total_cnt "$testsTotal" \
                      -duration "$testsDuration" -sqa_revision "$swRevNum"
              }
          }             
       }
      }
      set preRunStat $userInput(runStatus:)
      set userInput(runStatus:) [lreplace $userInput(runStatus:) $runIndex $runIndex "$updateStr"]
      WriteToQueueDebug "UpdateImagesDone replace runStatus with updateStr" \
             "Init status: $preRunStat\nupdateStr: $updateStr\n\
              New userInput(runStatus:): $userInput(runStatus:)"
      # -------------------------------------------------------------------------
      # if Use Database is on, update the test module table entry for this module
      # -------------------------------------------------------------------------
      if {$DEVREG(mysql,UseDb)} {
          set tmStatus ""
          set rrStatus ""
          set rId [getRegIdFromQId $qId]
          # ---------------------------------------------------------------------
          # At this port runStatus has already been replaced to current state
          #   - so just update the db
          # ---------------------------------------------------------------------
          if {[regexp -nocase "mainkill" $updateStr]} {
              puts "Hit mainkill"
              set tmStatus "MainKill"
              set rrStatus "Complete"
          } elseif {[regexp -nocase "mainfail" $updateStr]} {
              puts "Hit MainFail"
              set tmStatus "MainFail"
              set rrStatus "Complete"
              set skipUpdate 0
          } elseif {[regexp -nocase "downloadfail" $updateStr]} {
              puts "Hit DnldFail"
              set tmStatus "DnldFail"
              set rrStatus "Complete"
              set skipUpdate 0
          } elseif {[regexp -nocase "downloadkill" $updateStr]} {
              puts "Hit DnldKill"
              set tmStatus "DnldKill"
              set rrStatus "Complete"
          }  elseif {[regexp -nocase "pass" $updateStr]} {
              puts "Hit Pass"
              set skipUpdate 1
              set rrStatus "Complete"
          } else {
              puts "Hit ELSE mainkill"
              set tmStatus "MainFail"
              set rrStatus "Complete"
          }
          if {!$skipUpdate} {
              puts "Update test_module status $tmStatus"
              updateRegTestModule -reg_id $rId -name [lindex $userInput(moduleNames:) $runIndex] \
                  -status "$tmStatus"
          }
      }      
      # no more in queued/running mode, move this queue to $imagesFinishedDir
      if {[lsearch -regexp $userInput(runStatus:) "queued|running|reRunOn"]==-1} {
         WriteToQueueDebug "UpdateImagesDone Run Completed" \
                 "userInput(runStatus:): $userInput(runStatus:)"
         # -------------------------------------------------------------------------
         # if this is a jenkins run, send the jenkins url update
         # -------------------------------------------------------------------------
         if {$DEVREG(active,jenkins)} {
            puts "Jenkins update reg_run rId status $rrStatus"
            if {[regexp -nocase "fail" $userInput(runStatus:)]} {
                updateJenkinsRegIdStatus -q_id $qId -reg_id "$rId" -status ${rrStatus}_Fail -url "$DEVREG(active,jenkins_url)"
            } else {
                updateJenkinsRegIdStatus -q_id $qId -reg_id "$rId" -status ${rrStatus}_Pass -url "$DEVREG(active,jenkins_url)"
            }
         }
         # -------------------------------------------------------------------------
         # if Use Database is on, update the reg_run table entry for this module
         # -------------------------------------------------------------------------
         if {$DEVREG(mysql,UseDb)} {
            puts "Update reg_run rId status $rrStatus"
            updateRegIdStatus -reg_id "$rId" -status "$rrStatus"
         }
         if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
            if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
               result_error "Error: Can not create imagesFinishedDir dir...$reason"
               return -1
            }
         }
         if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId]} {
            if {[catch {file mkdir "$DEVREG(server,imagesFinishedDir)/$qId"} reason]} {
               result_error "Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId...$reason";
               return -1
            }
         }
         seek $fd_q 0 start
         foreach varName [array names userInput] {
            puts $fd_q "[format "%-20s %-20s" "$varName" $userInput($varName)]"
         }
         ftruncate $runningQueueFile/info [tell $fd_q]
         close $fd_q
         if {[catch {file rename -force $runningQueueFile/info "$DEVREG(server,imagesFinishedDir)/$qId/info"} reason]} {   ;# Force chosen as first run might create it already
            result_error "Error: Cannot rename $runningQueueFile/info to $DEVREG(server,imagesFinishedDir)/$qId/info...$reason";
            return -1
         } else {
            file delete $runningQueueFile
            return 1
         }
      } else {
         seek $fd_q 0 start
         foreach varName [array names userInput] {
            puts $fd_q "[format "%-20s %-20s" "$varName" $userInput($varName)]"
         }
         ftruncate $runningQueueFile/info [tell $fd_q]
         close $fd_q
         return 1
      }
   } else {  ;# qId not Found, an error
      WriteToQueueDebug "UpdateImagesDone" \
                 "QID NOT FOUND IN imagesRunning $qId...$queues"
      result_error "Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues";
      return -1
   }
}


##################################################################
# Procedure Name: RemoveQidFromPriority
#
# Description: As name indicates, this proc deletes a QueueId from the
#              priority file inside imagesQueued.
#
# Input args:
#           QueueId: queueId to work on inside imagesQueued
# Output args: none
# Typical usage:
#           if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc RemoveQidFromPriority {QueueId} {
   global DEVREG
   set lines ""
   if {[set fd_in [FileOpen $DEVREG(server,priorityFile) r+]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      lappend lines $line
   }
   seek $fd_in 0 start   ;# go to the top of the file again
   foreach line $lines {
      if {$line!=$QueueId} {
          set line [string trim $line "^@"];# Trim odd hex being added from someplace
          set line [string trim $line];
          if {[regexp {[A-Z]{3,3}_[0-9]{6,6}_[0-9]{6,6}} $line]} {
              puts $fd_in $line
          } else {
              puts "\n!!!\n!!!\n!!! BAD BAD BAD queueid $line !!!\n!!!\n!!!"
          }
      }
   }
   ftruncate $DEVREG(server,priorityFile) [tell $fd_in]
   close $fd_in
   return 1
}

##################################################################
# Procedure Name: ScheduleToKill
#
# Description: This proc replaces queued modules to be killed in case
#              user chose to kill a regression whole partial module(s)
#              are running.
#
# Input args:
#           qDir: Absolute path of queueId inside imagesQueued
# Output args: outIp: Returns the constructed info file
# Typical usage:
#           if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc ScheduleToKill {qDir outIp} {
   global DEVREG
   upvar outIp userInput

   # The caller will call this proc only if any module is queued and taken
   # in which case, this proc would remove the queue from imagesQueued
   # and update the same queue in imagesRunning for kill
   # Its better to delete all the 

   if {[set fd_inout [FileOpen $qDir/info r+]]==-1} {
      return $fd_inout
   }
   while {[gets $fd_inout infoLine]!=-1} {
      set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
   }
   for {set i 0} {$i<[llength $userInput(runStatus:)]} {incr i} {
      set status [lindex $userInput(runStatus:) $i]
      if {$status=="queued"} {
         set userInput(runStatus:) [lreplace $userInput(runStatus:) $i $i "killed"]
      }
   }
   seek $fd_inout 0 start   ;# go to the top of the file again
   foreach varName [array names userInput] {
      puts $fd_inout "[format "%-20s %-20s" "$varName" $userInput($varName)]"
   }
   ftruncate $qDir/info [tell $fd_inout]
   close $fd_inout
   puts "the arr [parray userInput]"
   return 1
}

##################################################################
# Procedure Name: UpdateIdle
#
# Description: This proc performs the update of a up file
#              to determine the uptime of a server.
#              Though new way has been devised to check for the servers'
#              uptime, this proc is retained (along with callers code) for
#              historical reasons for now.
#              The uptime is updated in terms of clock seconds in cfgFile
#
# Input args:
#           cfgFile: tail of the cfgFile to update the uptime with
# Output args: none
# Typical usage:
#           UpdateIdle $cfgFileTail
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc UpdateIdle {cfgFile} {
   global DEVREG

   set up [FileOpen "$DEVREG(server,regressionDir)/$cfgFile" "w"]
   puts $up [clock seconds]
   close $up
   after 3000
}

##################################################################
# Procedure Name: LocateQueueId
#
# Description: Given a qId, this proc locates the queueId from
#              any of imagesQueued/imagesRunning/imagesFinished dirs
### If some of the module are taken from a queue at a given instance,
### this proc would return the _imagesRunningDir_ location of the queue
### instead of imagesQueuedDir
### In above case, same queue will apear in both the dirs imagesQueuedDir
### and imagesRunningDir
### If it returns imagesRunningDir, it means all the modules in that
### queue are running at that instance
#
# Input args:
#           cfgFile: tail of the cfgFile to update the uptime with
# Output args: none
# Typical usage:
#           UpdateIdle $cfgFileTail
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc LocateQueueId {qId} {
   global DEVREG

   set imageDir -1
   ### Check for the qId in imagesRunningDir
   set imageDir [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/$qId]
   if {$imageDir!=""} {   ;# found match in imagesRunningDir
      return $imageDir
   } else {   ;# did not find match in imagesRunningDir
      ### Check for the qId in priorityFile
      set prFile [glob -nocomplain -- $DEVREG(server,priorityFile)]
      if {[set fd_pri [FileOpen $prFile r]]==-1} {
         return $fd_pri
      } else {
         while {[gets $fd_pri line]!=-1} {
            if {$line==$qId} {   ;# found match in imagesQueuedDir
               close $fd_pri
               return "$DEVREG(server,imagesQueuedDir)/$line"
            }
         }
         close $fd_pri  ;# did not find in imagesQueuedDir
      }
      set imageDir [glob -nocomplain -- $DEVREG(server,imagesFinishedDir)/$qId]
      if {$imageDir!=""} {  ;# found match in imagesFinishedDir
         return $imageDir
      } else {
         set imageDir [glob -nocomplain -- $DEVREG(server,imagesKilledDir)/$qId]
         if {$imageDir!=""} {  ;# found match in imagesKilled dir
             return $imageDir
         }
         return -1  ;# did not find match anywhere
      }
   }
}
##################################################################
#  Procedure Name: WriteToQueueDebug
#  Queue Debug Proc
#
# Category: Setup
##################################################################
proc WriteToQueueDebug {whereAmI text} {
   global DEVREG
   if {[info exists DEVREG(server,enableLogFile)] && $DEVREG(server,enableLogFile) && \
       [info exists DEVREG(server,queueLogFileName)]} {
       if {[set fd_out [FileOpen $DEVREG(server,queueLogFileName) a+]]==-1} {
            return $fd_out
       }
       catch {puts $fd_out "==== $whereAmI ====\n$text"} what
      funlock $fd_out
      close $fd_out
   }
}
##################################################################
#  Procedure Name: CreateQueueDebug
#  Queue Debug Proc
#
#
# Input args: none
# Output args: none
# Typical usage:
#           CreateQueueDebug
# Category: Setup
##################################################################
proc CreateQueueDebug { myQueueId runningIndex cfgFileTail } {
   global DEVREG
   if {[info exists DEVREG(server,enableLogFile)] && $DEVREG(server,enableLogFile)} {
       set DEVREG(server,queueLogFileName) "../main/Log/Q Debug $myQueueId $runningIndex $cfgFileTail.txt"
       puts "\n!!!!!\nQueue System Logging is E N A B L E D\n!!!!!\n";
   } else {
       puts "\n!!!!!\nQueue System Logging is  N O T  Enabled\n!!!!!\n";
   }
}
##################################################################
# Procedure Name: MoveReportToQueueFinished
#
# Description: This proc moves determins the correct target dir based on 
#              moduleUpdateStr. returns the targetDir to caller
#
# Input args:
#           queueId: queue id to work on
#           userIp: array of info file as passed  from the caller
#           index: runIndex to locate the desired module on which server worked on
#           moduleUpdateStr: take action appropriately based on moduleUpdateStr
# Output args: none
# Typical usage:
#           if {[set targetDir [MoveReportToQueueFinished $myQueueId \
#                              [array get uInput] $runningIndex downloadPassed]]==-1}
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc MoveReportToQueueFinished {queueId userIp index moduleUpdateStr} {
    global DEVREG
    global routingModules
    global env
    array set uInput $userIp
    global mainRetReRun
    global cfg
    global cfgFileTail
    global BLADES

    set moduleName [lindex $uInput(moduleNames:) $index]
    if {[info exists uInput(moduleTypes:)]} {
        set moduleType [lindex $uInput(moduleTypes:) $index]
        WriteToQueueDebug "MoveReportToQueueFinished" \
        "Found moduleTypes index for $moduleName index $index moduleType $moduleType"
    } else {
        set moduleType functional
        WriteToQueueDebug "MoveReportToQueueFinished" \
        "Found moduleTypes index for $moduleName index $index moduleType $moduleType"
    }
    set myRegPath  [GetModuleFullType $moduleType directory] ;# $myRegPath - Functionaltest | XML_API etc.
    set myNewType  [GetModuleFullType $moduleType runreg]
    set PLATFORM ""
    if {[info exists uInput(lockFile:)] && ![info exists uInput(platformToRunOn:)]} {
        if {[file isdirectory $DEVREG(server,imagesRunningDir)/$queueId]} {
            if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/$queueId \
                $DEVREG(server,imagesFinishedDir)} reason]} {
                WriteToQueueDebug "MoveReportToQueueFinished" \
                "Could not move $DEVREG(server,imagesRunningDir)/$queueId, $reason";
                result_error "Could not move $DEVREG(server,imagesRunningDir)/$queueId, $reason"
                return -1
            } else {
                WriteToQueueDebug "MoveReportToQueueFinished" "No plattoRunOn is set -- Return";
                return 1
            }
        } else {
            WriteToQueueDebug "MoveReportToQueueFinished" \
            "Could not find $DEVREG(server,imagesRunningDir)/$queueId";
            result_error "Could not find $DEVREG(server,imagesRunningDir)/$queueId"
            return -1
        }
    } else {
        WriteToQueueDebug "MoveReportToQueueFinished" \
            "Not a user lock. set platformType $uInput(platformToRunOn:)";
        set platformType $uInput(platformToRunOn:)
    }
    if {[info exists uInput(relInfo:)]} {
        WriteToQueueDebug "MoveReportToQueueFinished" "set releaseInfo $uInput(relInfo:)";
        set releaseInfo $uInput(relInfo:)
    } else {
        WriteToQueueDebug "MoveReportToQueueFinished" \
        "set releaseInfo current B/C no info exist uInput(relInfo)";
        set releaseInfo "current"
    }
    if {$releaseInfo==""} {
        WriteToQueueDebug "MoveReportToQueueFinished" "set releaseInfo current B/C releaseInfo=null";
        set releaseInfo "current"
    }
    #puts "\n<<<\n The releaseInfo $releaseInfo\nThe platformType at this point is $platformType\n >>>\n"
    global env
    global $platformType ; #Wierd. global the platform ex. Aspen later $Aspen will give legal prompt
    global bothAspen bothAspennapa bothOlympic bothJaguar bothNetgear ;# same as above.  For legal prompts
    set none ""
    set cfgFileName [lindex $uInput(runStatus:) $index]
    set cfgFile [string range $cfgFileName 9 end]  ;# get the cfg filename from runningOn$cfgFile
    set targetDir ""
    set Path Path

    result_debug "the moduleUpdateStr $moduleUpdateStr and cfgFile $cfgFile"
    WriteToQueueDebug "MoveReportToQueueFinished CONFIG FILE CHECK:" \
    "cfgFile $cfgFile - cfgFileTail $cfgFileTail - cfg $cfg"

    switch -regexp $moduleUpdateStr {
        "^PASS" {
            WriteToQueueDebug "MoveReportToQueueFinished plat: $platformType $queueId match Glob" \
                "$DEVREG(relInfoPath,$releaseInfo)/../${myRegPath}/$moduleName/Report/*$queueId*";
            set dirList [glob -nocomplain -- \
              "$DEVREG(relInfoPath,$releaseInfo)/../${myRegPath}/$moduleName/Report/*$queueId*"]
            set count 1
            WriteToQueueDebug "MoveReportToQueueFinished DirList" "$dirList";
            while {1} {  ;# While I do not know the target report dir
                set reportDir [lindex $dirList [expr [llength $dirList] -$count]]
                if {$reportDir==""} {
                    break
                }
                result_debug "The report dir = $reportDir"
                WriteToQueueDebug "MoveReportToQueueFinished in While to find dir" \
                  "The report dir = $reportDir";
                set reportFileName "$reportDir/report.txt"
                if {![file exists $reportFileName]} {
                    WriteToQueueDebug "MoveReportToQueueFinished in While, report.txt does not exist" \
                       "$reportFileName";
                    result_debug "Report file does not exist: $reportFileName"
                    break;
                }
                if {[set fd_in [FileOpen "$reportFileName" r]]==-1} {
                    return $fd_in
                }
                set targetDir ""
                while {[gets $fd_in readLine]!=-1} {
                    # Following line works for both runningOn and reRunOn strings
                    # For runningOn, cfgFile is matched
                    # For reRunOn, the queueId is matched
                    # Open the report.txt and look for the config file name
                    if {[regexp -nocase "^Using config file: .*$cfgFile" $readLine]||\
                      [regexp -nocase "^Using config file: .*$queueId" $readLine]} {
                        set targetDir $reportDir
                        break
                    }
                }
                funlock $fd_in
                close $fd_in
                if {$targetDir!=""} {
                    break
                }
                incr count
            }
            if {[GetModuleSubType $platformType $moduleName $myNewType] == "routingModules"} {
                set regSubType ipRoute1
            } else {
                set regSubType standard
            }
            regsub -all "    " $targetDir " " targetDir2
            regsub -all "   " $targetDir2 " " targetDir2
            regsub -all "  " $targetDir2 " " targetDir2
            set strl [split $targetDir2 " "]

            # Pull platform blade and build info from the report directory.
            set lastm1 [lindex $strl [expr [llength $strl]-2]]
            set lastm2 [lindex $strl [expr [llength $strl]-3]]
            set lastm3 [lindex $strl [expr [llength $strl]-4]]
            set lastm4 [lindex $strl [expr [llength $strl]-5]]
            set lastm5 [lindex $strl [expr [llength $strl]-6]]
            if [regexp {([0-9]+)\.([0-9]+)\.([0-9]+)} $lastm1] {
                set parsedBuild $lastm1
                set parsedBlade $lastm2
                set parsedBlade2 $lastm3
            } elseif [regexp {([0-9]+)\.([0-9]+)\.([0-9]+)} $lastm2] {
                set parsedBuild $lastm2
                set parsedBlade $lastm3
                set parsedBlade2 $lastm4
            } else {
                set parsedBuild $lastm3
                set parsedBlade $lastm4
                set parsedBlade2 $lastm5
            }
            WriteToQueueDebug "MoveReportToQueueFinished: Parse Report Dir to get build and blade" \
            "$targetDir split parsedBuild $parsedBuild parsedBlade2 $parsedBlade2 parsedBlade $parsedBlade";
            global supportedPlatform
            global userQDir
            set tmpQStr [format  %s_%s $queueId $uInput(platformToRunOn:)]
            set env(WEBSERVERDIR) "$userQDir/$uInput(userid:)/$tmpQStr"
            cd "../main"
            ### Do not call mysqlAutomate on rerun as mysqlMain already calls it.
            if {![info exists mainRetReRun]} {
                WriteToQueueDebug "MoveReportToQueueFinished: Calling get_platform_code" "ParsedBlade \
                $parsedBlade ParseBlade2 parsedBlade2 - proc args $myNewType \
                $regSubType ";
                if {[set PLATFORM [get_platform_code $myNewType $regSubType depricated $parsedBlade]]!=\
                    "not_found"} {
                    WriteToQueueDebug "MoveReportToQueueFinished " "Calling mysqlAutomate w/ known blade \
                        -regId $queueId, platform $PLATFORM, build $parsedBuild, module $moduleName, \
                        regSubType $regSubType,regType $myNewType \
                        $parsedBlade , targetDir $targetDir";
                    result_debug "<<<Calling mysqlAutomate w/ known blade -regId $queueId, \n \
                        reportDir = $targetDir, \n \
                        platform $PLATFORM, \n \
                        build $parsedBuild, \n \
                        module $moduleName, \n \
                        regSubType $regSubType,\n \
                        regType $myNewType, \n \
                        sysName \n \
                        blade $parsedBlade"
                    catch {exec $DEVREG(relInfoPath,$releaseInfo)/../main/mysqlAutomate.tcl \
                        -reportDir $targetDir -qId $queueId \
                        -regId $queueId -platform $PLATFORM -build $parsedBuild \
                        -module $moduleName -regType $myNewType \
                        -callLocation "$moduleUpdateStr regServer:" >@stdout} automateRet
                } else {
                    WriteToQueueDebug "MoveReportToQueueFinished " \
                    "Error: no PLATFORM found to submit to database: $PLATFORM";
                    result_error "Error: no PLATFORM found to submit to database: $PLATFORM"
                }
            }
            unset env(WEBSERVERDIR)
            cd "../Util"

        } "^DownloadPassed" {  
            ;# Not sure if we should move the report/result dir (if any) in case of downloadFailed
            # Since in case of download failed, location to loadimage.txt is sent for tracing purposes
            # For download passed, the report is moved to moduleName/downloadImage/Report dir
            set dirList [recursive_glob "$env(BASE_PATH)/Report/" loadimage.txt]
            WriteToQueueDebug "MoveReportToQueueFinished DownloadPassed" "DirList: $dirList";
            for {set i [expr [llength $dirList]-1]} {$i>=0} {incr i -1} {
                set dirName [lindex $dirList $i]
                if {[set fd_in [FileOpen "$dirName" r]]==-1} {
                    return $fd_in
                }
                set targetDir ""
                while {[gets $fd_in readLine]!=-1} {
                    if {[regexp -nocase "^Using config file: .*$cfgFile" $readLine]} {
                        set targetDir [file dirname $dirName]
                        WriteToQueueDebug "MoveReportToQueueFinished DownloadPassed" \
                        "set targetDir [file dirname $dirName]";
                        break
                    }
                }
                funlock $fd_in
                close $fd_in
                if {$targetDir!=""} {
                    break
                }
            }
        } "^DownloadFailed" -
        "^MainFailed" {
            WriteToQueueDebug "MoveReportToQueueFinished DownloadFail MainFail" \
            "set targetDir /tmp/Tmp/$queueId[pid]";
            set targetDir "/tmp/Tmp/$queueId[pid]"
        } "^DownloadKilled" -
        "^MainKilled" {
            WriteToQueueDebug "MoveReportToQueueFinished DownloadKilled MainKilled" \
            "set targetDir empty string";
            set targetDir ""
        } default {
            WriteToQueueDebug "MoveReportToQueueFinished UNKNOWN STATE" "return a negative 1";
            result_debug "Unknown update str"
            return -1
        }
    }
    result_debug "\n ============================================\n\
    ============================================\n\
    targetDir = $targetDir\n \
    Platform  = $PLATFORM\n \
    ============================================\n\
    ============================================"
    WriteToQueueDebug "MoveReportToQueueFinished Target should be set" \
        "the targetDir $targetDir";
    if {$targetDir!=""} {
        if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
            if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
                WriteToQueueDebug "MoveReportToQueueFinished - make images finished dir " \
                    "Error: Can not create imagesFinishedDir dir...$reason";
                result_error "Error: Can not create imagesFinishedDir dir...$reason"
                return -1
            }
        }
        WriteToQueueDebug "MoveReportToQueueFinished Images finished" \
            "mkdir $DEVREG(server,imagesFinishedDir)";
        if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$queueId]} {
            if {[catch {file mkdir "$DEVREG(server,imagesFinishedDir)/$queueId"} reason]} {
                WriteToQueueDebug "MoveReportToQueueFinished - make images finished dir " \
                    "Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$queueId...$reason";
                result_error "Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$queueId...$reason";
                return -1
            }
        }
        WriteToQueueDebug "MoveReportToQueueFinished Images finished" \
            "mkdir $DEVREG(server,imagesFinishedDir)/$queueId";
        if {[catch {file mkdir "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName"} reason]} {
            WriteToQueueDebug "MoveReportToQueueFinished - make images finished dir " \
                "Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName...$reason";
            result_error "Error: Cannot create dir \
                $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName...$reason";
            return -1
        }
        WriteToQueueDebug "MoveReportToQueueFinished Images finished" \
            "mkdir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName";
        if {[regexp -nocase "download" $moduleUpdateStr] && \
            ([regexp -nocase "killed" $moduleUpdateStr]!=1)} {
            if {[catch {file mkdir \
                "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage"} reason]} {
                WriteToQueueDebug "MoveReportToQueueFinished - download" \
                "Error: Cannot create dir \
                $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage...$reason";
                result_error "Error: Cannot create dir \
                $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage...$reason";
                return -1
            }
            WriteToQueueDebug "MoveReportToQueueFinished Images Download" \
                "mkdir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage";
            if {[regexp -nocase "downloadPassed" $moduleUpdateStr]} {
                catch {file rename -force $targetDir \
                    $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report} myR
                if {$PLATFORM=="not_found"} {
                     WriteToQueueDebug "MoveReportToQueueFinished - downloadPassed" \
                         "return neg 1";
                     return -1
                } else {
                    WriteToQueueDebug "MoveReportToQueueFinished - downloadPassed" \
                        "return $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report";
                    return "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report"
                }
            } else {
                catch {file rename -force $targetDir \
                     $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/loadimage.txt} reason
                if {$PLATFORM=="not_found"} {WriteToQueueDebug "MoveReportToQueueFinished - make images \
                finished dir " ""; return -1} else {
                    WriteToQueueDebug "MoveReportToQueueFinished - not downloadPassed " \
                    "return $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/";
                    return "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/"
                }
            }
        } else {
            if {[regexp -nocase "mainfailed" $moduleUpdateStr]} {
                if {[catch {file mkdir "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result"} reason]} {
                    WriteToQueueDebug "MoveReportToQueueFinished - Mainfailed " \
                        "Error: Cannot create dir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result...$reason";
                    result_error "Error: Cannot create dir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result...$reason";
                    return -1
                }
                catch {file rename -force $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/report.txt} reason
                if {$PLATFORM=="not_found"} {
                    WriteToQueueDebug "MoveReportToQueueFinished - mainfaild" \
                        "rename $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/report.txt";
                    return -1
                } else {
                    WriteToQueueDebug "MoveReportToQueueFinished - make images finished dir " \
                        "rename $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/report.txt";
                    return "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Result/"
                }
            } else {
                if {[file isdirectory $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report]} {
                    ;# reRun case
                    catch {file rename -force $targetDir \
                          $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report1} reason
                    if {$PLATFORM=="not_found"} {
                        WriteToQueueDebug "MoveReportToQueueFinished - Not mainfail \
                        $PLATFORM not found" "";
                        return -1
                    } else {
                        WriteToQueueDebug "MoveReportToQueueFinished - make images finished dir " "rename \
                        $targetDir $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report1";
                        return "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report1"
                    }
                } else {   ;# first run case
                    catch {file rename -force $targetDir \
                           $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report} reason
                    if {$PLATFORM=="not_found"} {
                        WriteToQueueDebug "MoveReportToQueueFinished - NOT a dir \
                            $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report]" \
                            "return 1"; 
                        return -1
                    } else {
                        WriteToQueueDebug "MoveReportToQueueFinished - not mainfailed" "rename $targetDir \
                        $DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report";
                        return "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report"
                    }
                }
            }
        }
    } else {
        if {[regexp -nocase "killed" $moduleUpdateStr]} {
            WriteToQueueDebug "MoveReportToQueueFinished - TargetDir = null Killed" \
            "Return [ProcessSrvrQueueKill $queueId]";
            return [ProcessSrvrQueueKill $queueId]   ;# always returns -1 as this is killed signal
        }
        WriteToQueueDebug "MoveReportToQueueFinished - TargetDir = null" "Return neg 1";
        return -1
    }
}

##################################################################
# Procedure Name: EmailReportFilesMail
#
# Description: This proc emails to the desired userId from userIp array
#              based on the state.
#
# Input args:
#           qId: queue id to work on
#           runIndex: runIndex to locate the desired module on which server worked on
#           cfgFile: config file name to be sent to email
#           targetDir: target Dir which has to be sent as a html link in message body
#           state: constists of one of pass/mainfailed/downloadpassed/downloadfailed etc.
# Output args: none
# Typical usage:
#           EmailReportFilesMail $myQueueId [array get uInput] $runningIndex $targetDir PASS
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc EmailReportFilesMail { qId runIndex cfgFile targetDir { state } args} {
    global DEVREG
    global harnessOwners


    parse_args EmailReportFilesMail $args {
        uip "null"
        mainReturnInfo ""
    }

    if {$uip=="null"} {
        if {[set imageDir [LocateQueueId $qId]]==-1} {
            result_error "Error: No queue Id $qId found."
            return $imageDir
        }
        ReadQueueInfoIntoArray $imageDir/info uInput
    } else {
        array set uInput $uip
    }

    # --- local vars ---
    set shortString ""
    set moduleName [lindex $uInput(moduleNames:) $runIndex]
    set platformChosen $uInput(platformToRunOn:)

    set hostName http://[lindex [split [exec hostname] .] 0]
    #   set s [format \\%s $hostName]
    #   set hostName [format \\%s $s]  ;# Manipulate the hostname to become \\$hostName
    set sharedDir ""
    if {[regsub "$DEVREG(server,regressionDir)" $targetDir "" sharedDir]==0} {
        set sharedDir ""
    }
    result_debug "the sharedDir $sharedDir"
    set rm 0
    if {[regexp -nocase "release-manager" $uInput(userid:)]} {
        set rm 1
        puts "Hit RELEASE-MANAGER - sentTo = $uInput(userid:)"
        set toBeSent ""
    } else {
        puts "MISSED RELEASE-MANAGER"
        if {[regexp -nocase "\@" $uInput(userid:)]} {
           set toBeSent "$uInput(userid:).extremenetworks.com"
        } else {
           set toBeSent "$uInput(userid:)@extremenetworks.com"
        }
    }
    set dbHref "http://biltmore.extremenetworks.com/cgi-bin/regdb.cgi?screen=regrun&id_label=${qId}";
    #set webStr "<a href=\"$dbHref\">Database Report</a></td>";
    set str "Report Directory: [format %s/%s/%s $hostName [file tail $DEVREG(server,regressionDir)] $sharedDir]\n\n$mainReturnInfo\n"
    if {$state == "PASS" || $state=="MAINFAILED"} {
       append str "$dbHref\n\n";
       set str [append str [PrintUserQueue [array get uInput] $qId]]
       set shortString $str
       set reportFileName "$targetDir/report.txt"
       if {![file exists $targetDir/report.txt]} {
           result_debug "Email report.txt does not exist:"
           result_debug "TargetDir: $targetDir\nsharedDir $sharedDir"
           result_debug "report.txt $targetDir/report.txt"
           return $state;
       }
       if {[set fd_in [FileOpen $reportFileName r reason]]==-1} {
          puts "Sending Email to $toBeSent"
          set str [append str "\n" $reason]
          set state FAIL
          if {!$rm} {
              if {[file isfile "/bin/mailx"]} {
                  exec /bin/mail -r "Sqaautosupport@extremenetworks.com" \
                  -s "$qId\($cfgFile\): $moduleName *$state*" \
                  $toBeSent << "$str" &
              } else {
                  exec /bin/mail -s "$qId\($cfgFile\): $moduleName *$state*" $toBeSent << "$str" &
              }
          }
          LogRegRun $qId 0 1 $runIndex $cfgFile [array get uInput]  ;# log the regression results to regrun.log
          return $fd_in
       }
       set testsPassed 0
       set testsFailed 1
       set swRevNum ""
       while {[gets $fd_in line]!=-1} {
          set str [append str "\n" $line]
          if {[regexp -nocase "^number of sub test cases failed" $line]} {
             set testsFailed [lindex $line [expr [llength $line]-1]]
          }
          if {[regexp -nocase "^number of sub test cases passed" $line]} {
             set testsPassed [lindex $line [expr [llength $line]-1]]
          }
          if {[regexp -nocase "^revision number:" $line]} {
              #Revision Number: 89516
              set swRevNum [lindex $line [expr [llength $line]-1]]
          }
       }
       close $fd_in
       if {$state=="PASS" && $testsFailed>=1} {
          set state "FAIL"
       }
       if {!$rm} {
           puts "Sending Email to $toBeSent"
           if {$state=="MAINFAILED"} {
              # EY-12-06-2007: Put entire list of recipients in double-quotes to
              # avoid e-mail addresses being separated by ".' characters.
              if {[file isfile "/bin/mailx"]} {
                  exec /bin/mail -r "Sqaautosupport@extremenetworks.com" -a "$reportFileName" \
                  -s "$qId\($cfgFile\): $moduleName *$state*" \
                  "$toBeSent $harnessOwners" << "$shortString" &
              } else {
                  exec /bin/mail -s "$qId\($cfgFile\): $moduleName *$state*" \
                  "$toBeSent $harnessOwners" \
                  -- -r "Sqaautosupport@extremenetworks.com" << "$str" &
              }
           } else {
              if {[file isfile "/bin/mailx"]} {
                  exec /bin/mail -r "Sqaautosupport@extremenetworks.com" \
                  -s "$qId\($cfgFile\): $moduleName *$state*" \
                  "$toBeSent" << "$str" &
              } else {
                  exec /bin/mail -s "$qId\($cfgFile\): $moduleName *$state*" \
                  "$toBeSent" -- -r "Sqaautosupport@extremenetworks.com" << "$str" &
              }
              
           }
       } elseif {$state=="MAINFAILED"} {
            # EY-12-06-2007: Put entire list of recipients in double-quotes to
            # avoid e-mail addresses being separated by ".' characters.
            if {[file isfile "/bin/mailx"]} {
                exec /bin/mail -r "Sqaautosupport@extremenetworks.com" -a "$reportFileName" \
                -s "$qId\($cfgFile\): $moduleName *$state*" \
                "$harnessOwners" << "$shortString" &
            } else {
                exec /bin/mail -s "$qId\($cfgFile\): $moduleName *$state*" \
                "$harnessOwners" \
                -- -r "Sqaautosupport@extremenetworks.com" << "$str" &
            }
       }
    } elseif {$state=="FAIL"||[regexp -nocase "killed" $state]} {   ;# failed during download
       puts "Sending Email to $toBeSent"
       set testsPassed 0
       set testsFailed 1
       set swRevNum ""
       if {[regexp -nocase "mainKilled" $state]} {
          set str [append str "main regression $state on $cfgFile setup with following queue information:\n"]
       } elseif {[regexp -nocase "downloadkilled" $state]} {
          set str [append str "download image killed via LoadImage.tcl on $cfgFile setup with following queue information:\n"]
       } elseif {[regexp -nocase "FAIL" $state]} {
          set str [append str "download image $state via LoadImage.tcl on $cfgFile setup with following queue information:\n"]
       }
       set str [append str [PrintUserQueue [array get uInput] $qId]]

       # EY-12-06-2007: Put entire list of recipients in double-quotes to
       # avoid e-mail addresses being separated by ".' characters.
       if {!$rm} {
           puts "NOT RELEASE-MANAGER SEND THE NOTE"
           if {[file isfile "/bin/mailx"]} {
               exec /bin/mail -r "Sqaautosupport@extremenetworks.com" \
               -s "$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image" \
               "$toBeSent $harnessOwners" << "$str" &
           } else {
               exec /bin/mail -s "$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image" \
                 "$toBeSent $harnessOwners" -- -r "Sqaautosupport@extremenetworks.com" << "$str" &
           }
       } else {
           if {[file isfile "/bin/mailx"]} {
               exec /bin/mail -r "Sqaautosupport@extremenetworks.com" \
               -s "$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image" \
               "$harnessOwners" << "$str" &
           } else {
               exec /bin/mail -s "$qId\($cfgFile\): [lindex $uInput(moduleNames:) $runIndex] *$state* in download image
" \
                 "$harnessOwners" -- -r "Sqaautosupport@extremenetworks.com" << "$str" &
           }
       }
    } elseif {$state=="AUTOLOCKED"} {
       puts "Sending Email to HARNESS OWNERS"
       set testsPassed 0
       set testsFailed 1
       set swRevNum ""
       set str [append str "This Test Bed ( $cfgFile ) has been Auto Locked:\n"]
       set str [append str [PrintUserQueue [array get uInput] $qId]];
       if {[file isfile "/bin/mailx"]} {
           exec /bin/mail -r "Sqaautosupport@extremenetworks.com" \
           -s "AUTOLOCKED $qId\($platformChosen\): [lindex $uInput(moduleNames:) $runIndex] ***$state***" \
           $harnessOwners << "$str" &;
       } else {
           exec /bin/mail -s "AUTOLOCKED $qId\($platformChosen\): [lindex $uInput(moduleNames:) $runIndex] ***$state***" \
            $harnessOwners -- -r "Sqaautosupport@extremenetworks.com" << "$str" &'
       }
    }
    LogRegRun $qId $testsPassed $testsFailed $runIndex $cfgFile [array get uInput]  ;# log the regression results to regrun.log

   return $state
}

##################################################################
# Procedure Name: LogRegStart
#
# Description: This proc writes the start regression log into regstart.log file
#              This is performed to maintain backward compatibility to runall
#              for tracing user logs.
#
# Input args:
#           queueId: queue id to write
#           runIndex: runIndex to locate the desired module on which server worked on
#           cfgFile: tail of the file to mention based on the server name
#           uInput: queue info array
# Output args: none
# Typical usage:
#           LogRegStart $myQueueId $runningIndex $cfgFileTail [array get uInput]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc LogRegStart {queueId runIndex cfgFile uInput} {
   global DEVREG
   global env
   array set userInput $uInput

   if {[set fd_out [FileOpen tmp[pid] w]]==-1} {
      return $fd_out
   }
   puts $fd_out "$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $runIndex] [lindex $userInput(moduleNames:) $runIndex]"
   result_debug "$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $runIndex] [lindex $userInput(moduleNames:) $runIndex]"
   close $fd_out
   # 1/18/05: Needed to append at start of file
   # Write to temp and append original at end of temp, move temp to original
   combineTwoFiles tmp[pid] $DEVREG(server,regressionDir)/regstart.log
   catch {file rename -force tmp[pid] $DEVREG(server,regressionDir)/regstart.log} myR
}

##################################################################
# Procedure Name: LogRegRun
#
# Description: This proc writes the run regression log into regrun.log file
#              This is performed to maintain backward compatibility to runall
#              for tracing user logs.
#
# Input args:
#           queueId: queue id to write
#           numPassed: number of passed tests
#           numFailed: number of Failed tests
#           index: index for accessing the module in queue info array
#           cfgFile: tail of the file to mention based on the server name
#           userIp: queue info array
# Output args: none
# Typical usage:
#           LogRegRun $qId $testsPassed $testsFailed $runIndex $cfgFile [array get uInput]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc LogRegRun {queueId numPassed numFailed index cfgFile userIp} {
   global DEVREG
   global env
   array set userInput $userIp

   if {[set fd_out [FileOpen tmp[pid] w]]==-1} {
      return $fd_out
   }
   puts $fd_out "$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $index] [lindex $userInput(moduleNames:) $index] FAIL=$numFailed of [expr $numPassed+$numFailed]"
   result_debug "$queueId $userInput(userid:) $cfgFile [lindex $userInput(moduleLists:) $index] [lindex $userInput(moduleNames:) $index] FAIL=$numFailed of [expr $numPassed+$numFailed]"
   close $fd_out
   combineTwoFiles tmp[pid] $DEVREG(server,regressionDir)/regrun.log
   catch {file rename -force tmp[pid] $DEVREG(server,regressionDir)/regrun.log} myR
}


##################################################################
# Procedure Name: KillImmediately
#
# Description: This proc takes the killDir as input dir name,
#              based on the imagesQueued/imagesRunning calls shell ps
#              and setuid killProc to kill the root server's run process.
#              After the kill is performed, an email is sent to the userid
#              as well as necessary move of imagesQueued/imagesRunning to imagesKilled dir.
#
# Input args:
#           killDir: queueId dir of any of imagesQueued/imagesRunning dirs
# Output args: none
# Typical usage:
#           if {[KillImmediately $imageDir]==1} {
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc KillImmediately {killDir force queueId} {
   global DEVREG

   if {[set fd_q [FileOpen $killDir/info r]]==-1} {
      return $fd_q
   }
   while {[gets $fd_q infoLine]!=-1} {
      set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
   }
   close $fd_q
   if {[info exists userInput(lockFile:)] && ![info exists userInput(platformToRunOn:)]} {
      ### lock queueId, process kill differently
      if {[set retCode [UnlockQueuedLock "$killDir" [array get userInput]]]==1} {
         return $retCode
      } else {
         result_error "Can not kill a locked testbed queueId"
         return -1
      }
   }
   global env
   if {[regexp -nocase "imagesQueued" $killDir]} {
      set grepStr queued
   } elseif {[regexp -nocase "imagesRunning" $killDir]} {
      set grepStr "runningOn|reRunOn|queued"
   }
   for {set i 0} {$i<[llength $userInput(runStatus:)]} {incr i} {
      set moduleName [lindex $userInput(moduleNames:) $i]
      set status [lindex $userInput(runStatus:) $i]
      if {[regexp -nocase $grepStr $status]} {
         switch -regexp $status {
         "queued" {
            ### Check if no module is running
            if {![regexp -nocase "runningOn|reRunOn" $userInput(runStatus:)]} {
                ### No module is running, just move imagesRunningDir to imagesKilledDir and rmdir imagesQueuedDir/queueId
                if {[catch {exec $env(BASE_PATH)/mvProc $killDir $DEVREG(server,imagesKilledDir)} reason]} {
                    if {$force != "null"} {
                       # ------------------------------------------------------------
                       # The move did not work.  Just whack the running or queued dir
                       # ------------------------------------------------------------
                       set queueId [file tail $killDir]
                       if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$queueId]} {   ;# delete the queuedDir and only move runningDir
                          if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$queueId} reason]} {
                             result_error "Could not remove $DEVREG(server,imagesQueuedDir)/$queueId, $reason"
                             return 137
                          } else {
                             if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {
                                return $retCode
                             } else {
                                dbKillReg $queueId
                                email_qKilled $queueId [array get userInput]
                                result_ok "Successfully deleted queueId: $queueId from images queued"
                                break;
                             }
                          }
                       }
                    } else {
                        result_error "Could not move $killDir, $reason"
                        return -1
                    }
                } else {
                   # Also remove the imagesQueuedDir/queueId
                   set queueId [file tail $killDir]
                   if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$queueId]} {   ;# delete the queuedDir and only move runningDir
                      if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$queueId} reason]} {
                         result_error "Could not remove $DEVREG(server,imagesQueuedDir)/$queueId, $reason"
                         return 137
                      } else {
                         if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {
                            return $retCode
                         } else {
                            dbKillReg $queueId
                            email_qKilled $queueId [array get userInput]
                            result_ok "Successfully deleted queueId: $queueId from images queued"
                            break;
                         }
                      }
                   }
               }
            } else {
               ### Do nothing
            } 
         }
         "^runningOn" -
         "^reRunOn" {
             regsub $grepStr $status "" configFile
             set qIdRunning [GetLatestIdRunning $configFile]
             set theCfg [lindex [split $configFile .] 0]
             set psLine [catch {exec ps -eafwww | egrep -e "Load.*$configFile|main.tcl.*$configFile|pybot.*$theCfg" | grep -v grep} psout]
             set psLineitest [catch {exec ps -eafwww | egrep -e "pybot.*$theCfg" | grep -v grep} psoutitest]
             puts "the psLine $psLine and configFile $configFile"
             puts "the pid to kill [lindex $psout 1] from $psout\n $killDir"
             puts "qIdRunning $qIdRunning != killDir [file tail $killDir]"
             if {$qIdRunning!=[file tail $killDir]} {
                puts "NOT EQUAL"
                if {[file isdirectory $DEVREG(server,imagesRunningDir)/[file tail $killDir]]} {
                   if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/[file tail $killDir] $DEVREG(server,imagesKilledDir)} reason]} {
                       if {$force != "null"} {
                          # ------------------------------------------------------------
                          # The move did not work.  Just whack the running or queued dir
                          # ------------------------------------------------------------
                          set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                          foreach fileName $imageQueuedDir {
                             #puts "the filename $fileName\n$env(BASE_PATH)/rmProc -rf $fileName"
                             if {[file tail $fileName]==[file tail $killDir]} {
                                 if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                    result_error "Could not remove $fileName, $reason"
                                    return -1
                                 }
                             }
                          }
                          puts "Now killing qId [file tail $killDir]"
                          RemoveQidFromPriority [file tail $killDir]
                          dbKillReg $queueId
                          set retValue 0
                       } else {
                          result_error "Could not move $DEVREG(server,imagesRunningDir)/[file tail $killDir], $reason"
                          set retValue 1
                       }
                   } else {
                      # Specific case of left over queueedDir removal. Notice -rf
                      set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                      foreach fileName $imageQueuedDir {
                         #puts "the filename $fileName\n$env(BASE_PATH)/rmProc -rf $fileName"
                         if {[file tail $fileName]==[file tail $killDir]} {
                             if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                result_error "Could not remove $fileName, $reason"
                                return -1
                             }
                         }
                      }
                      puts "Now killing qId [file tail $killDir]"
                      RemoveQidFromPriority [file tail $killDir]
                      dbKillReg $queueId
                      set retValue 0
                   }
                }  
             } elseif {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
                puts "FAILED qIdRunning $qIdRunning!=[file tail $killDir] Found Proc [lindex $psout 1]"
                set retValue [catch {exec $env(BASE_PATH)/killProc [lindex $psout 1]}]
                set cmd1 "wait [lindex $psout 1]"
                set outpid1 [catch "$cmd1" reason1]
                if {$outpid1} {
                    result_debug "Failed to wait for child return: $reason1\n"
                }
                if {$retValue==0} {
                    dbKillReg $queueId
                }
                if {[regexp -nocase {[0-9]+} [lindex $psoutitest 1]]} {
                    set retValue [catch {exec $env(BASE_PATH)/killProc [lindex $psoutitest 1]}]
                    set cmd1 "wait [lindex $psoutitest 1]"
                    set outpid2 [catch "$cmd1" reason2]
                    if {$outpid2} {
                        result_debug "Failed to wait for child return: $reason2\n"
                    }
                }
             } elseif {$qIdRunning==[file tail $killDir]&&![regexp -nocase {[0-9]+} [lindex $psout 1]]} {
                puts "qIdRunning $qIdRunning == [file tail $killDir] NOT Found Proc [lindex $psout 1]"
                if {[file isdirectory $DEVREG(server,imagesRunningDir)/[file tail $killDir]]} {
                   if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/[file tail $killDir] $DEVREG(server,imagesKilledDir)} reason]} {
                       if {$force != "null"} {
                          # ------------------------------------------------------------
                          # The move did not work.  Just whack the running or queued dir
                          # ------------------------------------------------------------
                          set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                          foreach fileName $imageQueuedDir {
                             if {[file tail $fileName]==[file tail $killDir]} {
                                 puts "Filename match $fileName $env(BASE_PATH)/rmProc -rf $fileName"
                                 if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                    result_error "Could not remove $fileName, $reason"
                                    return -1
                                 }
                             }
                          }
                          puts "Now killing qId [file tail $killDir]"
                          RemoveQidFromPriority [file tail $killDir]
                          dbKillReg $queueId
                          set retValue 0
                       } else {
                          result_error "Could not move $DEVREG(server,imagesRunningDir)/[file tail $killDir], $reason"
                          set retValue 1
                       }
                   } else {
                      # Specific case of left over queueedDir removal. Notice -rf
                      set imageQueuedDir [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
                      foreach fileName $imageQueuedDir {
                         if {[file tail $fileName]==[file tail $killDir]} {
                             puts "Filename match $fileName $env(BASE_PATH)/rmProc -rf $fileName"
                             if {[catch {exec $env(BASE_PATH)/rmProc -rf $fileName} reason]} {
                                result_error "Could not remove $fileName, $reason"
                                return -1
                             }
                         }
                      }
                      puts "Now killing qId [file tail $killDir]"
                      RemoveQidFromPriority [file tail $killDir]
                      dbKillReg $queueId
                      set retValue 0
                   }
                }
                set retValue 0
             } else {
                set retValue 1
             }
             if {$retValue==1} {
                result_error "error in killProc $retValue"
                return -1
             }
         }
         }
      }
   }

   return 1
}

##################################################################
# Procedure Name: PrintUserQueue
#
# Description: This proc prints the queueId's info information,
#              in a presentable way, dumps the moduleNames/moduleLists
#              and runStatus in table for better readibility
#
# Input args:
#           uInput: queueId info array to be printed
# Output args: none
# Typical usage:
#           PrintUserQueue [array get userInput]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc PrintUserQueue {uInput queueId} {
   array set usrInput $uInput
   global DEVREG
   set strToReturn ""
   global RestOfDUTType RestOfIPRDUTType DEVREG

   puts "[format "%-17s %-20s" userid: $usrInput(userid:)]"
   set strToReturn [append strToReturn "\n" [format "%-17s %-20s" userid: $usrInput(userid:)]]
   if {[info exists usrInput(platformToRunOn:)]} {
      set platformToRunOn $usrInput(platformToRunOn:)
   } else {
      set platformToRunOn ""
   }
   foreach varName [array names usrInput] {
      if {![regexp -nocase "userid|moduleLists|runStatus|moduleNames|moduleTypes" $varName]&&$platformToRunOn!=""} {
         # do not display disabled efence
         if {[string compare "efence:" $varName]==0 && $usrInput($varName)!="enable"} {
            continue
         }
         # do not display release info
         if {[string compare "relInfo:" $varName]==0 && $usrInput($varName)==""} {
            continue
         }
         if {![regexp -nocase "[string tolower $RestOfDUTType($platformToRunOn)]Image|[string tolower $RestOfIPRDUTType($platformToRunOn)]Image" $varName]&&\
             [regexp -- "Image" $varName]&&![regexp -nocase "$platformToRunOn" $varName]&&\
             ![regexp -nocase "[string tolower $RestOfDUTType($platformToRunOn)]BL_Image|[string tolower $RestOfIPRDUTType($platformToRunOn)]BL_Image" $varName]} {
             # Baseline case
            continue ;# Do not display unwanted platforms' image
         }
         puts "[format "%-17s %-20s" $varName $usrInput($varName)]"
         set strToReturn [append strToReturn "\n" [format "%-17s %-20s" $varName $usrInput($varName)]]
      } elseif {$platformToRunOn=="" && [regexp -nocase "lockFile" $varName]} {
         puts "[format "%-17s %-20s" $varName $usrInput($varName)]"
         set strToReturn [append strToReturn "\n" [format "%-17s %-20s" $varName $usrInput($varName)]]
      }
   }
   set maxLength 6
   for {set i 0} {$i<[llength $usrInput(runStatus:)]} {incr i} {
      set moduleName [lindex $usrInput(moduleNames:) $i]
      if {[string length $moduleName]>$maxLength} {
         set maxLength [string length $moduleName]
      }
   }
   set dashStr ""
   for {set i 0} {$i<$maxLength} {incr i} {
      set dashStr [append dashStr "-"]
   }
   set maxLength [append maxLength s]
   ### Now print module information in a table format
   puts "[format "%-17s %-$maxLength|%-5s|%-15s|%-15s" Modules: module List modType runStatus]"
   set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s|%-15s" Modules: module List modType runStatus]]
   puts "[format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $dashStr "-----" "---------------" "--------------------"]"
   set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $dashStr "-----" "-----------------" "------------------"]]
   for {set i 0} {$i<[llength $usrInput(runStatus:)]} {incr i} {
      set moduleName [lindex $usrInput(moduleNames:) $i]
      set moduleList [lindex $usrInput(moduleLists:) $i]
      if {[info exists usrInput(moduleTypes:)]} {
          set moduleType [lindex $usrInput(moduleTypes:) $i]
      } else {
          set moduleType functional
      }
      set moduleRunStat [lindex $usrInput(runStatus:) $i]

      if {[regexp -nocase "^takenBy|^runningOn|^reRunOn" $moduleRunStat]} {
         regexp -nocase "^takenBy|^runningOn(.*)" $moduleRunStat ma cfgStr
         if {[info exists cfgStr]!=1} {
            regexp -nocase "^reRunOn(.*)" $moduleRunStat ma cfgStr   ;# check the reRunOn
         }
         global BASE_PATH
         
         set psLine [catch {exec ps -eafwww | egrep -e "Load.*$cfgStr|main.tcl.*$cfgStr|mysqlMain.tcl.*$moduleName.*$cfgStr" | grep -v grep} psCmdLine]
#puts "the psLine $psLine and psCmdLine $psCmdLine"
         set qIdRunning [GetLatestIdRunning $cfgStr]
         if {$qIdRunning!=$queueId} {
            puts "[format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $moduleName $moduleList $moduleType $moduleRunStat]"
            set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $moduleName $moduleList $moduleType $moduleRunStat]]
         } else {
 
         set ppid [lindex $psCmdLine 2]
         set psLine [catch {exec ps -eafwww | egrep -e "tee" | grep -v grep | grep $ppid} psout]
         set tailFileTail [lindex $psout [expr [llength $psout]-1]]
#         set cfgName [lindex [split $cfgStr .] 0]
#         set retV [file exists /tmp/$cfgName]
#         if {$retV==1} {
#            set linkTarget [file readlink /tmp/$cfgName]
#            if {$linkTarget!=$tailFilePath} {  ;# symlink is stale, recreate
#               file delete /tmp/$cfgName
#               link -sym $tailFilePath /tmp/$cfgName
#            }
#            set symLinkPath /tmp/$cfgName
#         } elseif {$retV==0} {
#            file delete /tmp/$cfgName
#            link -sym $tailFilePath /tmp/$cfgName
#            set symLinkPath /tmp/$cfgName
#         } else {
#            set symLinkPath $tailFilePath
#         }
          set symLinkPath $tailFileTail

         ### Following lines get the duration w.r.t. LoadImage and main.tcl. If inside main.tcl, LoadImage duration is added.
         # LoadImage duration is picked from imagesFinished dir creation for this queueId

         set startTime [lindex $psout 4]
         set curTime [clock seconds]
         set duration [expr $curTime - [clock scan $startTime]]
         set downloadDuration 0
         if {[regexp -nocase "main.tcl.*$cfgStr" $psCmdLine]} { ;# First run main.tcl
            global imagesFinishedDir
            if {[file exists "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt"] && \
                [file stat "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt" downloadReportStat]==""} {
#puts "now inside cfgStr $cfgStr, psCmdLine $psCmdLine and duration $duration and $downloadReportStat(ctime)"
               set downloadCreateTime $downloadReportStat(ctime)
               file stat "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/loadimage.txt" loadimageStat
               set downloadDuration [expr $loadimageStat(ctime)-$downloadReportStat(ctime)]
               set duration [expr [clock seconds]-$downloadCreateTime]
            }
         } elseif {[regexp -nocase "mysqlMain.tcl.*$cfgStr" $psCmdLine]} { ;# second run
            if {[file exists "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt"] && \
                [file stat "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/info.txt" downloadReportStat]==""} {
#puts "now inside cfgStr $cfgStr, psCmdLine $psCmdLine and duration $duration and $downloadReportStat(ctime)"
               set downloadCreateTime $downloadReportStat(ctime)
               file stat "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/downloadImage/Report/loadimage.txt" loadimageStat
               set downloadDuration [expr $loadimageStat(ctime)-$downloadReportStat(ctime)]
               set duration [expr [clock seconds]-$downloadCreateTime]
            } elseif {[file stat "$DEVREG(server,imagesFinishedDir)/$queueId/$moduleName/Report/info.txt" FirstRunStat]==""} {
               set firstRunTime $FirstRunStat(ctime)
               set duration [expr [clock seconds]-$firstRunTime]
            }
         }
         set totalDuration NULL
         if {![info exists usrInput(platformToRunOn:)]} {
            set usrInput(platformToRunOn:) NULL
         }
         if {[regexp -nocase "Load.*$cfgStr" $psCmdLine]==1} {  ;# means its inside LoadImage right now
            set totalDuration [GetTotalDuration NULL $moduleName $usrInput(platformToRunOn:) $moduleList $moduleType [array get usrInput]]
         } elseif {$downloadDuration==0} {  ;# means its in main.tcl but no download was done for this module
            set totalDuration [GetTotalDuration 0 $moduleName $usrInput(platformToRunOn:) $moduleList  $moduleType [array get usrInput]]
         } elseif {$downloadDuration!=0} {
            set totalDuration [GetTotalDuration $downloadDuration $moduleName $usrInput(platformToRunOn:) $moduleList $moduleType [array get usrInput]]
         }
         if {$totalDuration=="NULL"} {
            set minSecs "[expr $duration/60]/$totalDuration min"
         } else {
            set minSecs "[expr $duration/60]/[expr $totalDuration/60] min"
         }
         ###

#         result_debug "the tailFileTail $tailFileTail"
         if {[file exists $tailFileTail]} {
            puts "[format "%-17s %-$maxLength|%-5s|%-15s|%-15s %-4s" "" $moduleName $moduleList $moduleType "$moduleRunStat (tail -f $tailFileTail)" ($minSecs)]"
            set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s|%-15s %-4s" "" $moduleName $moduleList $moduleType "$moduleRunStat (tail -f $tailFileTail)" ($minSecs)]]
         } else {
             puts "[format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $moduleName $moduleList $moduleType $moduleRunStat]"
             set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $moduleName $moduleList $moduleType $moduleRunStat]]
#            regsub "runningOn|reRunOn" $moduleRunStat  "abortedOn" abortedStr
#            puts "[format "%-17s %-$maxLength|%-5s|%-15s" "" $moduleName $moduleList $abortedStr]"
#            set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s" "" $moduleName $moduleList $abortedStr]]
         }
         }
      } else {
         puts "[format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $moduleName $moduleList $moduleType $moduleRunStat]"
         set strToReturn [append strToReturn "\n" [format "%-17s %-$maxLength|%-5s|%-15s|%-15s" "" $moduleName $moduleList $moduleType $moduleRunStat]]
      }
   }
   set strToReturn [append strToReturn "\n"]
   return $strToReturn
}

##################################################################
# Procedure Name: ReadQueueInfoIntoArray
#
# Description: This proc reads the filePath info into uInput.
#
# Input args:
#           filePath: queueId info file absolute file path
# Output args: uInput: Read queue info array
# Typical usage:
#           if {[set retCode [ReadQueueInfoIntoArray $imageDir/info uInput]]==-1} {
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc ReadQueueInfoIntoArray {filePath uInput} {
   upvar uInput userInput
   array unset userInput
   global DEVREG
      if {[set fd_info [FileOpen $filePath r]]==-1} {
         return $fd_info
      } else {
         while {[gets $fd_info infoLine]!=-1} {
            # --------------------------------------------------
            # if there happens to be a set Var Val, trim the set
            # --------------------------------------------------
            regsub -all "^set " $infoLine "" infoLine
            regsub -all "  " $infoLine " " infoLine
            regsub -all "   " $infoLine " " infoLine
            regsub -all "    " $infoLine " " infoLine
            regsub -all {[ ]+} $infoLine " " infoLine
            set infoLine [string trim $infoLine]
            if {$infoLine == ""} {
                continue
            }
            set parsedVarName [string trim [lindex $infoLine 0]]
            set parsedVarName  [string trim $parsedVarName :]
            if {![regexp -nocase ":" $parsedVarName]} {
                set parsedVarName "${parsedVarName}:"
            }
            set userInput($parsedVarName) [lrange $infoLine 1 end]
            set DEVREG(userInput,$parsedVarName) [lrange $infoLine 1 end]
         }
         close $fd_info
      }
    return 1
}

##################################################################
# Procedure Name: ProcessSrvrQueueKill
#
# Description: This proc moves the imagesRunning/imagesQueued dir
#              and their corresponding modules' log into imagesKilled dir.
#              Uses setuid rmProc and mvProc shell utilities.
#              Since this is called inside regression server, the
#              queueId may be in imagesQueued/imagesRunning.
#              It only moves the imagesRunning in this case and removes the imagesQueued
#
# Input args:
#           queueId: queueId to be moved
# Output args: none
# Typical usage:
#           return [ProcessSrvrQueueKill $queueId]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc ProcessSrvrQueueKill {queueId} {
   global DEVREG
   global env
   if {![file isdirectory $DEVREG(server,imagesKilledDir)]} {
      if {[catch {file mkdir $DEVREG(server,imagesKilledDir)} reason]} {
         puts "Error: Can not create imagesKilledDir dir...$reason"
         return 137
      }
   }
   if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$queueId]} {   ;# delete the queuedDir and only move runningDir
      if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$queueId} reason]} {
         result_error "Could not remove $DEVREG(server,imagesQueuedDir)/$queueId, $reason"
         return 137
      } else {
         if {[set retCode [RemoveQidFromPriority $queueId]]==-1} {
            return 137
         }
      }
   }
   # Since its inside server, the imagesRunningDir may be there or may not be there
   # depending on which server kills it first.
   if {[file isdirectory $DEVREG(server,imagesRunningDir)/$queueId]} {
      if {[catch {exec $env(BASE_PATH)/mvProc $DEVREG(server,imagesRunningDir)/$queueId $DEVREG(server,imagesKilledDir)} reason]} {
         result_error "Could not move $DEVREG(server,imagesRunningDir)/$queueId, $reason"
         return 137
      } else {
         return 137
      }
   }
   return 137
}
##################################################################
# Procedure Name: GetModList
#
# Description: This proc gets the contents of a 2d array
#              but if nothing exists for the 2nd element- plat
#              it subs All
#
# Input args:
#           plat: platform to run on
#           regtype: Functionaltest, SnmpFunctionaltest, XML_API etc         
# Output args: none
# Typical usage:
#           GetModList $plat $regtype
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc GetModList {stdrtr regtype plat} {
    global stdMods rtrMods cit2nodeMods
    global DEVREG
    global platformList
    set platformList [regsub "," $platformList " "]
    set platformList [regsub ", " $platformList " "]
    set platformList [regsub "  " $platformList " "]
    if {$stdrtr == "std"} {
        if {![info exists stdMods($regtype,$plat)]} {
            if {[info exists stdMods($regtype,All)]} {
                set updatedList $stdMods($regtype,All);
                foreach platform $platformList {
                    if {[info exists stdMods($regtype,$platform)]} {
                        set updatedList [concat $updatedList $stdMods($regtype,$platform)]	
                    }
                }
                set finalList [lsort -nocase -unique $updatedList];
                set stdMods($regtype,All) $finalList
                return $finalList;
            } else {
                puts "\n!!!!!\n!!!!!\nERROR NO STD MODULES DEFINED\n!!!!!\n!!!!!"
            }
        } else {
            set updatedList2 $stdMods($regtype,$plat);
            foreach platform $platformList {
                if {[info exists stdMods($regtype,$platform)]} {
                    set updatedList2 [concat $updatedList2 $stdMods($regtype,$platform)]
                }
            }
            set finalList2 [lsort -nocase -unique $updatedList2];
            set stdMods($regtype,$plat) $finalList2
            return $finalList2;
        }
    } elseif {$stdrtr == "rtr"} {
        if {![info exists rtrMods($regtype,$plat)]} {
            if {[info exists rtrMods($regtype,All)]} {
                set updatedListrtr $rtrMods($regtype,All);
                foreach platform $platformList {
                    if {[info exists rtrMods($regtype,$platform)]} {
                        set updatedListrtr [concat $updatedListrtr $rtrMods($regtype,$platform)]
                    }
                }
                set finalListrtr [lsort -nocase -unique $updatedListrtr];
                set rtrMods($regtype,All) $finalListrtr
                return $finalListrtr;
            } else {
                puts "\n!!!!!\n!!!!!\nERROR NO RTR MODULES DEFINED\n!!!!!\n!!!!!"
            }
        } else {
            set updatedListrtr $rtrMods($regtype,$plat);
            foreach platform $platformList {
                if {[info exists rtrMods($regtype,$platform)]} {
                    set updatedListrtr [concat $updatedListrtr $rtrMods($regtype,$platform)]
                }
            }
            set finalListrtr [lsort -nocase -unique $updatedListrtr];

            set rtrMods($regtype,All) $updatedListrtr
            return $finalListrtr;
        }
    } elseif {$stdrtr == "cit2node"} {
        if {![info exists cit2nodeMods($regtype,$plat)]} {
            if {[info exists cit2nodeMods($regtype,All)]} {
                return [lsort -nocase -unique $cit2nodeMods($regtype,All)];
            } else {
                puts "\n!!!!!\n!!!!!\nERROR NO CIT 2node MODULES DEFINED\n!!!!!\n!!!!!"
            }
        } else {
            return [lsort -nocase -unique $cit2nodeMods($regtype,$plat)];
        }
    }
}
##################################################################
# Procedure Name: PrintModulesSupported
#
# Description: This proc prints the modules info in tabular format
#              dividing standard and routing information,
#
# Input args:
#           platform: platform to run on
# Output args: none
# Typical usage:
#           PrintModulesSupported $userInput(platformToRunOn:)
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc PrintModulesSupported {plat regtype} {
   global stdMods rtrMods cit2nodeMods
   global DEVREG
   
   set cit2nodeModules ""
   if {[regexp -nocase ".cfg$" $plat]} {  ;# usr cfg specified
      set srvrType [runningServerTypes $plat]
      set srvrRegType [lindex $srvrType 0]
      set srvrPlatType [lindex $srvrType 1]
      if {$srvrPlatType=="Mariner"} {
         if {$srvrRegType=="standard"} {
            set stdModules [GetModList std $regtype Mariner]
            set routingModules ""
         } else {
            set stdModules ""
            set routingModules [GetModList rtr $regtype Mariner]
         }
      } elseif {$srvrPlatType=="PC"} {
         if {$srvrRegType=="standard"} {
            set stdModules [GetModList std $regtype PC]
            set routingModules ""
         } else {
            set stdModules ""
            set routingModules ""
         }
      } else {
            if {$srvrRegType=="standard"} {
                set stdModules [GetModList std $regtype $srvrPlatType]
                #set stdModules [expr $[string tolower $srvrPlatType]Modules]
                set routingModules ""
            } elseif {[regexp -nocase "rout" $srvrRegType]} {
                set stdModules ""
                set routingModules [GetModList rtr $regtype $srvrPlatType]
                #set routingModules  [expr $[string tolower $srvrPlatType]RoutingModules]
            } elseif {[regexp -nocase "cit2node" $srvrRegType]} {
                set stdModules ""
                set routingModules ""
                set cit2nodeModules [GetModList cit2node $regtype $srvrPlatType]
            }
      }
   } else {
      set stdModules [GetModList std $regtype $plat]
      set routingModules [GetModList rtr $regtype $plat]
      set cit2nodeModules [GetModList cit2node $regtype $plat] 
   }
   set stdLength [llength $stdModules]
   set rouLength [llength $routingModules]
   set cit2Length [llength $cit2nodeModules]
   if {$cit2Length > 0 && $stdLength == 0 && $rouLength == 0} {
        puts "Current modules supported:"
        puts "[format "%-35s" "Cit2Node modules"]"
        puts "[format "%-35s" "--------------------"]"
        foreach module1 $cit2nodeModules {
            puts "[format "%-35s" $module1]"
        }
        return "$cit2nodeModules"
   } else {
        set newList ""
        if {$stdLength>=$rouLength} {
            set limit $stdLength
        } else {
            set limit $rouLength
        }
        for {set i 0} {$i<$limit} {incr i} {
            lappend newList "[lindex $stdModules $i]"
            lappend newList "[lindex $routingModules $i]"
        }

        puts "Current modules supported:"
        puts "[format "%-35s %-35s" "Standard modules" "Routing modules"]"
        puts "[format "%-35s %-35s" "--------------------" "--------------------"]"
        foreach {module1 module2} $newList {
            puts "[format "%-35s %-35s" $module1 $module2]"
        }
        return "$stdModules $routingModules"
   }
   return "$stdModules $routingModules"
}

proc UnlockQueuedLock {queueDir uinp} {
   global DEVREG
   array set uip $uinp
   if {[set fd_q [FileOpen $queueDir/info r+]]==-1} {
      return $fd_q
   }
   seek $fd_q 0 start
   set uip(runStatus:) [lreplace $uip(runStatus:) 0 0 "done"]

   foreach varName [array names uip] {
      puts $fd_q "[format "%-20s %-20s" "$varName" $uip($varName)]"
   }
   ftruncate $queueDir/info [tell $fd_q]
   close $fd_q
   return 1
}

##################################################################
# Procedure Name: GetLocalImageDir
#
# Description: This proc gets the local images dir from user dirs
#              if an input image is not NULL, it checks for valid file path
#
# Input args:
#           id: queueId to be referred
#           userI386Dir: i386 image dir
#           userMarinerDir: Mariner image dir
#           userAspenDir: Aspen image dir
#           userCougarDir: Cougar image dir
# Output args:
#           localI386 : local i386 image file
#           localMariner : local Mariner image file
#           localAspen : local Aspen image file
#           localCougar : local Cougar image file
# Typical usage:
#           return [ProcessSrvrQueueKill $queueId]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc GetLocalImageDir {args}    {

   parse_args GetLocalImageDir $args {
      id                "null"
      platformList      "null"
      platformImageList "null"
   }

   global DEVREG

   result_debug "\n-----\nVerify platformList: $platformList \nPaths: $platformImageList\n-----"
   set a 0;
   foreach plat $platformList {
      set DEVREG(imageDir,$plat) "$DEVREG(server,imagesQueuedDir)/$id/[file tail [lindex $platformImageList $a]]"
      if {![file isfile "$DEVREG(imageDir,$plat)"]} {
          result_debug "Invalid local $plat file $DEVREG(imageDir,$plat)"
      } else {
          result_debug "$plat image located: $DEVREG(imageDir,$plat)"
      }
      incr a
   }
   return 1;
}

##################################################################
# Procedure Name: UpdateImagesRerun
#
# Description: This proc gets called by the regServer to update 
#              info file for imagesRunning  after a module fails
#              in first run.
#
# Input args:
#           myQ: queueId to work on inside imagesQueued/imagesRunning
#           runInd: index of the module in info file
#           cfgFile: tail of the server config file path
# Output args: none
# Typical usage:
#           if {[UpdateImagesRerun $myQueueId $runIndex $cfgFileTail]==-1} {
#            exit -1
#         }
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc UpdateImagesRerun {myQ runInd cfgFile} {
   global DEVREG
   # update the imagesRunning in case myQ is still running or already finished. imagesQueued scenario is irrelevant
   set runningQueueFile "$DEVREG(server,imagesRunningDir)/$myQ"
   after 1000  ;# To avoid race condition sometimes amongst the servers
   if {![catch {glob -- $runningQueueFile} queues]} { ;# myQ is running
      # Have to be careful writing as other servers might be
      # running as well.
      # At this point, Read the running info file, change the status of module
      # at runInd that was passed into this proc
      ReadQueueInfoIntoArray $DEVREG(server,imagesRunningDir)/$myQ/info uInput
      if {[set fd_q [FileOpen $runningQueueFile/info r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
#      result_debug "array runningRegression [parray userInput]"
      seek $fd_q 0 start
      set userInput(runStatus:) [lreplace $userInput(runStatus:) $runInd $runInd "reRunOn$cfgFile"]
      
      foreach varName [array names userInput] {
         puts $fd_q "[format "%-20s %-20s" "$varName" $userInput($varName)]"
      }  
      ftruncate $runningQueueFile/info [tell $fd_q]
      close $fd_q
   } else {  ;# myQ is finished w.r.t. runInd module
      ReadQueueInfoIntoArray $DEVREG(server,imagesFinishedDir)/$myQ/info uInput
      if {![file isdirectory $DEVREG(server,imagesRunningDir)]} {
         if {[catch {file mkdir $DEVREG(server,imagesRunningDir)} reason]} {
            result_error "Error: Can not create imagesRunningDir dir...$reason"
            return -1
         }
      }
      if {[catch {file mkdir "$runningQueueFile"} reason]} {
         result_error "Error: Cannot create dir $runningQueueFile...$reason";
         return -1
      }
      if {[set fd_out [FileOpen $runningQueueFile/info w]]==-1} {
         return $fd_out
      }
      set uInput(runStatus:) [lreplace $uInput(runStatus:) $runInd $runInd "reRunOn$cfgFile"]
      foreach varName [array names uInput] {
         puts $fd_out "[format "%-20s %-20s" "$varName" $uInput($varName)]"
      }
      ftruncate $runningQueueFile/info [tell $fd_out]
      close $fd_out
   }
   return 1
}



##################################################################
# Procedure Name: notifyCurrentLockUser
#
# Description: Check if testbed is actively locked.  If so, email current user
#              that another user is queued, waiting to lock the testbed.
#
# Input args:
#             testbed - testbed that is queued for locking. (i.e. p1_mar_ipr.cfg)
#             user - User Id of person that has queued the lock
#
# Output args: 1 - User notified
#              0 - No user notified.  Currently not locked.
#
##################################################################
proc notifyCurrentLockUser { testbed queuedUser } {
    global DEVREG

    ;# cat $images/RunningDir/SC_041112_114831/info 
    ;#
    ;# moduleNames:         none                
    ;# userid:              alim                
    ;# runStatus:           runningOnp1_mar_g60t.cfg
    ;# lockFile:            p1_mar_g60t.cfg     
    ;# moduleLists:         none                
    
    set returnVal 0
    set platformInfo ""
    set queues ""
    set currentUser ""

    ;# Create a list of each qId directory
    set queues [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/*]

    ;# Look for any qId that is actively using queued platform
    foreach qIdPath $queues {
        set catchVal [catch {exec egrep -e "lockFile:\ *$testbed" $qIdPath/info} platformInfo]
        if {! $catchVal} {
            set catchVal [catch {exec egrep -e "userid:" $qIdPath/info} userInfo]
            if {! $catchVal} {
                ;# Assuming format is...
                ;# userid:              alim                
                regexp {userid:\ *([A-Za-z0-9_\-\.]+)\ *$} $userInfo ignore currentUser
            }
            break;
        }
    }

    if {$currentUser != ""} {
        set qId ""
        regexp {.*\/(.*)$} $qIdPath ignore qId
        if {! [regexp -nocase "\@" $currentUser]} {
            set toBeSent "$currentUser@extremenetworks.com"
        }
        set subject "Queueid:$qId ***lock request*** testbed $testbed"

        set str "$queuedUser has queued a lock request for testbed $testbed\n"
        append str "Please contact $queuedUser if you DO NOT plan on releasing\n"
        append str "$testbed any time soon."
        append str "\n\n\n--- CURRENT PLATFORM STATUS ---\nQueueID:\t\t$qId\n[exec cat $qIdPath/info]"
        catch {exec /bin/mail -s "$subject" $toBeSent << "$str"} mailOut

        result_debug "Sending email to $toBeSent indicating you are queued to lock $testbed"

        set returnVal 1
    } 

    return $returnVal
}

##################################################################
# Procedure Name: GetLatestIdRunning
#
# Description: Checks the latest queueId running from imagesRunning dir for a given regServer
#
# Input args:
#             cfg - regSevrer config file name to match in runningOn str
#
# Output args: $id - queue Id
#              0 - no cfg file located
#
##################################################################
proc GetLatestIdRunning {cfg} {
global DEVREG
set id 0
set runningDirs [glob -nocomplain -- "$DEVREG(server,imagesRunningDir)/*"]
set runningDirs [lsort -decreasing $runningDirs];
foreach runningDir $runningDirs {
   if {[set retCode [ReadQueueInfoIntoArray $runningDir/info uInput]]==-1} {
      return $retCode
   } else {
      if {[info exists uInput(runStatus:)] && [regexp -nocase "runningon$cfg|rerunon$cfg" $uInput(runStatus:)]} {
#puts "the runningDir $runningDir"
          set id [file tail $runningDir]
          break
      }
   }
}

return $id
}

proc combineTwoFiles {fileName1 fileName2} {
   global DEVREG
   if {[set fd1 [FileOpen $fileName1 a+]]==-1} {
      return $fd1
   }
   if {[set fd2 [FileOpen $fileName2 r]]==-1} {
      return $fd2
   }
#   set fd1 [open $fileName1 a+]
#   set fd2 [open $fileName2]
   set lines [split [read $fd2] "\n"]
   close $fd2
   #fconfigure stdout -buffering full
   for {set i 0} {$i <= [expr {[llength $lines]-2}]} {incr i 1} {
      puts $fd1 [lindex $lines $i]
   }
   close $fd1
}

##################################################################
# Procedure Name: GetTotalDuration
#
# Description: This proc is responsible for computing total duration of a given userInput array
#              gets the times from exosautoweb
#
# Input args:
#             downloadTime - this is time that is sent by caller if its in main.tcl, 0 otherwise
#             featureName - feature name
#             platformName - platform name cougar/mariner/aspen/i386
#             listName - module list quick/pass/all
#             userInput - array of queueId
#
# Output args: returns total duration
#
##################################################################
proc GetTotalDuration {downloadTime featureName platformName listName featureType userInput} {
   global DEVREG IPRTIMEDIR STDTIMEDIR RestOfDUTType RestOfIPRDUTType LoadImageSetupTime DOWNLOADTIME
   array set qInput $userInput

   set totalTimeDuration NULL
   set moduleRunDuration 0
   set durationFile ""
   set cfg 0

   if {$platformName=="NULL"} {
      return $totalTimeDuration
   }

   set moduleSubType [GetModuleSubType $platformName $featureName $featureType]

   if {$moduleSubType=="standardModules"} {
      set durationFile "$STDTIMEDIR($platformName)/$featureName.time.txt"
   } elseif {$moduleSubType=="routingModules"} {
      set durationFile "$IPRTIMEDIR($platformName)/$featureName.time.txt"
   }
   if {[file exists $durationFile]} {
      lappend parameterList "{SETUP:} 1"
      lappend parameterList "{CHK_CONN:} 1"
      lappend parameterList "{QUICK:} 1"
      lappend parameterList "{PASS:} 1"
      lappend parameterList "{ALL:} 1"
      set value [GetKeyValue "$durationFile" $parameterList]
      unset parameterList
      set setup [lindex $value 0]
      set chk_conn [lindex $value 1]
      set quick [lindex $value 2]
      set pass [lindex $value 3]
      set all [lindex $value 4]
      set moduleRunDuration [expr $setup+$chk_conn+$$listName]
#      puts "the moduleRunDuration $moduleRunDuration" 
   } else {
      set moduleRunDuration NULL
   }

   if {$downloadTime=="NULL"} {  ;# get default download time duration from cfg file
      set defaultDownloadTime 0
      if {$platformName=="PC"} {
         if {$moduleSubType=="standardModules"} {
            set defaultDownloadTime [expr $LoadImageSetupTime+[expr 2*$DOWNLOADTIME(i386)]]
         } elseif {$moduleSubType=="routingModules"} {
            set defaultDownloadTime [expr $LoadImageSetupTime+[expr 5*$DOWNLOADTIME(i386)]]
         }
      } else {
         if {$moduleSubType=="standardModules"} {
            set otherDutImage $qInput([string tolower $RestOfDUTType($platformName)]Image:)
            if {$otherDutImage=="NULL"} {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)]
            } else {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)+$DOWNLOADTIME($RestOfDUTType($platformName))]
            }
         } elseif {$moduleSubType=="routingModules"} {
            set otherIprDutImage $qInput([string tolower $RestOfIPRDUTType($platformName)]Image:)
            if {$otherIprDutImage=="NULL"} {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)]
            } else {
               set defaultDownloadTime [expr $LoadImageSetupTime+$DOWNLOADTIME($platformName)+[expr 4*$DOWNLOADTIME($RestOfIPRDUTType($platformName))]]
            }
         }
      }
      set downloadTime $defaultDownloadTime
   } else { ;# add downloadTime into total duration as passed from caller
   }
   if {$moduleRunDuration=="NULL"} {
   } else {
      set totalTimeDuration [expr $downloadTime+$moduleRunDuration]
   }

   return $totalTimeDuration
}

##################################################################
# Procedure Name: verifyUserInputFile
#
# Description: This proc is verifies the user inputs from a runReg -file standpoint
#              Calls GetKeyValue to get all keys, verifies them individually
#
# Input args:
#             filePath - absolute path of runReg provided input file
#             userInput - array of queueId, inout variable, passes back to caller after filling it
#
# Output args: returns -1 if error
# Sample input file:
##set userid               skumar
##set platformToRunOn      Mariner 
##set aspenImage           NULL
##set aspennapaImage       NULL
##set cougarImage          NULL
##set marinerImage        /tftp/cougar-11.2.0.1-br-HWBeta-6.xos
##set i386Image            NULL
##set jaguarImage          NULL
##set pantherImage         NULL
##set branchAndPD          "nothing specified"
##set moduleNames         "BGP_RFCConform"
##set moduleLists         "pass"
##set SSH_SCP,value       /tftp2/bd10K-11.2.1.1-ssh.xmod
#
##################################################################
proc verifyUserInputFile {filePath userInput} {
    global DEVREG
    global platformsSupported moduleArgFeatures
    upvar userInput uInput
    
    if [ReadQueueInfoIntoArray $filePath uInput] {
        if {![info exists uInput(sustaining:)]} { set uInput(sustaining:) 0;}
        if {![info exists uInput(relInfo:)]} {set uInput(relInfo:) "";}
        if {![info exists uInput(priority:)]} {set uInput(priority:) 3;}
        if {![info exists uInput(rerun:)]} {set uInput(rerun:) 1;}
        if {![info exists uInput(branchAndPD:)]} {set uInput(branchAndPD:) "";}
        if {![info exists uInput(efence:)]} {set uInput(efence:) "no";}
        if {![info exists uInput(LocalAAA,value:)]} {set uInput(LocalAAA,value:) "NULL";}
        if {![info exists uInput(sustaining:)]} {set uInput(sustaining:) 0;}
        if {![info exists uInput(SSH_SCP,value:)]} {set uInput(SSH_SCP,value:) "NULL";}
        if {![info exists uInput(tag:)]} { set uInput(tag:) "";}
        if {![info exists uInput(comment:)]} { set uInput(comment:) "";}
        if {![info exists uInput(xmod:)]} { set uInput(xmod:) NULL;}
        if {![info exists uInput(faillock:)]} { set uInput(faillock:) "no";}
        if {![info exists uInput(harness:)]} { set uInput(harness:) "all";}
        regsub -all "\{|\}" $uInput(moduleNames:) "" uInput(moduleNames:)
        set uInput(moduleNames:) [string trim $uInput(moduleNames:)]
        set uInput(moduleNames:) [split $uInput(moduleNames:) " "]

        # check module names is set
        if {![info exists uInput(userid:)]} {
            puts "Error: userid is a required parameter"
            return -1
        }
        if {![info exists uInput(moduleNames:)]} {
            puts "Error: moduleNames is a required parameter"
            return -1
        }
        # check module types is set
        if {![info exists uInput(moduleTypes:)]} {
            puts "!!!!!\n!!!!!\n!!!!!\nYour info file is out of date.\n\
            A new variable \'moduleTypes\' has been added.\n\
            This variable stores a list that matches up with moduleNames\n\
            and moduleLists.  Type refers to functional,snmp,\n\
            scalability or xml test plan types.\n\n\
            In this case it will be assumed that you intended\n\
            to run functional tests and the variable will be \n\
            created for you.\n\n\
            Please correct this issue for future runs.\n!!!!!\n!!!!!\n!!!!!"
            set uInput(moduleTypes:) ""
            foreach fillType $uInput(moduleNames:) {
                lappend uInput(moduleTypes:) "functional"
            }
        }
        # check module lists is set
        if {![info exists uInput(moduleLists:)]} {
            puts "Error: moduleLists is a required parameter"
            return -1
        }
        regsub -all "\{|\}" $uInput(moduleTypes:) "" uInput(moduleTypes:)
        set uInput(moduleTypes:) [string trim $uInput(moduleTypes:)]
        set uInput(moduleTypes:) [split $uInput(moduleTypes:) " "]
        regsub -all "\{|\}" $uInput(moduleLists:) "" uInput(moduleLists:)
        set uInput(moduleLists:) [string trim $uInput(moduleLists:)]
        set uInput(moduleLists:) [split $uInput(moduleLists:) " "]

        # Check if the platform to run on is set
        if {![info exists uInput(platformToRunOn:)]} {
            puts "Error: Platform to run on is not set"
            return -1
        }
        # Check valid platformToRunOn
        set useSshModArg 0
        if {[VerifyPlatformType $uInput(platformToRunOn:)]==-1} {
            puts "Error: Unsupported platformToRunOn:$uInput(platformToRunOn:). Valid: $DEVREG(server,platformsSupported)"
            return -1
        } else {
            # Check to see if a version match can be obtained from the plat to run on image.
            set pImgKey "$uInput(platformToRunOn:)Image:"
            if {[info exists uInput($pImgKey)] && $uInput($pImgKey) != "skip" && \
                 [string trim $uInput($pImgKey)] != "" && [file isfile $uInput($pImgKey)] } {
                set iFN [file tail $uInput($pImgKey)]
                if {[regexp -nocase {^[a-zA-Z0-9]+\-([0-9]{2,2}\.[0-9]{1,1})} $iFN ab v]} {
                    set vList [split $v "."]
                    if {[lindex $vList 0] < 16} {
                        set useSshModArg 1
                    }
                }
            }
        }
        
        foreach moduleName $uInput(moduleNames:) {
            #
            #  Check for debugChoice Yes
            #
            if {[info exists uInput($moduleName,debugChoice:)] && [regexp -nocase "^Y" $uInput($moduleName,debugChoice:)]} {
                # Check for Debug File
                set infoFile [file tail $filePath]
                set pathLeft [string trimright $filePath $infoFile]
                # Check for Debug File
                if {[file isfile ${pathLeft}${moduleName}.dbg]} {
                    source ${pathLeft}${moduleName}.dbg
                    if {[info exists debugCliList] && [info exists dutList] && [info exists debugOverRide]} {
                        puts "   Debug Enabled: Found Debug File ${pathLeft}${moduleName}.dbg"
                        set uInput($moduleName,debugChoice:) "Yes"
                        set uInput($moduleName,dbgFile:) "${pathLeft}${moduleName}.dbg"
                    } else {
                        puts "   Error: Debug file format incorrect!  Format should be"
                        puts "   File: ${pathLeft}${moduleName}.dbg"
                        puts "     ################################################"
                        puts "     set debugOverRide 1"
                        puts "     set dutList {1 2}"
                        puts "     set debugCliList {{show vlan} {show switch} {show fdb}}"
                        puts "     ################################################"
                        return -1
                    }
                    unset debugCliList
                    unset dutList
                    unset debugOverRide
                } else {
                    puts "   Error Debug Not Enabled: No Debug File ${pathLeft}${moduleName}.dbg"
                    puts "    - File Name Format Should Be: modulename.dbg"
                    puts "    - The File should be in the same location as your -file"
                    return -1
                }
            } ;# End of debugChoice
            if {[lsearch -exact $moduleArgFeatures $moduleName]==-1} {
                continue
            } else {
                if {![info exists uInput($moduleName,value:)] && !$useSshModArg && [regexp -nocase "ssh|aaa" $moduleName]} {
                    set uInput($moduleName,value:) "NULL"
                }
                if {[info exists uInput($moduleName,value:)] && $uInput($moduleName,value:) == "NULL"} {
                    continue;
                }
                if {[info exists uInput($moduleName,value:)] && ![regexp -nocase "^\/" $uInput($moduleName,value:)]} {
                    puts "   Error: $moduleName:value should start from /"
                    return -1
                } else {
                    if {$useSshModArg && ![file isfile $uInput($moduleName,value:)]} {
                        puts "   Error: $moduleArgVal is invalid file" 
                        return -1
                    }
                }
            }
        }
        # Check for priority
        if {$uInput(priority:)<1 || $uInput(priority:)>5} {
            puts "Error: Priority must be between 1 and 5"
            return -1
        }
        # Check for rerun
        if {$uInput(rerun:)!=1 && $uInput(rerun:)!=0} {
            puts "Error: Rerun must be either 1 or 0"
            return -1
        }
        if {![info exists uInput(branchAndPD:)]} {
            set uInput(branchAndPD:) ""
        }
        # Check for lockFile
        if {[info exists uInput(lockFile:)]} {
        set runningSrvr [runningServers]
            if {$runningSrvr!=1} {
                if {[lsearch -exact $runningSrvr $uInput(lockFile:)]!=-1} {
                    set srvrType [runningServerTypes $uInput(lockFile:)]
                    set uInput(platformToRunOn:) [lindex $srvrType 1]
                } else {
                    result_error "Test bed: $uInput(lockFile:) is not running amongst: $runningSrvr"
                    return -1
                }
            } else {
                result_error "No server running: $runningSrvr"
                return -1
            }
        }
        if {$uInput(sustaining:)} {
            set susArg "sustaining"
        } else {
            set susArg "normal"
        }
        if {[info exists uInput(moduleTypes:)]} {
           set imageLists [constructPlatformImages $uInput(platformToRunOn:) $uInput(moduleNames:) $uInput(moduleTypes:) $susArg]
        } else {
           set tCount [llength $uInput(moduleNames:)]
           for {set b 0} {$b<$tCount} {incr b} {
              lappend mtList functional
           }
           set uInput(moduleTypes:) $mtList
           set imageLists [constructPlatformImages $uInput(platformToRunOn:) $uInput(moduleNames:) $uInput(moduleTypes:) $susArg]
        }
        if {$imageLists==-1} {
            result_error "Error: Unavailable testbed $uInput(platformToRunOn:)"
            return -1
        }
        set DEVREG(active,platList) ""
        for {set imageIndex 0} {$imageIndex<[llength $imageLists]} {incr imageIndex} {
            set imageList [lindex $imageLists $imageIndex]
            foreach {imageName imageVar} $imageList {
                set thePlat [string tolower $imageName]
                lappend DEVREG(active,platList) $thePlat
                if {$uInput(platformToRunOn:)=="$imageName"} {
                    if {![info exists uInput(${imageVar}:)]} {
                        puts "   Error: a required image variable is missing -- $imageVar :"
                        return -1
                    }
                    if {![regexp -nocase "^\/" $uInput(${imageVar}:)]&&$uInput(${imageVar}:)!="skip"} {
                        puts "   Error: $imageName File $uInput(${imageVar}:) should start from /"
                        return -1
                    } else {
                        if {![file isfile $uInput(${imageVar}:)]&&$uInput(${imageVar}:)!="skip"} {
                            puts "   Error: $imageName File $uInput(${imageVar}:) is invalid file"
                            return -1
                        }
                    }
                    
                } elseif {$uInput(${imageVar}:)!="NULL" && $uInput(${imageVar}:)!="skip"} {
                    if {![info exists uInput(${imageVar}:)]} {
                        puts "   Error: a required image variable is missing -- $imageVar :"
                        return -1
                    }
                    if {![regexp -nocase "^\/" $uInput(${imageVar}:)]} {
                        puts "   Error: $imageName File $uInput(${imageVar}:) should start from /" 
                        return -1
                    } else {
                        if {![file isfile $uInput(${imageVar}:)]} {
                            puts "   Error: $imageName File $uInput(${imageVar}:) is invalid file"
                            return -1
                        }
                    }

                } else {
                    set uInput(${imageVar}:) $uInput($imageVar:)
                }
            }
        }
        if {[info exists uInput(efence:)] && [regexp -nocase "enable|no" $uInput(efence:)]!=1} {
            puts "   Error: incorrect efence $uInput(efence:)"
            return -1
        } else {
            set uInput(efence:) no
        }
        if {[info exists uInput(relInfo:)] && [regexp -nocase [string trim $uInput(relInfo:)] $DEVREG(server,relInfoList)]} {
            set uInput(relInfo:) $uInput(relInfo:)
        } elseif {[info exists uInput(relInfo:)] && ([string trim $uInput(relInfo:)]=="" || [string trim $uInput(relInfo:)]=="NULL") } {
            set uInput(relInfo:) ""
        } else {
            puts "   Error: The relInfo: value you entered is not allowed: Only - $DEVREG(server,relInfoList)"
            return -1
        }
        
        # Verify correct pair of moduleLists with either quick/pass/all values
        if {[llength $uInput(moduleNames:)]!=[llength $uInput(moduleLists:)] || \
        [llength $uInput(moduleNames:)]!=[llength $uInput(moduleTypes:)] } {
            puts "   Error: # of moduleNames [llength $uInput(moduleNames:)] is unequal to \n\
            the number of moduleLists [llength $uInput(moduleLists:)] or \n\
            moduleTypes [llength $uInput(moduleTypes:)]"
            return -1
        } else {
            set i 0
            foreach moduleList $uInput(moduleLists:) {
                if {[lsearch -exact $DEVREG(server,listsSupported) $moduleList]==-1} {
                    puts "Error: Unsupported moduleList $moduleList for module [lindex $uInput(moduleNames:) $i]"
                    return -1
                }
                    incr i
            }
            set i 0
            foreach moduleType $uInput(moduleTypes:) {
                if {[lsearch -exact $DEVREG(server,regTypeList) $moduleType]==-1} {
                    puts "Error: Unsupported moduleType $moduleType for module [lindex $uInput(moduleNames:) $i]"
                    return -1
                }
                incr i
            }
        }
    } else {
        puts "Error: Could not parse the info file $filePath"
        return -1
    }
}

##################################################################
# Procedure Name: constructPlatformImages
#
# Description: This proc constructs platform images based on what modules
#              Vs. what platform are selected in the test bed config
#
# Input args:
#             platformName - name of the platform
#             moduleNames - name of the modules to get right image platform images
#
# Output args: returns imageList on success, -1 if error
#
##################################################################
proc constructPlatformImages {platformName moduleNames moduleTypes sustaining} {
set imageList -1

global RestOfDUTType
global RestOfIPRDUTType
global citDut2ImageType
global DEVREG COMMONIMAGE
global X480EXISTS

set platformHit() ""
set platformN [lindex $platformName 0]
set moduleSubTypes [GetModuleSubType $platformN $moduleNames $moduleTypes]
if {$moduleSubTypes==""} {
   puts "Error: Incorrect module $moduleNames specified."
   return $imageList
} else {
   puts "Found: moduleSubTypes $moduleSubTypes"
}
if {$platformN=="PC"} {   ;# potential problem here, if PC is first in coma separated list
   set i386Image "NULL"
   set imageList "i386 i386Image"
   if {$sustaining == "sustaining"} {
       set i386SImage "NULL"
       set imageList "i386 i386Image"
   } else {
       set i386Image "NULL"
       set imageList "i386 i386Image"
   }
} else {
   foreach platformN $platformName {
       if {[info exists platformHit($platformN)] && $platformHit($platformN)} {
           continue;
       } else {
           set platformHit($platformN) 1
       }
       set platformNameVar [string tolower $platformN]
       set restDut    [string tolower $RestOfDUTType($platformN)]
       set restDutIpr [string tolower $RestOfIPRDUTType($platformN)]
       set restCit2n  [string tolower $citDut2ImageType($platformN)]
       if {$sustaining == "sustaining"} {
           set [set platformNameVar]SImage "NULL"
           set [set restDut]SImage "NULL"
           set [set restDutIpr]SImage "NULL"
           set [set restCit2n]SImage "NULL"
           set imageList "$platformN [set platformNameVar]SImage"
       } else {
           set [set platformNameVar]Image "NULL"
           set [set restDut]Image "NULL"
           set [set restDutIpr]Image "NULL"
           set [set restCit2n]Image "NULL"
           set imageList "$platformN [set platformNameVar]Image"
       }
       # ------------------------------------ 
       #  SubTypes are used here to determine
       #  whether or not to use RestOfIpr or
       #  RestOfStd for additional images
       # ------------------------------------
       set addedX480 0
       foreach moduleSubType $moduleSubTypes {
            if {$sustaining == "sustaining"} {
                if {$moduleSubType=="standardModules" && [regexp -nocase [set restDut] $platformN]!=1 && [regexp -nocase [set restDut] $imageList]!=1} {
                    set imageList [format "%s %s %s" $imageList $RestOfDUTType($platformN) [set restDut]SImage]
                } elseif {$moduleSubType=="routingModules" && [regexp -nocase [set restDutIpr] $platformN]!=1 && [regexp -nocase [set restDutIpr] $imageList]!=1} {
                    set imageList [format "%s %s %s" $imageList $RestOfIPRDUTType($platformN) [set restDutIpr]SImage]
                } elseif {$moduleSubType=="cit2nodeModules" && [regexp -nocase [set restCit2n] $platformN]!=1 && [regexp -nocase [set restCit2n] $imageList]!=1} {
                    set imageList [format "%s %s %s" $imageList $citDut2ImageType($platformN) [set restCit2n]SImage]
                }
            } else {
                if {$moduleSubType=="standardModules" && [regexp -nocase [set restDut] $platformN]!=1 && [regexp -nocase [set restDut] $imageList]!=1} {
                    set imageList [format "%s %s %s" $imageList $RestOfDUTType($platformN) [set restDut]Image]
                    set hitStd 1
                } elseif {$moduleSubType=="routingModules" && [regexp -nocase [set restDutIpr] $platformN]!=1 && [regexp -nocase [set restDutIpr] $imageList]!=1} {
                    set imageList [format "%s %s %s" $imageList $RestOfIPRDUTType($platformN) [set restDutIpr]Image]
                    set hitRtr 1
                } elseif {$moduleSubType=="cit2nodeModules" && [regexp -nocase [set restCit2n] $platformN]!=1 && [regexp -nocase [set restCit2n] $imageList]!=1} {
                    set imageList [format "%s %s %s" $imageList $citDut2ImageType($platformN) [set restCit2n]Image]
                    set hitCit2n 1
                }
            }
            if {[info exists X480EXISTS($platformN,routing)] && !$addedX480 && \
               $X480EXISTS($platformN,routing) && $moduleSubType=="routingModules"} {
                 set imageList [format "%s %s %s" $imageList x480 x480Image]
            } elseif {[info exists X480EXISTS($platformN,standard)] && !$addedX480 && \
               $X480EXISTS($platformN,standard) && $moduleSubType=="standardModules"} {
                 set imageList [format "%s %s %s" $imageList x480 x480Image]
            }
       }
       lappend imageListList $imageList
   }
   set imageList $imageListList
}
   return $imageList
}

##################################################################
# Procedure Name: VerifyCfgTestList
#
# Description: This proc verifies and returns the testListFile
#              Dumps tests if ? entered
#
# Input args:
#             platform - name of the platform
#             modName  - name of the feature desired
#             testsList - , separated list of tests
#             testListFile - out arg to return
#
# Output args: returns testListFile on success, -1 if error
#
##################################################################
proc VerifyCfgTestList {platform modName testsList release testListFile} {
   global BASE_PATH
   global DEVREG
   global MODPATHDEF
   global ITARPATHDEF

   # ----------------------------------------------------------------------
   # The DEVREG(active,regType) is gathered in runReg as the type of reg
   #    to run.  ie snmp or functional. GetModuleFullType formats as needed
   # ----------------------------------------------------------------------
   set myRegPath  [GetModuleFullType $DEVREG(active,regType) directory]

   set itest_tc [get_itest_mod_tests -itarPath "$ITARPATHDEF" -modPath "$MODPATHDEF" -module "$modName" \
                      -category [get_itest_category -modPath $myRegPath]]

   if {$release==""} {
      set release "current"
   }
   set Path Path
   set sourceCompleteTestsDir "$DEVREG(relInfoPath,$release)/../$myRegPath/$modName/completetests.lst"
   puts "$sourceCompleteTestsDir"
   upvar $testListFile fileToReturn
   set fileToReturn "./$modName"
   set tmptests [split [string trim $testsList ,] ,]   ;# , separated list of tessts
   foreach tmptest $tmptests {
      lappend tests [string trim $tmptest]
   }

   # Could not copy the completetests.lst return an error
   if {[catch {exec cp -L $sourceCompleteTestsDir ./completetests.lst} reason]} {
      puts "Error: Cannot copy file to ./completetests.lst ...$reason";
      return -1
   }
   set what [GetCleanTestList dev]

   # user passed in illegal value return a reprompt
   if {$testsList==""||$testsList=="?"} {
      regsub -all " " $what ", " comaSeparated
      puts "$comaSeparated"
      file delete completetests.lst
      return -1
   }
   # File will not open - return
   if {[set fd_out [FileOpen $fileToReturn w]]==-1} {
      file delete completetests.lst
      return $fd_out
   }
   # Get all possible tests from the completetests
   set allCTProcs [GetCleanTestList dev]
   if {[llength itest_tc] > 0} {
       set allCTProcs [concat $allCTProcs $itest_tc]
   }
   # Make sure that all of the tests passed in are in the completetests.lst
   foreach inTest $tests {
       if {[lsearch $allCTProcs $inTest] < 0} {
            # Above lsearch does not use -exact intentionally.
            # causes, false invalid tests cuzz of comments of PD, usr cmnts
            # just verify using regexp
            result_error "invalid test for $modName"
            file delete completetests.lst
            close $fd_out
            file delete $fileToReturn
            return -1
       }
   }
   # -----------------------------------------------------
   # Start to build the new smaller completetests.lst
   #
   # 
   # -----------------------------------------------------
   puts $fd_out "set tests_to_run(all) \{"
   # -----------------------------------------------------
   # Insert cases to be checked against completetests.lst
   # -----------------------------------------------------
   set hit1Init 0
   if {[lsearch $allCTProcs "1.init"] >= 0} {set hit1Init 1}
   set allCTProcs [ldelete $allCTProcs "1.init"]
   set allCTProcs [concat "1.init" $allCTProcs]
   # Set the end proc for each init so we know how to setup and cleanup
   array set endByInit [GetEndArray $allCTProcs]
   # -----------------------------------------------------
   # Set the init and end script for each case proc
   #    initByProc(proc) initfile required for each proc
   #    endByProc([proc) endfile required for each proc
   #    procsByInit(proc.init) all procs for an init file
   # -----------------------------------------------------
   set res [GetTestCaseCTListArrays $allCTProcs initByProc endByProc procsByInit]
   set tList ""
   set initIndexList [lsearch -all -regexp $allCTProcs init]
   set endIndexList [lsearch -all -regexp $allCTProcs end]
   # ------------------------------------------------------
   # convert proc names passed in to their index in the 
   #    list of all tests in the feature
   # ------------------------------------------------------
   # If there is a 1.init file, put that in.
   if {$hit1Init} {
       puts "1.init"
       puts $fd_out "1.init"
   }
   set inIndexList ""
   foreach t $tests {
       set inIndex [lsearch $allCTProcs $t]
       lappend inIndexList $inIndex
   }
   set inIndexList [lsort -integer $inIndexList]
   set top [llength $inIndexList]   
   # loop through the indexes of all of the cases passed in.
   set procsPrinted ""
   set printed ""
   for {set it 0} {$it<$top} {incr it} {
       set printed ""
       # get the real alltests index number for the inProc
       set inIndex [lindex $inIndexList $it]
       # init a variable to to be set if the tests falls b/t an init and end
       set matched 0
       # loop through all of the init indexes
       set ii 0
       foreach i $initIndexList {
           # If the index passed in is inbetween and init and end pair
           if {$inIndex > $i && $inIndex < $endByInit($i)} {
               # if the in cases is not an end or init proc
               if {[lsearch $endIndexList $inIndex] < 0 && [lsearch $initIndexList $inIndex] < 0} {
                   set matched 1
                   set initProcName [lindex $allCTProcs $i]
                   set testProcName [lindex $allCTProcs $inIndex]
                   set iPrint 1
                   puts "$initProcName"
                   puts $fd_out "$initProcName"
                   lappend printed $initProcName
                   #puts "$testProcName"
                   while {[lsearch $procsByInit($initProcName) $testProcName] >= 0} {
                       foreach ibp $initByProc($testProcName) {
                           if {[lsearch $printed $ibp] < 0 && $ibp != "1.init"} {
                               puts "$ibp"
                               puts $fd_out "$ibp"
                               lappend printed $ibp
                           }
                       }
                       if {[lsearch $procsPrinted $testProcName] < 0} {
                           puts "$testProcName"
                           puts $fd_out "$testProcName"
                           lappend procsPrinted $testProcName
                       }
                       set lastTestProc $testProcName
                       incr it
                       set inIndex [lindex $inIndexList $it]
                       set testProcName [lindex $allCTProcs $inIndex]
                   }
                   foreach ebp $endByProc($lastTestProc) {
                       puts "$ebp"
                       puts $fd_out "$ebp"
                   }
                   #puts "End [lindex $allCTProcs $endByInit($i)]"
                   incr it -1
               }
           }
       }
       if {!$matched} {
           puts "[lindex $allCTProcs $inIndex]"
           puts $fd_out "[lindex $allCTProcs $inIndex]"
           lappend procsPrinted [lindex $allCTProcs $inIndex]
       }
   }
   # -----------------------------------------------------
   # Loop through all tests to see what we can drop
   # -----------------------------------------------------
   puts $fd_out "\}"
   file delete completetests.lst
   close $fd_out
   return 1
}

##################################################################
# Procedure Name: CreateDebugFile
#
# Description: This proc creates a debug cli file in a tmp location
#              for later relocation to mod directories
#
# Input args:
#             modName  - name of the feature desired
#             dutList - a string "set dut dutList"
#             cliList - a string "set cli cliList"
#
# Output args: returns debugFile on success, 0 if error
#
##################################################################
proc CreateDebugFile {modName dutString cliString debugFile faillock} {
   global DEVREG
   upvar $debugFile fileToReturn
   set fileToReturn "./$modName.dbg"

   if {[set fd_out [FileOpen $fileToReturn w]]==-1} {
      return 0
   }
   puts $fd_out "set debugOverRide 1"
   puts $fd_out "set faillock $faillock"
   puts $fd_out "# List of DUTs to run these commands on"
   puts $fd_out "$dutString"
   puts $fd_out "# List of commands to send to the duts"
   puts $fd_out "$cliString"
   close $fd_out
   return 1
}

proc _getMysqlAutomateSubType {platform feature ftype} {
   global DEVREG
   set subType NULL
   set moduleSubType [GetModuleSubType $platform $feature $ftype]
   if {$moduleSubType=="standardModules"} {
      set subType standard
   } elseif {$moduleSubType=="routingModules"} {
      set subType ipRoute1
   }
   return $subType
}

proc UpdateTimedLockFile {cfg lockFlag} {
   global DEVREG
   if {$lockFlag=="lock"} {
      if {[set fd_out [FileOpen $DEVREG(server,timedLockFile) a+]]==-1} {
        return $fd_out
      }
      puts $fd_out $cfg
      funlock $fd_out
      close $fd_out
      return 1
   } elseif {$lockFlag=="unlock"} {
      set lines ""
      if {[set fd_in [FileOpen $DEVREG(server,timedLockFile) r]]==-1} {
         return $fd_in
      }
      while {[gets $fd_in line]!=-1} {
         lappend lines $line
      }
      funlock $fd_in
      close $fd_in
      if {$lines!=""} {
         if {[set fd_out [FileOpen $DEVREG(server,timedLockFile) w]]==-1} {
            return $fd_out
         }
         foreach line $lines {
            if {[string compare $line $cfg]!=0} {
               puts $fd_out $line
            }
         }
         close $fd_out
      }
      return 1
   }
}

proc timedLockServers { } {
   global DEVREG
   set lines ""
   if {[set fd_in [FileOpen $DEVREG(server,timedLockFile) r]]==-1} {
      return $fd_in
   }
   while {[gets $fd_in line]!=-1} {
      lappend lines $line
   }
   funlock $fd_in
   close $fd_in
   return $lines
}

proc OrderPriorityFile {} {
   global DEVREG
   set pri1 ""
   set pri2 ""
   set pri3 ""
   set pri4 ""
   set pri5 ""

   if {[set fd_in [FileOpen $DEVREG(server,priorityFile) r+]]==-1} {
      return $fd_in
   }
   array set priArr ""
   while {[gets $fd_in line]!=-1} {
      set line [string trim $line]
      if {$line == ""} {
          continue
      } elseif {![regexp {[A-Z]{3,3}_[0-9]{6,6}_[0-9]{6,6}} $line]} {
          puts "\n!!!\n!!!\n!!! BAD BAD BAD queueid $line !!!\n!!!\n!!!"
          continue
      }
      set qId $line
      set queueInfoFile $DEVREG(server,imagesQueuedDir)/$qId/info
      if {![file exists $queueInfoFile]} {   ;# if queueId does not exist
         continue
      }
      #puts "QIF - $queueInfoFile"
      if {[file isfile $queueInfoFile]} {
          ReadQueueInfoIntoArray $queueInfoFile uInput
          if {[info exists uInput(priority:)]} {
             lappend pri$uInput(priority:) $qId
          } else {
             lappend pri3 $qId
          }
      } else {
          puts "$queueInfoFile needs cleanup"
      }
   }

#   result_debug "pri1 $pri1, pri2 $pri2, pri3 $pri3, pri4 $pri4, pri5 $pri5"
   set pri1 [lsort $pri1]
   set pri2 [lsort $pri2]
   set pri3 [lsort $pri3]
   set pri4 [lsort $pri4]
   set pri5 [lsort $pri5]

   seek $fd_in 0 start
    
   # After sorting is done, write to temp file
   foreach index $pri1 {
      set id [string trim $index "^@"];# Trim odd hex being added from someplace
      puts $fd_in $id
   }
   foreach index $pri2 {
      set id [string trim $index "^@"];# Trim odd hex being added from someplace
      puts $fd_in $id
   }
   foreach index $pri3 {
      set id [string trim $index "^@"];# Trim odd hex being added from someplace
      puts $fd_in $id
   }
   foreach index $pri4 {
      set id [string trim $index "^@"];# Trim odd hex being added from someplace
      puts $fd_in $id
   }
   foreach index $pri5 {
      set id [string trim $index "^@"];# Trim odd hex being added from someplace
      puts $fd_in $id
   }
   close $fd_in
   return 1
}
################################################################################
#
#
#
#
#
################################################################################
proc VerifyDUTsForDebug {{dString 1} debugDutList} {
   global DEVREG
   upvar $debugDutList duts
   set duts NULL;

   set dutList [split $dString ,];
   set state BAD;
   foreach dut $dutList {
      set dut [string trim $dut]
      if {[regexp -nocase {^1$|^2$|^3$|^4$|^5$} $dut]} {
         set state OK;
      } else {
         return 0;
      }
   }
   if {$state=="OK"} {
      #set dutList \{\{1\}\}
      set duts "set dutList \{$dutList\}";
      return 1;
   } else {
      return 0;
   }
}


proc timeSortDirList {dirList} {
   global DEVREG
   set mtimeList ""
   foreach d $dirList {
      lappend mtimeList [file mtime $d]
   }
   set sortedmtimeList [lsort -integer $mtimeList]
   set newDirList ""
   foreach mtimeL $sortedmtimeList {
      set index [lsearch $mtimeList $mtimeL]
      if {$index!=-1} {
         lappend newDirList [lindex $dirList $index]
      }
   }

   return $newDirList
}

##################################################################
#  Procedure Name: VerifyRegserverFileSystem
#  Queue Debug Proc
#
#
# Input args: none
# Output args: none
# Typical usage:
#           VerifyRegserverFileSystem
# Category: Setup
##################################################################
proc VerifyRegserverFileSystem {} {
    global DEVREG

    if {![file isdirectory $DEVREG(server,regressionDir)]} {
        if {[catch {file mkdir $DEVREG(server,regressionDir)} reason]} {
            puts "Error: Can not create regressionDir dir...$reason"
            return -1
        } else {
            puts "Created regressionDir Dir"
        }
    }
    if {![file isdirectory $DEVREG(server,imagesQueuedDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesQueuedDir)} reason]} {
            puts "Error: Can not create imagesQueuedDir dir...$reason"
            return -1
        } else {
            puts "Created imagesQueuedDir Dir"
        }
    }
    if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
            puts "Error: Can not create imagesFinishedDir dir...$reason"
            return -1
        } else {
            puts "Created imagesFinishedDir Dir"
        }
    }
    if {![file isdirectory $DEVREG(server,imagesKilledDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesKilledDir)} reason]} {
            puts "Error: Can not create imagesKilledDir dir...$reason"
            return -1
        } else {
            puts "Created imagesKilledDir Dir"
        }
    }
    if {![file isdirectory $DEVREG(server,imagesRunningDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesRunningDir)} reason]} {
            puts "Error: Can not create imagesRunningDir dir...$reason"
            return -1
        } else {
            puts "Created imagesRunningDir Dir"
        }
    }

    if {![file isfile "$DEVREG(server,priorityFile)"]} {
        puts "Priority File Does Not Exist. Create it"
        if {[set fd1 [FileOpen $DEVREG(server,priorityFile) a+]]==-1} {
            puts  "Create Priority File Failed"
            close $fd1
            return $fd1
        } else {
            close $fd1
            puts  "$DEVREG(server,priorityFile) Created Successfully"
        }
    }
    if {![file isfile "$DEVREG(server,lockFile)"]} {
        puts "lockFile File Does Not Exist. Create it"
        if {[set fd1 [FileOpen $DEVREG(server,lockFile) a+]]==-1} {
            puts  "Create lockFile File Failed"
            close $fd1
            return $fd1
        } else {
            close $fd1
            puts  "$DEVREG(server,lockFile) Created Successfully"
        }
    }
    if {![file isfile "$DEVREG(server,timedLockFile)"]} {
        puts "timedLockFile File Does Not Exist. Create it"
        if {[set fd1 [FileOpen $DEVREG(server,timedLockFile) a+]]==-1} {
            puts  "Create timedLockFile File Failed"
            close $fd1
            return $fd1
        } else {
            close $fd1
            puts  "$DEVREG(server,timedLockFile) Created Successfully"
        }
    }
}
##################################################################
#  Procedure Name: GetModuleFullType
#  Get a full test directory
#
#
# Input args: none
# Output args: none
# Typical usage:
#           GetModuleFullType
# Category: Setup
##################################################################
proc GetModuleFullType {modType format} {
   global DEVREG
   switch -regexp $modType {
      "functional" {
          if {$format == "runreg"} {
              return "functional"
          } else {
              return "Functionaltest"
          }
      }
      "fit" {
          if {$format == "runreg"} {
              return "fit"
          } else {
              return "FeatureInteraction"
          }
      }
      "snmp" {
          if {$format == "runreg"} {
              return "snmp"
          } else {
              return "SnmpFunctionaltest"
          }
      }
      "xml" {
          if {$format == "runreg"} {
              return "xml"
          } else {
              return "XML_API"
          }
      }
      "scal" {
          if {$format == "runreg"} {
              return "scalability"
          } else {
              return "Scalabilitytest"
          }
      }
      "stess" {
          if {$format == "runreg"} {
              return "stresstest"
          } else {
              return "Stresstest"
          }
      }
      "perf" {
          if {$format == "runreg"} {
              return "performance"
          } else {
              return "PerformanceTest"
          }
      }
      "default" {
          if {$format == "runreg"} {
              return "functional"
          } else {
              return "Functionaltest"
          }
      }
   }

}
##################################################################
#  Procedure Name: partnerInUse
#  - Check to see if this testbeds partner queues are in use
#    specifically by checking to see if loadimage or main is 
#    running.
#
# Input args: list of partner cfgs
# Output args: none
# Typical usage:
#           partnerInUse {p1_voy_std.cfg p3_voy_std.cfg}
# Category: Setup
##################################################################
proc partnerInUse {{partnerCfgList}} {
    set i 0
    foreach configFile $partnerCfgList {
        set psLine [catch {exec ps -eafwww | egrep -e "mysql.*$configFile|.*phore.*$configFile|Load.*$configFile|main.tcl.*$configFile" | grep -v grep} psout]
        #puts "the psLine $psLine and configFile $configFile"
        if {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
            return $i;
        }
        incr i
    }
    sleep 3
    foreach configFile $partnerCfgList {
        set psLine [catch {exec ps -eafwww | egrep -e "mysql.*$configFile|.*phore.*$configFile|Load.*$configFile|main.tcl.*$configFile" | grep -v grep} psout]
        #puts "the psLine $psLine and configFile $configFile"
        if {[regexp -nocase {[0-9]+} [lindex $psout 1]]} {
            return $i;
        }
        incr i
    }
    return -1;
}
##################################################################
#  Procedure Name: aquire_process_lock
#  - 
#     
#    
#
# Input args: 
# Output args: 
# Typical usage:
#           aquire_process_lock $lockid
# Category: Utility
##################################################################
proc aquire_process_lock {LOCKID} {
    global LOCK_SOCKET
    
    set PORT [port_process_map "$LOCKID"]
    # 'socket already in use' error will be our lock detection mechanism
    
    if { [catch {socket -server dummy_process_accept $PORT} SOCKET] } {
        puts "Could not aquire lock"
        return 0
    }
    
    set LOCK_SOCKET("$LOCKID") "$SOCKET"
    
    return 1
}
##################################################################
#  Procedure Name: release_process_lock
#  - 
#     
#    
#
# Input args: 
# Output args: 
# Typical usage:
#           release_process_lock $lockid
# Category: Utility
##################################################################
proc release_process_lock {LOCKID} {
    global LOCK_SOCKET
    
    if { [catch {close $LOCK_SOCKET("$LOCKID")} ERRORMSG] } {
        puts "Error '$ERRORMSG' on closing socket for lock '$LOCKID'"
        return 0
    }
    
    unset LOCK_SOCKET("$LOCKID")
    
    return 1
}

##################################################################
#  Procedure Name: port_process_map
#  - 
#     
#    
#
# Input args: 
# Output args: 
# Typical usage:
#           port_process_map $lockid
# Category: Utility
##################################################################
proc port_process_map {LOCKID} {
    # calculate our 'unique' port number using a hash function.
    # this mapping function comes from dr. KNUTH's art of programming volume 3.
    
    set LEN [string length $LOCKID]
    set HASH $LEN
    
    for {set IDX 0} {$IDX < $LEN} {incr IDX} {
    scan [string index "$LOCKID" $IDX] "%c" ASC
    set HASH [expr (($HASH<<5)^($HASH>>27))^$ASC];
    }
    
    # always use a prime for remainder
    # note that the prime number used here will basicly determine the maximum
    # number of simultaneous locks
    
    return [expr (65535 - ($HASH % 101))]

}
##################################################################
#  Procedure Name: port_process_map
#  - 
#     
#    
#
# Input args: 
# Output args: 
# Typical usage:
#           dummy_process_accept $newsock $addr $port
# Category: Utility
##################################################################
proc dummy_process_accept {newsock addr port} {

}
##################################################################
#  Baseline download proc
#
#
##################################################################
proc QueueDownloadBaseline {modType platformType myQueueId userArray runningIndex} {

    global RestOfDUTType
    global RestOfIPRDUTType
    global DEVREG COMMONIMAGE
    global skipMysqlAutomate
    global mainPath
    global myRegPathSmall
    global cfg
    global runRegPlatformCode
    
    array set uInput $userArray
    set hitAllNull 0
    set featureSubType [_getMysqlAutomateSubType $platformType [lindex $uInput(moduleNames:) $runningIndex] $modType];
    if {[info exists uInput(platformToRunOn:)]} {
        set targetPlatform $uInput(platformToRunOn:)
        set targetPlatformLower [string tolower $targetPlatform]
        # ----- Determine DUT2+ image type ... rtr or std
        if {$featureSubType == "standard" } {
            set restDutLower [string tolower $RestOfDUTType($targetPlatform)]
            if {[info exists uInput(${restDutLower}BL_Image:)]} {
                set dut2Plat $RestOfDUTType($targetPlatform)
                set dut2Image $uInput(${restDutLower}BL_Image:)
            }
        } else {
            set restDutLower [string tolower $RestOfIPRDUTType($targetPlatform)]
            if {[info exists uInput(${restDutLower}BL_Image:)]} {
                set dut2Plat $RestOfIPRDUTType($targetPlatform)
                set dut2Image $uInput(${restDutLower}BL_Image:)
            }
        }
        # --------------------------------------------------------
        # Check the 2 images for NULL
        # --------------------------------------------------------
        if {[info exists uInput(${targetPlatformLower}BL_Image:)] && \
            $uInput(${targetPlatformLower}BL_Image:)=="NULL" && \
            $dut2Image=="NULL"} {
                set hitAllNull 1; # Hit null
        }
    }

    # --------------------------------------------------------------------
    #  If the platform to run  $uInput(platformToRunOn:) and the
    #  image $uInput(${targetPlatformLower}BL_Image:) is set to skip 
    #  then skip download
    # --------------------------------------------------------------------
    
    # Start the download process
    WriteToQueueDebug "Regserver Baseline Download" "Normal Baseline Download Start";
    # ----------------------------------------------------------------------
    #  Get the platformToRunOn and use it to get/link to the DUT1 image
    #     path as well as the DUT2+ paths.
    # ----------------------------------------------------------------------
    set plats ""
    set platImagePaths ""
    # --- targetPlatformLower set above
    if {[info exists uInput(${targetPlatformLower}BL_Image:)] && \
    $uInput(${targetPlatformLower}BL_Image:)!="NULL" } {
        # -----------------------------------------------------------
        # Set the image name to the oldest common name
        #   Sonoma -> Aspen
        #   Melange-> Aspen
        #   Torino -> Olympic
        #
        # COMMONIMAGE($targetPlatform) is initialized in runReg.cfg
        # -----------------------------------------------------------
        
        # -----------------------------------------------------------
        # Set image info for DUT1
        # -----------------------------------------------------------
        set commonImageA $COMMONIMAGE($targetPlatform); # $COMMONIMAGE(Sonoma)->Aspen
        set commonImageALower [string tolower $commonImageA]
        set uInput(${commonImageALower}BL_Image:) $uInput(${targetPlatformLower}BL_Image:)
        lappend plats "$commonImageA"; # List of platforms "Aspen"
        lappend platImagePaths "$uInput(${commonImageALower}BL_Image:)"; # List of full image paths
        # -----------------------------------------------------------
        # Set image info for DUT2
        # -----------------------------------------------------------
        set commonImageB $COMMONIMAGE($dut2Plat); # $COMMONIMAGE(Sonoma)->Aspen
        set commonImageBLower [string tolower $commonImageB]
        set uInput(${commonImageBLower}BL_Image:) $dut2Image
        if {[string tolower [file tail $uInput(${commonImageBLower}BL_Image:)]] != "null"} {
            puts "NULL not hit: [string tolower [file tail $uInput(${commonImageBLower}BL_Image:)]]"
            lappend plats "$commonImageB"; # List of platforms "Aspen Cougar"
            lappend platImagePaths "$uInput(${commonImageBLower}BL_Image:)"; # List of full image paths
        }
    }
    
    GetLocalImageDir -id $myQueueId -platformList $plats -platformImageList $platImagePaths
    #GetLocalImageDir $myQueueId $uInput(i386Image:) $uInput(marinerImage:) $uInput(aspenImage:) \
    #     $uInput(aspennapaImage:) $uInput(cougarImage:) $uInput(olympicImage:) $uInput(jaguarImage:) \
    #     $uInput(pantherImage:) $uInput(voyagerImage:) i386Image marinerImage aspenImage aspennapaImage \
    #     cougarImage olympicImage jaguarImage pantherImage voyagerImage 
    # ----------------------------------------------------------------------
    # Re-create the image path lists from variables set in GetLocalImageDir
    # ----------------------------------------------------------------------
    set platImagePaths ""
    foreach myPlat $plats {
        lappend platImagePaths $DEVREG(imageDir,$myPlat)
    }
    set mydir [pwd]
    cd $mainPath
    WriteToQueueDebug "QLoadImage Baseline call" "QLoadImage.tcl -cfg $cfg \
        -platformList $plats -qId $myQueueId -platformImageList $platImagePaths";
    catch {exec ./QLoadImage.tcl -cfg $cfg -platformList $plats -qId $myQueueId \
        -platformImageList $platImagePaths  >@stdout | busybox tee /tmp/Tmp/$myQueueId[pid]} resD
    cd $mydir
    WriteToQueueDebug "After Baseline QLoadImage call" "Result = $resD";
    if {[catch {exec cp /tmp/Tmp/$myQueueId[pid] /tmp/Tmp/BL_DL_$myQueueId} reason]} {
        puts "Error: Cannot cp /tmp/Tmp/$myQueueId[pid] to /tmp/Tmp/BL_DL_$myQueueId ...$reason";
        return -1
    }
    
    set oldQueueId $myQueueId
    set oldResD $resD
    WriteToQueueDebug "End of Download choices" "oldResD $resD oldQueueId $myQueueId";
    if {($resD==0)||([regexp -nocase "^0" $resD]==1&&[regexp -nocase "write error" $resD])} {
        # Download image successful, move the report dir to avoid conflict with failed ones
        # Since we do not want to compute the info file here but only move the
        # download report dir
        set DEVREG(active,failcount) 0
        WriteToQueueDebug "Download image successful" "Call MoveReportToQueueFinished";
        file delete /tmp/Tmp/$myQueueId[pid]
        if {[set targetDir [MoveReportToQueueFinished $myQueueId [array get uInput] $runningIndex DownloadPassed]]==-1} {
            set targetDir "Baseline Download Report dir not generate"
        }
        puts "!!!!\nTarget Dir\n$targetDir\n!!!!!"
        if {$uInput(platformToRunOn:)=="PC"} {
           set platToRunOn i386
        } else {
           set platToRunOn [string tolower $uInput(platformToRunOn:)]
        }
        if {$uInput([set platToRunOn]BL_Image:)!="skip"} {
            if {!$skipMysqlAutomate} {
                WriteToQueueDebug "Download baseline image successful" "mysqlAutomate: -platform $runRegPlatformCode \
                    -regId $myQueueId \
                    -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex]  -qId $myQueueId \
                    -regType $myRegPathSmall -regSubType $featureSubType";
                catch {exec $mainPath/../main/mysqlAutomate.tcl -regId $myQueueId -platform $runRegPlatformCode \
                    -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex]  -qId $myQueueId \
                    -regType $myRegPathSmall -regSubType $featureSubType -callLocation \
                    "regServer: resD=0 download successful $cfg">@stdout} automateRet
            }
        }
        return 0
    } else {
        return -1
    }
}
##################################################################
# Procedure Name: ReQueueModules
#
# Description: This proc goes through images running and looks
#              for download fails and mainfails and requeues them
#
# Input args:
#           qId: queueId to work on inside imagesFinished
# Typical usage:
#           ReQueueModules $myQueueId
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc ReQueueModules {qId {finished no} {features "null"}} {
   global DEVREG

   if {$finished == "yes"} {
      set inFinished 0
      set inRunning 0
      if {[file isfile "$DEVREG(server,imagesFinishedDir)/$qId/info"]} {
         puts "Found info in Finished"
         set fileToUse $DEVREG(server,imagesFinishedDir)/$qId/info
         set inFinished 1
      }
      if {[file isfile "$DEVREG(server,imagesRunningDir)/$qId/info"]} {
         puts "Found info in Running"
         set fileToUse $DEVREG(server,imagesRunningDir)/$qId/info
         set inRunning 1
      }
      if {!$inFinished && !$inRunning} {
         result_error "Error: no info file available"
         return -1
      }
      if {!$inRunning && ![file isdirectory $DEVREG(server,imagesRunningDir)/$qId/]} {
         if {[catch {file mkdir $DEVREG(server,imagesRunningDir)/$qId/} reason]} {
            result_error "Error: Can not create $DEVREG(server,imagesRunningDir)/$qId/ dir...$reason"
            return -1
         }
      }
      if {![file isdirectory $DEVREG(server,imagesQueuedDir)/$qId/]} {
         if {[catch {file mkdir $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
            result_error "Error: Can not create $DEVREG(server,imagesQueuedDir)/$qId/ dir...$reason"
            return -1
         }
      }
      if {$inRunning} {
         if {[catch {exec cp $DEVREG(server,imagesRunningDir)/$qId/info \
            $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
            puts "Error: Cannot cp $DEVREG(server,imagesRunningDir)/$qId/info \
            to $DEVREG(server,imagesQueuedDir)/$qId/ ...$reason";
            return -1
         }
      } else {
         if {[catch {exec cp $DEVREG(server,imagesFinishedDir)/$qId/info $DEVREG(server,imagesRunningDir)/$qId/} reason]} {
            puts "Error: Cannot cp $DEVREG(server,imagesFinishedDir)/$qId/info to $DEVREG(server,imagesRunningDir)/$qId/ ...$reason";
            return -1
         }
         if {[catch {exec cp $DEVREG(server,imagesFinishedDir)/$qId/info $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
            puts "Error: Cannot cp $DEVREG(server,imagesFinishedDir)/$qId/info to $DEVREG(server,imagesQueuedDir)/$qId/ ...$reason";
            return -1
         }
      }
      set runningInfoFile "$DEVREG(server,imagesRunningDir)/$qId/info"
      if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;# qId is already running
         if {[set fd_r [FileOpen $runningInfoFile r+]]==-1} {
            return $fd_r
         }
         set cpList ""
         while {[gets $fd_r infoLine]!=-1} {
            set runInfo([lindex $infoLine 0]) [lrange $infoLine 1 end]
            if {[string trim [lrange $infoLine 1 end]] != "NULL" && [regexp "Image" [lindex $infoLine 0]] && \
                [lsearch $cpList [string trim [lrange $infoLine 1 end]]] < 0} {
               puts "Copy [string trim [lrange $infoLine 1 end]] to $qId"
               if {[catch {exec cp [string trim [lrange $infoLine 1 end]] $DEVREG(server,imagesQueuedDir)/$qId/} reason]} {
                  puts "Error: Cannot cp cp [string trim [lrange $infoLine 1 end]] $DEVREG(server,imagesQueuedDir)/$qId/ ...$reason";
                  if {![regexp "480" [string trim [lrange $infoLine 1 end]]]} {
                      return -1
                  }
               }
               lappend cpList "[string trim [lrange $infoLine 1 end]]" 
            } elseif {[lsearch $cpList [string trim [lrange $infoLine 1 end]]] >= 0} {
                puts "Already copied [string trim [lrange $infoLine 1 end]] to $qId"
            }
         }
      } else {  ;# qId not Found, an error
         result_error "Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues";
         return -1
      }
      close $fd_r
      SetPriorityFile $qId
   } 

   set runningInfoFile "$DEVREG(server,imagesRunningDir)/$qId/info"
   set queueInfoFile "$DEVREG(server,imagesQueuedDir)/$qId/info"
   if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;# qId is already running
      if {[set fd_r [FileOpen $runningInfoFile r+]]==-1} {
         return $fd_r
      }
      while {[gets $fd_r infoLine]!=-1} {
         set runInfo([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
   } else {  ;# qId not Found, an error
      result_error "Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues";
      return -1
   }
   if {![catch {glob -- $DEVREG(server,imagesQueuedDir)/$qId} queues]} { ;# qId is in queued dir
      if {[set fd_q [FileOpen $queueInfoFile r+]]==-1} {
         return $fd_q
      }
      while {[gets $fd_q infoLine]!=-1} {
         set queueInfo([lindex $infoLine 0]) [lrange $infoLine 1 end]
      }
   } else {  ;# qId not Found, an error
      result_error "Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues";
      return -1
   }

   if {$features != "null"} {
       set replaceIList ""
       foreach rFeat $features {
           set fIndex [lsearch $queueInfo(moduleNames:) $rFeat]
           lappend replaceIList $fIndex
       }
   } else {
       set replaceIList [lsearch -regexp -all $runInfo(runStatus:) ^Main|^Down]
   }
   foreach r $replaceIList {
       set runInfo(runStatus:) [lreplace $runInfo(runStatus:) $r $r "queued"]
       set queueInfo(runStatus:) [lreplace $queueInfo(runStatus:) $r $r "queued"]
   }
   set replaceIList2 [lsearch -regexp -all $runInfo(runStatus:) ^runn]
   foreach r2 $replaceIList2 {
       set mod [lindex $runInfo(moduleNames:) $r2]
       set cfgList [split [lindex $runInfo(runStatus:) $r2] "On"]
       set cfg [lindex $cfgList 1]
       set psLineitest [catch {exec ps -eafwww | egrep -e "main\.tcl.*-module.*$mod.*$qId" | grep -v grep} psoutmod]
       if {[string trim $psoutmod] == "" || [regexp -nocase "child process exited abnormally" $psoutmod]} {
           puts "$mod is not running on $cfgList $psoutmod "
           lappend replaceIList $r2
           set runInfo(runStatus:) [lreplace $runInfo(runStatus:) $r2 $r2 "queued"]
           set queueInfo(runStatus:) [lreplace $queueInfo(runStatus:) $r2 $r2 "queued"]
       } else {
           puts "$mod is running on $cfgList $psoutmod"
       }
   }
   set replaceIList3 [lsearch -regexp -all $runInfo(runStatus:) ^reRun]
   foreach r2 $replaceIList3 {
       set mod [lindex $runInfo(moduleNames:) $r2]
       set cfgList [split [lindex $runInfo(runStatus:) $r2] "On"]
       set cfg [lindex $cfgList 1]
       set psLineitest [catch {exec ps -eafwww | egrep -e "main\.tcl.*-module.*$mod.*$qId" | grep -v grep} psoutmod]
       if {[string trim $psoutmod] == "" || [regexp -nocase "child process exited abnormally" $psoutmod]} {
           puts "$mod is not reRunning on $cfgList $psoutmod "
           lappend replaceIList $r2
           set runInfo(runStatus:) [lreplace $runInfo(runStatus:) $r2 $r2 "queued"]
           set queueInfo(runStatus:) [lreplace $queueInfo(runStatus:) $r2 $r2 "queued"]
       } else {
           puts "$mod is reRunning on $cfgList $psoutmod"
       }
   }

   #set psLineitest [catch {exec ps -eafwww | egrep -e "main\.tcl.*-module L2" | grep -v grep} psoutitest]
   # -------------------------------------------------------------------------
   # if Use Database is on, update the test module table entry for this module
   # -------------------------------------------------------------------------
   if {$DEVREG(mysql,UseDb)} {
       set rId [getRegIdFromQId $qId]
       # Login to rdureg auto db
       set hdl [quick_db_connect rtp-otps devweb_db]
       if {$hdl != "fail"} {
           set autoRegId [getRegressionIdDb -hdl $hdl -queue_id $qId]
           puts "autoRegId = $autoRegId"
       }
       foreach r $replaceIList {
           set cfgList [split [lindex $runInfo(runStatus:) $r] "On"]
           updateRegTestModule -reg_id $rId -name [lindex $runInfo(moduleNames:) $r] \
               -pass_cnt_1 "0" -total_cnt_1 "0" -duration_1 "0" -pass_cnt "0" -total_cnt "0" \
               -duration "0"  -status "queued" -testbed "[lindex $cfgList 1]"

           if {[catch {exec rm -rf $DEVREG(server,imagesFinishedDir)/$qId/[lindex $runInfo(moduleNames:) $r]} reason]} {
                puts "Error: Cannot rm $DEVREG(server,imagesFinishedDir)/$qId/[lindex $runInfo(moduleNames:) $r]"
                puts  "     ..$reason";
           } else {
                puts "rm -rf $DEVREG(server,imagesFinishedDir)/$qId/[lindex $runInfo(moduleNames:) $r]"
           }

           # delete the results from the auto db.
           if {$hdl != "fail"} {
               deleteReportsAndLogsDb -hdl $hdl -regression_id $autoRegId \
                  -feature_type [lindex $runInfo(moduleTypes:) $r]  \
                  -feature_directory [lindex $runInfo(moduleNames:) $r]
           }
       }
       if {$hdl != "fail"} {
           mysqlclose $hdl
       }
   }
   seek $fd_q 0 start
   foreach varName [array names queueInfo] {
       puts $fd_q "[format "%-20s %-20s" "$varName" $queueInfo($varName)]"
   }
   ftruncate $queueInfoFile [tell $fd_q]
   close $fd_q

   seek $fd_r 0 start
   foreach varName [array names runInfo] {
       puts $fd_r "[format "%-20s %-20s" "$varName" $runInfo($varName)]"
   }
   ftruncate $runningInfoFile [tell $fd_r]
   close $fd_r
   return 1
}
#############################################################################
# proc to get info about running and queued regressions.  
# 
# Return a platform keyed array of usage.
#############################################################################
proc checkPlatQueued {} {
    
    global auto_path
    source /auto/automation/Util/runReg.cfg   ;# need to change it when run from elsewhere
    source /auto/automation/Util/iTest.cfg
    set autoPath "/auto/automation/"
    # Decide which queue_ids will be store on the local server
    set DEVREG(server,HOST)              [exec hostname -s]
    
    if {[regexp -nocase "devreg|rdu" $DEVREG(server,HOST)]} {
        # rdu case -
        set match RTP
    } elseif {[regexp -nocase "sal" $DEVREG(server,HOST)]} {
        set match SALEM
    } else {
        #SC case.. set all of these to Complete
        set match SC
    }
    
    #Get an array aligning cfg files with platforms for all running queues.
    array set RR [allRunningServerTypes]
    #parray RR
    
    set myPlat Manhattan10G 
    #set myPlat x480
    set plats [getFromRegRunWhere "platform, reg_id, id_label" "(status = 'Queued' OR status = 'Running') AND type = 'Private' AND id_label LIKE '${match}%'"]
    set pInfoList(p) ""
    set pList ""
    set ptCount(x,y) ""
    set putLock(p,t) ""
    set patLock(p,t) ""
    set RUNREGINFO(pppppp) ""
    foreach {p v l} $plats {
        #puts "$p $v $l"
        set p2 0
        set p5 0
        set patLock($p,rtr) ""
        set patLock($p,std) ""
        if {![info exists putLock($p,rtr)]} {
            set putLock($p,rtr) ""
        }
        if {![info exists putLock($p,std)]} {
            set putLock($p,std) ""
        }
        lappend pInfoList($p) "$p"
        if {$p == ""} {
            continue;
        } else {
            set mods [getValueTestModWhere name "reg_id = '$v' AND (status = 'queued' OR status = 'running')"]
            foreach m $mods {
                #puts "Plat $p Mod $m regid $v $l"
                if {[lsearch $stdMods(functional,All) $m]>=0 || [lsearch $stdMods(functional,$p) $m]>=0 || [lsearch $istdMods(functional,All) $m]>=0} {
                    incr p2
                }
                if {[lsearch $rtrMods(functional,All) $m]>=0 || [lsearch $rtrMods(functional,$p) $m]>=0 || [lsearch $irtrMods(functional,All) $m]>=0} {
                    incr p5
                }
            }
            lappend pList "$p" 
            if {![info exists ptCount($p,std)]} {
                set ptCount($p,std) $p2
            } else {
                set ptCount($p,std) [expr $ptCount($p,std) + $p2]
            }
            if {![info exists ptCount($p,rtr)]} {
                set ptCount($p,rtr) $p5
            } else {
                set ptCount($p,rtr) [expr $ptCount($p,rtr) + $p5]
            }
        }
    }
    #
    #  Get userlock info
    #
    if {1} {
        set queues [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/*]
        ;# Look for any qId that is actively using queued platform
        foreach qIdPath $queues {
            set catchVal [catch {exec egrep -e "lockFile:" $qIdPath/info} userInfo]
            if {! $catchVal} {
                regexp {lockFile:\ *([A-Za-z0-9_\-]+\.cfg)\ *$} $userInfo ignore cCfg
                set tbp $RR(platCfg,null,$cCfg)
                set tbt $RR(platType,$cCfg,$tbp);
                lappend pList $tbp
                if {$tbt == "routing"} {
                    set putLock($tbp,rtr) "rtr(UL)"
                } else {
                    set putLock($tbp,std) "std(UL)"
                }
            } else {
    
            }
        }
        set queues [glob -nocomplain -- $DEVREG(server,imagesQueuedDir)/*]
        ;# Look for any qId that is actively using queued platform
        foreach qIdPath $queues {
            set catchVal [catch {exec egrep -e "lockFile:" $qIdPath/info} userInfo]
            if {! $catchVal} {
                regexp {lockFile:\ *([A-Za-z0-9_\-]+\.cfg)\ *$} $userInfo ignore cCfg
                set tbp $RR(platCfg,null,$cCfg)
                set tbt $RR(platType,$cCfg,$tbp);
                puts "$tbp $tbt - UserLocked"
                lappend pList $tbp
                if {$tbt == "routing"} {
                    set putLock($tbp,rtr) "rtr(UL)"
                } else {
                    set putLock($tbp,std) "std(UL)"
                }
                if {![info exists patLock($tbp,rtr)]} {
                    set patLock($tbp,rtr) ""
                }
                if {![info exists patLock($tbp,std)]} {
                    set patLock($tbp,std) ""
                }
            } else {
    
            }
        }
    }
    
    #
    #  Get the admin locked test beds
    #
    set lines ""
    if {[set fd_in [FileOpen $DEVREG(server,lockFile) r]]==-1} {
        return $fd_in
    }
    while {[gets $fd_in line]!=-1} {
        set line [string trim $line "!"]
        set tbp $RR(platCfg,null,$line)
        set tbt $RR(platType,$line,$tbp);
        set patLock($tbp,rtr) ""
        set patLock($tbp,std) ""
        if {![info exists putLock($tbp,rtr)]} {
            set putLock($tbp,rtr) ""
        }
        if {![info exists putLock($tbp,std)]} {
            set putLock($tbp,std) ""
        }
        lappend lines $line
    }
    funlock $fd_in
    close $fd_in
    foreach li $lines {
        set tbp $RR(platCfg,null,$li)
        set tbt $RR(platType,$li,$tbp);
        #puts "$tbp $tbt - ADMINLOCKED";
        lappend pList "$tbp"
        if {$tbt == "routing"} {
            set patLock($tbp,rtr) "rtr(AL)"
        } else {
            set patLock($tbp,std) "std(AL)"
        }
    }
    foreach myP $pList {
        if {[info exists ptCount($myP,std)]} {
            if {$ptCount($myP,std) == 0} {
                set stdtext ""
            } else {
                set stdtext "std($ptCount($myP,std))"
            }
        } else {
            set stdtext ""
        }
        if {[info exists ptCount($myP,rtr)]} {
            if {$ptCount($myP,rtr) == 0} {
                set rtrtext ""
            } else {
                set rtrtext "rtr($ptCount($myP,rtr))"
            }
        } else {
            set rtrtext ""
        }
        if {![info exists putLock($myP,rtr)]} {
            set putLock($myP,rtr) ""
        }
        if {![info exists putLock($myP,std)]} {
            set putLock($myP,std) ""
        }
        if {![info exists patLock($myP,rtr)]} {
            set patLock($myP,rtr) ""
        }
        if {![info exists patLock($myP,std)]} {
            set patLock($myP,std) ""
        }
        #puts "$myP ${stdtext}${rtrtext}$patLock($myP,std)$patLock($myP,rtr)$putLock($myP,std)$putLock($myP,rtr)"
        lappend RUNREGINFO($myP) "${stdtext}${rtrtext}$patLock($myP,std)$patLock($myP,rtr)$putLock($myP,std)$putLock($myP,rtr)"
    }
    return [array get RUNREGINFO]
}
##################################################################
# Procedure Name: GetPlatformsWithImageFiles
#
# Description: This proc returns a list of platforms that have
#              images associated with it in the info file
#
# Input args:
#           uInput: queueId info array
# Output args: none
# Typical usage:
#           GetPlatformsWithImageFiles [array get userInput]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc GetPlatformsWithImageFiles {uInput} {
    array set usrInput $uInput
    global DEVREG
    set strToReturn ""
    global RestOfDUTType RestOfIPRDUTType DEVREG

    #GH 09-08-2014 Added to support passing all platforms with images into QLoadimages
    foreach varName [array names usrInput] {
        if {[regexp -nocase "image:" $varName]} {
            if {[string tolower [file tail $uInput($varName)]] != "null"} {
                regsub "Image:" $varName  "" downloadPlat
                puts "Hit a platform with a valid image to download: $downloadPlat"
                lappend strToReturn "$downloadPlat"; # Add any platform that has a real image in the info file
            }
        }
    }

    return $strToReturn

}
proc _MyServerIp {} {
    # find out localhost's IP address
    # courtesy David Gravereaux, Heribert Dahms
    set TheServer [socket -server none -myaddr [info hostname] 0]
    set MyIP [lindex [fconfigure $TheServer -sockname] 0]
    close $TheServer
    return $MyIP
}
# ---------------------------------------------------------------------------------------
#  QueueAUserLock
#
#  A procedure to dynamically create a lock entry for a user
#
#  input args: Array with lock info
#
#  outputs
#
#
# ---------------------------------------------------------------------------------------
proc QueueAUserLock {lInput} {
    global DEVREG mysqlstatus  mysql_handler

    array set userInput $lInput

    set pid [pid]
    # ---  Open the file the will become the info file
    if {[set fd_out [FileOpen "/tmp/Tmp/$pid" w]]==-1} {
        puts "Could not create auto lock entry"
        return $fd_out
    }

    set submitRequest ""
    sleep 1
    set queueId [format %s_%s $DEVREG(server,location) [clock format [clock seconds] \
        -format %y%m%d_%H%M%S]]  ;# for now this is the queueId
    # ----------------------------------------------------------------------
    # Create the queue dir (RTP_######_######) inside imagesQueuedDir
    # ----------------------------------------------------------------------
    set queueDir "$DEVREG(server,imagesQueuedDir)/$queueId"
    if {[file isdirectory $queueDir]} {
        # --- If the queuedir exists make a new one ---
        set queueId [format %s_%s $DEVREG(server,location) \
        [clock format [clock seconds] -format %y%m%d_%H%M%S]]  ;# for now this is the queueId
        set queueDir "$DEVREG(server,imagesQueuedDir)/$queueId"
    }
    # --- Create the RTP_######_###### dir
    if {[catch {file mkdir $queueDir} reason]} {
        puts "Error: Can not create queueDir dir...$reason"
        exit -1
    }
    chmod 0777 $queueDir
    # ---------------------------------------------------------------------
    # Write entire userInput array to the tmp info file
    # ---------------------------------------------------------------------
    foreach varName [array names userInput] {
        puts $fd_out "[format "%-20s %-20s" "$varName" $userInput($varName)]"
    }
    close $fd_out
    # ---------------------------------------------------------------------
    # Move info file to the imagesQueued/RTP_######_######/ directory
    # ---------------------------------------------------------------------
    if {[catch {file rename /tmp/Tmp/$pid "$queueDir/info"} reason]} {
        puts "Error: Cannot copy file to $queueDir...$reason";
        exit -1
    }
    chmod 0777 $queueDir/info

    # set the priority of image in priority file
    SetPriorityFile $queueId
    if {[OrderPriorityFile]!=1} {
        puts "Could not reorder the priority file"
        return -1
    }
    # ---------------------------------------------------------------------------------
    # Post the reg_run entry to the database
    # ---------------------------------------------------------------------------------
    if {$DEVREG(mysql,UseDb)} {
        set bId ""
        set platformName ""
        set bType ""
        set bTag ""
        InsertQueueEntry -id_label "$queueId" -build_id "$bId" -reg_server "$DEVREG(server,FULLHOST)" \
            -user "$userInput(userid:)" -platform "$platformName" -type "$bType" -status "Queued" \
            -branch "$bTag"

        set rId [getRegIdFromQId $queueId]
        puts "The reg_id from the database is: $rId"
        # --- Now post each module to the test_module table ---
        set u 0
        foreach mod $userInput(moduleNames:) {
            set myLst [lindex $userInput(moduleLists:) $u]
            InsertQModuleEntry -reg_id $rId -name $mod -list $myLst -status "queued"
            incr u
        }
    }
    puts "Submitted the lock for $userInput(userid:) with queueId $queueId"
}
# ---------------------------------------------------------------------------------------
# SetTerminalTitle - use the runReg.cfg plus any cfg override to set xterm title
#
#
#
# ---------------------------------------------------------------------------------------
proc SetTerminalTitle {args} {
    global MAIN

    parse_args SetTerminalTitle $args {
        title "null"
        add   "null"
    }

    if {![info exists MAIN(XTERMTITLEON)] || !$MAIN(XTERMTITLEON)} {
        return
    }
    if {$title == "null"} {
        set ntext ""
        if {$MAIN(XTERMTITLE) != "null"} {
            append ntext "$MAIN(XTERMTITLE) "
        }
        if {[info exists MAIN(SWDEVXTERM)] && $MAIN(SWDEVXTERM) != "null"} {
            append ntext "$MAIN(SWDEVXTERM)"
        }
        if {[info exists MAIN(cfg)]} {
            append ntext "$MAIN(cfg) "
        }
        if {[info exists MAIN(feature_directory)] && $MAIN(feature_directory) != "null"} {
            append ntext "$MAIN(feature_directory) "
        }
        if {[info exists MAIN(CURRENTTESTCASE)] && $MAIN(CURRENTTESTCASE) != "null"} {
            append ntext "$MAIN(CURRENTTESTCASE)"
        }
        if {$add != "null"} {
            append ntext "$add"
        }
    } else {
        set ntext $title

    }
    set bob "\033]0;$ntext\007"
    puts $bob\n
}
# ---------------------------------------------------------------------------------------
# Procedure: _update_scm_db_from_report_txt
#
#
#
#
#
# ---------------------------------------------------------------------------------------
proc _update_scm_db_from_report_txt {args} {
    global DEVREG mysqlIP my_db MAIN DEVREG
    set host $mysqlIP
    set db $my_db

    parse_args _update_scm_db_from_report_txt $args {
        log_pid     "NULL"
        module      "NULL"
        reportDir   "NULL"
        qId         "NULL"
        run         "1"
        scmJob      "0"
    }

    set rp 0;# report pass count
    set rf 0;# fail count
    set sv 0;# subversion rev
    set rd 0;# duration
    set dv "0.0.0.0";# dut1 sw version
    set rs "Fail";# status
    set core "null";
    set cz 0;# core db setting
    if {![info exists DEVREG(mysql,centralserver)]} {
        puts "The SW Dev environment is not defined.  DEVREG vars need to be set"
        return;
    }
    set reportFile ${reportDir}/report.txt
    if {![file exists $reportFile]} {
        if {$log_pid != "NULL"} {
            puts $log_pid "DEVREG DB CANNOT BE UPDATED: $reportFile is not a valid file"
            puts "DEVREG DB CANNOT BE UPDATED: $reportFile is not a valid file"
        } else {
            puts "DEVREG DB CANNOT BE UPDATED: $reportFile is not a valid file"
        }
        return;
    }
    if {$qId == "NULL"} {
        if {$log_pid != "NULL"} {
            puts $log_pid "DEVREG DB CANNOT BE UPDATED: qId not passed in"
            puts "DEVREG DB CANNOT BE UPDATED: qId not passed in"
        } else {
            puts "DEVREG DB CANNOT BE UPDATED: qId not passed in"
        }
        return;        
    } else {
        if {$scmJob==0 || ![regexp -nocase "RTP|CIT" $qId]} {
            if {$log_pid != "NULL"} {
                puts $log_pid "DEVREG DB CANNOT BE UPDATED: scmJob set false or qId no legal. scmJob:$scmJob $qId"
                puts "DEVREG DB CANNOT BE UPDATED: scmJob set false or qId no legal. scmJob:$scmJob $qId"
            } else {
                puts "DEVREG DB CANNOT BE UPDATED: scmJob set false or qId no legal. scmJob:$scmJob $qId"
            }
            return;
        }
    }
    if {$module == "NULL"} {
        if {$log_pid != "NULL"} {
            puts $log_pid "DEVREG DB CANNOT BE UPDATED: module not passed in"
            puts "DEVREG DB CANNOT BE UPDATED: module not passed in"
        } else {
            puts "DEVREG DB CANNOT BE UPDATED: module not passed in"
        }
        return;
    }
    # -- tgz glob check report dir --
    set tgzList  [glob -nocomplain -- ${reportDir}/*.tgz]
    if {$log_pid != "NULL"} {
        puts $log_pid "TGZ FILES: $tgzList"
    }
    set scm_id [getFromRegRunWhere "reg_id" "id_label = '$qId'"]
    set core [_get_report_txt_core_uploaded \
               -reportFile $reportFile]
    set rp [_get_report_txt_subcounts -state pass \
               -reportFile $reportFile]
    set rf [_get_report_txt_subcounts -state fail \
               -reportFile $reportFile]
    set sv [_get_report_txt_subverion \
               -reportFile $reportFile]
    set dv [_get_report_txt_version \
               -reportFile $reportFile]
    set rd [_get_report_txt_duration \
               -reportFile $reportFile]
    set rt [expr $rp + $rf]
    if {$rf == 0 && $rt > 0} {set rs "Pass"}
    if {[llength $tgzList] > 0 && $core!="core" && $core!="ccov" && $core!="both"} {
        set cz 5
    } elseif {[llength $tgzList] > 0 && $core=="core"} {
        set cz 1
    } elseif {[llength $tgzList] > 0 && $core=="both"} {
        set cz 2
    } elseif {[llength $tgzList] > 0 && $core=="ccov"} {
        set cz 3
    } elseif {[llength $tgzList] == 0 && $core!="null"} {
        set cz 4
    }

    if {$run == 1} {
        updateRegTestModule -reg_id $scm_id  -name $module -pass_cnt $rp -total_cnt $rt \
            -duration $rd  -sqa_revision $sv -status $rs -corefiles $cz
        updateRegIdEntry -id_label $qId -version $dv
        puts $log_pid "Update BILTMORE: reg_id:$scm_id run1 PASS:$rp FAIL:$rf TOT:$rt Dur:$rd \n\
             Status:$rs SUBVERSION:$sv DUT SW:$dv cores $cz"
    } elseif {$run == 2} {
        updateRegTestModule -reg_id $scm_id  -name $module -pass_cnt_1 $rp -total_cnt_1 $rt \
            -duration_1 $rd  -sqa_revision $sv -status $rs -corefiles_1 $cz
        puts $log_pid "Update BILTMORE: reg_id:$scm_id run2 PASS:$rp FAIL:$rf TOT:$rt Dur:$rd \n\
             Status:$rs SUBVERSION:$sv DUT SW:$dv cores $cz"
    }
    # reconnect to database to reset mysql_handler
    puts $log_pid "re-connecting to database $db at $host"
    set connStatus [conn_to_db $host $db]
    puts $log_pid "reconnect database $db at $host - status $connStatus"
    puts "reconnect database $db at $host - status $connStatus"
}
