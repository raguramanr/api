#load {expect52.dll}
#set auto_path [linsert $auto_path 0 . ]

# ---------------------------------------------------------------------------
# proc _initDUTs_infoArray
#
#  !!!  All variables that will be used in DUTs_info should be added here !!!
#       The IKEYS list will be used for printing output and writing
#       to the initFile for dev and autodev modes
# ---------------------------------------------------------------------------
proc _initDUTs_infoArray {} {
    global DUTs_info IKEYS MAIN CFG_PLATFORM IKEYTEXT
    puts "\n\n\n-- Init DUTs_info Variables --\n\n"

    _getTestBedNumNodes;# Make sure MAIN(NODECOUNT) is set.
    _getTestBedStandbyNodes;# Set MAIN(STDBYCOUNT) and MAIN(STDBYLIST)
    # When adding keys, keep in mind that this is the order that the debug
    #   print displays.  Group variables logically so you don't have to look
    #   around too much
    if [info exists IKEYS] {unset IKEYS}
    if [info exists idef] {unset idef}
    lappend IKEYS "sysName";# System Name - changes with snmp so not good for ID'ing system
        set IKEYTEXT(sysName) "System Name"  
    lappend IKEYS "sysType";# good for ID'ing System, but Type + Stack for a stack - (Stack) is stripped
        set IKEYTEXT(sysType) "System Type"
    lappend IKEYS "platform";# The Sys Type OR Stack
        set IKEYTEXT(platform) "Platform"
    lappend IKEYS "sysMAC";# Mac
        set IKEYTEXT(sysMAC) "System MAC"
    lappend IKEYS "version";# Version from show switch on the booted partition
        set IKEYTEXT(version) "Image Version"
    lappend IKEYS "sVVersion";# Version from show version.  Most accurate
        set IKEYTEXT(sVVersion) "Version from Show Verison"
    lappend IKEYS "verTime";#
        set IKEYTEXT(verTime) "Running image built on"
    lappend IKEYS "relMaster";#
        set idef(relMaster) "release-manager";# Example of setting a default value
        set IKEYTEXT(relMaster) "Release Master"
    lappend IKEYS "partitionCli";# full port partitioning cli list for this DUT
        set idef(partitionCli) "";
        set IKEYTEXT(partitionCli) "DUT Port partioning info"
    lappend IKEYS "firstConnTimeOut";# On first login attempts use a shorter time than connectionTimeout
        set idef(firstConnTimeOut) "15";
        set IKEYTEXT(firstConnTimeOut) "Initial DUT connect expect timeout"
    lappend IKEYS "UncSwAdditionalTime";# If default.xsf reboots or takes a while.. more time may be needed.
        set idef(UncSwAdditionalTime) "0";
        set IKEYTEXT(UncSwAdditionalTime) "Additional delay after unconfigure switch"
    lappend IKEYS "coreFileTarget";# The location to store corefiles
        set idef(coreFileTarget) "internal-memory";
        set IKEYTEXT(coreFileTarget) "Core file target"
    lappend IKEYS "InbandNetConnected";# Track if inband network test was run and passed for this DUT
        set idef(InbandNetConnected) "0";
        set IKEYTEXT(InbandNetConnected) "Status of front panel network at Setup"
    lappend IKEYS "MgmtNetConnected";# Track if mgmt network test was run and passed for this DUT
        set idef(MgmtNetConnected) "0";
        set IKEYTEXT(MgmtNetConnected) "Status of mgmt port at System Setup"
    lappend IKEYS "serial";# Serial number
        set IKEYTEXT(serial) "System Serial Number"
    lappend IKEYS "productNum";
        set IKEYTEXT(productNum) "System Product Number"
    lappend IKEYS "currState";# Operation Master or Backup
        set IKEYTEXT(currState) "Switch State"
    lappend IKEYS "imageSel";# Select image for the console I am on
        set IKEYTEXT(imageSel) "Image Selected"
    lappend IKEYS "imageSelA";# Select image for the console I am on
        set IKEYTEXT(imageSelA) "Image Selected Primary"
    lappend IKEYS "imageSelB";# Selected image for the OR master capable.
        set IKEYTEXT(imageSelB) "Image Selected Backup"
    lappend IKEYS "imageBooted";# Booted image
        set IKEYTEXT(imageBooted) "Image Booted"
    lappend IKEYS "imageBootedA";# Booted image for console I am connected to
        set IKEYTEXT(imageBootedA) "Image Booted Primary"
    lappend IKEYS "imageBootedB";# Booted image for other Master capable
        set IKEYTEXT(imageBootedB) "Image Booted Primary"
    lappend IKEYS "priImage";# Primary bank version of console I am on
        set IKEYTEXT(priImage) "Primary Image"
    lappend IKEYS "priImageA";# Primary bank version of console I am on
        set IKEYTEXT(priImageA) "Primary Image on Primary"
    lappend IKEYS "priImageB";# Primary bank version of other console
        set IKEYTEXT(priImageB) "Primary Image on Backup"
    lappend IKEYS "secImage";#
        set IKEYTEXT(secImage) "Secondary Image"
    lappend IKEYS "secImageA";#
        set IKEYTEXT(secImageA) "Secondary Image on Primary"
    lappend IKEYS "secImageB";#
        set IKEYTEXT(secImageB) "Secondary Image on Backup"
    lappend IKEYS "bootROM";#
        set IKEYTEXT(bootROM) "BootROM"
    lappend IKEYS "numSlots";#
        set IKEYTEXT(numSlots) "Number of Slots"
    lappend IKEYS "numSlotsFM";#
        set IKEYTEXT(numSlotsFM) "Number of FM Slots"
    lappend IKEYS "hwList";# a list of systypes for chassis or stack switches
        set IKEYTEXT(hwList) "Slot Card List"
    lappend IKEYS "slotNums";# vpex may be "1 33 44 58"
        set IKEYTEXT(slotNums) "Slot Numbers List"
    lappend IKEYS "numExtSlots";#
        set IKEYTEXT(numExtSlots) "Number of VPEX Slots"
    lappend IKEYS "hwListFM";#
        set IKEYTEXT(hwListFM) "FM Slot Card List"
    lappend IKEYS "dlReqD";#
        set IKEYTEXT(dlReqD) "Download Flag Init"
    lappend IKEYS "debugFlag";#
        set IKEYTEXT(debugFlag) "Debug-Mode state"
    lappend IKEYS "snmpVersion";#
        set IKEYTEXT(snmpVersion) "SNMP version"
    lappend IKEYS "license";#  
        set IKEYTEXT(license) "License"
    lappend IKEYS "feature_licenses";#
        set IKEYTEXT(feature_licenses) "Feature Licenses"
    lappend IKEYS "memoryCard";# memory card present in msm
        set IKEYTEXT(memoryCard) "memoryCard status"

    for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
        if {![info exists CFG_PLATFORM($i)]} {
            set CFG_PLATFORM($i) "null"
        }
        global DUT${i}_MASK DUT${i}_SETUP DUT${i}_DefaultBlade
        if {![info exists DUT${i}_MASK]} {
            set DUT${i}_MASK 24
        }
        if {![info exists DUT${i}_SETUP]} {
            set DUT${i}_SETUP ""
            puts "DUT${i}_SETUP initialized to null.  Missing from configuration file"
        }
        if {![info exists DUT${i}_DefaultBlade]} {
            set DUT${i}_DefaultBlade 0
        }
        global DUT${i}_CONNECT DUT${i}_CONNECTB
        foreach infoKey $IKEYS {
            if {[info exists idef($infoKey)]} {
                set val $idef($infoKey)
            } else {
                set val "INVALID"
            }
            set DUTs_info(DUT$i,$infoKey) $val
        }
        #
        # DUT cfg file variables
        #
        if {[info exists DUT${i}_CONNECT]} {
            set DUTs_info(DUT$i,connect) [set DUT${i}_CONNECT]
            if {[lsearch $IKEYS "connect"] < 0} {
                lappend IKEYS "connect"
                set IKEYTEXT(connect) "DUT Terminal Server Connection"
            }
        }
        if {[info exists DUT${i}_CONNECTB]} {
            set DUTs_info(DUT$i,connectB) [set DUT${i}_CONNECTB]
            if {[lsearch $IKEYS "connectB"] < 0} {
                lappend IKEYS "connectB"
                set IKEYTEXT(connectB) "DUT Backup Terminal Server Connection"
            }
        }
    }
    puts "dut1 pre source $DUTs_info(DUT1,sysType)"
    set iFile [GetInitFileName $MAIN(autoRoot) $MAIN(cfg) Tmp2]
    if {[file exists $iFile] && [info exists MAIN(feature_directory)] && \
               $MAIN(feature_directory) == "QLoadImage"} {
        if {[catch {source $iFile} oops]} {
            puts "Sourcing the initFile failed: $oops"
        } else {
            puts "Sourced $iFile"
        }
    } else {
        puts "Couldn't find $iFile $MAIN(feature_directory)"
    }
    puts "dut1 post source $DUTs_info(DUT1,sysType)"
}
# ---------------------------------------------------------------------------
# proc _initDUTs_Slot_infoArray
#
#
#
# ---------------------------------------------------------------------------
proc _initDUTs_Slot_infoArray {} {

    global DUTs_Slot_info IKEYS ISLOTKEYS MAIN

    set slist "1 2 3 4 5 6 7 8 A B"

    if [info exists ISLOTKEYS] {unset ISLOTKEYS}
    if [info exists islotdef] {unset islotdef}
    lappend ISLOTKEYS "serial";#
    lappend ISLOTKEYS "productNum";#
    lappend ISLOTKEYS "hwModType"
    lappend ISLOTKEYS "sysType"
    lappend ISLOTKEYS "confType"
    lappend ISLOTKEYS "state"
    lappend ISLOTKEYS "numPorts"
    lappend ISLOTKEYS "npRev"
        set islotdef(npRev) "1.0";# Example of setting a default value
    lappend ISLOTKEYS "npProc1"
    lappend ISLOTKEYS "npProc2"
    lappend ISLOTKEYS "imageSel"
    lappend ISLOTKEYS "priImage"
    lappend ISLOTKEYS "secImage"
    lappend ISLOTKEYS "version"
    lappend ISLOTKEYS "verTime"
    lappend ISLOTKEYS "dlReqD"
    lappend ISLOTKEYS "category"


    for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
        foreach infoKey $ISLOTKEYS {
            if {[info exists islotdef($infoKey)]} {
                set val $islotdef($infoKey)
            } else {
                set val "INVALID"
            }
            foreach s $slist {
                set DUTs_Slot_info(DUT$i,slot$s,$infoKey) $val
            }
        }
    }

}
# -------------------------------------------------------------------------------
# proc ReunSetupScript
#
#
#
#
# -------------------------------------------------------------------------------
proc RunSetupScript {{connectList "0.0.0.0"} {setupScriptList ""} {args} } {

    parse_args RunSetupScript $args {
	at "main"  ;# location of script run "download" for download file section 
	dut 1     ;# dut supplied when called from download
    }

    global spawn_id
    global in
    global POWERCYCLE_DUT
    global forceSerialReboot
    global numDUT
    for {set i 1} {$i<=$numDUT} {incr i} {
       global DUT($i)_CONNECT
    }
    global switchPort2DefaultRouter
    global defaultRouter
    global regRouterIPAddr
    global MGMT_REG

    set MGMT_REG(forceConsole) 1; #This proc should always run over the console
    UpdateTrackDBTxt "executing: RunSetupScript";# tracking db location
    set in $at
    for {set i 1} {$i<= $numDUT} {incr i} {
       lappend dutList $i
    }

    if { [info exists forceSerialReboot] && $forceSerialReboot == 1} {
        result_debug "Force serial set in cfg file; Do Serial Setup Script"
        set runSetupRetVal [DoSerialRunSetup $dutList $connectList $setupScriptList $at $dut]
        return $runSetupRetVal
    }

    if { ([regexp -nocase "mgmt" $switchPort2DefaultRouter]) } {
	result_debug "network port is mgmt; run setup script parallely"
	set runSetupRetVal [DoParallelRunSetup $dutList $connectList $setupScriptList $at $dut]
	return $runSetupRetVal
    }

    if { ![info exists regRouterIPAddr] } {
	result_debug "regRouterIPAddr not defined; Do Serial Setup Script"
	set runSetupRetVal [DoSerialRunSetup $dutList $connectList $setupScriptList $at $dut]
        set MGMT_REG(forceConsole) 0;
	return $runSetupRetVal
    } else {

	# First try to login to each DUT to make sure that its even possible
	# If not possible, no need to proceed further
	# Only "need" this here because this is where we do the disable port on regrouter...
	# We dont want situation where regrouter ports are disabled and scripts abort on login,
	# leaving the ports in disabled state...
	if { [info exists regRouterIPAddr] } {
	    foreach dutnumber $dutList {
		set DUTName [format %s%d DUT $dutnumber]
		global ${DUTName}_CONNECT
		
		if { [Login [set ${DUTName}_CONNECT] -CheckOperational 0 -masterCheck 0] != 1 } {
		    result_error "Could not login to DUT$dutnumber [set ${DUTName}_CONNECT]"
                    set MGMT_REG(forceConsole) 0;
		    return "Error"
		}
	    }
	}

	result_debug "network port is on I/O blade; try to disable switchPort2DefaultRouter links"

	if { $regRouterIPAddr == $defaultRouter } {
	    result_error "FATAL ERROR: regRouterIPAddr cannot be same as defaultRouter IP ($defaultRouter). Check cfg file."
            set MGMT_REG(forceConsole) 0;
	    return "REGROUTER_FAILED"
	}

	set unconfigSwAllFound 0
	if { [string tolower $at] != "download" } {
	    # Not called from LoadImage
	    # (if it was, there is no need to disable mgmt links, because that does not do unconfig sw all anyway)
	    foreach setupScript $setupScriptList {
		foreach command $setupScript {
		    if  { [string match "unc* sw*" $command] == 1 } {
			# Do the disable/enable port and parallel SetupScript
			set unconfigSwAllFound 1
			break
		    }
		}
		if { $unconfigSwAllFound } {
		    # No need to check any further... disable/enable regRouter ports required.
		    break
		}
	    }
	}
	if { $unconfigSwAllFound } {
	    set portList [DisableRegRouterMgmtLinks]
	} else {
	    set portList "NotNeeded"
	}

	if { $portList == "Error" } {
	    result_debug "Could not disable ports on regRouter; run SetupScript serially"
	    set runSetupRetVal [DoSerialRunSetup $dutList $connectList $setupScriptList $at $dut]
	} elseif { $portList == "NotNeeded" } {
	    result_debug "Disabling regRouter ports not required; run SetupScript parallely"
	    set runSetupRetVal [DoParallelRunSetup $dutList $connectList $setupScriptList $at $dut]
	} else {
	    result_debug "regRouter ports disabled successfully; run SetupScript parallely"
	    set runSetupRetVal [DoParallelRunSetup $dutList $connectList $setupScriptList $at $dut]
	}

	if {0} {
	    if { $unconfigSwAllFound } {
		set retVal [EnableRegRouterMgmtLinks $portList]
	    } else {
		set retVal "NotNeeded"
	    }
	}
	if { $portList == "NotNeeded" } {
	    global regRouterMGMTPorts
	    set portList [join $regRouterMGMTPorts ","]
	}
	set retVal [EnableRegRouterMgmtLinks $portList]

	if { ($portList != "Error") && ($portList != "NotNeeded") && ($retVal == "Error") } {
	    # If disable port was successful and enable port was not successful
	    
	    result_error "FATAL ERROR: Could not re-enable the ports on the RegRouter."
            set MGMT_REG(forceConsole) 0;
	    return "REGROUTER_FAILED"
	}
    }
    set MGMT_REG(forceConsole) 0;
    return $runSetupRetVal
}

proc DisableRegRouterMgmtLinks { } {
    global regRouterIPAddr
    global regRouterMGMTPorts
    global regRouterLogin
    global regRouterPassword

    report_start_test "Disable links on Reg Router before unconfig all DUT's"

    if { [Login $regRouterIPAddr -userid $regRouterLogin -passwd $regRouterPassword -CheckOperational 0] != 1 } {
	result_error "Could not login to regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    }

    #In case of any extra whitespace between the portnumbers....
    set portList [split $regRouterMGMTPorts]
    foreach portnum $portList {
	if { $portnum == "" } {
	    continue
	}
	lappend pList $portnum
    }
    set portList [join $pList ","]

    if { [regexp -nocase "illegal" [CheckCmdLegal "disable port $portList"]] } {
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    } else {
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return $portList
    }
}

proc EnableRegRouterMgmtLinks { portList } {
    global regRouterIPAddr
    global regRouterLogin
    global regRouterPassword

    report_start_test "Re-enable links on Reg Router after unconfig all DUT's"

    if { [Login $regRouterIPAddr -userid $regRouterLogin -passwd $regRouterPassword -CheckOperational 0] != 1 } {
	result_error "Could not login to regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    }

    if { [regexp -nocase "illegal" [CheckCmdLegal "enable port $portList"]] } {
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return "Error"
    } else {
	# Verify ports are now in enabled state
	foreach portNum [split $portList ","] {
	    lappend parameterList "{^ *$portNum .*E } exist"
	}
	if { [CheckKeyValue "show port $portList info" $parameterList \
		-comment "Verifying all ports re-enabled on regRouter $regRouterIPAddr"] == "error" } {

	    # Disable port was successful and enable port was not successful
	    
	    logout
	    # --- use it for delay without using sleep
	    puts "Logged out of regrouter $regRouterIPAddr"
	    report_end_test
	    result_error "FATAL ERROR: Could not re-enable the ports on the RegRouter."
	    return "Error"
	}
	logout
	# --- use it for delay without using sleep
	puts "Logged out of regrouter $regRouterIPAddr"
	report_end_test
	return $portList
    }
}
#
# _multiRunSetupScript
#
proc _multiRunSetupScript {args} {
    global MAIN DUTs_info at wayToBootPart forceSerialReboot

    parse_args _multiRunSetupScript $args {
        dutListIn  "null"
    }

    if {![info exists MAIN(NODECOUNT)]} {_getTestBedNumNodes;}
    if {![info exists at]} {set at "main";}

    if {$dutListIn != "null"} {
        set DUTLIST $dutListIn
    } else {
        set DUTLIST $MAIN(DUTLIST)
    }

    if {[info exists forceSerialReboot] && $forceSerialReboot} {
        puts "\n\n -----   Setup in SERIAL MODE"
        foreach stdby $MAIN(STDBYLIST) {
            global STDBY${stdby}_CONNECT
            set me [expr 100 + $stdby]
            set DUTs_info(DUT$me,SHOWPROCESSES) 0
            Login [set STDBY${stdby}_CONNECT] -masterCheck 0 -CheckOperational 0
            puts "STANDBYs 1st!  Start _unconfigSwToPartition  -dut none -bootPart primary -standby $stdby"
            set res [_unconfigSwToPartition  -dut none -bootPart primary -standby $stdby]
        }
        foreach dut $DUTLIST {
            global DUT${dut}_SETUP DUT${dut}_CONNECT
            if {$wayToBootPart($dut) == "null"} {continue;}
            set DUTs_info(DUT$dut,SHOWPROCESSES) 0
            Login [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0
            if {$wayToBootPart($dut) == "setupScript"} {
                puts "Start RunSetupScript_Single \"[set DUT${dut}_CONNECT]\" \"[set DUT${dut}_SETUP]\" \
                          -at $at -dut $dut"
                set res [RunSetupScript_Single [set DUT${dut}_CONNECT] [set DUT${dut}_SETUP] -at $at -dut $dut]
            } elseif {$wayToBootPart($dut) == "unconfigSw"} {
                set res [_unconfigSwToPartition  -dut $dut -bootPart $MAIN(bootPart)]
            }
        }
    } else {
        puts "\n\n -----   Setup in FORKED MODE"
        set setupList ""
        foreach dut $DUTLIST {
            global DUT${dut}_SETUP DUT${dut}_CONNECT
            if {$wayToBootPart($dut) == "null"} {continue;}
            set DUTs_info(DUT$dut,SHOWPROCESSES) 0
            if {$wayToBootPart($dut) == "setupScript"} {
                lappend setupList "RunSetupScript_Single \"[set DUT${dut}_CONNECT]\" \"[set DUT${dut}_SETUP]\" -at $at -dut $dut"
            } elseif {$wayToBootPart($dut) == "unconfigSw"} {
                lappend setupList "_unconfigSwToPartition  -dut $dut -bootPart $MAIN(bootPart)"
            }
        }
        foreach stdby $MAIN(STDBYLIST) {
            set me [expr 100 + $stdby]
            set DUTs_info(DUT$me,SHOWPROCESSES) 0
            lappend setupList "_unconfigSwToPartition  -dut none -bootPart primary -standby $stdby"
        }

        if {[llength $setupList] == 0} {
            result_debug "All DUTs are on the correct bank for download to start."
        } else {
            result_debug "\nRunning Configuration File Setup Script with minimal print out\n$setupList\n\n"
            _setShowOutput -screen on -log on -res_fmt on
                MultiTask $setupList
            _setShowOutput -screen on -log on -res_fmt on
            result_debug "Setup scripts completed"
        }
    }
    # -- Turn show process back on in CheckOperational
    foreach dut $DUTLIST {
        if {$wayToBootPart($dut) == "null"} {continue;}
        set DUTs_info(DUT$dut,SHOWPROCESSES) 1
    }
    foreach stdby $MAIN(STDBYLIST) {
        set me [expr 100 + $stdby]
        set DUTs_info(DUT$me,SHOWPROCESSES) 1
    }
    return
}
#
# Unc switch to the target partition.
#
proc _unconfigSwToPartition {args} {
    global MAIN DUTs_info

    parse_args _unconfigSwToPartition $args {
        bootPart    "primary"
        dut         "1"
        standby     "null"
    }

    if {$standby != "null" && [regexp "\[0-9]" $standby]} {
        global STDBY${standby}_CONNECT
        if {![info exists STDBY${standby}_CONNECT]} {
            result_error "STDBY${standby}_CONNECT variable is called but is not in cfg"
            return;
        }
        Login [set STDBY${standby}_CONNECT] -masterCheck 0 -CheckOperational 0
    } else {
        global DUT${dut}_CONNECT
        Login [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0
    }
    SendACmd "use image $bootPart"

    if {[UnconfigSwAll -initial_unconfig yes -at "download"] == 0 } {
        result_error "Unconfig sw all failed"
        return 0
    } else {
        puts "!!\n!!\nDUT $dut completed unconfig to parition\n!!\n!!";
        return 1
    }
}

proc DoParallelRunSetup { dutList connectList setupScriptList at dut } {

    set pid [pid]


    package require Tclx

    foreach dutnumber $dutList {
	
	# Need to login once before the child processes are forked, 
	# because spawn_id from parent is used later in get_DUTs_info
	set DUTName [format %s%d DUT $dutnumber]
	global ${DUTName}_CONNECT
	if {![regexp -nocase "download" $at] } {
	   Login [set ${DUTName}_CONNECT] -CheckOperational 0
        }
	set sec [clock seconds]
	lappend childPids [fork]
	after 1000 ;# required to avoid children getting the same tmp file sometimes being too fast
	if {[lindex $childPids [expr $dutnumber-1]]} {
	    if {$dutnumber==[llength $dutList]} {
		set co 1
		foreach childPid $childPids {
		    result_debug "Parent now waiting for child # $co with pid $childPid"
                    set childRetCode  [wait $childPid]
		    if {![regexp -nocase "EXIT 0" $childRetCode]} {    ;# parent waits here for child to complete
                       result_debug "Now child returned with pid $childPid with $childRetCode status"
                       return -1
                    } else {
                       result_debug "Now child returned with pid $childPid"
                       incr co
                    }
		}
	    }
	} else {
	    result_debug "child # $dutnumber enters with pid [pid]"
	    set connect [lindex $connectList [expr $dutnumber-1]]
	    set setupScript [lindex $setupScriptList [expr $dutnumber-1]]
	    
	    if {[RunSetupScript_Single $connect $setupScript -at $at -dut $dutnumber]==-1} {
		return -1
	    }
	    exit   ;# Child exits here, returns back to the waiting parent
	    # end of fork construct
	}
    }
            exSleep 2 ;# needed to avoid race condition in consoles
}

proc DoSerialRunSetup  { dutList connectList setupScriptList at dut } {
    result_debug "Could not disable ports on regRouter; run unconfig sequentially"
    foreach dutnumber $dutList {
	set connect [lindex $connectList [expr $dutnumber-1]]
	set setupScript [lindex $setupScriptList [expr $dutnumber-1]]	
	if {[RunSetupScript_Single $connect $setupScript -at $at -dut $dutnumber]==-1} {
	    if { [regexp -nocase "download" $at] } {
		# called from LoadImage; return dutnum
		return "$dutnumber-1"
	    } else {
		return -1
	    }
	}
    }
}

proc RunSetupScript_Single {{connect "0.0.0.0"} {setupScript ""} {args} } {
    global spawn_id

    parse_args RunSetupScript $args {
        at "main"  ;# location of script run "download" for download file section 
        dut 1     ;# dut supplied when called from download
    }
    global in
    global POWERCYCLE_DUT
    global whichDutNow
    global SWDEVSERVER MAIN
    global DUT${dut}_TYPE DUT${dut}_CONNECT SKIPPCTOBOOTROM SKIPPCTOBOOTROMFLAG

    set in $at
    if {$in=="download" && [info exists SWDEVSERVER] && $SWDEVSERVER} {
        if {[info exists POWERCYCLE_DUT($dut)]} {
            set platform [GetPlatform DUT$dut]
            if {[regexp -nocase "$SKIPPCTOBOOTROM" $platform] || $SKIPPCTOBOOTROMFLAG} {
                # Some platforms are not able to power cycle to boot rom
                puts "Skip power cycle for this platform $platform"
            } else {
                # Power cycle to the bootrom and select the primary partition
                if {[pcToBootRom $dut]=="ok"} {
                    result_debug "Wait for 120 secs for rebooted DUT $dut to come up..."
                    exSleep 100
                    Login $connect -masterCheck 0 -CheckOperational 0
                    set output [CheckOperational]
                    if { $output == 0 } {
                        result_error "Some slots not operational"
                        error "Some slots not operational"
                    }
                } else {
                    set MAIN(loginQuick) 5
                    if {[Login [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0] == 0} {
                        result_debug "Quick login with power cycle on no interaction failed"
                    }
                    set MAIN(loginQuick) 0
                }
            }
        }
    }

    # Do not checkOperational as unc first
    if {[Login $connect -CheckOperational 0] != 1} {
        if {$in=="download"} { 
            result_debug "Login failed, but in Download.  It may not matter." 
            return -1   ;# Error during login
        } else {
            result_error "Login Failed.  CheckOperational Return a failure! "
            return -1   ;# Error during login
        }
    }

    if {($in == "download")} {
        # - Disable pacman
        global DUTs_info MAIN
        if {[info exists MAIN(bootPart)]} {
            SendACmd "use image $MAIN(bootPart)"
        }
        if {![info exists DUTs_info(DUT${whichDutNow},version)] || \
                                  $DUTs_info(DUT${whichDutNow},version) == "INVALID"} {
            set DUTs_info(DUT${whichDutNow},version) 24.1.1.1 ;# Set to any value so jerry cmd will work
        }
        set buf [SendACmd ""]
        if {[regexp -nocase "pacman" $buf]} {
            EnableDebugMode
            result_debug "Disable pacman"
            SendACmd "jerry disable pacman"
            exSleep 2
        }
        # Swidswap chassis I/O module if necessary, and only if RunSetupScript is called from Qloadimage
        #     # Currently only supported for BDX 100G/100G XL (EXOS 15.6 & later)
        if {"DUT$whichDutNow" == "DUT1"} {
            global swidSwapList
            if {[info exists swidSwapList]} {
                EnableDebugMode
                foreach swidSwap $swidSwapList {
                    set swidSlot [lindex $swidSwap 0]
                    set swid [lindex $swidSwap 1]
                    lappend parameterList "{Status:.*changing.*from.*to} $swid"
                    lappend parameterList "{SUCCESS:.*SwidSwap.*completed}"
                    if {![regexp -nocase "ok" [CheckKeyValue "jerry hal swidswap slot $swidSlot" $parameterList]]} {
                        if {![regexp -nocase "ok" [CheckKeyValue "jerry hal swidswap slot $swidSlot" $parameterList]]} {
                            result_error "Could not complete SwidSwap on slot $swidSlot for swid $swid"
                            return -1
                        }
                    }
                }
            }
        }

        # VPEX DUT may need default.xsf applied before image download to pass CheckOperational with BPE slots
        if {[regexp -nocase "vpex" [GetPlatform DUT$whichDutNow]]} {
            puts "\n!!\nIn vpex createdefault xsf pre download"
            CreateDefaultXsf -dut $whichDutNow
            Login $connect -CheckOperational 0
            puts "\n!!\n!!Completed vpex createdefault xsf pre download"
        }
    }

    foreach command $setupScript {
        if { ([string match "unc* sw*" $command] == 1) \
            && ([string tolower $at] != "download") } {
            if {[UnconfigSwAll -initial_unconfig yes] == 0 } {
                result_error "Unconfig sw all failed" 
                return -1
            }
        } elseif { ([string match "unc* sw*" $command] == 1) } {
            puts "Skipping Unconfig Switch for Download" 
        } else {
            set buf [SendACmd $command]
            set backupStr "Error: This command can only be executed on Master"
            if {[regexp -nocase $backupStr $buf]} {
                if {[string tolower $at] == "download"} {
                    result_debug "Backup encountered"
                } else {
                    result_error "Backup encountered, aborting"
                    return -1
                }
            }
            if { ([string match "reboo*" $command] == 1) } {
                result_debug "Adding Extra Time for Reboot"
                exSleep 150
            }
        }
    }
    if {[info exists whichDutNow]} {
        result_debug "\n\n\n@@@@ Completed running DUT $whichDutNow Setup @@@@\n\n"
    }
}


################################################################## 
# Procedure Name: SaveAndReboot
#   
# Description: Performs save/reboot to the current DUT
#
#              
#     
#
# Input args:      -waitLogin "true|false" after reboot wait for auth and login.
#                             default is "false"
# Output args: none
# Typical usage:
#              SaveAndReboot
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc SaveAndReboot {args} {
    global whichDutNow timeout

    parse_args SaveAndReboot $args {
        waitLogin   "false"
    }

    if {[info exists whichDutNow]} {
        set dut $whichDutNow
    } else {
        set dut 1
    }
    global DUT${dut}_CONNECT

    result_debug "****Save and reboot.****"
    send "save\r"
    expect {
        "database?" {
            send "y\r"
        }
        -nocase "(y*n*)" {
            send "y\r"
        }
        timeout {
            puts "Did not get an expected prompt from the Save CLI"
            send "\r"
        }
    }
    expect "#"
    send "reboot\n"
    expect -nocase "(y*n*)"
    send "y\r"
    expect {
        -re "Requesting system reboot|Copyright|DRAM|Default BootLoader|Using Default image|Self Test|Press|xtreme" {
            if {[regexp -nocase "true|y" $waitLogin]} {
                exp_continue
            } else {
                result_debug "\nDUT $dut has started reboot process. Continue test"
                return
            }
        }
        -re "login|password|Authentication Service" {
            result_debug "\nSave and Reboot reached Authentication.  Login to DUT $dut"
            Login [set DUT${dut}_CONNECT] -CheckOperational 0 -masterCheck 0
            return
        }
        timeout {
            puts "\nDUT did not hit authentication prompts in $timeout seconds"
        }
    }
}

################################################################## 
# Procedure Name: clearFdb
#   
# Description: Performs clear fdb on the current DUT, retained for historical reasons
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              clearFdb
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc clearFdb {fd} {
   global DUTs_info;
   global whichDutNow;

   result_debug "--- clear fdb";
   send "clear fdb\r";

   # For Aspen and Cougar platform delay 5 seconds to sync FDB cache on MSM with HW deleted FDBs on IO module.
   global bcmPlatform
   if {[regexp -nocase $bcmPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
      result_debug "Sleeping 5s awaiting clear fdb completion";
      exSleep 5;
   }

   expect "#";

   global pioneerPlatform
   if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
       result_print "Sleeping 15s awaiting PIONEER clear fdb completion....";
       exSleep 15
   } 
}


################################################################## 
# Procedure Name: get_DUTs_info
#   
# Description: creates a DUTs_info array after discovering all DUTs information in the testbed.
#              fills in all elements of DUTs_info array with relevant information.
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              get_DUTs_info
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc get_DUTs_info {{infoFilename "info"} {tmpdir "Tmp"}} {
global spawn_id
global numDUT
global MAIN
global DUT
global exos
global in
#variable to store all the DUTs interested information
global DUTs_info
global DUTs_Slot_info
global harness chassis stacking
global CFG_PLATFORM stackable i386Stackable

set pid [pid]

set fd_res [open_result_file "$infoFilename"]
set slotDump 0   
for {set i 1} {$i <= $numDUT} {incr i 1} { 
    global eware_dut
    if {([info exists eware_dut]) && ([lsearch $eware_dut $i] > -1 )} {
        global DUT[set i]_CONNECT
        Login [set DUT[set i]_CONNECT]
        get_DUTs_info_eware
    } else {
        global DUT[set i]_CONNECT
        if {![info exists CFG_PLATFORM($i)]} {
            set CFG_PLATFORM($i) "null"
        }

        if {[info exists in] && ([string tolower $in] == "download")} {
            result_debug "Skipping CheckOperational in download"
            Login "[set DUT[set i]_CONNECT]" -CheckOperational 0
        } else {
            result_debug "CheckOperational not in download"
            Login [set DUT[set i]_CONNECT]
            result_debug "Autotest is entering here"
        }

        set platform [GetPlatform DUT[set i]]
        CheckOperational    
        Login [set DUT[set i]_CONNECT]
        if {[regexp -nocase "stack" $platform] } {
            set showSwitchOutput ""
            lappend showSwitchOutput "{Current.*State} {MASTER.*BACKUP.*In.*Sync} inLine exists"
            CheckKeyValue "show switch" $showSwitchOutput -testNo $infoFilename -time {s: 1 i: 20 d: 120 f: 240 r} \

        }

        ################################################################
       ##  Get Slot info dump if Platform Type is BD or BT or Godzilla etc
       ################################################################
       set fd_in [open "$tmpdir/tmp_info_DUT$i$pid" "w"]

       SendACmd "disable clipaging"
       SendACmd "disable auto-provision"
       SendACmd "show version detail"
       SendACmd "show version images"
       SendACmd "show fans detail"
       SendACmd "show switch" $fd_res $fd_in
       SendACmd "show version" $fd_res $fd_in
       close $fd_in

       ################################################################
       ##  Initiallize variables to be gathered.
       ################################################################
       set imageSel "NONE"
       set imageBooted "NONE"
       set priImage "INVALID"
       set secImage "INVALID"
       set version "INVALID"
       set platform "INVALID"
       set sysMAC "INVALID"
       set bootROM "INVALID"
       set relMaster "INVALID"
       set hwList 0
       set hwListFM 0
       set numSlots  "0" 
       set numSlotsFM "0"  
       set verTime   "INVALID"
       set memoryCard "INVALID"
       set coreTarget "internal-memory"
       set dlReqD    "0"
       set showVerVersion ""
       set snmpVersion "2"
       set sysN "INVALID"
       set sysT "INVALID"
       set license "INVALID"
       set slotNums ""
       set numExtSlots 0
       set slotSers ""

       set DUTs_info(DUT$i,imageSel) $imageSel
       set DUTs_info(DUT$i,imageBooted) $imageBooted
       set DUTs_info(DUT$i,priImage) $priImage
       set DUTs_info(DUT$i,secImage) $secImage
       set DUTs_info(DUT$i,version) $version
       set DUTs_info(DUT$i,verTime)   $verTime   
       set DUTs_info(DUT$i,platform) $platform
       set DUTs_info(DUT$i,sysMAC) $sysMAC
       set DUTs_info(DUT$i,bootROM) $bootROM
       set DUTs_info(DUT$i,numSlots)  $numSlots
       set DUTs_info(DUT$i,numSlotsFM)  $numSlotsFM      
       set DUTs_info(DUT$i,relMaster) $relMaster
       set DUTs_info(DUT$i,hwList) $hwList
       set DUTs_info(DUT$i,hwListFM) $hwListFM
       set DUTs_info(DUT$i,dlReqD)   $dlReqD
       set DUTs_info(DUT$i,sysName) $sysN
       set DUTs_info(DUT$i,sysType) $sysT
       set DUTs_info(DUT$i,debugFlag) 1
       set DUTs_info(DUT$i,sVVersion) $showVerVersion
       set DUTs_info(DUT$i,snmpVersion) $snmpVersion
       set DUTs_info(DUT$i,license) $license
       set DUTs_info(DUT$i,memoryCard) NULL
       set DUTs_info(DUT$i,slotNums)  $slotNums
       set DUTs_info(DUT$i,numExtSlots) $numExtSlots
       set DUTs_info(DUT$i,slotSerials) $slotSers 

       set bList "NULL"
       set location "NULL"
       # Check the cfg file for DEFAULTXSF partition settings
       _SetPartitionVars -dut $i

       set fd_in [open "$tmpdir/tmp_info_DUT$i$pid" "r"]
       set devSerialNum "null"
       while {[gets $fd_in line] != -1} {
          regexp -nocase -all "(Switch|Chassis).*(\[a-zA-Z0-9]{5,5}\-\[a-zA-Z0-9]{5,5})" $line dummy d2 devSerialNum;
          #grant
          if {[regexp -nocase "vpex" $platform]} {
              if {[regexp -nocase -all "Slot-(\[0-9]+).*(\[a-zA-Z0-9]{5,5}\-\[a-zA-Z0-9]{5,5})" \
                      $line dummy d2 devSerialNum]} {
                  lappend slotSers $devSerialNum
                  if {$d2==1 && [regexp -nocase "vpex" $platform]} {
                      set mainSerial $devSerialNum
                  }
              }
          }
          set cookedLine [cookString $line]


          #result_debug "----- cookedLine=$cookedLine"
          set aList [split $cookedLine]

          if {$bList != "NULL"} {

          # Determine location in file search "show switch, slot or version"
          if { ([lindex $bList 0] == "sysName:") || ([lindex $bList 0] == "SysName:") } {
              set location "switch"
          }

          if { ([lindex $bList 0] == "Chassis:")  || \
               ([lindex $bList 0] == "Chassis")   || \
               ([lindex $bList 0] == "Slot-1")   || \
               ([lindex $bList 0] == "Switch")   || \
               ([lindex $bList 0] == "CPU")   || \
               ([lindex $bList 0] == "Daughtercard:") || \
               ([lindex $bList 0] == "Baseboard:")  } {
             set location "version"
          }

    ###########   Find image version selected to boot###########################

          if { ([lindex $bList 0] == "Image") &&     \
               ([lindex $bList 1] == "Selected:") &&      \
               ( $location == "switch"        )  && [lindex $aList 2]!=""} {
             set imageSel [lindex $aList 2]
             set imageSel [string tolower $imageSel]
          }
          #for 6.2.1
          if { ([lindex $aList 0] == "Image") &&     \
               ([lindex $aList 1] == "Booted:") && [lindex $aList 2]!="" } {
             set imageBooted [lindex $aList 2]
             set imageBooted [string tolower $imageBooted]
          }


    ############ Find the names of the images load in the 2 MSM spaces.. ###


          #find primary image
          if { ( $location == "switch" ) &&     \
               ([string tolower [lindex $bList 0]] == "primary") &&     \
               ([string tolower [lindex $bList 1]] == "ver:") } {
             set priImage [lindex $bList 2]
          }
          #find second image
          if { ( $location == "switch" ) &&     \
               ([string tolower [lindex $bList 0]] == "secondary") &&   \
               ([string tolower [lindex $bList 1]] == "ver:") } {
             set secImage [lindex $bList 2]
          }
          #find System Name
          if { ([string tolower [lindex $bList 0]] == "sysname:") } {
             #set platform [computeSysName [lindex $bList 1]]
             set sysN [lindex $bList 1]
          }
          #find System Type
          if { ( $location == "switch" ) &&     \
               ([string tolower [lindex $bList 0]] == "system") &&   \
               ([string tolower [lindex $bList 1]] == "type:") } {
                   set sysT [lindex $bList 2]
                   if {$sysT == "VPEX"} {
                       set sysT "[lindex $bList 2] [lindex $bList 3]"
                   }
                   if {[regexp -nocase stack $bList match]} {
                       set platform $match
                   }  else {
                       set platform $sysT
                   }
                   if {[info exists CFG_PLATFORM($i)] && $CFG_PLATFORM($i) != "null"} {
                       set platform $CFG_PLATFORM($i)
                   }
             }

                          
          
          #find system MAC
          if { ([lindex $bList 0] == "System") &&     \
               ([lindex $bList 1] == "MAC:") } {
             set sysMAC [lindex $bList 2]

          }
          #find release master, time of the build, and the release master
          # EY-06-15-2006: Added elseif clause to handle new "ExtremeXOS"
          # software name.
          if { ( $location == "version" )     && \
               ([lindex $bList 0] == "Image") && \
               ([lindex $bList 3] == "XOS")   && \
               ([lindex $bList 4] == "version")} {

             set version [lindex $bList 5];
             set showVerVersion [lindex $bList 6];
             # Compute the version for patch builds in EXOS
             if {[regexp -nocase "\\-" $showVerVersion]} {
                set patchList [split $showVerVersion "-"];
                foreach str [lrange $patchList 1 end] {
                   set version [format %s-%s $version $str];
                }
             }
             set relMaster [lindex $bList 8];
          } elseif { ( $location == "version" )          && \
                     ([lindex $bList 0] == "Image")      && \
                    (([lindex $bList 2] == "ExtremeXOS") || \
                     ([lindex $bList 2] == "NETGEAR")   || \
                    ([lindex $bList 2] == "AviatOS"))   && \
                     ([lindex $bList 3] == "version")} {

              set version [lindex $bList 4];
              set showVerVersion [lindex $bList 5];
              # Compute the version for patch builds in EXOS
              if {[regexp -nocase "\\-" $showVerVersion]} {
                 set patchList [split $showVerVersion "-"];
                 foreach str [lrange $patchList 0 end] {
                    set version [format %s-%s $version $str];
                 }
              }
              # Add support for change in Image : formatting 16.1.0.27 and higher
              set versionDigits [split $version "."]
              if {[lindex $versionDigits 0] >= 16} {
                  set relMaster [lindex $bList 6];
              } else {
                  set relMaster [lindex $bList 7];
              }
          } elseif { ( $location == "version" )          && \
                     ([lindex $bList 0] == "Image")      && \
                     (([lindex $bList 2] == "NETGEAR") || \
                     ([lindex $bList 2] == "AviatOS")) &&  \
                     ([lindex $bList 3] == "version")} {

              set version [lindex $bList 4];
              set showVerVersion [lindex $bList 5];
              # Compute the version for patch builds in EXOS
              if {[regexp -nocase "\\-" $showVerVersion]} {
                 set patchList [split $showVerVersion "-"];
                 foreach str [lrange $patchList 0 end] {
                    set version [format %s-%s $version $str];
                 }
              }
              set relMaster [lindex $bList 7];
          } elseif { ( $location == "version" )          && \
                     ([lindex $bList 0] == "Image")      && \
                     ([lindex $bList 2] == "SwitchOS") && \
                     ([lindex $bList 3] == "version")} {

              set version [lindex $bList 4];
              set showVerVersion [lindex $bList 5];
              # Compute the version for patch builds in EXOS
              if {[regexp -nocase "\\-" $showVerVersion]} {
                 set patchList [split $showVerVersion "-"];
                 foreach str [lrange $patchList 0 end] {
                    set version [format %s-%s $version $str];
                 }
              }
              set relMaster [lindex $bList 7];
          }

          if { ( $location == "version" ) &&     \
               ([lindex $bList 0] == "on")} {
             set verTime [lrange $bList 1 6]
          }



          #find BootROM
          if { ([lindex $bList 0] == "BootROM") } {
             set bootROM [lindex $bList 2]

          }      

       }
          set bList $aList;# This sets bList equal to the PREVIOUS line aList
       }  ;# end of file while

       set parameterList ""
       if {[regexp -nocase "by" $relMaster] || [regexp -nocase "by" $showVerVersion]} {
           lappend parameterList "{by} 1"
           lappend parameterList "{by} -1"
           lappend parameterList "{by} -2"
           set getVerInfo [GetKeyValue "show version" $parameterList]
           set getVerInfo [split [lindex $getVerInfo 0] " "] 
           set relMaster [lindex $getVerInfo 0]
           set showVerVersion [lindex $getVerInfo 1]
           if {[lindex $getVerInfo 2] == "version"} {
               set version [lindex $getVerInfo 1]
           } else {
               set version [lindex $getVerInfo 2]
           }
       }
       if {$version == "INVALID"} {
           lappend parameterList "{ExtremeXOS version} 1"
           lappend parameterList "{by} 1"
           lappend parameterList "{by} -1"
           set getVerInfo [GetKeyValue "show version" $parameterList]
           set getVerInfo [list $getVerInfo]
           set version [lindex $getVerInfo 0]
           set relMaster [lindex $getVerInfo 1]
           set showVerVersion [lindex $getVerInfo 2]
       }
       unset parameterList
       #get slot info to figure out hardware type
       set hardwareType "NEW_GEN"
       set bladeType "NONE"
       global chassis everestChassis
       global i386Chassis
        if {[regexp -nocase "$chassis|$i386Chassis|vpex" $platform]} {
            lappend parameterList "{^Slot-\[0-9\]+} 1"
            set HardwareList [GetKeyValue "show slot" $parameterList]
            unset parameterList
            set hwList ""
            set k 0;
            # Stacks have Slot-# prompt. This may match the paralist above
            foreach sVal $HardwareList {
                if {[regexp -nocase "stack" $sVal]} {
                    continue;
                }
                lappend hwList $sVal
                incr k 1;
            }
            result_debug "HardwareList: $HardwareList"
            result_debug "hwList: $hwList"
            foreach hardware $HardwareList {
                if {[lsearch -regexp $bladeType $hardware]==-1} {
                    if {$bladeType=="NONE"} {set bladeType ""}
                    if {![regexp -nocase "none|Empty|stack" $hardware]} {
                        set bladeType "$bladeType$hardware"
                    }
                }
            }
            # Use foreach loop count to set numSlots
            set numSlots $k;
            result_debug "The number of I/O slots is $k"
            #VPEX slot numbers
            if {[regexp -nocase "vpex" $platform]} {
                lappend parameterList "{^Slot-\[0-9\]+} 0"
                set slotNumList [GetKeyValue "show slot" $parameterList]
                unset parameterList
                set newSlotCount 0
                foreach aSlot $slotNumList {
                    if {[regexp -nocase {slot-([0-9]+)|msm-([ab])|mm-([ab])} $aSlot allmatch myNum]} {
                        incr newSlotCount
                        lappend slotNums $myNum
                        if {$myNum > 32} {
                            incr numExtSlots
                        }
                    }
                }
                set devSerialNum $mainSerial
                set numSlots $newSlotCount
                puts "hwSlotNumbers $slotNums"
            }

            #get FM slot info for Everest chassis
            if {[regexp -nocase "$everestChassis" $platform]} {
                lappend parameterList "{^FM-\[0-5\]+} 1"
                set HardwareListFM [GetKeyValue "show slot" $parameterList]
                unset parameterList
                result_debug "HardwareListFM: $HardwareListFM"
                set hwListFM $HardwareListFM;

                set m 0;
                foreach hardwareFM $HardwareListFM {
                    if {[lsearch -regexp $bladeType $hardwareFM]==-1} {
                        if {$bladeType=="NONE"} {set bladeType ""}
                        if {![regexp -nocase "none|Empty" $hardwareFM]} {
                        set bladeType "$bladeType$hardwareFM"
                        }
                    }
                    incr m 1;
                }
                # Use foreach loop count to set numSlotsFM
                set numSlotsFM $m;
                result_debug "The number of FM slots is $m"

            }

        } else {
            if { [regexp -nocase "$stackable|$i386Stackable" $platform]} {
                set hardwareType "NEW_GEN"
            }
        }

       
       ################################################################
       ##  Determine whether memorycard present, fill in memoryCard in DUTs_info
       ################################################################
       set memBuf [SendACmd "show memorycard"]
       if {![regexp -nocase "Memorycard is not present|No such file or directory" $memBuf]} {
           set memoryCard "present"
       }
       ################################################################
       ##  Set the location that core files will be written to
       ##  Chassis with memorycards - target = memory card
       ##  For now stackables with USB/memorycard will still use int-memory
       ################################################################
       if {$memoryCard == "present" && [regexp -nocase "$chassis" $platform] && \
          ![regexp -nocase "$stacking" $platform]} {
           set coreTarget "memorycard"
       }
       if {$memoryCard == "present" && [info exists MAIN(CORESTOSTACKABLEMEMORYCARD)] && $MAIN(CORESTOSTACKABLEMEMORYCARD)} {
           set coreTarget "memorycard"
       }

       set parameterList ""
       lappend parameterList "{Enabled License Level:} 0 1"
       lappend parameterList "{Enabled License Level:} 1 1"
       set getLicense [GetKeyValue "show license" $parameterList];
       # EY-05-15-2008: Cleared out parameterList before end of loop.
       # This fixes a problem when retrieving slot info on a test bed with
       # more than one chassis or stack DUT.
       unset parameterList;
       if {[lindex [lindex $getLicense 0] 1] != ""} {
          set temp [split [lindex $getLicense 0] " "]
          set currentLicense [concat [lindex $temp 0][lindex $temp 1]]
       } else {
          set temp [split [lindex $getLicense 0] " "]
          set currentLicense [lindex $temp 0]
       }
       set license $currentLicense



       ################################################################

       global _VERSION
       global VERSION
       set _VERSION $version
       set VERSION [string range $_VERSION 0 0]
       set DUTs_info(DUT$i,VERSION) $VERSION
       ################################################################

       puts "####### version $version  ###########################"
       set DUTs_info(DUT$i,imageSel) $imageSel
       set DUTs_info(DUT$i,imageBooted) $imageBooted
       set DUTs_info(DUT$i,priImage) $priImage
       set DUTs_info(DUT$i,secImage) $secImage
       set DUTs_info(DUT$i,version) $version
       set DUTs_info(DUT$i,verTime) $verTime   
       set DUTs_info(DUT$i,platform) $platform
       set DUTs_info(DUT$i,sysName) $sysN
       set DUTs_info(DUT$i,sysType) $sysT
       set DUTs_info(DUT$i,serial) $devSerialNum
       set DUTs_info(DUT$i,sysMAC) [string toupper $sysMAC]
       set DUTs_info(DUT$i,relMaster) $relMaster
       set DUTs_info(DUT$i,bootROM) $bootROM
       set DUTs_info(DUT$i,numSlots) $numSlots
       set DUTs_info(DUT$i,numSlotsFM) $numSlotsFM
       set DUTs_info(DUT$i,hwList) $hwList
       set DUTs_info(DUT$i,hwListFM) $hwListFM
       set DUTs_info(DUT$i,slotNums) $slotNums
       set DUTs_info(DUT$i,numExtSlots) $numExtSlots
       set DUTs_info(DUT$i,HardwareType) $hardwareType
       set DUTs_info(DUT$i,bladeType) $bladeType
       set DUTs_info(DUT$i,dlReqD)   $dlReqD
       set DUTs_info(DUT$i,sVVersion) $showVerVersion
       set DUTs_info(DUT$i,memoryCard) $memoryCard
       set DUTs_info(DUT$i,coreFileTarget) $coreTarget
       set DUTs_info(DUT$i,snmpVersion) $snmpVersion
       set DUTs_info(DUT$i,license) [string tolower $license]
       set DUTs_info(DUT$i,connect) [set DUT[set i]_CONNECT]
       if {[info exists DUT${i}_CONNECTB]} {
           set DUTs_info(DUT$i,connectB) [set DUT[set i]_CONNECTB]
       }

       result_debug "****** START DEVICE INFORMATION DUT$i ********"
       result_debug "DUT$i Image Selected = $DUTs_info(DUT$i,imageSel)"
       result_debug "DUT$i Image Booted = $DUTs_info(DUT$i,imageBooted)"
       result_debug "DUT$i Image Version = $DUTs_info(DUT$i,version)"
       result_debug "DUT$i Connect type= $DUTs_info(DUT$i,connectType)"
       result_debug "DUT$i Running Image Built on $DUTs_info(DUT$i,verTime)"   
       result_debug "DUT$i Primary Image = $DUTs_info(DUT$i,priImage)"
       result_debug "DUT$i Secondary Image = $DUTs_info(DUT$i,secImage)"
       result_debug "DUT$i Platform = $DUTs_info(DUT$i,platform)"
       result_debug "DUT$i System MAC = $DUTs_info(DUT$i,sysMAC)"
       result_debug "DUT$i System Type = $DUTs_info(DUT$i,sysType)"
       result_debug "DUT$i System Serial Number = $DUTs_info(DUT$i,serial)"
       result_debug "DUT$i BootROM = $DUTs_info(DUT$i,bootROM)"
       result_debug "DUT$i Release Master = $DUTs_info(DUT$i,relMaster)"
       result_debug "DUT$i Slot Card List = $DUTs_info(DUT$i,hwList)"
       result_debug "DUT$i FM Slot Card List = $DUTs_info(DUT$i,hwListFM)"
       result_debug "DUT$i Slot Numbers List = $DUTs_info(DUT$i,slotNums)"
       result_debug "DUT$i Number of VPEX Slots = $DUTs_info(DUT$i,numExtSlots)"
       result_debug "DUT$i Number of Slots = $DUTs_info(DUT$i,numSlots)"
       result_debug "DUT$i Number of FM Slots = $DUTs_info(DUT$i,numSlotsFM)"      
       result_debug "DUT$i Hardware Type = $DUTs_info(DUT$i,HardwareType)"
       result_debug "DUT$i Blade Type = $DUTs_info(DUT$i,bladeType)"
       result_debug "DUT$i Download Flag Init    = $DUTs_info(DUT$i,dlReqD)"
       result_debug "DUT$i Version from Show Version = $DUTs_info(DUT$i,sVVersion)"
       result_debug "DUT$i memoryCard status = $DUTs_info(DUT$i,memoryCard)"
       result_debug "DUT$i core file target = $DUTs_info(DUT$i,coreFileTarget)"
       result_debug "DUT$i SNMP version = $DUTs_info(DUT$i,snmpVersion)"
       result_debug "DUT$i License = $DUTs_info(DUT$i,license)"
       result_debug "DUT$i Console = $DUTs_info(DUT$i,connect)"
       if {[info exists DUT${i}_CONNECTB]} {
           result_debug "DUT$i Backup Console = $DUTs_info(DUT$i,connectB)"
       }   
       result_debug "****** END DEVICE INFORMATION DUT$i ********"

       close $fd_in
       catch {file delete "$tmpdir/tmp_info_DUT$i$pid"}

       if {[info exist MAIN(ifPipe)] && $MAIN(ifPipe) != "NULL"} {
           # Later after DUTs_info array is fixed by removing 1Dim entries
           #foreach dKeyName [lsort [array_dimnames DUTs_info 1]] {
           #    if {[info exists DUTs_info(DUT$i,$dKeyName)]} {
           #        puts "---- set DUTs_info(DUT$i,$dKeyName) \"$DUTs_info(DUT$i,$dKeyName)\""
           #    }
           #}
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,imageSel) \"$DUTs_info(DUT$i,imageSel)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,imageBooted) \"$DUTs_info(DUT$i,imageBooted)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,version) \"$DUTs_info(DUT$i,version)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,connectType) \"$DUTs_info(DUT$i,connectType)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,VERSION) \"$DUTs_info(DUT$i,VERSION)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,priImage) \"$DUTs_info(DUT$i,priImage)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,secImage) \"$DUTs_info(DUT$i,secImage)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,platform) \"$DUTs_info(DUT$i,platform)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sysMAC) \"$DUTs_info(DUT$i,sysMAC)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,bootROM) \"$DUTs_info(DUT$i,bootROM)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,relMaster) \"$DUTs_info(DUT$i,relMaster)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,verTime) \"$DUTs_info(DUT$i,verTime)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,serial) \"$DUTs_info(DUT$i,serial)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,hwList) \"$DUTs_info(DUT$i,hwList)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,hwListFM) \"$DUTs_info(DUT$i,hwListFM)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,slotNums) \"$DUTs_info(DUT$i,slotNums)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,numExtSlots) \"$DUTs_info(DUT$i,numExtSlots)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,numSlots) \"$DUTs_info(DUT$i,numSlots)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,numSlotsFM) \"$DUTs_info(DUT$i,numSlotsFM)\""              
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,HardwareType) \"$DUTs_info(DUT$i,HardwareType)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,bladeType) \"$DUTs_info(DUT$i,bladeType)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,dlReqD) \"$DUTs_info(DUT$i,dlReqD)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sysName) \"$DUTs_info(DUT$i,sysName)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sysType) \"$DUTs_info(DUT$i,sysType)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sVVersion) \"$DUTs_info(DUT$i,sVVersion)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,snmpVersion) \"$DUTs_info(DUT$i,snmpVersion)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,license) \"$DUTs_info(DUT$i,license)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,memoryCard) \"$DUTs_info(DUT$i,memoryCard)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,coreFileTarget) \"$DUTs_info(DUT$i,coreFileTarget)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,UncSwAdditionalTime) \"$DUTs_info(DUT$i,UncSwAdditionalTime)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,partitionCli) \"$DUTs_info(DUT$i,partitionCli)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,debugFlag) \"$DUTs_info(DUT$i,debugFlag)\""
           puts $MAIN(ifPipe) "set DUTs_info(DUT$i,connect) \"$DUTs_info(DUT$i,connect)\""
           if {[info exists DUT${i}_CONNECTB]} {
               puts $MAIN(ifPipe) "set DUTs_info(DUT$i,connectB) \"$DUTs_info(DUT$i,connectB)\""
           }
           puts "Just wrote DUTs_info to $MAIN(initFile)"
       } elseif {[info exists MAIN(runMode)] && $MAIN(runMode) == 0} {
            result_error "There is an issue with the initFile to be written to.\
                   \npipe= $MAIN(ifPipe) file= $MAIN(initFile)"
            
       }
    }
}
if {[info exists MAIN(ifPipe)] && $MAIN(ifPipe) != "NULL"} {
    flush $MAIN(ifPipe)
}
close_result_file  
# Now get the info from the individual slots if platform matches
     if {$slotDump} {
         get_DUTs_Slot_info $tmpdir
     }
     global ixiaCh1
     if {($ixiaCh1 != "NO_IXIA")} {
         if {![info exists DUT(LoadImage)]} { ;# Need to turn of when run LoadImage
             #
             # EY-04-04-2013: Check return value of getTECardSpeed.
             if {[set rc [getTECardSpeed]] != 0} {
                 puts "Error $rc while calling getTECardSpeed.";
                 return -1;
             }
         }
     }
    return 0;
}

################################################################## 
# Procedure Name: DutSlotType
#   
# Description: Return the slot name of a specified DUT and Slot
#     
#
# Input args: DUT number, Slot Number
# Output args: none
# Return value: Return the slot name of a specified DUT and Slot
# Typical usage:
#              DutSlotType 1 1
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc DutSlotType {{dut ""} {slot ""}} {
   global DUTs_info
   if {$DUTs_info(DUT$dut,bladeType) != "NONE"} {
       set cardType [lindex $DUTs_info(DUT${dut},hwList) [expr $slot -1]]
   } else {
       set cardType "NONE"
   }

   return $cardType
}

################################################################## 
# Procedure Name: DutSlotNumPorts
#   
# Description: Return the number of ports on a slot
#     
#
# Input args: DUT number, Slot Number
# Output args: none
# Return value: Return the number of slots on a port
# Typical usage:
#              DutSlotNumPorts 1 1
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc DutSlotNumPorts {{dut ""} {slot ""}} {
   global DUTs_info

   if {$DUTs_info(DUT$dut,bladeType) != "NONE"} {
       set cardType [lindex $DUTs_info(DUT${dut},hwList) [expr $slot -1]]
   } else {
       set cardType "0"
   }

   if {0} {
      if {[regexp -nocase "(\[0-9\]+)" $cardType str]} {
         set numPort $str
      } else {
         set numPort "0"
      }
   } else {
      if {[regexp -nocase "(\[0-9\]+)" $cardType str]} {
          Login $DUTs_info(DUT${dut},connect)
          lappend parameterList "available: 1"
          set numPort [GetKeyValue "show slot $slot" $parameterList]
          unset parameterList
      } else {
         set numPort "0"
      }
   }

   return $numPort
}

################################################################## 
# Procedure Name: DutSlotStateRT
#   
# Description: Return the state of a slot from a real time show slot x
#     
#
# Input args: DUT number, Slot Number
# Output args: none
# Return value: Return the state of the card
# Typical usage:
#              DutSlotStateRT 1 1
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc DutSlotStateRT {{dut ""} {slot ""}} {
    global DUTs_info

    Login $DUTs_info(DUT${dut},connect)

    if {$DUTs_info(DUT$dut,bladeType) != "NONE"} {
        lappend parameterList "State: 1"
        set slotState [GetKeyValue "show slot $slot" $parameterList]
        unset parameterList
    } else {
        set slotState NONE
    }
    return $slotState
}


################################################################## 
# Procedure Name: computeSysName
#   
# Description: determines the platform system name. Run a sh ver and determines platform based on
#              number of slots i.e. whether 16,8 or 4 for GZ, BD or BT respectively.
#
#              
#     
#
# Input args: none
# Output args: none
# Return value: Returns the system name either BD, BT, GODZILLA or Sysname
# Typical usage:
#              computeSysName
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc computeSysName {{sysName ""}} {

   if {[regexp -nocase "MSM" $sysName]} {
      lappend parameterList "{SLOT *16 :} 1"
      set slot16Value [GetKeyValue "show ver" $parameterList]
      unset parameterList
      result_debug "slot16Value: $slot16Value"
      if {[regexp -nocase "KEY_NOT_FOUND" $slot16Value]} {   ;# BD or BT
         lappend parameterList "{SLOT *5 :} 1"
         set slot5Value [GetKeyValue "show ver" $parameterList]
         unset parameterList
         result_debug "slot5Value: $slot5Value"
         if {[regexp -nocase "KEY_NOT_FOUND" $slot5Value]} {   ;# BT
            set platform BT
         } else {
             # no more set BD to MSM64 after ridding of EXTREME_PLATFORM
             #set platform $sysName ;# BD
             set platform BD
         }
      } else {    ;# Godzilla
         set platform GODZILLA
      }
   } else {
      set platform $sysName
   }
   return $platform
}


################################################################## 
# Procedure Name: getTECardSpeed
#   
# Description: determines the test equipment card's speed i.e. 10/100 or 1G
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              getTECardSpeed
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc getTECardSpeed {} {
   global ixiaCh1
   global startCardNum
   global MAIN
   #
   # EY-04-04-2013: New global ixiaTclSrvr variable in case TCL server to
   # connect to is not the same as the chassis.
   global ixiaTclSrvr;

   global cardSpeed
   set cardSpeed 0
  if {[info exists ixiaCh1]} {   
     global env
     global auto_path
     global ixiaPath

     set MAIN(skipIxInit) 0; set MAIN(IxiaReady) 1;
     #set env(IXIA_HOME) $ixiaPath($ixiaCh1)
     SetIxiaEnv $ixiaPath($ixiaCh1)
     #source $ixiaPath($ixiaCh1)
     set auto_path_temp ""
     foreach var $auto_path {
         set var1 [split $var "/"]
         if {![regexp -nocase "ixia" $var1] && $var1 != "."} {
             lappend auto_path_temp $var
         }
     }
     unset auto_path
     lappend auto_path "$ixiaPath($ixiaCh1)/lib"
     lappend auto_path "$ixiaPath($ixiaCh1)/lib/ixTcl1.0"
     foreach adir $auto_path_temp {
         lappend auto_path $adir
     }
#     puts "DEBUG [set auto_path]\n\nIXIA_HOME env var = $env(IXIA_HOME)"    
     puts "\n--- DEBUG TCL Variables and Ixia $ixiaCh1 ---\n [set auto_path]"    
     puts "Autotest the IXIA_HOME var is $env(IXIA_HOME)"
     if {[set fd_out [FileOpen [file join $env(IXIA_HOME) "lib/ixTcl1.0/ixTclHal.tcl"] r+]]==-1} {
         return $fd_out 
      }
      package require IxTclHal
      funlock $fd_out 
      package require Tclx
      package require Mpexpr
      #clean up any previous mess
   #   cleanUp
      #
      # EY-04-04-2013: ixInitialize was deprecated back in IxOS v3.80.
      # Replace it with calls to ixConnectToTclServer and ixConnectToChassis.
      #ixInitialize $ixiaCh1
      if {[isUNIX]} {
         #
         # The expression to test needs to be in curly-braces to keep the
         # TCL interpreter from trying to substitute ixiaTclSrvr too soon.
         set tclSrvrIp [expr {[info exists ixiaTclSrvr] ? $ixiaTclSrvr : $ixiaCh1}];
         if {[ixConnectToTclServer $tclSrvrIp]} {
            puts "@@@@ Error connecting to Ixia TCL server @@@@";
            puts "Error connecting to Ixia TCL server $tclSrvrIp.";
            return -1;
         }
      }
      if {[set rc [ixConnectToChassis $ixiaCh1]] != 0} {
         switch $rc {
            1       {puts "Error connecting to Ixia chassis $ixiaCh1.";}
            2       {puts "Version mismatch when connecting to Ixia chassis $ixiaCh1.";}
            3       {puts "Timeout while trying to connect to Ixia chassis $ixiaCh1.";}
            default {puts "Unknown error while attempting to connect to Ixia chassis $ixiaCh1.";}
         }
         return -2;
      }
      if {[chassis get $ixiaCh1]} {
         puts "Error reading chassis configuration from Ixia chassis $ixiaCh1.";
         return -3;
      }
      set chId [chassis cget -id];
      #
      # EY-04-04-2013: Add code to handle new case of startCardNum containing
      # a colon-separated port ID.
      if {[info exists startCardNum]} {
         set tmp [split $startCardNum ":"];
         if {[llength $tmp] > 1} {
            set startCard [lindex $tmp 0];
            set startPort [lindex $tmp 1];
         } else {
            set startCard $startCardNum;
            set startPort 1;
         }
         if {[port get $chId $startCard $startPort]} {
            puts "Error reading port configuration from port $startCard:$startPort on Ixia chassis $ixiaCh1.";
            return -4;
         }
         set cardSpeed [port cget -speed]
         if {[info exist MAIN(ifPipe)] && ($MAIN(ifPipe) != "NULL")} {
            puts $MAIN(ifPipe) "set cardSpeed $cardSpeed"
         }
      }
   }
   return 0;
}

################################################################## 
# Procedure Name: smallIxiaInit
#   
# Description: This performs a faster ixia init in case of dev mode run.
#
#
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              smallIxiaInit
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc smallIxiaInit {} {
      # ----- Ixia initialization
  global ixiaCh1
  global ixiaNoReset
  global MAIN

  if {[info exists ixiaCh1]} {
      global env
      global auto_path
      global ixiaPath
      
      set MAIN(skipIxInit) 0; set MAIN(IxiaReady) 1;
      SetIxiaEnv $ixiaPath($ixiaCh1)
      set auto_path_temp ""
      foreach var $auto_path {
          set var1 [split $var "/"]
          if {![regexp -nocase "ixia" $var1] && $var1 != "."} {
              lappend auto_path_temp $var
          }
      }
      unset auto_path
      lappend auto_path "$ixiaPath($ixiaCh1)/lib"
      lappend auto_path "$ixiaPath($ixiaCh1)/lib/ixTcl1.0"
      foreach adir $auto_path_temp {
          lappend auto_path $adir
      }
      puts "DEBUG [set auto_path]"
      puts "Autotest the IXIA_HOME var is $env(IXIA_HOME)"
      if {[set fd_out [FileOpen [file join $env(IXIA_HOME) "lib/ixTcl1.0/ixTclHal.tcl"] r+]]==-1} {
          return $fd_out
      }
      package require IxTclHal
      funlock $fd_out
      package require Tclx
      package require Mpexpr

      ixInitialize $ixiaCh1
      if {![info exists ixiaNoReset]} {
          IxiaPortsInit
      }
  }
    
}
##################################################################
#
#
#
#
#
#
##################################################################
proc smallStcInit {} {
    global MAIN stcPath LABSERVER SPIRENTCH1

    set ::LABSERVER 10.69.5.245
    lappend auto_path "/auto/ixia_5_70/lib/mpexpr-1.1/"
    overWriteProcs $MAIN(LIB_PATH) [file join $MAIN(LIB_PATH) spirent]
    source [file join $MAIN(LIB_PATH) ePTLib ePTUtils.tcl]
    logcmd lappend auto_path $stcPath($SPIRENTCH1)
    stcInit $LABSERVER
    package require Mpexpr
    puts "\n\nPackage Require SpirentTestCenter"
    logcmd package require SpirentTestCenter
    GenerateDUTPortMapping; # Add here temporarily b/c called in SystemSetup
    set returnFlag "connectionOkay"
    ReservePorts
    set MAIN(IxInitialized) 1

}

################################################################## 
# Procedure Name: RunUnCon
#   
# Description: This performs a uncon sw a at a slower speed making sure evey char typed is 
#              is accepted by DUT
#
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              RunUnCon
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc RunUnCon {{connect "0.0.0.0"}      
               {setupScript ""}
               {fd "NULL"}} {
   global spawn_id
   Login $connect
   set timeout 120

   foreach command $setupScript {
      if { [string match "unc* sw*" $command] == 1 } {
         result_debug "Make sure that this is not a direct telnet connection"
         result_debug "Reseting to factory defaults..."
         foreach letter {u n c o n " " s w " " a} {
            send $letter
             expect {
                "$letter" {
                    after 10
                }
                timeout {
                   for {set c 0} {$c<10} {incr c} {
                      send $letter
                      expect {
                         "$letter" {
                            break
                         }
                         timeout {
                            after 10
                         }
                      }
                   }
                }
             }
         }
         send "\r"
         expect -nocase "(y*n*)"
         send "y\r"
         log_user 1
      }     
   }        
#   logout  
}           
##################################################################
# Procedure Name: GetBcomPortInfoStd
# Description: Init Globals for PortId_Info and Trunk_Info 
# portId and Trunk port on a standard regression bed.
#
# Sets globals: 
#
#       PortID_Info($i,portSpeed) $portSpeed
#       PortID_Info($i,showSpeed) 100Mbps|1Gbps|10Gbps|40Gbps - how it is display on show port info det
#       PortID_Info($i,normTxPerc) (lowest portId speed / portSpeed) * 100
#       PortID_Info($j,normTxPercBy100) (lowest portId speed / portSpeed)
#
#       -- These variables are used in test cases where sw forwarding may or may not be used
#          depending on the platform or the port ID
#       PortID_Info($i,txSwHwPercHigh) sw or hw tx perc - applicatin specific;
#       PortID_Info($i,txSwHwPercLow) sw or hw tx perc - applicatin specific;
#       PortID_Info($i,txSwHwPerc) sw or hw tx perc - applicatin specific;
#       PortID_Info($i,txSwHwRateHigh) sw or hw tx frame rate - applicatin specific;
#       PortID_Info($i,txSwHwRateLow) sw or hw tx frame rate - applicatin specific;
#       PortID_Info($i,txSwHwRate) sw or hw tx frame rate - applicatin specific;
#       PortID_Info($i,txSwHwNumFrames) 64k for sw 3M for hw
#       PortID_Info($i,txPath) sw|hw;
#
#       Main_Info(stdIdCount) 8|12
#       Main_Info(portSpeedList) list of all 8|12 speeds "100 100 1000 100 10000 40000 ...."
#
# Input args: none
# Output args: none
# Return value: none
# Typical usage:
#       GetPortIdInfoStd;
# Category: Utility
##################################################################
proc GetPortIdInfoStd {{saveMode 0}} {
    global Trunk_Info;
    global DUTs_info;
    global PortID_Info;
    global Main_Info;
    global chassis;
    global DUT1_CONNECT;
    global DUT2_CONNECT;
    global chassis;
    global whichDutNow;
    global bcmPlatform;
    global bcmJaguar;
    global napaBlade;
    global bcmChassis;
    global stacking;
    global MAIN;
    global portIDsUsed;

    set saveGlobals 0;
    if {[info exist MAIN(ifPipe)] && ($MAIN(ifPipe) != "NULL") && ($saveMode != "0")} {
        _getPortIdTypeInfo 1;
    } else {
        _getPortIdTypeInfo;
        set saveMode 0;
    }

    set portSpeedList "";
    # EY-12-16-2009: Fixed typo and cleaned up indentation.
    if {[info exists portIDsUsed]} {
        foreach portId $portIDsUsed {
            set portSpeed [GetPortIdSpeed $portId];
            lappend portSpeedList $portSpeed;
            set portSpeedArray(portID${portId},speed) $portSpeed;
            set PortID_Info($portId,portSpeed) $portSpeed;
            if {$saveMode} {puts $MAIN(ifPipe) "set PortID_Info($portId,portSpeed) $portSpeed";}
            switch $portSpeed {
                "100"   {set PortID_Info($portId,showSpeed) 100Mbps;}
                "1000"  {set PortID_Info($portId,showSpeed) 1Gbps;}
                "2500"  {set PortID_Info($portId,showSpeed) "2.5Gbps";}
                "5000"  {set PortID_Info($portId,showSpeed) 5Gbps;}
                "10000" {set PortID_Info($portId,showSpeed) 10Gbps;}
                "40000" {set PortID_Info($portId,showSpeed) 40Gbps;}
            }
        }
        set Main_Info(portSpeedList) $portSpeedList;
        if {$saveMode} {puts $MAIN(ifPipe) "set Main_Info(portSpeedList) \"$portSpeedList\"";}

        # Sort the port speeds from lowest to highest
        set portSpeedList [lsort -integer $portSpeedList];
        set Main_Info(sortPortSpeedList) $portSpeedList;
        if {$saveMode} {puts $MAIN(ifPipe) "set Main_Info(sortPortSpeedList) \"$portSpeedList\"";}
        set lowestPortSpeed [lindex $portSpeedList 0];
        foreach portUsed $portIDsUsed {
            set PortID_Info($portUsed,normTxPerc) [mpexpr int(double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed)) * 100)];
            if {$saveMode} {
                puts $MAIN(ifPipe) "set PortID_Info($portUsed,normTxPerc) [mpexpr int(double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed)) * 100)]";
            }      
            set PortID_Info($portUsed,normTxPercBy100) [mpexpr double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed))];
            if {$saveMode} {
                puts $MAIN(ifPipe) "set PortID_Info($portUsed,normTxPercBy100) [mpexpr double($lowestPortSpeed) / double($PortID_Info($portUsed,portSpeed))]";
            }

            set i $portUsed;
            if {$PortID_Info($i,BcomGen) == "NewGen" || $PortID_Info($i,BcomGen) == "Default"} {
                switch [GetPortIdSpeed $i] {
                    "40000" {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 59200000;
                             set PortID_Info($i,txSwHwRateLow) 592000;
                             set PortID_Info($i,txSwHwRate) 592000}
                    "10000" {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 14800000;
                             set PortID_Info($i,txSwHwRateLow) 148000;
                             set PortID_Info($i,txSwHwRate) 148000}
                    "1000"  {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 1480000;
                             set PortID_Info($i,txSwHwRateLow) 14800;
                             set PortID_Info($i,txSwHwRate) 148000}
                    "100"   {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 148000;
                             set PortID_Info($i,txSwHwRateLow) 1480;
                             set PortID_Info($i,txSwHwRate) 14800;}
                    default {set PortID_Info($i,txSwHwPercHigh) 100;
                             set PortID_Info($i,txSwHwPercLow) 10;
                             set PortID_Info($i,txSwHwPerc) 100;
                             set PortID_Info($i,txSwHwRateHigh) 148000;
                             set PortID_Info($i,txSwHwRateLow) 1480;
                             set PortID_Info($i,txSwHwRate) 14800}
                }; # switch [GetPortIdSpeed $i]
                #result_debug "PortID $i is on a NewGen Broadcom OR Genesis Chassis Blade"
                set PortID_Info($i,txSwHwNumFrames) 3000000;
                set PortID_Info($i,txPath) hw;
            } else {
                switch [GetPortIdSpeed $i] {
                    "40000" {set PortID_Info($i,txSwHwPercHigh) .003; #copy 10000 settings until the correct value is determined DH 29-Apr-2011
                             set PortID_Info($i,txSwHwPercLow) .001;
                             set PortID_Info($i,txSwHwPerc) .003;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    "10000" {set PortID_Info($i,txSwHwPercHigh) .003;
                             set PortID_Info($i,txSwHwPercLow) .001;
                             set PortID_Info($i,txSwHwPerc) .003;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    "1000"  {set PortID_Info($i,txSwHwPercHigh) .02;
                             set PortID_Info($i,txSwHwPercLow) .01;
                             set PortID_Info($i,txSwHwPerc) .02;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    "100"   {set PortID_Info($i,txSwHwPercHigh) .25;
                             set PortID_Info($i,txSwHwPercLow) .10;
                             set PortID_Info($i,txSwHwPerc) .25;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                    default {set PortID_Info($i,txSwHwPercHigh) .25;
                             set PortID_Info($i,txSwHwPercLow) .10;
                             set PortID_Info($i,txSwHwPerc) .25;
                             set PortID_Info($i,txSwHwRateHigh) 200;
                             set PortID_Info($i,txSwHwRateLow) 100;
                             set PortID_Info($i,txSwHwRate) 200}
                }; # switch [GetPortIdSpeed $i]
                #result_debug "PortID $i is OldGen Broadcom Stackable"
                set PortID_Info($i,txSwHwNumFrames) 64000;
                set PortID_Info($i,txPath) sw;
            }; # else
        }; # foreach portUsed $portIDsUsed
    }; # if {[info exists portIDsUsed]}
}; # proc GetPortIdInfoStd

################################################################## 
# Procedure Name: get_DUTs_Slot_info
#   
# Description: This creates and fills in the array  DUTs_Slot_info with the help of DUTs_info
#              All slot specific necessary information may be obtained from this array. This array
#              may be referred with known information of DUT and slot number
#
#     
#
# Input args: tmpdir
# Output args: none
# Typical usage:
#              get_DUTs_Slot_info
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc get_DUTs_Slot_info {{tmpdir "Tmp"}} {
global spawn_id
global numDUT
global MAIN

set numSlots 8

#variable to store all the DUTs interested information
global DUTs_info
global DUTs_Slot_info

set fd_res [open_result_file "slotinfo"]

for {set i 1} {$i <= $numDUT} {incr i 1} {

   global DUT${i}_CONNECT
   global DUT${i}_CONNECTB
   set numSlots $DUTs_info(DUT$i,numSlots)
   set hwModType "NULL"
   set confType  "NULL"
   set state     "NULL"
   set npRev     "NULL"
   set npProc1   "NULL"
   set npProc2   "NULL"
   set imageSel  "NULL"
   set priImage  "NULL"
   set secImage  "NULL"
   set version   "NULL"
   set verTime   "NULL"
   set dlReqD    "0"
   set category  "NULL"

   for {set j 1} {$j <= $numSlots} {incr j} {
   # Hardware module type
   set DUTs_Slot_info(DUT$i,slot$j,hwModType) $hwModType
   # Module type set in the configuration
   set DUTs_Slot_info(DUT$i,slot$j,confType)  $confType
   # State of the card (Operational or not)
   set DUTs_Slot_info(DUT$i,slot$j,state)     $state
   # Revision of the C5 Network Processor
   set DUTs_Slot_info(DUT$i,slot$j,npRev)     $npRev
   # Status of each NP on the slot
   set DUTs_Slot_info(DUT$i,slot$j,npProc1)   $npProc1
   # Status of each NP on the slot
   set DUTs_Slot_info(DUT$i,slot$j,npProc2)   $npProc2
   # Image selected to boot from
   set DUTs_Slot_info(DUT$i,slot$j,imageSel)  $imageSel
   # Image in the primary slot
   set DUTs_Slot_info(DUT$i,slot$j,priImage)  $priImage
   # Image in the secondary slot
   set DUTs_Slot_info(DUT$i,slot$j,secImage)  $secImage
   # Image in the slot that is chosen to boot from ASSUMED RUNNING IMAGE
   set DUTs_Slot_info(DUT$i,slot$j,version)   $version
   # Date and Time that the running image was made
   set DUTs_Slot_info(DUT$i,slot$j,verTime)   $verTime
   # For use to determine downloads
   set DUTs_Slot_info(DUT$i,slot$j,dlReqD)    $dlReqD
   # Set category OldGen NewGen NP
   set DUTs_Slot_info(DUT$i,slot$j,category)  $category

   }


   #For the NP Cards we need more than 1 line captured

   set bList "NULL"
   set location "NULL"

   set fd_in [open "$tmpdir/tmp_info_DUT$i" "r"]
   while {[gets $fd_in line] != -1} {
      set cookedLine [cookString $line]


#result_debug "----- cookedLine=$cookedLine"
      set aList [split $cookedLine]

      if {$bList != "NULL"} {

# Determine location in file search "show switch, slot or version"
      if { ([lindex $bList 0] == "sysName:")} {
         set location "switch"
         }
      if { ([lindex $bList 0] == "Chassis:")} {
         set location "version"
         }

######## Loop through slots #########################################
  for {set j 1} {$j <= $numSlots} {incr j} {

        if { ([lindex $bList 0] == "Slot") &&    \
           ([lindex $bList 1] == "$j") &&       \
           ([lindex $bList 2] == "information:") } {
            set location "slot$j"
        }


###########   Find image version selected to boot###########################

      #find image version selected on an NP Card


        if {    ([lindex $bList 0] == "Software") &&     \
                ([lindex $bList 1] == "image") &&        \
                ([lindex $bList 2] == "booted:") &&      \
                ( $location == "slot$j"        )  } {
            set DUTs_Slot_info(DUT$i,slot$j,imageSel) [lindex $bList 3]
            set npImageSel $DUTs_Slot_info(DUT$i,slot$j,imageSel)
            set DUTs_Slot_info(DUT$i,slot$j,imageSel) \
                   [string tolower $DUTs_Slot_info(DUT$i,slot$j,imageSel)]

        }


###########  Find name of image version booted #############################
      #find image version booted name on an NP Card
      set tmp [lindex $bList 0]
      set tmp [string tolower $tmp]

        if {   ($tmp == $DUTs_Slot_info(DUT$i,slot$j,imageSel)) && \
               ([string tolower [lindex $bList 1]] == "software") &&        \
               ([string tolower [lindex $bList 2]] == "version:") &&    \
               ($location == "slot$j") } {
            set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 1] [string trimleft \
                              [lindex $aList 2] "("] [string trimright [lindex $aList 3] ")"] \
                              [lindex $aList 6]"
            if {[lindex $aList 4] == "Prj"} {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 12] [lindex $aList 13] \
                                 [lindex $aList 14] [lindex $aList 15] [lindex $aList 16]"
            }
            if {[lindex $aList 4] == "(Type:"} {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 9] [lindex $aList 10] \
                                 [lindex $aList 11] [lindex $aList 12] [lindex $aList 13]"
            }
            if { ([lindex $aList 0] == "6.2.1")  && \
                 ([lindex $aList 4] == "by")   } {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 7] [lindex $aList 8] \
                                 [lindex $aList 9]"
                set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 0] [string trimleft \
                              [lindex $aList 1] "("] [string trimright [lindex $aList 2] ")"]"
            }                  
            if { ([lindex $aList 0] >= "7.0.0")  && \
                 ([lindex $aList 5] == "by")   } {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 8] [lindex $aList 9] \
                                 [lindex $aList 10]"
                set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 0] [lindex $aList 3]"
            }
            if { ([lindex $aList 0] >= "7.0.0")  && \
                 ([lindex $aList 4] == "by")   } {
                set DUTs_Slot_info(DUT$i,slot$j,verTime) "[lindex $aList 7] [lindex $aList 8] \
                                 [lindex $aList 9]"
                set DUTs_Slot_info(DUT$i,slot$j,version) "[lindex $aList 0] b[string trimright \
                                 [lindex $aList 2] ")"]"
            }
        }



############ Find the names of the images load in the 2 spaces.. NP cards###
      #find primary image
      if { ( $location == "slot$j" ) &&     \
           ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set DUTs_Slot_info(DUT$i,slot$j,priImage) "[lindex $aList 1] [string trimleft \
                            [lindex $aList 2] "("] [string trimright [lindex $aList 3] ")"] \
                            [lindex $aList 6]"
         if {[lindex $aList 0] == "6.2.1"} {
             set DUTs_Slot_info(DUT$i,slot$j,priImage) "[lindex $aList 0] [string trimleft \
                           [lindex $aList 1] "("] [string trimright [lindex $aList 2] ")"]"
         }
      }
      #find second image
      if { ( $location == "slot$j" ) &&     \
           ([string tolower [lindex $bList 0]] == "secondary") &&   \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set DUTs_Slot_info(DUT$i,slot$j,secImage) "[lindex $aList 1] [string trimleft \
                            [lindex $aList 2] "("] [string trimright [lindex $aList 3] ")"] \
                            [lindex $aList 6]"
         if {[lindex $aList 0] == "6.2.1"} {
             set DUTs_Slot_info(DUT$i,slot$j,secImage) "[lindex $aList 0] [string trimleft \
                           [lindex $aList 1] "("] [string trimright [lindex $aList 2] ")"]"
         }
      }
      #find Hardware module type
      if { ([lindex $bList 0] == "HW") &&     \
           ([lindex $bList 2] == "Type:") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,hwModType) [lindex $bList 3]

      }

      #find Slot s/w Configured setting
      if { ([lindex $bList 0] == "Configured") &&     \
           ([lindex $bList 1] == "Type:") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,confType) [lindex $bList 2]

      }
      #find find operational state
      if { ([lindex $bList 0] == "State:") &&  \
            ( $location == "slot$j" ) } {
         set DUTs_Slot_info(DUT$i,slot$j,state) [lindex $bList 1]

      }
      #find NP Revision
      if { ([lindex $bList 0] == "NP") &&     \
           ([lindex $bList 1] == "1:") && \
           ([lindex $bList 2] == "Rev") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,npRev) [lindex $bList 3]
      }
      #find NP 1 Proc State
      if { ([lindex $bList 0] == "Network") &&     \
           ([lindex $bList 1] == "Processor") && \
           ([lindex $bList 2] == "1") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,npProc1) [lindex $bList 4]
      }
      #find NP 2 Proc State
      if { ([lindex $bList 0] == "Network") &&     \
           ([lindex $bList 1] == "Processor") && \
           ([lindex $bList 2] == "2") && \
            ( $location == "slot$j" )   } {
         set DUTs_Slot_info(DUT$i,slot$j,npProc2) [lindex $bList 4]
      }

   }
   }
   set bList $aList

}



for {set j 1} {$j <= $numSlots} {incr j} {

    switch $DUTs_Slot_info(DUT$i,slot$j,hwModType) {
        "A3ci"    {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "P3ci"    {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "P12ci"   {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "ARM"     {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "ASMGM2X" {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "MPLS"    {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "SMA"     {set DUTs_Slot_info(DUT$i,slot$j,category) NP}
        "G8Xi"    {set DUTs_Slot_info(DUT$i,slot$j,category) NEW_GEN}
        "F48Ti"   {set DUTs_Slot_info(DUT$i,slot$j,category) NEW_GEN}
        "G12Xi"   {set DUTs_Slot_info(DUT$i,slot$j,category) NEW_GEN}
        "F32T"    {set DUTs_Slot_info(DUT$i,slot$j,category) OLD_GEN}
        "F24T"    {set DUTs_Slot_info(DUT$i,slot$j,category) OLD_GEN}
    }

   result_debug "*** DUT$i *** Slot$j Info ********"
   result_debug "Hardware Module Type = $DUTs_Slot_info(DUT$i,slot$j,hwModType)"
   result_debug "Module Configured = $DUTs_Slot_info(DUT$i,slot$j,confType)"
   result_debug "Slot State = $DUTs_Slot_info(DUT$i,slot$j,state)"
   result_debug "Network Processor Rev = $DUTs_Slot_info(DUT$i,slot$j,npRev)"
   result_debug "Network Processor 1 Status = $DUTs_Slot_info(DUT$i,slot$j,npProc1)"
   result_debug "Network Processor 2 Status = $DUTs_Slot_info(DUT$i,slot$j,npProc2)"
   result_debug "Image Selected = $DUTs_Slot_info(DUT$i,slot$j,imageSel)"
   result_debug "Booted Version Name = $DUTs_Slot_info(DUT$i,slot$j,version)"
   result_debug "Build Date = $DUTs_Slot_info(DUT$i,slot$j,verTime)"
   result_debug "Primary Image = $DUTs_Slot_info(DUT$i,slot$j,priImage)"
   result_debug "Secondary Image = $DUTs_Slot_info(DUT$i,slot$j,secImage)"
   result_debug "Card Category = $DUTs_Slot_info(DUT$i,slot$j,category)"


      if {[info exist MAIN(ifPipe)] && ($MAIN(ifPipe) != "NULL")} {
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,hwModType) \"$DUTs_Slot_info(DUT$i,slot$j,hwModType)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,confType) \"$DUTs_Slot_info(DUT$i,slot$j,confType)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,state) \"$DUTs_Slot_info(DUT$i,slot$j,state)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,npRev) \"$DUTs_Slot_info(DUT$i,slot$j,npRev)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,npProc1) \"$DUTs_Slot_info(DUT$i,slot$j,npProc1)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,npProc2) \"$DUTs_Slot_info(DUT$i,slot$j,npProc2)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,imageSel) \"$DUTs_Slot_info(DUT$i,slot$j,imageSel)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,version) \"$DUTs_Slot_info(DUT$i,slot$j,version)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,verTime) \"$DUTs_Slot_info(DUT$i,slot$j,verTime)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,priImage) \"$DUTs_Slot_info(DUT$i,slot$j,priImage)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,secImage) \"$DUTs_Slot_info(DUT$i,slot$j,secImage)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,category) \"$DUTs_Slot_info(DUT$i,slot$j,category)\""
       puts $MAIN(ifPipe) "set DUTs_Slot_info(DUT$i,slot$j,dlReqD)   \"$DUTs_Slot_info(DUT$i,slot$j,dlReqD)\""       
      }

}

   close $fd_in                          


}
close_result_file

}



################################################################## 
# Procedure Name: get_DUTs_info_eware
#   
# Description: creates a DUTs_info array after discovering all DUTs information in the testbed.
#              fills in all elements of DUTs_info array with relevant information.
#
#              
#     
#
# Input args: none
# Output args: none
# Typical usage:
#              get_DUTs_info
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc get_DUTs_info_eware {{infoFilename "info"} {tmpdir "Tmp"}} {
global spawn_id
global numDUT
global MAIN
global DUT
global DUTs_info
global DUTs_Slot_info
global branch
global pioneerPlatform
global everestChassis
global DUTs_info
global whichDutNow

global tmpPath
if [info exists tmpPath] {
    set tmpdir $tmpPath
}

set fd_res [open_result_file "$infoFilename"]
set slotDump 0   
#for {set i 1} {$i <= $numDUT} {incr i 1} {

#   global eware_dut
#   if {[info exists eware_dut]} {
#      if {[lsearch $eware_dut $i] > -1 } {
#         set loopVar 1
 #     } else {
 #        set loopVar 0
 #     }
 #  } else {
 #     set loopVar 0
 #  }

  # if {$loopVar} {
   global whichDutNow
   set i $whichDutNow
   global DUT[set i]_CONNECT
   Login [set DUT[set i]_CONNECT]

   lappend parameterList "{SysName:}   1"
   set sysN [GetKeyValue "show switch" $parameterList]
   unset parameterList

   ################################################################
   ##  Determine Platform Type as BD or BT or Godzilla etc
   ################################################################
   set platFType [computeSysName $sysN]
   set platFType [string tolower $platFType]
   ################################################################
   ##  Get Slot info dump if Platform Type is BD or BT or Godzilla etc
   ################################################################
   set fd_in [open "$tmpdir/tmp_info_DUT$i-[pid]" "w"]
   SendACmd "sh sw" $fd_res $fd_in
   SendACmd "sh ver" $fd_res $fd_in
   SendACmd "sh vlan default" $fd_res $fd_in
   if {([regexp -nocase "bd|bt" $platFType])      || \
       ([regexp -nocase "Alpine*" $platFType])    || \
       ([regexp -nocase "godzilla" $platFType])  } {
      SendACmd "sh slot" $fd_res $fd_in
      set slotDump 1
   }      
   close $fd_in
   ################################################################
   ##  Initiallize variables to be gathered.
   ################################################################
   set imageSel "NONE"
   set priImage "INVALID"
   set secImage "INVALID"
   set version "INVALID"
   set platform "INVALID"
   set techRel   "INVALID"   
   set sysMAC "INVALID"
   set bootROM "INVALID"
   set relMaster "INVALID"
   set numPorts 0
   set merge     "INVALID"
   set numSlots  "0"   
   set version2  "INVALID"
   set verTime   "INVALID"
   set dlReqD    "0"
   set priVer    ""
   set secVer    ""
   set showVerVersion ""
   set snmpVersion "2"

   set DUTs_info(DUT$i,imageSel) $imageSel
   set DUTs_info(DUT$i,priImage) $priImage
   set DUTs_info(DUT$i,secImage) $secImage
   set DUTs_info(DUT$i,version) $version
   set DUTs_info(DUT$i,verTime)   $verTime   
   set DUTs_info(DUT$i,platform) $platform
   set DUTs_info(DUT$i,sysMAC) $sysMAC
   set DUTs_info(DUT$i,bootROM) $bootROM
   set DUTs_info(DUT$i,numSlots)  $numSlots   
   set DUTs_info(DUT$i,relMaster) $relMaster
   set DUTs_info(DUT$i,numPorts) $numPorts
   set DUTs_info(DUT$i,techRel)   $techRel
   set DUTs_info(DUT$i,merge)    $merge
   set DUTs_info(DUT$i,dlReqD)   $dlReqD
   set DUTs_info(DUT$i,sysName) $sysN
   set DUTs_info(DUT$i,debugFlag) 1
   set DUTs_info(DUT$i,sVVersion) $showVerVersion
   set DUTs_info(DUT$i,snmpVersion) $showVerVersion

   set masterOfsset "17"
   set masterEnd "28"
   set isMSM "FALSE"
   set bList "NULL"
   set location "NULL"
   set msmLocation "NULL"
   set msmMaster   "MSM-B"

   set fd_in [open "$tmpdir/tmp_info_DUT$i-[pid]" "r"]
   while {[gets $fd_in line] != -1} {
      set cookedLine [cookString $line]


#result_debug "----- cookedLine=$cookedLine"
      set aList [split $cookedLine]

      if {$bList != "NULL"} {

# Determine location in file search "show switch, slot or version"
      if { ([lindex $bList 0] == "sysName:") || ([lindex $bList 0] == "SysName:") } {
         set location "switch"
         }
    #Determine if you are in an msm image section
      set msmType [string toupper  [lindex $bList 0]]
      switch -exact -- $msmType {
        "MSM-A" { set msmLocation "MSM-A" }    
        "MSM-B" { set msmLocation "MSM-B" }    
        "MSM-C" { set msmLocation "MSM-C" }    
        "MSM-D" { set msmLocation "MSM-D" }   
      }  
      if { ([lindex $bList 0] == "Chassis:")  || \
           ([lindex $bList 0] == "Chassis")   || \
           ([lindex $bList 0] == "CPU")   || \
           ([lindex $bList 0] == "Daughtercard:") || \
           ([lindex $bList 0] == "Baseboard:")  } {
         set location "version"
      }

      if { ([lindex $bList 0] == "Slot") &&    \
           ([lindex $bList 1] == "1") &&       \
           ([lindex $bList 2] == "information:") } {
         set location "slot"
      }
      #6.2.1b10
      if { ([lindex $aList 0] == "Current") &&     \
           ([lindex $aList 1] == "State:") } {

         set masterOffset "29"
         set masterEnd "40"
         set isMSM "TRUE"
         if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)] || \
             [regexp -nocase $everestChassis $DUTs_info(DUT$whichDutNow,platform)]} {
             set msmMaster MM-B
         } else {
             set msmMaster MSM-B
         }
         if {[string tolower [lindex $aList 2]] == "master" } {
             set masterOfsset "17"
             set masterEnd "28"
             set msmMaster MSM-A
             if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
                 set msmMaster MM-A
             } else {
                 set msmMaster MSM-A
             }
         }
      }

  ###########   Find both image versions Fix for 700b37 new Show switch #########
      if { ([string tolower [lindex $aList 0]] == "primary") &&     \
           ([string tolower [lindex $aList 1]] == "ew") &&        \
           ([string tolower [lindex $aList 2]] == "ver:") } {
      set priVer [string tolower [lindex $aList 3]]
      }
          if { ([string tolower [lindex $aList 0]] == "secondary") &&     \
               ([string tolower [lindex $aList 1]] == "ew") &&        \
               ([string tolower [lindex $aList 2]] == "ver:") } {
          set secVer [string tolower [lindex $aList 3]]
          }

  ################   Find image version selected to boot IMAGE RUNNING NOW  #####

      #find image version selected on switch

      if { ([lindex $bList 0] == "Software") &&     \
           ([lindex $bList 1] == "image") &&        \
           ([lindex $bList 2] == "booted:") &&      \
           ( $location == "switch"        )  } {
         set imageSel [lindex $bList 3]
         set imageSel [string tolower $imageSel]
           puts "**$imageSel***from the wrong place 618 code########"
      }
      ###### Fix for ABU new Show Switch 700b44##################################
      if { ([lindex $bList 0] == "Module") &&     \
           ([lindex $bList 1] == "Image") &&        \
           ([lindex $bList 4] == "Booted") &&      \
           ( $location == "switch"        )  } {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
         if {$imageSel == "primary"} {
             set version $priVer
         } elseif {$imageSel == "secondary"} {
             set version $secVer
         }
      }
      ###### Fix for ABU new Show Switch 700b45 and above##################################
      if { ([lindex $bList 0] == "------") &&     \
           ( $location == "switch"        )  } {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
         if {$imageSel == "primary"} {
             set version $priVer
         } elseif {$imageSel == "secondary"} {
             set version $secVer
         }
      }
      if { ([lindex $bList 0] == "Image") &&     \
           ([lindex $bList 1] == "Selected:") &&      \
           ( $location == "switch"        )  } {
         set imageSel [lindex $aList 2]
         set imageSel [string tolower $imageSel]
         if {$imageSel == "primary"} {
             set version $priVer
         } elseif {$imageSel == "secondary"} {
             set version $secVer
         }
      puts "** 700 changes for Alpine  ########"
      }
      #for 6.2.1
      if { ([lindex $aList 0] == "Image") &&     \
           ([lindex $aList 1] == "Booted:") } {
         set imageSel [lindex [string range $line $masterOfsset $masterEnd] 0]
         set imageSel [string tolower $imageSel]
 puts "**$imageSel***from 621 code########"
      }


      # Find image version booted name on MSM
      #

      set tmp [lindex $bList 0]
      set tmp [string tolower $tmp]
      if { ($tmp == $imageSel) && ($location == "switch") &&    \
           ([string tolower [lindex $bList 1]] == "software") &&        \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set version [lindex $bList 3]
         set slot [lindex $bList 5]
         if { $slot == "MSM-A" || $slot == "MM-A"} {
            if {$version == "empty"} {
               set version [string tolower "[lindex $bList 6]"]
            } else {
               set version [string tolower "[lindex $bList 3]"]
            }
         }
      }

      #6.2.1b10
      set tmp [lindex $aList 0]
      set tmp [string tolower $tmp]      
      if { ($tmp == $imageSel) &&     \
           ([string tolower [lindex $aList 1]] == "ew") &&        \
           ([string tolower [lindex $aList 2]] == "ver:") &&  \
           ($msmLocation == "NULL")     } {
      set version [string tolower [lindex $aList 3]]
         if { $isMSM == "TRUE" } {
            if {$masterOfsset == "17"} {
               set version [string tolower "[lindex [string range $line $masterOfsset $masterEnd] 0]"]
            } else {
               set version [string tolower "[lindex [string range $line $masterOfsset $masterEnd] 0]"]
            }
         }
      }
      #7.0.0b39 RTPFixes5
      # Primary   EW Ver:   7.3.0.22 branch-4digit_v730b22 [non-ssh] [base] 
      # Secondary EW Ver:   7.1.1b11 branch.PA-0311-01-r2 [non-ssh]      
      set tmp [lindex $bList 0]
      set tmp [string tolower $tmp]      
      if { ($tmp == $imageSel) &&     \
           ([string tolower [lindex $bList 1]] == "ew") &&        \
           ([string tolower [lindex $bList 2]] == "ver:") &&      \
           ($msmMaster == $msmLocation)    } {
         set version [string tolower [lindex $bList 3]]
      }
      set version1 $version

#############################################################################
###               Find the names of the images load in the 2 MSM spaces.. ###
###              SHOW SWITCH                                              ###
#############################################################################

      #find primary image
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set priImage [lindex $bList 3]
      }
      #for 6.2.1
      if { ([string tolower [lindex $aList 0]] == "primary") &&     \
           ([string tolower [lindex $aList 1]] == "ew") &&    \
           ([string tolower [lindex $aList 2]] == "ver:") && \
           ($msmLocation == "NULL")    } {
         set priImage [lindex [string range $line $masterOfsset $masterEnd] 0]
      }
      #for 700b39 rtpfixes on
      if { ([string tolower [lindex $bList 0]] == "primary") &&     \
           ([string tolower [lindex $bList 1]] == "ew") &&    \
           ([string tolower [lindex $bList 2]] == "ver:") && \
           ($msmMaster == $msmLocation)    } {
           #fix for 701b4
           if {[regexp -nocase "ssh" [lindex $bList 4]]} {
               set priImage "[lindex $bList 3]"
           } else {
               set priImage "[lindex $bList 3] [lindex $bList 4]"
           }

      }
      #find second image
      if { ( $location == "switch" ) &&     \
           ([string tolower [lindex $bList 0]] == "secondary") &&   \
           ([string tolower [lindex $bList 1]] == "software") &&    \
           ([string tolower [lindex $bList 2]] == "version:") } {
         set secImage [lindex $bList 3]
      }
        #for 6.2.1
        if { ([string tolower [lindex $aList 0]] == "secondary") &&   \
             ([string tolower [lindex $aList 1]] == "ew") &&    \
             ([string tolower [lindex $aList 2]] == "ver:") &&  \
             ($msmLocation == "NULL")    } {
           set secImage [lindex [string range $line $masterOfsset $masterEnd] 0]
        }
        #for 700b39 rtpfixes5 and on
        if { ([string tolower [lindex $bList 0]] == "secondary") &&   \
             ([string tolower [lindex $bList 1]] == "ew") &&    \
             ([string tolower [lindex $bList 2]] == "ver:") &&  \
             ($msmMaster == $msmLocation)    } {

           #fix for 701b4
           if {[regexp -nocase "ssh" [lindex $bList 4]]} {
               set secImage "[lindex $bList 3]"
           } else {
               set secImage "[lindex $bList 3] [lindex $bList 4]"
           }
        }
      #find System Name
      if { ([string tolower [lindex $bList 0]] == "sysname:") } {
         set platform [computeSysName [lindex $bList 1]]
      }
      #find system MAC
      if { ([lindex $bList 0] == "System") &&     \
           ([lindex $bList 1] == "MAC:") } {
         set sysMAC [lindex $bList 2]

      }
######################################################################################
#    Show version portion of the file 
#
######## find release master, time of the build ######################################
      if { ( $location == "version" ) &&     \
           ([lindex $bList 0] == "Image") &&     \
           ([lindex $bList 2] == "Extremeware") &&  \
           ([lindex $bList 3] == "Version")} {

         #should be able to handle 4 and 3 digit version like:
         #Image : Extremeware  Version 7.3.0.30 [non-ssh] [wlan] by 
         #Build_Master on 05/17/04 17:23:30                 
         #
         #Image  :  Extremeware Version 6.2.2 (Build 156)  by 
         #Release_Master 02/13/04 18:33:39 
         #
         #extract the version 
         regexp -nocase {Version +([^ ]+)} $bList dummy showVerVersion
         #extract the build number if exist
         if [regexp -nocase {Build +([0-9]+)} $bList dummy matchb] {
            set showVerVersion "${showVerVersion}b$matchb"
         }

         # Santa Clara base, Tech Release Code, or branch build??????
         # First Case is for IPSERV code. Adjust build # and BuildMaster
         if {[lindex $bList 8] == "IP_SERV_TECH_REL"} {
            set version2 [lindex $bList 9]
            set relMaster [lindex $bList 11]
            ### Set the build time for this Version of Code 
            ### (for download comparison##
            set verTime \
               "[lindex $bList 12] [lindex $bList 13] [lindex $bList 14]"
         }


         # Second Case is for Santa Clara built  
         if {[lindex $bList 8] != "IP_SERV_TECH_REL"} {
             set relMaster [lindex $bList 8]
             set verTime \
                "[lindex $bList 9] [lindex $bList 10] [lindex $bList 11]"
         }


         ### fix for 6.2.1 build 17 (sandbox)
         if {([lindex $bList 4] == "6.2.1") 
            && ([lindex $bList 10] == "on")} {
             set verTime "[lindex $bList 11] [lindex $bList 12]"
             set relMaster [lindex $bList 9]
             set merge [lindex $bList 7]
             regsub -all {\.} $merge "_" merge
         }

         ### fix for 6.2.1 build 10 (new linux buildmaster)
         if {([lindex $bList 4] == "6.2.1") 
            && ([lindex $bList 10] != "on")} {
             set verTime "[lindex $bList 10] [lindex $bList 11]"
         }



         ###### fix for 7.0.0 on ncbuild1 FINAL BUILD MASTER?
         #should handle the following syntax for various builds:
         #
         #Image : Extremeware  Version 7.3.0.25 [non-ssh] [base] by 
         #Build_Master on 04/01/04 14:06:55                       
         #
         #Image : Extremeware  Version 7.3.0.30 [non-ssh] [wlan] by 
         #Build_Master on 05/17/04 17:23:30                 
         #
         #Image : Extremeware  Version 7.2.0 (Build 25) 
         #branch.PA-720-0404-01-r1 [non-ssh] by Patch_Master on 05/06/04 
         #22:07:46       
         #
         #Image : Extremeware  Version 7.2.0 (Build 24) [non-ssh] by 
         #Release_Master on 03/18/04 00:55:14            
         #
         #Image : Extremeware  Version 7.1.1 (Build 15) 
         #branch.PA-711-0405-1-r1 [non-ssh] by Patch_Master on 05/05/04 
         #18:51:38   
         # 
         #Image : Extremeware  Version 7.1.1 (Build 13) [non-ssh] by 
         #Release_Master on 01/16/04 18:21:29 
         #
         #Image : Extremeware  Version 7.3.0.22 br-4dig_v730b22 [non-ssh] 
         #[wlan] by Build_Master on 03/19/04 19:54:59
         #
         if {[lindex $bList 4] >= "7.0.0"} {
            #extract relMaster and verTime
            regexp -nocase {by +([^ ]+) +.+ +([0-9]+:[0-9]+:[0-9]+)} \
               $bList dummy relMaster verTime
            #extract merge string
            #for 4 digit version the merge string is any non space char 
            #in between version number and a open square bracket, but 
            #don't match anything in bracket like "[non-ssh]"
            #note that in bList any square bracket is preceded by a brace 
            if ![regexp -nocase \
               {\.[0-9a-z]+ +([^ \[]+) +\{?\[} $bList dummy merge] {
               #if not 4 digit version, the merge string is in between
               # ")" and "[". if this doesn't match there is no
               #branch information to extract
               regexp {\) +([^ \[]+) +\{?\[} $bList dummy merge
            }
            regsub -all {\.} $merge "_" merge
         }
      }

#    End Show Version
######################################################################################

      #find BootROM
      if { ([lindex $bList 0] == "BootROM") } {
         set bootROM [lindex $bList 2]

      }      
      if { ([lindex $bList 0] == "snmpVersion") } {
         set snmpVersion [lindex $bList 2]

      }       
      #find total ports
      if { ([lindex $bList 0] == "Ports:") } {
         set numPorts [lindex $bList 1]

      } 
   }
   set bList $aList
   }  ;# end while

   # Add the Technology Release or Merge info to the version
   if {$version2 == "INVALID"} {
       set version "$version1"
   } else {
       set version "$version1 $version2"
   }

   #get slot info to figure out hardware type
   set hardwareType "NEW_GEN"
   set bladeType "NONE"
   if {[regexp -nocase "bd|bt|godzilla|alpine*" $platform]} {
      lappend parameterList "{HW Module Type:} 1"
      set HardwareList [GetKeyValue "show slot" $parameterList]
      unset parameterList
      result_debug "HardwareList: $HardwareList"
      foreach hardware $HardwareList {
         if {[lsearch -regexp $bladeType $hardware]==-1} {
            if {$bladeType=="NONE"} {set bladeType ""}
            if {![regexp -nocase "none|Empty" $hardware]} {
               set bladeType "$bladeType$hardware"
            }
         }
         switch $hardware {
      	   F32T -
      	   F24T {
               	   set hardwareType "OLD_GEN"     		   
      		} 
         }
      }
   } else {
       if {([regexp -nocase {[0-9|s]i} $platform] == 0) && 
             ([regexp -nocase summit\[2-4\]00 $platform] == 0)} {
           set hardwareType "OLD_GEN"
       }
   }
   ################################################################
   ##  Determine number of slots in the chassis
   ################################################################
   switch $platFType {
       bd         {set numSlots 8}
       bt         {set numSlots 4}
       godzilla   {set numSlots 16}
       alpine3808 {set numSlots 8}
       alpine3804 {set numSlots 4}
       alpine3802 {set numSlots 2}
       default    {set numSlots 0}
   }
   puts "####### version $version  ###########################"
   set DUTs_info(DUT$i,imageSel) $imageSel
   set DUTs_info(DUT$i,priImage) $priImage
   set DUTs_info(DUT$i,secImage) $secImage
   set DUTs_info(DUT$i,version) $version
   set DUTs_info(DUT$i,verTime) $verTime   
   set DUTs_info(DUT$i,platform) $platform
   set DUTs_info(DUT$i,sysMAC) [string toupper $sysMAC]
   set DUTs_info(DUT$i,relMaster) $relMaster
   set DUTs_info(DUT$i,bootROM) $bootROM
   set DUTs_info(DUT$i,numSlots)     $numSlots
   set DUTs_info(DUT$i,numPorts) $numPorts
   set DUTs_info(DUT$i,HardwareType) $hardwareType
   set DUTs_info(DUT$i,bladeType) $bladeType
   set DUTs_info(DUT$i,techRel) $version2
   set DUTs_info(DUT$i,merge)   [string tolower $merge]
   set DUTs_info(DUT$i,dlReqD)   $dlReqD
   set DUTs_info(DUT$i,sVVersion) $showVerVersion
   set DUTs_info(DUT$i,snmpVersion) $snmpVersion
 #  global SNMPv3
 #  global SNMPv2

#   #Determine the SNMP version depending upon the version
#   if { [CompareVersion_eware "6.2.2." DUT$i] <= 0 } {
#      set DUTs_info(DUT$i,snmpVersion) $SNMPv3
#   } else {
#      set DUTs_info(DUT$i,snmpVersion) $SNMPv2
#   }

   if { $version2 != "INVALID" } {
       set buildList [split $version2 "."]
       set bNum [lindex $buildList 0]
       set branch "$version1 ipserv[string trimleft $bNum "v"]"
   }  else {
       set branch "$version1"
   }

   global _VERSION
   global VERSION
   set _VERSION $version
   set VERSION [string range $_VERSION 0 0]
   set DUTs_info(DUT$i,VERSION) $VERSION

   result_debug "****** DUT$i Info ********"
   result_debug "Image Selected = $DUTs_info(DUT$i,imageSel)"
   result_debug "Image Version = $DUTs_info(DUT$i,version)"
   result_debug "Running Image Built on $DUTs_info(DUT$i,verTime)"   
   result_debug "Primary Image = $DUTs_info(DUT$i,priImage)"
   result_debug "Secondary Image = $DUTs_info(DUT$i,secImage)"
   result_debug "Platform = $DUTs_info(DUT$i,platform)"
   result_debug "System MAC = $DUTs_info(DUT$i,sysMAC)"
   result_debug "BootROM = $DUTs_info(DUT$i,bootROM)"
   result_debug "Release Master = $DUTs_info(DUT$i,relMaster)"
   result_debug "Total Ports = $DUTs_info(DUT$i,numPorts)"
   result_debug "Number of Slots = $DUTs_info(DUT$i,numSlots)"   
   result_debug "Hardware Type = $DUTs_info(DUT$i,HardwareType)"
   result_debug "Blade Type = $DUTs_info(DUT$i,bladeType)"
   result_debug "Tech Release version = $DUTs_info(DUT$i,techRel)"
   result_debug "Merge Release version = $DUTs_info(DUT$i,merge)"
   result_debug "Download Flag Init    = $DUTs_info(DUT$i,dlReqD)"
   result_debug "Version from Show Version = $DUTs_info(DUT$i,sVVersion)"
 #  result_debug "SNMP version = $DUTs_info(DUT$i,snmpVersion)"
   close $fd_in

   if {[info exist MAIN(ifPipe)] && ($MAIN(ifPipe) != "NULL")} {
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,imageSel) \"$DUTs_info(DUT$i,imageSel)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,version) \"$DUTs_info(DUT$i,version)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,VERSION) \"$DUTs_info(DUT$i,VERSION)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,priImage) \"$DUTs_info(DUT$i,priImage)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,secImage) \"$DUTs_info(DUT$i,secImage)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,platform) \"$DUTs_info(DUT$i,platform)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sysMAC) \"$DUTs_info(DUT$i,sysMAC)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,bootROM) \"$DUTs_info(DUT$i,bootROM)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,relMaster) \"$DUTs_info(DUT$i,relMaster)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,numPorts) \"$DUTs_info(DUT$i,numPorts)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,numSlots) \"$DUTs_info(DUT$i,numSlots)\""       
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,HardwareType) \"$DUTs_info(DUT$i,HardwareType)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,bladeType) \"$DUTs_info(DUT$i,bladeType)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,techRel) \"$DUTs_info(DUT$i,techRel)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,merge) \"$DUTs_info(DUT$i,merge)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,dlReqD) \"$DUTs_info(DUT$i,dlReqD)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sysName) \"$DUTs_info(DUT$i,sysName)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,sVVersion) \"$DUTs_info(DUT$i,sVVersion)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,snmpVersion) \"$DUTs_info(DUT$i,snmpVersion)\""
       puts $MAIN(ifPipe) "set DUTs_info(DUT$i,debugFlag) \"$DUTs_info(DUT$i,debugFlag)\""
       puts $MAIN(ifPipe) "set branch \"$branch\""
   }
#}
#}

close_result_file  
# Now get the info from the individual slots if platform matches
#     if {$slotDump} {
#         get_DUTs_Slot_info $tmpdir
#     }
#     if {![info exists DUT(LoadImage)]} { ;# Need to turn of when run LoadImage
#         getTECardSpeed
#     }

#     for {set i 1} {$i <= $numDUT} {incr i 1} {
#	 file delete "$tmpdir/tmp_info_DUT$i-[pid]"
#     }
}

################################################################## 
# Procedure Name: _get_HW_DUTs_info
#   
# Description: Stores a Single Switch information to
#              the DUTs_info array
#
#    NOTE: use /tmp for all temporary files b/c NAS would
#          slow the performance if we use relative dirs.          
#
# Input args: none
# Output args: none
# Typical usage:
#
#   for single DUT
#      _get_HW_DUTs_info -dut $dut
#              
#   More common from multiTask
#
#    set getInfoList ""
#    set numDUT 1
#    while { [info exists DUT${numDUT}_CONNECT] } {
#        puts "***** DUT${numDUT}_CONNECT=$connect ***** "
#        puts "***** numDUT=$numDUT ***** "
#        lappend getInfoList "_get_HW_DUTs_info -dut $numDUT"
#        incr numDUT 1
#    }
#    incr numDUT -1
#    MultiTask $getInfoList
#
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: Setup
##################################################################
proc _get_HW_DUTs_info {args} {
    global spawn_id fd_res
    global DUT MAIN
    global exos
    global in
    global DUTs_info
    global DUTs_Slot_info
    global chassis
    global harness
    global eware_dut
    global CFG_PLATFORM

    parse_args _get_HW_DUTs_info $args {
        dut   "1"
        checkOperational "0"
    }

    # --- Turn off printing SendACmd output to stdout
    _setShowOutput -screen off -log off -res_fmt on

    # --------------------------------------------------------------
    #  If Multitask calls this we need to save variables to a tmp
    #     file b/c the caller is in a different scope
    #
    #    passUp is only turned on when multiTask calls this proc
    #
    # --------------------------------------------------------------    
    set passUp 0
    if {[info exists MAIN(MULTITASKON)] && $MAIN(MULTITASKON)} {
        set passUp 1
        set fd_g [open "/tmp/[pid]_setvars" "w"]
    }

    set pid [pid]
    set DUTs_info(DUT$dut,show_output) "empty"

    # This is a TMP file to support SendACmd fd_res. We don't care
    #   about the data
    if ![info exists fd_res] {
        set fd_res [open "/tmp/HwInfo_DUT${dut}_$pid" "w"]
    } else {
        flush $fd_res
    }
    set slotDump 0

    if {[info exists eware_dut] && $eware_dut != ""} {
        result_debug "_get_HW_DUTs_info does not support ExtremeWare"
        return 0
    }

    global DUT[set dut]_CONNECT
    global DUT[set dut]_CONNECTB
    global DUT[set dut]_CONNECTC
    global DUT[set dut]_CONNECTD
    global DUT[set dut]_CONNECTE
    global DUT[set dut]_CONNECTF
    global DUT[set dut]_CONNECTG
    global DUT[set dut]_CONNECTH

    Login "[set DUT[set dut]_CONNECT]" -CheckOperational 0
    
    set DUTs_info(DUT$dut,sysType) [GetSystemType $dut]
    if {[info exists CFG_PLATFORM($dut)] && $CFG_PLATFORM($dut) != "null"} {
        set DUTs_info(DUT$dut,platform) $CFG_PLATFORM($dut)
    } else {
        set DUTs_info(DUT$dut,platform) $DUTs_info(DUT$dut,sysType)
    }
    if {$passUp} {
        puts $fd_g "set DUTs_info(DUT$dut,sysType) [GetSystemType $dut]"
        puts $fd_g "set DUTs_info(DUT$dut,platform) $DUTs_info(DUT$dut,sysType)"
    }

    if {$checkOperational} {
        result_debug "Login with - CheckOperational"
        Login [set DUT[set dut]_CONNECT]

        if {[regexp -nocase "stack" [GetSystemType $dut]] } {
            set showSwitchOutput ""
            lappend showSwitchOutput "{Current.*State} {MASTER.*BACKUP.*In.*Sync} inLine exists"
            CheckKeyValue "show switch" $showSwitchOutput -testNo none \
                                         -time {s: 5 i: 30 d: 120 f: 240 r}
        }
    }
    ################################################################
    ##  Get switch info dump
    #     - open capture file
    #     - get outputs
    #     - pull output for parsing
    #     - delete tmp capture files
    ################################################################
    # -- open files to hold the temp data
    set fd_in [open "/tmp/tmp_hwinfo_DUT${dut}$pid" "w"]

    SendACmd "disable clipaging"
    SendACmd "show switch" $fd_res $fd_in
    SendACmd "show version" $fd_res $fd_in
    SendACmd "show license" $fd_res $fd_in
    if {[regexp -nocase "$chassis" $DUTs_info(DUT$dut,platform)] || \
        [regexp -nocase "stack" $DUTs_info(DUT$dut,platform)] || \
        [regexp -nocase "vpex" $DUTs_info(DUT$dut,platform)]} {
        SendACmd "show slot" $fd_res $fd_in
    }
    close $fd_in;# Close file that hold data we are parsing
    close_result_file;# Close gen harness file for fd_res / SendACmd

    # -- Read in data for parsing
    set fp [open "/tmp/tmp_hwinfo_DUT${dut}$pid" r]
    set show_data [read $fp]
    close $fp
    # -- Delete the supporting files
    catch {file delete -force /tmp/tmp_hwinfo_DUT${dut}$pid} oops;# fd_in
    if {[file exists /tmp/HwInfo_DUT${dut}_$pid]} {
        catch {file delete -force /tmp/HwInfo_DUT${dut}_$pid} oops;# fd_res
    }
    #
    # End Gathering data section
    #

    # --------- Save switch output for printing later -----------
    set DUTs_info(DUT$dut,show_output) "$show_data"
    if {$passUp} {
        set fd_so [open "/tmp/${pid}_showout" "w"]
        puts $fd_so "set DUTs_info(DUT$dut,show_output) \{$show_data\}"
        close $fd_so
    }
    # ------- A boat load of regexp to grab switch info ---------

    # Information from show switch
    # SysName:
    if {![regexp -nocase {SysName\: *([a-zA-Z0-9\-]+)} \
               $show_data ignore val]} {
        puts "SysName not set"
    } else {
        set DUTs_info(DUT$dut,sysName) $val
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,sysName) $val"
        }
    }
    # System MAC:
    if {![regexp -nocase {System MAC\: *([a-fA-F0-9\:]{17,17})} \
               $show_data ignore val]} {
        puts "System MAC not set"
    } else {
        set DUTs_info(DUT$dut,sysMAC) [string toupper $val]
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,sysMAC) [string toupper $val]"
        }
    }
    # System Type:
    if {![regexp -nocase {System Type\: *([a-zA-Z0-9\-]+).*} \
               $show_data mline val]} {
        puts "System Type not set"
    } else {
        if {[info exists CFG_PLATFORM($dut)] && $CFG_PLATFORM($dut) != "null"} {
            set DUTs_info(DUT$dut,platform) $CFG_PLATFORM($dut)
            set DUTs_info(DUT$dut,sysType) $val
            if {$passUp} {
                puts $fd_g "set DUTs_info(DUT$dut,platform) $CFG_PLATFORM($dut)"
                puts $fd_g "set DUTs_info(DUT$dut,sysType) $val"
            }
        } elseif {[regexp -nocase "stack" $mline]} {
            set DUTs_info(DUT$dut,platform) "Stack"
            set DUTs_info(DUT$dut,sysType) "Stack"
            if {$passUp} {
                puts $fd_g "set DUTs_info(DUT$dut,platform) \"Stack\""
                puts $fd_g "set DUTs_info(DUT$dut,sysType) \"Stack\""
            }
        } else {
            set DUTs_info(DUT$dut,platform) $val
            set DUTs_info(DUT$dut,sysType) $val
            if {$passUp} {
                puts $fd_g "set DUTs_info(DUT$dut,platform) $val"
                puts $fd_g "set DUTs_info(DUT$dut,sysType) $val"
            }
        }
    }
    # Current State:
    set master "INVALID"; set backup "INVALID"; set stat "INVALID";
    if ![regexp -nocase \
          {Current State\:[ ]+([a-zA-Z\-]+)[ ]+([a-zA-Z\-]+)?[ ]+(\([a-zA-Z]+\)?|\([a-zA-Z]+ [a-zA-Z]+\))?} \
          $show_data csLine master backup stat] {
        puts "Switch State not set"
    } else {
        set DUTs_info(DUT$dut,currState) $master
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,currState) $master"
        }
    }
    # Image Selected:
    set master1 "INVALID"; set backup1 "INVALID";
    if ![regexp -nocase {Image Selected\:[ ]+([a-zA-Z]+)[ ]+([a-zA-Z]+)?} $show_data iselectLine  master1 backup1] {
        puts "Image selected could not be determined"
    } else {
        set DUTs_info(DUT$dut,imageSel) $master1
        set DUTs_info(DUT$dut,imageSelA) $master1
        set DUTs_info(DUT$dut,imageSelB) $backup1
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,imageSel) $master1"
            puts $fd_g "set DUTs_info(DUT$dut,imageSelA) $master1"
            puts $fd_g "set DUTs_info(DUT$dut,imageSelB) $backup1"
        }
    }
    # Image Booted:
    set master2 "INVALID"; set backup2 "INVALID";
    if {![regexp -nocase {Image Booted\:[ ]+([a-zA-Z]+)[ ]+([a-zA-Z]+)?} \
               $show_data ibootLine  master2 backup2]} {
        puts "Image Booted not set"
    } else {
        set DUTs_info(DUT$dut,imageBooted) $master2
        set DUTs_info(DUT$dut,imageBootedA) $master2
        set DUTs_info(DUT$dut,imageBootedB) $backup2
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,imageBooted) $master2"
            puts $fd_g "set DUTs_info(DUT$dut,imageBootedA) $master2"
            puts $fd_g "set DUTs_info(DUT$dut,imageBootedB) $backup2"
        }
    }
    # Primary Ver:
    set mBuild "INVALID"; set bBuild "INVALID";
    if {![regexp -nocase {Primary ver:[ ]+([0-9]{2,2}\.[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})\
                         [ ]+([0-9]{2,2}\.[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})?} \
               $show_data priILine  mBuild bBuild]} {
        puts "Primary Image not set"
    } else {
        set DUTs_info(DUT$dut,priImage) $mBuild
        set DUTs_info(DUT$dut,priImageA) $mBuild
        set DUTs_info(DUT$dut,priImageB) $bBuild
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,priImage) $mBuild"
            puts $fd_g "set DUTs_info(DUT$dut,priImageA) $mBuild"
            puts $fd_g "set DUTs_info(DUT$dut,priImageB) $bBuild"
        }
    }
    # Secondary Ver:
    set mBuild "INVALID"; set bBuild "INVALID";
    if {![regexp -nocase {Secondary ver:[ ]+([0-9]{2,2}\.[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})\
                         [ ]+([0-9]{2,2}\.[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})?} \
               $show_data secILine mBuild bBuild]} {
        puts "Secondary Image not set"
    } else {
        set DUTs_info(DUT$dut,secImage) $mBuild
        set DUTs_info(DUT$dut,secImageA) $mBuild
        set DUTs_info(DUT$dut,secImageB) $bBuild
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,secImage) $mBuild"
            puts $fd_g "set DUTs_info(DUT$dut,secImageA) $mBuild"
            puts $fd_g "set DUTs_info(DUT$dut,secImageB) $bBuild"
        }
    }
    # ------------------ Logic to set the version based on booted --------------------
    # Check for mismatch
    set AOk 0
    set BOk 0
    if {[string trim $DUTs_info(DUT$dut,priImageA)] != "" && \
        [string trim $DUTs_info(DUT$dut,priImageA)] != "INVALID"} {
        set AOk 1
    }
    if {[string trim $DUTs_info(DUT$dut,priImageB)] != "" && \
        [string trim $DUTs_info(DUT$dut,priImageB)] != "INVALID"} {
        set BOk 1
    }
    if {$AOk && $BOk} {
        if {$DUTs_info(DUT$dut,priImageA) != $DUTs_info(DUT$dut,priImageB)} {
            set MAIN(MISMATCH_pri) 1
        } else {
            set MAIN(MISMATCH_pri) 0
        }
        if {$DUTs_info(DUT$dut,secImageA) != $DUTs_info(DUT$dut,secImageB)} {
            set MAIN(MISMATCH_sec) 1
        } else {
            set MAIN(MISMATCH_sec) 0
        }
    } else {
        # -- standalone
        set MAIN(MISMATCH_pri) 0; set MAIN(MISMATCH_sec) 0
    }
    if {[regexp -nocase "pri" $DUTs_info(DUT$dut,imageBooted)]} {
        set DUTs_info(DUT$dut,version) $DUTs_info(DUT$dut,priImage);
    } else {
        set DUTs_info(DUT$dut,version) $DUTs_info(DUT$dut,secImage);
    }
    if {$passUp} {
        puts $fd_g "set MAIN(MISMATCH_pri) $MAIN(MISMATCH_pri)"
        puts $fd_g "set MAIN(MISMATCH_sec) $MAIN(MISMATCH_sec)"
        puts $fd_g "set DUTs_info(DUT$dut,version) $DUTs_info(DUT$dut,version)"
    }
    # get serial for chassis and switch
    set ischassis 0
    set prodnum "INVALID"; set ser "INVALID";
    if {![regexp -nocase {Chassis[ ]+:[ ]+([0-9]+\-[0-9]+\-[0-9]+)[ ]+([0-9A-Z]{5,5}\-[0-9A-Z]{5,5})} \
               $show_data swChSerLine prodnum ser]} {
    } else {
        set ischassis 1
        set DUTs_info(DUT$dut,serial) $ser
        set DUTs_info(DUT$dut,productNum) $prodnum
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,serial) $ser"
            puts $fd_g "set DUTs_info(DUT$dut,productNum) $prodnum"
        }
    }
    set isVM 0
    set prodnum "INVALID"; set ser "INVALID";
    if {![regexp -nocase {Switch[ ]+:[ ]+(PN\:[a-z0-9]{6,6})[ ]+(SN\:[0-9]{6,6})[ ]+Rev} \
               $show_data swChSerLine prodnum ser]} {
    } else {
        set isVM 1
        set DUTs_info(DUT$dut,serial) $ser
        set DUTs_info(DUT$dut,productNum) $prodnum
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,serial) $ser"
            puts $fd_g "set DUTs_info(DUT$dut,productNum) $prodnum"
        }
    }
    if {!$isVM && !$ischassis && [set DUTs_info(DUT$dut,platform)] != "Stack"} {
        set prodnum "INVALID"; set ser "INVALID";
        if {![regexp -nocase {Switch[ ]+:[ ]+([0-9]+\-[0-9]+\-[0-9]+)[ ]+([0-9A-Z]{5,5}\-[0-9A-Z]{5,5})} \
                   $show_data swChSerLine prodnum ser]} {
            puts "Standalone Switch serial number not hit"
            if {$passUp} {
                puts $fd_g "set DUTs_info(DUT$dut,serial) \"INVALID\""
                puts $fd_g "set DUTs_info(DUT$dut,productNum) \"INVALID\""
            }
        } else {
            set DUTs_info(DUT$dut,serial) $ser
            set DUTs_info(DUT$dut,productNum) $prodnum
            if {$passUp} {
                puts $fd_g "set DUTs_info(DUT$dut,serial) $ser"
                puts $fd_g "set DUTs_info(DUT$dut,productNum) $prodnum"
            }
        }
    }
    if {[regexp -nocase "stack" $DUTs_info(DUT$dut,platform)] || $ischassis || \
        [regexp -nocase "vpex" $DUTs_info(DUT$dut,platform)]} {
        # get slots serial for stack
        #
        # vpex slots start at 33
        if {[regexp -nocase "vpex" $DUTs_info(DUT$dut,platform)]} {
            set slotVals 1
            for {set sv 33} {$sv <= 64 } {incr sv} {
                lappend slotVals $sv
            }
        } else {
            set slotVals {1 2 3 4 5 6 7 8 A B}
        }
        set nslot 0
        foreach i $slotVals {
            set prodnum "INVALID"; set ser "INVALID"; set sl "INVALID"
            if {![regexp -nocase "(Slot\-${i}|MSM\-${i}|MM\-${i})\[ ]+:\[ ]+(\[0-9]+\-\[0-9]+\-\[0-9]+)\[ ]+(\[0-9A-Z]{5,5}\-\[0-9A-Z]{5,5})" \
                       $show_data swChSerLine sl prodnum ser]} {
                if {$passUp} {
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,serial) \"INVALID\""
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,productNum) \"INVALID\""
                }
            } else {
                if {[regexp -nocase "slot" $sl]} {incr nslot}
                set DUTs_Slot_info(DUT$dut,slot$i,serial) $ser
                set DUTs_Slot_info(DUT$dut,slot$i,productNum) $prodnum
                if {$passUp} {
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,serial) $ser"
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,productNum) $prodnum"
                }
            }
            set tp "INVALID"; set cf "INVALID"; set stt "INVALID"; set pts "INVALID";
            if {![regexp -nocase "(Slot\-${i})\[ ]+(\[a-z0-9]+\-\[a-z0-9\(\)]+)\[ ]+(\[a-z0-9]+\-\[a-z0-9\(\)]+)?\[ ]+(\[ a-z]+)\[ ]+(\[0-9]+)" \
                       $show_data sltLine slt tp cf stt pts]} {
            } else {
                set DUTs_Slot_info(DUT$dut,slot$i,sysType) $tp
                set DUTs_Slot_info(DUT$dut,slot$i,hwModType) $tp
                set DUTs_Slot_info(DUT$dut,slot$i,state) $stt
                set DUTs_Slot_info(DUT$dut,slot$i,confType) $cf
                set DUTs_Slot_info(DUT$dut,slot$i,numPorts) "$pts"
                if {$passUp} {
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,sysType) $tp"
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,hwModType) $tp"
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,state) $stt"
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,confType) $cf"
                    puts $fd_g "set DUTs_Slot_info(DUT$dut,slot$i,numPorts) $DUTs_Slot_info(DUT$dut,slot$i,numPorts)"
                }
            }
        }
        set DUTs_info(DUT$dut,numSlots) $nslot
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,numSlots) $nslot"
        }
    }
    # Get version showVerVersion version builder date
    set os "INVALID"; set bld "INVALID"; set svv "INVALID"; set builder "INVALID"; set bdate "INVALID";
    if {![regexp -nocase {Image[ ]+:[ ]+(ExtremeXOS|NETGEAR|AviatOS)[ ]+version([ ]+[0-9]{2,2}\.[0-9]\.[0-9]\.[0-9]{1,2})[ ]+([a-zA-Z0-9_\-\.]+)?[by ]+([]a-zA-Z\-]+).*on[ ]+([a-zA-Z0-9\ :]+).*BootROM|Diagnostics} \
              $show_data versLine os bld svv builder bdate]} {
        puts "Show version info not foud"
        set DUTs_info(DUT$dut,version) "INVALID"
        set DUTs_info(DUT$dut,verTime) "INVALID"
        set DUTs_info(DUT$dut,relMaster) "INVALID"
        set DUTs_info(DUT$dut,sVVersion) "INVALID"
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,version) \"INVALID\""
            puts $fd_g "set DUTs_info(DUT$dut,verTime) \"INVALID\""
            puts $fd_g "set DUTs_info(DUT$dut,relMaster) \"INVALID\""
            puts $fd_g "set DUTs_info(DUT$dut,sVVersion) \"INVALID\""
        }
    } else {
        set svvList [split $svv "."]
        if {[llength $svvList] == 2 && ![regexp -nocase {[a-z]} $svv]} {
            set svv [string trim $bld]
        }
        if {[llength $svvList] == 1 && [string trim $svv] == "by"} {
            set svv [string trim $bld]
        }
        set DUTs_info(DUT$dut,version) "$bld"
        set DUTs_info(DUT$dut,verTime) "$bdate"
        set DUTs_info(DUT$dut,relMaster) "$builder"
        set DUTs_info(DUT$dut,sVVersion) "$svv"
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,verTime) \"$bdate\""
            puts $fd_g "set DUTs_info(DUT$dut,verTime) \"$bdate\""
            puts $fd_g "set DUTs_info(DUT$dut,relMaster) \"$builder\""
            puts $fd_g "set DUTs_info(DUT$dut,sVVersion) \"$svv\""
        }
    }
    # Bootrom
    set br "INVALID";
    if {![regexp -nocase {[ ]+on.*BootROM[ ]+:[ ]+([0-9]{1,2}\.[0-9]\.[0-9]\.[0-9]{1,2}|[0-9]{1,2}\.[0-9])} \
               $show_data bpLine br]} {
        puts "bootrom not found"
        set DUTs_info(DUT$dut,bootROM) "INVALID"
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,bootROM) \"INVALID\""
        }
    } else {
        set DUTs_info(DUT$dut,bootROM) $br
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,bootROM) $br"
        }
    }
    # License info
    set lic "INVALID"
    set fpack "INVALID"
    if {![regexp -nocase {Enabled License Level:.*\n[ ]+([ a-zA-Z]+).*Packs:.*\n[ ]+([ a-zA-Z0-9]+)} \
               $show_data bpLine lic fpack]} {
    } else {
        set DUTs_info(DUT$dut,license) [string trim $lic]
        set DUTs_info(DUT$dut,feature_licenses) "\"[string trim $fpack]\""
        if {$passUp} {
            puts $fd_g "set DUTs_info(DUT$dut,license) [string trim $lic]"
            puts $fd_g "set DUTs_info(DUT$dut,feature_licenses) $DUTs_info(DUT$dut,feature_licenses)"
        }
    }

    #
    # Show slot stuff
    #


    if {$passUp} {
        close $fd_g
    }
    logout;# For some reason to be discovered later, the spawnid tracking is not working
    _setShowOutput -screen on -log on -res_fmt on
}
# -------------------------------------------------------------------------------------
# proc _printDutsInfoVars
#
#   Dump the values set for DUTs_info for all DUTs
#
#
# Typical usage:
#  _printDutsInfoVars
# -------------------------------------------------------------------------------------  
proc _printDutsInfoVars {{type normal}} {
    global DUTs_info IKEYS MAIN IKEYTEXT

    if ![array exists DUTs_info] {
        result_debug "DUTs_info has not be set"
        return;
    }
    if {$type=="info"} {
        for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
            foreach infoKey $IKEYS {
                if [info exists DUTs_info(DUT$i,$infoKey)] {
                    puts "[format "%-45s = %-45s" "DUTs_info(DUT$i,$infoKey)" "$DUTs_info(DUT$i,$infoKey)"]"
                }
            }
        }
    } elseif {$type=="normal"} {
        for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
            puts "\n"
            result_debug "****** START DEVICE INFORMATION DUT$i ********"
            foreach infoKey $IKEYS {
                if [info exists DUTs_info(DUT$i,$infoKey)] {
                    result_debug "DUT$i $IKEYTEXT($infoKey) = $DUTs_info(DUT$i,$infoKey)"
                }
            }
        }
    } else {
        #    set rList [list "mod_current_test" "$cTest" "mod_name" "$modName" "queue_id" "$qId" \
        #         "mod_results" "complete"]
        #    handleOutput $s "[listToJson -mlist $rList -elem "TCLResult"]"
        for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
            set jout($i) ""
            foreach infoKey $IKEYS {
                if [info exists DUTs_info(DUT$i,$infoKey)] {
                    lappend jout($i) "$infoKey"
                    lappend jout($i) "$DUTs_info(DUT$i,$infoKey)"
                    #result_debug "DUT$i $IKEYTEXT($infoKey) = $DUTs_info(DUT$i,$infoKey)"
                }
            }
            puts "[listToJson -mlist $jout($i) -elem "DUT$i"]"
        }
    }

}
# -------------------------------------------------------------------------------------
# proc _printDUTSlotInfoVars
#
#
#
#
# -------------------------------------------------------------------------------------
proc _printDUTSlotInfoVars {} {
    global DUTs_Slot_info IKEYS ISLOTKEYS MAIN

    set slist "1 2 3 4 5 6 7 8 A B"

    if ![array exists DUTs_Slot_info] {
        result_debug "DUTs_Slot_info has not been set"
        return;
    }

    for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
        foreach infoKey $ISLOTKEYS {
            foreach s $slist {
                if [info exists DUTs_Slot_info(DUT$i,slot$s,$infoKey)] {
                    puts "[format "      %-45s = %-45s" "DUTs_Slot_info(DUT$i,slot$s,$infoKey)" "$DUTs_Slot_info(DUT$i,slot$s,$infoKey)"]"
                }
            }
        }
    }
}
# -------------------------------------------------------------------------------------
# proc WriteDutsInfoVarsToInit
#
#   After gathering test bed variables write them to the init file
#
# -------------------------------------------------------------------------------------
proc WriteDutsInfoVarsToInit {} {
    global DUTs_info IKEYS MAIN

    if ![array exists DUTs_info] {
        result_debug "DUTs_info has not be set"
        return;
    }
    if {![info exists MAIN(ifPipe)] || $MAIN(ifPipe) == "NULL"} {
        #open the init
    }
    for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
        foreach infoKey $IKEYS {
            if [info exists DUTs_info(DUT$i,$infoKey)] {
                puts $MAIN(ifPipe) "set DUTs_info(DUT$i,$infoKey) $DUTs_info(DUT$i,$infoKey)"
            }
        }
    }

}
# -------------------------------------------------------------------------------------
# proc _printMultiTaskOutput
#
#     set the variable internally in the multitask as
#    
#     DUTs_info(DUT$dut,show_output) $show_data
#
# Typical usage: _printMultiTaskOutput    
# -------------------------------------------------------------------------------------
proc _printMultiTaskOutput {{dutList "null"}} {
    global MAIN DUTs_info

    if {$dutList != "null"} {
        set DUTLIST $dutList
    } else {
        set DUTLIST $MAIN(DUTLIST)
    }

    foreach i $DUTLIST {
        set h1 "----------------------------------------------------------------"
        set ho "\n"
        append ho "$h1\n"
        append ho "                          DUT $i \n"
        append ho $h1
        result_debug $ho
        if {[info exists DUTs_info(DUT$i,show_output)]} {
            puts "[string trim $DUTs_info(DUT$i,show_output)]"
            result_pre "[string trim $DUTs_info(DUT$i,show_output)]"
        }
    }

}
# -------------------------------------------------------------------------------------
# Procedure: _get_duts_info
#
#
#
# -------------------------------------------------------------------------------------
proc _get_duts_info {s   p} {
    global MAIN DUTs_info
    set getInfoList ""
    for {set i 1} {$i<=$MAIN(NODECOUNT)} {incr i} {
        lappend getInfoList  "_get_HW_DUTs_info -dut $i -checkOperational 0"
    }
    MultiTask $getInfoList
    if {$s=="show"} {
        _printMultiTaskOutput;
    }
    if {$p=="print"} {
        _printDutsInfoVars
    }
}
