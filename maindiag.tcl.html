<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>maindiag.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#maindiag.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>maindiag.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="maindiag.tcl-annot.html">annotations</a> | <a href="maindiag.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>


source ../Lib/mainLib.tcl

<strong><a name="::::print_usage_6">proc <a href="maindiag.tcl-annot.html#::::print_usage">::::print_usage</a></a></strong> {} {
   puts &#34;\r&#34;
   puts {Usage: maindiag.tcl -module &lt;module&gt; -sfilePath &lt;diagnostics software file&gt; -cfg &lt;config file&gt; [-lst &lt;test list&gt;] [-regPath &lt;regression Path&gt;]}
   puts {   &lt;module&gt;: Mariner (case insensitive, nearest match accepted)}
   puts {   &lt;sfilePath&gt;: Path of the diagnostic software name (e.g. /tftp/gen_test_pmon_v1064.elf)}
   puts {   &lt;cfg&gt;: Path of the config file name (e.g. short/p1_mar_diag.cfg)}
   puts {   [&lt;test list&gt;]: test list (all|pass|quick|userDefined). By default all, userDefined is a filename value in module)}
   puts {   [&lt;regPath&gt;]: regression Path (DiagnosticsTest. By default DiagnosticsTest, case insensitive, nearest match accepted)}
   puts &#34;\r&#34;
}

;<span class="comment-line"># Description: Generates summary file of execution durations</span>
;<span class="comment-line"># NOTE: calculateTestsToRuna assumes current directory contains completetests.lst</span>
;<span class="comment-line"># If standard list type is NOT given we just display basic Setup and CheckConn</span>
;<span class="comment-line"># times along with total run time.</span>
<strong><a name="::::generateExecutionSummary_21">proc <a href="maindiag.tcl-annot.html#::::generateExecutionSummary">::::generateExecutionSummary</a></a></strong> { execTimeFileName listFile module \
	{setupDur 0} {checkConnDur 0} {totalTestDur 0} \
	{fileName &#34;execSummary.txt&#34;} } {
    
    set quickExecDuration &#34;NA&#34;
    set passExecDuration &#34;NA&#34;
    set allExecDuration &#34;NA&#34;

    ;<span class="comment-line"># If we use standard list type, calculate each.</span>
    if { ($listFile == &#34;quick&#34;) || ($listFile == &#34;pass&#34;) || ($listFile == &#34;all&#34;) } {

	if { ! [file exists &#34;completetests.lst&#34;] } {
	    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;File completetests.lst not found in directory [pwd]&#34;
	    return 0
	}   

	set platform &#34;Mariner&#34;;
	
	;<span class="comment-line"># Format the Execution Time file into a {{testcase duration} .. } format</span>
	set formattedExecTimeFile [parseExecTimeFile $execTimeFileName]
	
	;<span class="comment-line"># Generate testcase arrays of each run time (quick/pass/all)</span>
	set testsToRunQuick [calculateTestToRun &#34;quick&#34; $platform]
	array set tests_to_runQ $testsToRunQuick
	;<span class="comment-line"># Calculate duration for this list type</span>
	set quickExecDuration [calcExecTime \
		$formattedExecTimeFile \
		[combineAndStripTestList tests_to_runQ] ]
	
	if {($listFile == &#34;pass&#34;) || ($listFile == &#34;all&#34;) } {
	    set testsToRunPass [calculateTestToRun &#34;pass&#34; $platform]
	    array set tests_to_runP $testsToRunPass
	    ;<span class="comment-line"># Calculate duration for this list type</span>
	    set passExecDuration [calcExecTime \
		    $formattedExecTimeFile \
		    [combineAndStripTestList tests_to_runP] ]
	}
	if {$listFile == &#34;all&#34;} {
	    set testsToRunAll [calculateTestToRun &#34;all&#34; $platform]
	    array set tests_to_runA $testsToRunAll
	    ;<span class="comment-line"># Calculate duration for this list type</span>
	    set allExecDuration [calcExecTime \
		    $formattedExecTimeFile \
		    [combineAndStripTestList tests_to_runA] ]
	}
    } 
    
    set execSummaryFileName &#34;[<a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$fileName&#34;
    set fdout [open  $execSummaryFileName &#34;w+&#34;]

    puts $fdout &#34;----- Execution Time Summary For $module -----&#34;
    puts $fdout &#34;   SETUP: $setupDur  \t([formatSeconds $setupDur])&#34;
    puts $fdout &#34;CHK_CONN: $checkConnDur  \t([formatSeconds $checkConnDur])&#34;
    puts $fdout &#34;   QUICK: $quickExecDuration  \t([formatSeconds $quickExecDuration])&#34;
    puts $fdout &#34;    PASS: $passExecDuration  \t([formatSeconds $passExecDuration])&#34;
    puts $fdout &#34;     ALL: $allExecDuration  \t([formatSeconds $allExecDuration])&#34;
    puts $fdout &#34;\nTOTAL CURRENT RUN:  $totalTestDur  ([formatSeconds $totalTestDur])&#34;

    return 1
}


<strong><a name="::::executeTestsToRun_83">proc <a href="maindiag.tcl-annot.html#::::executeTestsToRun">::::executeTestsToRun</a></a></strong> {testsToRun} {

    global numMSM
    global msmList
    global MSMA_CONNECT
    global MSMB_CONNECT
    global connect
    global script
    global execTimeFileName

    set returnFlag &#34;testCompleted&#34;

    ;<span class="comment-line"># For backward compatibility with previous eval command</span>
    ;<span class="comment-line"># we need to handle array like eval did, rather than using foreach </span>
    set pID [pid]
    set tmpFileName &#34;Tmp/testsToRun_$pID&#34;
    set fdin_ttr [open  $tmpFileName &#34;w+&#34;]

    puts $fdin_ttr $testsToRun

    set fdin_execTime [open $execTimeFileName &#34;RDWR APPEND CREAT&#34;]
    ;<span class="comment-line"># Dump tests to run, so we can see what we intended to run.</span>
    flush $fdin_execTime

    flush $fdin_ttr
    seek $fdin_ttr 0 start
    
    while {[gets $fdin_ttr line] != -1} {

	;<span class="comment-line"># Tag START time</span>
	set timeStart [clock seconds];

	if [catch {eval $line} reason] {
            global errorInfo
	    puts &#34;errorInfo: $errorInfo&#34;
	    puts &#34;****ERROR REASON: $reason&#34;
	    ;<span class="comment-line"># Write report out</span>
	    <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Failed to continue test - Reason: &lt;$reason&gt;&#34;
	    <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to continue - Reason: $reason\n&#34;
	    <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;errorInfo: $errorInfo&#34;
	    <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	    <a name="::close_result_file(1)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
	    <a name="::fix_report_level(1)"><a href="./report.tcl.html#::fix_report_level_306">::fix_report_level</a></a>
	    ;<span class="comment-line"># trim whitespace</span>
	    set line [string trim $line] 
	    if { ! [regexp &#34;invalid command name\ *\&#34;$line\&#34;&#34; $reason] } {
		;<span class="comment-line"># Clean up DUTs in case testcase ended abruptly</span>
		;<span class="comment-line"># But NOT for bad testcase name passed in.  Saves some unfonf time</span>
<span class="comment-line">#		foreach msm $msmList {</span>
<span class="comment-line">#		    global MSM${msm}_CONNECT</span>
<span class="comment-line">#		    global MSM${msm}_SETUP</span>
<span class="comment-line">#		    set connect [set MSM${msm}_CONNECT]</span>
<span class="comment-line">#		    set script [set MSM${msm}_SETUP]</span>
<span class="comment-line">#		    RunSetupScript $connect $script</span>
<span class="comment-line">#		}</span>
	    }

	} else {
            <span class="comment-line"># Checking reason for -1, in case init returns before full run</span>
            if {$reason==-1} {
               return $reason
            }
	    set tc [parseTestCaseFromLine $line]
	    if {$tc != &#34;&#34;} {

		;<span class="comment-line"># Log END time</span>
		set timeEnd [clock seconds];
		set duration [expr $timeEnd - $timeStart]
		
		;<span class="comment-line"># write to testcase and duration to execTime.txt</span>
		;<span class="comment-line"># Write out duration to Execution Time File</span>
		;<span class="comment-line"># Add testcase: and duration: for easier parsing</span>
		<a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;testcase:$tc\tduration:$duration&#34;

		puts $fdin_execTime &#34;testcase:$tc\tduration:$duration&#34;
		flush $fdin_execTime
	    }
	}
    }

    close $fdin_ttr

    close $fdin_execTime
    
    catch {file delete -force &#34;$tmpFileName&#34;} reason

    return $returnFlag
}

   
   source ../Lib/parse_args.tcl

   <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> main $argv {
      module &#34;null&#34;
      cfg &#34;null&#34;
      lst &#34;all&#34;
      tcList &#34;&#34;
      regPath &#34;diagnostics&#34;
      sfilePath &#34;&#34;
   }

   <span class="comment-line"># checking command parameters</span>
   if {$argc&lt;3 || $sfilePath == &#34;&#34;} {
      puts &#34;Not enough parameters&#34;
      <a name="::::print_usage(1)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
      puts stderr &#34;Not enough parameters&#34;
      return
   }

   set diagFile &#34;$sfilePath&#34;;

   <span class="comment-line"># Get the regression types</span>
   set regressions [glob -- ../*]
   set regNames &#34;&#34;
   foreach regName $regressions {
      if {[file isdir $regName]} {
         lappend regNames $regName
      }
   }

   set LIB_PATH &#34;../../Lib&#34;
   lappend auto_path $LIB_PATH

   puts &#34;DEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;

   foreach regName $regNames {
      set match &#34;&#34;
      set str &#34;&#34;
      if {[regexp -nocase &#34;(^../$regPath.*)&#34; $regName match str]} {
         set regPath $str
      }
   }
   ;<span class="comment-line"># We append path info later, so we save raw module name for use later</span>
   set modName $module
   
   <a name="::::gen_index(1)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;./../Lib&#34;
  
   set modules [glob -- $regPath/*]
   set regressionModules &#34;&#34;
   foreach moduleName $modules {
      if {[file isdir $moduleName]} {
         lappend regressionModules $moduleName
      }
   }

   foreach regressionModule [lsort $regressionModules] {
      set match &#34;&#34;
      set str &#34;&#34;
      if {[regexp -nocase &#34;(^$regPath/$module.*)&#34; $regressionModule match str]} {
         set module $str
	 break
      }
   }
   set sourceFile &#34;&#34;
   <span class="comment-line"># backtracked path needed for other utilties outside main to work</span>
   if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
      puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
      puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
      exit -1
   }

   if {$cfg != &#34;null&#34;} {
       set sourceFile $cfg
       if {([regexp -nocase &#34;^short&#34; $sourceFile]&amp;&amp;[regexp -nocase {/} $sourceFile]) || \
           [regexp -nocase &#34;^pt&#34; $sourceFile]} {
          puts &#34;regPath:$regPath  module:$module  sourceFile: $sourceFile&#34;
          <span class="comment-line">#set sourceFile [format %s/%s/%s $regPath $module $sourceFile]</span>
          set sourceFile [format %s/%s $module $sourceFile]
          set sourceFile [string trim $sourceFile];
       } elseif {![regexp -nocase &#34;^cfg&#34; $sourceFile] &amp;&amp; ![regexp -nocase {/} $sourceFile]} {
          if {[file exists $sourceFile]==0} {
             set sourceFile [format %s/%s cfg $sourceFile]
             set sourceFile [string trim $sourceFile];
          }
       }
       puts &#34;Using config file: ($sourceFile)&#34;
   }

   if {[file exists $sourceFile] == 0} {
      puts &#34;Cannot find config file: $sourceFile\n&#34;
      puts stderr &#34;Cannot find config file: $sourceFile&#34;
      return
   }

   puts &#34;************** ABOUT TO source $sourceFile *****************&#34;
   catch {source $sourceFile} reason

   if {![file isdirectory ../main/Tmp]} {
      file mkdir ../main/Tmp
   }
   set optionalPath &#34;&#34;

<span class="comment-line"># ## CHANGE TO USE MSMA_CONNECT serial port IP Address as unique ID ###</span>
   set initFileId $MSMA_CONNECT

   cd $module

<span class="comment-line">############################################################</span>
<span class="comment-line"># Expect Hacks</span>
<span class="comment-line">############################################################</span>

<span class="comment-line"># This is necessary to get an absolute path for logging</span>
set REG_PATH [pwd]

<span class="comment-line">#load {expect52.dll}</span>
if {$tcl_platform(platform) == &#34;windows&#34;} {
  load &#34;expect52.dll&#34;
} else {
  load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
}

log_user 0

<span class="comment-line">############################################################</span>
<span class="comment-line"># NEW PARSE ARGS SECTION</span>
<span class="comment-line">############################################################</span>
<span class="comment-line">############################################################</span>
<span class="comment-line">############################################################</span>
set returnFlag &#34;NULL&#34;

<span class="comment-line">#############################################################</span>
<span class="comment-line"># Arg description</span>
<span class="comment-line">#############################################################</span>
<span class="comment-line"># -cfg smokeATM8.cfg   ;Traditional config file to be loaded in each module</span>
<span class="comment-line"># -module null ;Module to be run a dir half name would work as the code puts wildcards</span>
<span class="comment-line">############################################################</span>
<span class="comment-line"># Parse Args</span>
<span class="comment-line">############################################################</span>
   <span class="comment-line">## module setup</span>
   if {$module != &#34;null&#34;} {
      puts &#34;Setting to run regression for module $module&#34;
   }
   
<span class="comment-line">############################################################</span>
<span class="comment-line"># Create Directories</span>
<span class="comment-line">############################################################</span>

   if {![file isdirectory Report]} {
      file mkdir Report
   }
   if {![file isdirectory Result]} {
     file mkdir Result
   }
   if {![file isdirectory Tmp]} {
      file mkdir Tmp
   }
   if {![file isdirectory Log]} {
      file mkdir Log
   }
   set initFile &#34;Tmp/DUTINFO_$initFileId&#34;
   set fn [file tail $cfg]
   set fn [string trim $fn]
   set fn [file rootname $fn]
   append initFile &#34;_&#34;
   append initFile $fn
   append initFile &#34;.txt&#34;
   set auto_path [linsert $auto_path 0 . ]
   <a name="::::gen_index(2)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> .

if {[file exists $initFile]} {
   if {[catch {file delete $initFile} reason]} {
<span class="comment-line">#      puts &#34;Failed to delete init file $initFile: $reason&#34;</span>
   }
}

<span class="comment-line"># generate a new initialization file</span>
if {(![file exists $initFile])} {
   catch {open $initFile &#34;w&#34;} fast
   if {[regexp -nocase &#34;denied&#34; $fast]} {
      ;
   }
}

<span class="comment-line">############################################################</span>

set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set passCount 0
set failCount 0
set skipCount 0
set testDuration 0
set testHour 0
set testMin 0
set testSec 0
set resultDir &#34;NULL&#34;


puts &#34;maindiag.tcl CUR DIR: [pwd]&#34;

set fd_res [<a name="::open_result_file(1)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;main&#34;]
result_h1 &#34;[file tail [pwd]] Test&#34;

<span class="comment-line">#added following definition to aid per module report-mailing</span>
global DUTs_info

set DUTs_info(current_module) $module

set returnFlag [DiagSysSetup];

set tSetupEnd [clock seconds]
set tSetupDuration [expr $tSetupEnd - $tStartTime]

<span class="comment-line"># If tests_to_run not defined so far, try to source now</span>
<span class="comment-line"># If this were a re-run, we would use a pt_xxx cfg file which would contain</span>
<span class="comment-line"># tests_to_run in it.  In this case, we don't need to &#34;figure out&#34; which</span>
<span class="comment-line"># tests to run.</span>
if {![info exists tests_to_run]} {
   set fName &#34;&#34;
<span class="comment-line">#   regexp -nocase &#34;couldn't read file (.*):&#34; $reason match fName</span>
<span class="comment-line">#   set fn [string trimleft $fName &#34;\&#34;&#34;]</span>
<span class="comment-line">#   set fm [string trimright $fn &#34;\&#34;&#34;]</span>
<span class="comment-line">#   puts &#34;DEBUG: fm: $fm&#34;</span>
<span class="comment-line">#   source $fm</span>
  
   set platform &#34;Mariner&#34;;
   set testsToRun [calculateTestToRun $lst $platform]
   array set tests_to_run $testsToRun

} else {
    ;<span class="comment-line"># Zero out so we don't try to generate execution times</span>
    set lst &#34;none&#34;
}

<a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;tests to run [parray tests_to_run]&#34;

    set execTimeFileName &#34;[<a name="::get_result_dir(2)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/execTime.txt&#34;

    <a name="::::AddTestbedInfoToDUTs_info(1)"><a href="./SystemSetup.tcl.html#::::AddTestbedInfoToDUTs_info_905">::::AddTestbedInfoToDUTs_info</a></a>

    if {$tcList != &#34;&#34;} {
	global lst
	<a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Test case list defined on command line: $tcList&#34;
	unset tests_to_run
	set tests_to_run [list]
	foreach testcase $tcList {
	    set tests_to_run &#34;$tests_to_run\n$testcase&#34;
	}
	set lst &#34;custom&#34;
    }

    if { [array size tests_to_run] == 0 } {
	;<span class="comment-line"># Convert old list style to array</span>
	set tempList $tests_to_run
	unset tests_to_run
	set tests_to_run(all) $tempList
    }

    set testtorunNo 1

    ;<span class="comment-line"># Array of tests_to_run() lists. i.e. tests_to_run(all), tests_to_run(7.0),etc.</span>
    set indexList [array names tests_to_run]      
    mainSort indexList
    
    foreach arrayIndex $indexList {      
	set ver [string tolower $arrayIndex]
	
	if { (&#34;$ver&#34; == &#34;all&#34;) || (&#34;$ver&#34; == &#34;null&#34;) \
		|| [<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> $ver [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 ]] &lt;= 0 } {

	    if {[regexp -nocase &#34;clitest&#34; $regPath]} {
		set returnFlag [executeCLITestsToRun $tests_to_run($ver) \
			$regPath $testtorunNo]

		if {$returnFlag == &#34;testCompleted&#34;} {
		    incr testtorunNo
		}
	    } else {		
		set returnFlag [<a name="::executeTestsToRun(1)"><a href="./maindiag.tcl.html#::executeTestsToRun_83">::executeTestsToRun</a></a> $tests_to_run($ver)]
                if {$returnFlag==-1} {
                   break
                }
	    }

	} else {
	    set returnFlag &#34;testSkipped&#34;
	}
    }       

set tEndTime [clock seconds]
set testDuration [expr $tEndTime-$tStartTime]

<a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n*** Time for [file tail [pwd]] Regression test = $testDuration seconds&#34;
<a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;***    ( [formatSeconds $testDuration] )\n\n&#34;

;<span class="comment-line"># Write all buffered data into result file.</span>
if {$fd_res != &#34;&#34;} {
    catch {flush $fd_res} result
    if {$result != &#34;&#34;} { <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$result&#34; }
}

<a name="::save_test_report(1)"><a href="./report.tcl.html#::save_test_report_329">::save_test_report</a></a> &#34;[<a name="::get_result_dir(3)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34;
my_gen_text_report &#34;[<a name="::get_result_dir(4)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34; &#34;[<a name="::get_result_dir(5)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.txt&#34; &#34;[file tail [pwd]]&#34; $sourceFile
my_gen_text_report &#34;[<a name="::get_result_dir(6)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34; &#34;stdout&#34; &#34;[file tail [pwd]]&#34; $sourceFile

flush stdout
flush stderr

;<span class="comment-line"># Generate a Execution Summary File only if we used &#34;all/pass/quick&#34; list.</span>
if {[file exists $execTimeFileName] } {

    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Generating Execution Summary File&#34;
    if {[<a name="::generateExecutionSummary(1)"><a href="./maindiag.tcl.html#::generateExecutionSummary_21">::generateExecutionSummary</a></a> $execTimeFileName $lst $module \
	    &#34;$tSetupDuration&#34; &#34;0&#34; $testDuration] == 0} {
	<a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;...No execution summary file was generated...&#34;
    }

} else {    
    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Execution Summary File NOT generated&#34;
    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$execTimeFileName present:  [file exists $execTimeFileName]&#34;
    <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;lst file: $lst&#34;
}

<a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;maindiag.tcl returnFlag: $returnFlag&#34;
if { $returnFlag == &#34;testCompleted&#34; || $returnFlag == &#34;testSkipped&#34; } {
    ;<span class="comment-line"># Move the complete result directory to report directory</span>
    <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Moving contents of [<a name="::get_result_dir(7)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>] to Report directory&#34;
    my_move_result_directory $optionalPath &#34;&#34; $execTimeFileName
} else {
    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;main.tcl error $returnFlag&#34;
    <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Report NOT moved to Report directory&#34;
}

;<span class="comment-line"># Write return code to stderr so runall_monitor.tcl can &#34;catch&#34; the value</span>
;<span class="comment-line"># If main.tcl terminates abnormal somewhere else in the code without writing</span>
;<span class="comment-line"># to stderr, we can &#34;catch&#34; that.</span>

puts stderr $returnFlag
flush stderr

cd ..

<a name="::close_result_file(2)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
