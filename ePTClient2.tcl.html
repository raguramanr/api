<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>ePTClient2.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#ePTClient2.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>ePTClient2.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="ePTClient2.tcl-annot.html">annotations</a> | <a href="ePTClient2.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">####################### Global Variables initialization Starts Here ##################################</span>
set numFrames 1
set stream_name &#34;s1&#34;
set framesize &#34;60&#34;
set frameSizeType &#34;sizeFixed&#34;
set frameSizeMAX &#34;1514&#34;
set frameSizeMIN &#34;60&#34;
set rateMode &#34;fixed&#34;
set percentPacketRate &#34;100&#34;
set fcs &#34;good&#34;
set fir &#34;true&#34;
set patternType &#34;nonRepeat&#34;
set dataPattern &#34;1234&#34;
set sa &#34;00debb000001&#34;
set da &#34;00debc000002&#34;
set saRepeatCounter &#34;idle&#34;
set daRepeatCounter &#34;idle&#34;
set numSA &#34;0&#34;
set numDA &#34;0&#34;
set frameType &#34;08 00&#34;
set dma &#34;fixed&#34;
set cfi  &#34;0&#34;
set vlan_mode &#34;vIdle&#34;
set repeat &#34;1&#34;
set userPriority &#34;0&#34;
set protocolTagId &#34;8100&#34;
set vlan_id &#34;0&#34;
set name &#34;mac&#34;
set enable802dot1qTag &#34;false&#34;
set ethernetType &#34;noType&#34;
set appName &#34;none&#34;
set captureFilterEnable &#34;true&#34;
set captureTriggerEnable &#34;true&#34;
set userDefinedStat1Enable &#34;false&#34;
set userDefinedStat1DA &#34;00:00:00:00:00:00&#34;
set userDefinedStat1SA &#34;00:00:00:00:00:00&#34;
set captureFilterPattern &#34;0&#34;
set captureTriggerPattern &#34;0&#34;
set captureTriggerDA &#34;00:00:00:00:00:00&#34;
set captureFilterDA &#34;00:00:00:00:00:00&#34;
set userDefinedStat1Pattern &#34;0&#34;
set userDefinedStat2Enable &#34;0&#34;
set pattern1 &#34;0000&#34;
set patternOffset1 &#34;14&#34;
set DA1 &#34;00:00:00:00:00:00&#34;
set SA1 &#34;00:00:00:00:00:00&#34;
set matchType1 &#34;00:00:00:00:00:00&#34;
set ipProtocol &#34;ip&#34;
set destClass &#34;classC&#34;
set destIpAddr &#34;127.0.0.1&#34;
set destIpMask &#34;255.255.255.0&#34;
set destIpAddrMode &#34;ipIdle&#34;
set sourceClass &#34;classC&#34;
set sourceIpAddr &#34;127.0.0.1&#34;
set sourceIpMask &#34;255.255.255.0&#34;
set sourceIpAddrMode &#34;ipIdle&#34;
set sourceIpAddrRepeatCount &#34;1&#34;
set destIpAddrRepeatCount &#34;1&#34;
set destMacAddr &#34;00 A1 F1 00 00 02&#34;
set destDutIpAddr &#34;127.0.0.1&#34;
set ttl &#34;64&#34;
set useValidChecksum &#34;true&#34;
set fragment &#34;0&#34;
set options &#34;&#34;
set delay &#34;0&#34;
set throughput &#34;0&#34;
set reliability &#34;0&#34;
set precedence &#34;000&#34;
set lengthOverride &#34;0&#34;
set totalLength &#34;20&#34;
set identifier &#34;6558&#34;
set sourceNetwork &#34;00.00.00.00&#34;
set sourceNetworkMaskSelect &#34;0&#34;
set sourceNode &#34;000000000000&#34;
set sourceSocket &#34;0400&#34;
set destNetwork &#34;00.00.00.00&#34;
set destNode &#34;000000000000&#34;
set destSocket &#34;0400&#34;
set command &#34;ripRequest&#34;
set version &#34;2&#34;
set familyId &#34;2&#34;
set routeTag &#34;00&#34;
set ipAddress &#34;0.0.0.0&#34;
set subnetMask &#34;0.0.0.0&#34;
set nextHop &#34;0.0.0.0&#34;
set metric &#34;1&#34;
set opCode &#34;01&#34;
set hwType &#34;01&#34;
set transactionID &#34;8a9ab8e8&#34;
set seconds &#34;7680&#34;
set dhcp_flags &#34;0000&#34;
set clientIpAddr &#34;127.0.0.1&#34;
set yourIpAddr &#34;127.0.0.1&#34;
set serverIpAddr &#34;0.0.0.0&#34;
set relayAgentIpAddr &#34;0.0.0.0&#34;
set clientHwAddr &#34;00:A1:F1:00:00:01&#34;
set optionData &#34;ff&#34;
set version &#34;1&#34;
set igmp_type &#34;16&#34;
set groupIpAddress &#34;224.0.0.1&#34;
set maxResponseTime &#34;10&#34;
set igmp_mode &#34;1&#34;
set repeatCount &#34;1&#34;
set sourcePort &#34;0000&#34;
set destPort &#34;0000&#34;
set sequenceNumber &#34;0&#34;
set synchronize &#34;0&#34;
set finished &#34;0&#34;
set resetConnection &#34;0&#34;
set acknowledgeValid &#34;0&#34;
set pushFunctionValid &#34;0&#34;
set urgentPointerValid &#34;0&#34;
set type &#34;08&#34;
set code &#34;00&#34; 
set id &#34;0&#34;
set sequence &#34;0&#34;
set sourceProtocolAddr &#34;127.0.0.1&#34;
set destProtocolAddr &#34;127.0.0.1&#34;
set sourceProtocolAddrMode &#34;arpIdle&#34;
set destProtocolAddrMode &#34;arpIdle&#34;
set sourceHardwareAddr &#34;00:A1:F1:00:00:01&#34;
set destHardwareAddr &#34;FF:FF:FF:FF:FF:FF&#34;
set sourceProtocolAddrRepeatCount &#34;1&#34;
set destProtocolAddrRepeatCount &#34;1&#34;
set operation &#34;1&#34;
set sourceHardwareAddrMode &#34;arpIdle&#34;
set sourceHardwareAddrRepeatCount &#34;1&#34;
set destHardwareAddrMode &#34;arpIdle&#34;
set destHardwareAddrRepeatCount &#34;1&#34;
set trafficClass &#34;3000&#34;
set flowLabel &#34;00&#34;
set hopLimit &#34;01&#34;
set sourceAddr &#34;3555:5555:6666:7777:7777:8888:8888&#34;
set sourceMask &#34;ffff:ffff:ffff:ffff:ffff:ffff:ffff&#34;
set destAddr &#34;FE80:0:0:0:201:3FF:FE00:100&#34;
set destMask &#34;ffff:ffff:ffff:ffff:ffff:ffff:ffff&#34;
set nextHeader &#34;06&#34;
set sourceAddrMode &#34;ipV6Idle&#34;
set sourceAddrRepeatCount &#34;1&#34;
set destAddrMode &#34;ipV6Idle&#34;
set destAddrRepeatCount &#34;1&#34;
set destMacAddr &#34;00E02B000001&#34;
set sourceudpPort &#34;0000&#34;
set destudpPort &#34;0000&#34;
set checksumMode &#34;0000&#34;
set enable &#34;false&#34;
set continuousCount &#34;false&#34;
set initval &#34;00&#34;
set offset &#34;0&#34;
set countertype &#34;c8&#34;
set statAllStats  &#34;0&#34;
set statFramesSent &#34;0&#34; 
set getstatAllStats &#34;0&#34;
set protocol_offset &#34;0&#34;
set getRatestatAllStats &#34;0&#34;  
<span class="comment-line">####################### Global Variables initialization Ends Here ##################################</span>

<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure: ePTServer_read</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Reads the buffer from the TclServer socket</span>
<span class="comment-line">#</span>
<span class="comment-line"># Results:</span>
<span class="comment-line">###############################################################################</span>
if { 0 } {
<strong><a name="::::ePTServer_read_166">proc <a href="ePTClient2.tcl-annot.html#::::ePTServer_read">::::ePTServer_read</a></a></strong> {aa} {
after 500
set err [catch {set data1 [gets $aa data]} errmsg]
if {$err != 0} {
puts &#34;Error &lt;$aa&gt;: $errmsg&#34;
} else {
<span class="comment-line"># Process incoming messages here:</span>
puts &#34;Server sent:$data&#34;
return $data
}
}
}
<strong><a name="::::ePTServer_read_178">proc <a href="ePTClient2.tcl-annot.html#::::ePTServer_read">::::ePTServer_read</a></a></strong> {socket} \
{
    variable buffer
    after 1500
    set buffer &#34;&#34;
    set length -1
	if {[eof $socket] || [catch {gets $socket buffer}]} {
	<span class="comment-line"># end-of-file or abnormal connection drop</span>
<span class="comment-line">#        catch {close $socket}</span>
        puts &#34;Error &lt;$socket&gt;: $errmsg&#34;
    } else {
        puts &#34;buffer=$buffer&#34;
<span class="comment-line">#        flush $socket </span>
        return $buffer
    }
}
<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTGettingPrefix</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTGettingPrefix_197">proc <a href="ePTClient2.tcl-annot.html#::::ePTGettingPrefix">::::ePTGettingPrefix</a></a></strong> {address} {

set address_list [split $address &#34;:&#34;]
set address_len  [llength $address_list]
set append_len  [expr 9 - $address_len]
puts &#34;$append_len&#34;
set append_pre &#34;&#34;
set prefix &#34;64&#34;

for {set i 0} {$i &lt; $append_len} {incr i} {

   append append_pre &#34;:0&#34;

}
   append append_pre &#34;:&#34;

 regsub -all &#34;::&#34; $address $append_pre exp_address

  puts &#34;Expanded Address $exp_address&#34;
set address_list [split $exp_address &#34;:&#34;]
set address_prefix &#34;&#34;

 set trunk_len [expr $prefix / 16]

 for {set i 0} {$i &lt; $trunk_len} {incr i} {

  append address_prefix [lindex $address_list $i]

if {!($i == [expr $trunk_len -1])} {
  append address_prefix :
}
 }
   puts &#34;ADDRESS Prefix $address_prefix&#34;
   return $exp_address
}

<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTConnectToChassis</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This procedure connects to a list of chassis. An ID number is assigned to</span>
<span class="comment-line">#              the chassis in sequence starting from 1 in the order that the list is passed.</span>
<span class="comment-line">#              The first chassis in the list is assigned as the master chassis.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    chassisList - The list of hostnames or IP addresses of chassis in a chain</span>
<span class="comment-line">#    cableLength - Optional.  The length of the cables between the chassis.  If not passed in,</span>
<span class="comment-line">#                  then uses cable3feet.  Note - may be a list of lengths, one for each chassis</span>
<span class="comment-line">#                  in the chassisList.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">#    0 : if no error</span>
<span class="comment-line">#    1 : if error connecting to chassis</span>
<span class="comment-line">#    2 : if version mismatch, ePTTcl_versionMismatch</span>
<span class="comment-line">#    3 : if chassis timeout occurred, ePTTcl_chassisTimeout</span>
<span class="comment-line">#    4 : if connection interrupted by user</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTConnectToChassis_253">proc <a href="ePTClient2.tcl-annot.html#::::ePTConnectToChassis">::::ePTConnectToChassis</a></a></strong> {} \
{
	global clientSocket portmap_List
		set mac_address [exec ifconfig eth0 | grep -i &#34;HWaddr&#34;]
		set mac_address [lindex $mac_address 4]
		set ip_address [exec ifconfig eth0 | grep -i &#34;inet addr:&#34;]
		set ip_address [lindex [split [lindex $ip_address 1] &#34;:&#34;] 1]
                set chassisList1 &#34;1:1:1#1:1:2#1:1:3#1:1:4#1:1:5#1:1:6#1:1:7#1:1:8&#34;
		set portmap_List &#34;01#$chassisList1#$clientSocket#$ip_address#$mac_address&#34;
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $portmap_List]
		flush $clientSocket
                after 200
		}
           
<span class="comment-line">#        set ePTConnectToChassis_output [ePTServer_read $clientSocket]</span>
	return 0 
}

<span class="comment-line">#	return $portmap_List</span>
<span class="comment-line">#}</span>

<span class="comment-line">#######################################################################################</span>
<span class="comment-line">#  Procedure : ePTputs</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Description:  This command is similar to &#34;puts&#34; except that it has an update :command</span>
<span class="comment-line"># so that the output queue gets flushed and the message gets printed immediately. In</span>
<span class="comment-line"># Window 95/NT platform, the &#34;puts&#34; command does not print the messages rightaway.</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Arguments :</span>
<span class="comment-line">#       args - Message to display</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTputs_286">proc <a href="ePTClient2.tcl-annot.html#::::ePTputs">::::ePTputs</a></a></strong> {args} \
{
	catch {
		if {[lindex $args 0] == &#34;-nonewline&#34;} {
			set args [lreplace $args 0 0]
				puts -nonewline [join $args &#34; &#34;]
		} else {
			puts [join $args &#34; &#34;]
		}
<span class="comment-line"># Reported that the update blocks the display on Solaris using wish8.0</span>
<span class="comment-line"># so use update idletasks instead</span>
<span class="comment-line">#		update</span>
	}
}
<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTDisconnectTclServer</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This procedure disconnects from the Server</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    serverName - UNUSED.  Still exists for backwards script support</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTDisconnectTclServer_310">proc <a href="ePTClient2.tcl-annot.html#::::ePTDisconnectTclServer">::::ePTDisconnectTclServer</a></a></strong> {{serverName &#34;&#34;}} \
{
<span class="comment-line">#global clientSocket</span>
<span class="comment-line">#	set retCode 0</span>

<span class="comment-line">#	if {[info exists clientSocket]} {</span>
<span class="comment-line">#		set retCode [close $clientSocket]</span>
<span class="comment-line">#	}</span>
<span class="comment-line">#       set ePTDisconnectTclServer_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    map       </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to map the T.G ports              </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::map_335">proc <a href="ePTClient2.tcl-annot.html#::::map">::::map</a></a></strong> {add args} \
{
	global tx_port rx_port direction 
		set tx_rx_ports $args
                puts &#34;INSIDE map Proc -------------&gt; TX_RX PORTS : $tx_rx_ports&#34;
		set tx_port [join [lrange $tx_rx_ports 0 2] &#34;:&#34;]
		set rx_port [join [lrange $tx_rx_ports 3 5] &#34;:&#34;]
		if {[lrange $tx_rx_ports 6 8] != &#34;&#34;} {
			set rx_port [join [lrange $tx_rx_ports 6 8] &#34;:&#34;]
				set tx_port [join [lrange $tx_rx_ports 9 11] &#34;:&#34;]
				set direction &#34;2way&#34;
		} else {
			set direction &#34;1way&#34;
		}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    card      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a port in client side.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::card_363">proc <a href="ePTClient2.tcl-annot.html#::::card">::::card</a></a></strong> {option args} \
{
puts &#34;-------------------------- inside card---&#34;
switch $option {

  &#34;get&#34; {
        global cardportget clientSocket
        set getVariable_list $args
        set cardportget [join $getVariable_list &#34;#&#34;]
        set portget_mac &#34;29#$cardportget&#34;
	set retCode [puts $clientSocket $portget_mac]
	flush $clientSocket
        after 200
	}
   &#34;cget&#34; {
        global portcount clientSocket
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == &#34;-portCount&#34;} {
        set dummy_data &#34;Getting Port Count&#34; 
	set dummy_data &#34;30#$dummy_data&#34;
	set retCode [puts $clientSocket $dummy_data]
	flush $clientSocket
        after 200
        set portcount [<a name="::ePTServer_read(1)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        return $portcount
      }
}
}
}       
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    port      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a port in client side.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<span class="comment-line">#         if {$portget_mac == &#34;1:1:9&#34; || $portget_mac == &#34;1:1:10&#34; || $portget_mac == &#34;1:1:11&#34; || $portget_mac == &#34;1:1:12&#34; || $portget_mac == &#34;1:1:13&#34; || $portget_mac == &#34;1:1:14&#34; || $portget_mac == &#34;1:1:15&#34; || $portget_mac == &#34;1:1:16&#34; || $portget_mac == &#34;1:1:17&#34; || $portget_mac == &#34;1:1:18&#34; || $portget_mac == &#34;1:1:19&#34;} {</span>
<span class="comment-line">#        set portget_mac &#34;1:1:2&#34;</span>
<span class="comment-line">#         }</span>
<span class="comment-line">#        set portget_mac1 &#34;31#$portget_mac&#34;</span>
<span class="comment-line">#	set retCode [puts $clientSocket $portget_mac1]</span>
<span class="comment-line">#	flush $clientSocket</span>
<span class="comment-line">#        after 200</span>
<strong><a name="::::port_412">proc <a href="ePTClient2.tcl-annot.html#::::port">::::port</a></a></strong> {option args} \
{
global buffer
puts &#34;-------------------------- inside port----&#34;
switch $option {

  &#34;get&#34; {
        global portget_mac clientSocket
        set getVariable_list $args
        set portget_mac [join $getVariable_list &#34;:&#34;]
	}
   &#34;cget&#34; {
        global MacAddress clientSocket portget_mac
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == &#34;-MacAddress&#34;} {
        set dummy_data &#34;Getting MacAddress&#34; 
        puts &#34;CLIENT SOCKET : $clientSocket&#34; 
	set dummy_data &#34;32#$portget_mac&#34;
	set retCode [puts $clientSocket $dummy_data]
	flush $clientSocket
        after 200
        set MacAddress [<a name="::ePTServer_read(2)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set MacAddress [lindex [split $MacAddress &#34;#&#34;] 1]
        return $MacAddress
      }
}
}
}       
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    stream    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a stream in client side.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::stream_453">proc <a href="ePTClient2.tcl-annot.html#::::stream">::::stream</a></a></strong> {option args} \
{
puts &#34;-------------------------- inside stream ----&#34;
switch $option {

&#34;config&#34; {

	global numFrames stream_name framesize frameSizeType frameSizeMAX frameSizeMIN \
		rateMode percentPacketRate fcs fir patternType dataPattern sa da \
		saRepeatCounter daRepeatCounter numSA numDA frameType dma

	array set param $args

	if { [info exists param(-name)] } {
		set stream_name $param(-name)
	}
	if { [info exists param(-numFrames)] } {
		set numFrames $param(-numFrames)
	}
	if { [info exists param(-frameSizeType)] } {
		set frameSizeType $param(-frameSizeType)
		if {$frameSizeType == &#34;sizeRandom&#34;} {
			if { [info exists param(-frameSizeMAX)] } {
				set frameSizeMAX $param(-frameSizeMAX)
				set frameSizeMAX [expr $param(-frameSizeMAX) -4]
			}
			if { [info exists param(-frameSizeMIN)] } {
				set frameSizeMIN $param(-frameSizeMIN)
				set frameSizeMIN [expr $param(-frameSizeMIN) -4]
			}
	}
        }
        if { [info exists param(-framesize)] } {
				set framesize [expr $param(-framesize) -4]
                                puts &#34;Frame Size : $framesize&#34;
	}
	if { [info exists param(-rateMode)] } {
		set rateMode $param(-rateMode)
	}
	if { [info exists param(-percentPacketRate)] } {
		set percentPacketRate $param(-percentPacketRate)
	}
	if { [info exists param(-fcs)] } {
		set fcs $param(-fcs)
	}
	if { [info exists param(-patternType)] } {
		set patternType $param(-patternType)
	}
	if { [info exists param(-dataPattern)] } {
		set dataPattern [join $param(-dataPattern) &#34;&#34;]
	}
	if { [info exists param(-frameType)] } {
		set frameType $param(-frameType)
                set frameType [join $frameType &#34;&#34;]  
	}
	if { [info exists param(-saRepeatCounter)] } {
		set saRepeatCounter $param(-saRepeatCounter)
	}
	if { [info exists param(-daRepeatCounter)] } {
		set daRepeatCounter $param(-daRepeatCounter)
	}
	if { [info exists param(-numSA)] } {
                 if {$param(-numSA) == 1 } {
		set numSA 0
                   } else {
		set numSA $param(-numSA)
                  }
	}
	if { [info exists param(-numDA)] } {
                 if {$param(-numDA) ==1} {
		set numDA 0
                   } else {
		set numDA $param(-numDA)
                  }
	}
	if { [info exists param(-asyncIntEnable)] } {
		set asyncIntEnable $param(-asyncIntEnable)
	}
	if { [info exists param(-fir)] } {
		set fir $param(-fir)
	}
	if { [info exists param(-sa)] } {
                set sa [join [join [split $param(-sa) &#34;:&#34;] &#34;&#34;] &#34;&#34;]
               if {$sa == &#34;&#34;} {
                   set sa &#34;00A1F1000001&#34;
                }
	}
	if { [info exists param(-da)] } {
		set da [join [join [split $param(-da) &#34;:&#34;] &#34;&#34;] &#34;&#34;]
               if {$da == &#34;&#34;} {
                   set sa &#34;00A1F1000002&#34;
                }
	}
	if { [info exists param(-dma)] } {
		set dma $param(-dma)
	}
}
&#34;get&#34; {

   	global stream_port_id

	set getvariable_list $args
	puts &#34; ----------- args --- $args&#34;
		set stream_get_data $args
		set stream_port_id [lrange $stream_get_data 0 2]
        puts &#34;-------------- STREAM PORT ID : $stream_port_id&#34;
}
&#34;cget&#34; {

   	global streamsent tx_port stream_port_id
	global clientSocket
	set cgetvariable_list $args
puts &#34;-----------inside stream cget function--------&#34;
puts &#34;-----------Variable LIST : $cgetvariable_list&#34;
puts &#34;-----------Variable LIST1 : [lindex $cgetvariable_list 0]&#34;
	if {[lindex $cgetvariable_list 0] == &#34;-packetView&#34;} {
	set portList $stream_port_id
	set portList [join $portList &#34;:&#34;]
	set portList &#34;34#$portList&#34;
	set retCode [puts $clientSocket $portList]
        flush $clientSocket
        after 200
        set streamsent [<a name="::ePTServer_read(3)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set streamsent [lindex [split $streamsent &#34;#&#34;] 1]
        return $streamsent
        }
        }
}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    protocol  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a protocol stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::protocol_595">proc <a href="ePTClient2.tcl-annot.html#::::protocol">::::protocol</a></a></strong> {config args} {

puts &#34;----------Enter into protocol---------------&#34;
	global protocol_name enable802dot1qTag ethernetType appName

	array set param $args

	if { [info exists param(-name)] } {
		set protocol_name $param(-name)
	}
	if { [info exists param(-enable802dot1qTag)] } {
		set enable802dot1qTag $param(-enable802dot1qTag)
	}
	if { [info exists param(-ethernetType)] } {
		set ethernetType $param(-ethernetType)
	}
	if { [info exists param(-appName)] } {
		set appName $param(-appName)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    vlan      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a vlan stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::vlan_628">proc <a href="ePTClient2.tcl-annot.html#::::vlan">::::vlan</a></a></strong> {config args} \
{

puts &#34;############################Inside VLAN PROC###########################&#34;
 
	array set param $args

	global cfi vlan_mode vlan_repeat vlan_id userPriority protocolTagId

	if { [info exists param(-cfi)] } {
		set cfi $param(-cfi)
                if {$cfi == &#34;resetCFI&#34;} {
                      set cfi 0
                   }
           }
	if { [info exists param(-mode)] } {
		set vlan_mode $param(-mode)
           }
	if { [info exists param(-repeat)] } {
		set vlan_repeat $param(-repeat)
           }
	if { [info exists param(-vlanID)] } {
		set vlan_id $param(-vlanID)
           }
	if { [info exists param(-userPriority)] } {
		set userPriority $param(-userPriority)
           }
	if { [info exists param(-protocolTagId)] } {
		set protocolTagId $param(-protocolTagId)
           }
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    protocoloffset  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a protocol offset in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::protocolOffset_672">proc <a href="ePTClient2.tcl-annot.html#::::protocolOffset">::::protocolOffset</a></a></strong> {config args} {

puts &#34;--------- Enter into protocolOffset --------------&#34;
	global protocoloffset_enable protocol_offset userDefinedTag

		array set param $args

		if { [info exists param(-enable)] } {
			set protocoloffset_enable $param(-enable)
		}
	if { [info exists param(-offset)] } {
		set protocol_offset $param(-offset)
	}
	if { [info exists param(-userDefinedTag)] } {
		set userDefinedTag $param(-userDefinedTag)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    filter          </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a filter in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::filter_702">proc <a href="ePTClient2.tcl-annot.html#::::filter">::::filter</a></a></strong> {config args} {

puts &#34;--------- Enter into filter --------------&#34;

	array set param $args

		if { [info exists param(-captureFilterEnable)] } {
			set captureFilterEnable $param(-captureFilterEnable)
		}
	if { [info exists param(-captureTriggerEnable)] } {
		set captureTriggerEnable $param(-captureTriggerEnable)
	}
	if { [info exists param(-userDefinedStat1Enable)] } {
		set userDefinedStat1Enable $param(-userDefinedStat1Enable)
	}
	if { [info exists param(-userDefinedStat1DA)] } {
		set userDefinedStat1DA $param(-userDefinedStat1DA)
	}
	if { [info exists param(-userDefinedStat1SA)] } {
		set userDefinedStat1SA $param(-userDefinedStat1SA)
	}
	if { [info exists param(-captureFilterPattern)] } {
		set captureFilterPattern $param(-captureFilterPattern)
	}
	if { [info exists param(-captureTriggerPattern)] } {
		set captureTriggerPattern $param(-captureTriggerPattern)
	}
	if { [info exists param(-captureTriggerDA)] } {
		set captureTriggerDA $param(-captureTriggerDA)
	}
	if { [info exists param(-captureFilterDA)] } {
		set captureFilterDA $param(-captureFilterDA)
	}
	if { [info exists param(-userDefinedStat1Pattern)] } {
		set userDefinedStat1Pattern $param(-userDefinedStat1Pattern)
	}
	if { [info exists param(-userDefinedStat2Enable)] } {
		set userDefinedStat2Enable $param(-userDefinedStat2Enable)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    filterPallette          </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a filter in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::filterPallette_755">proc <a href="ePTClient2.tcl-annot.html#::::filterPallette">::::filterPallette</a></a></strong> {config args} {

puts &#34;--------- Enter into filterPallette --------------&#34;
	array set param $args

		if { [info exists param(-pattern1)] } {
			set pattern1 $param(-pattern1)
		}
	if { [info exists param(-patternOffset1)] } {
		set patternOffset1 $param(-patternOffset1)
	}
	if { [info exists param(-DA1)] } {
		set DA1 $param(-DA1)
	}
	if { [info exists param(-SA1)] } {
		set SA1 $param(-SA1)
	}
	if { [info exists param(-matchType1)] } {
		set matchType1 $param(-matchType1)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    ip         </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a ip stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ip_789">proc <a href="ePTClient2.tcl-annot.html#::::ip">::::ip</a></a></strong> {config args} {

puts &#34;--------- Enter into ip --------------&#34;
	global ipProtocol destClass destIpAddr destIpMask destIpAddrMode sourceClass\
		sourceIpAddr sourceIpMask sourceIpAddrMode sourceIpAddrRepeatCount\
		destIpAddrRepeatCount destMacAddr destDutIpAddrttl useValidChecksum\
		fragment options delay throughput reliability precedence lengthOverride\
		totalLength identifier 

	array set param $args
	if { [info exists param(-ipProtocol)] } {
		set ipProtocol $param(-ipProtocol)
	}
	if { [info exists param(-destClass)] } {
		set destClass $param(-destClass)
	}
	if { [info exists param(-destIpAddr)] } {
		set destIpAddr $param(-destIpAddr)
	}
	if { [info exists param(-destIpMask)] } {
		set destIpMask $param(-destIpMask)
	}
	if { [info exists param(-destIpAddrMode)] } {
		set destIpAddrMode $param(-destIpAddrMode)
	}
	if { [info exists param(-sourceClass)] } {
		set sourceClass $param(-sourceClass)
	}
	if { [info exists param(-sourceIpAddr)] } {
		set sourceIpAddr $param(-sourceIpAddr)
	}
	if { [info exists param(-sourceIpMask)] } {
		set sourceIpMask $param(-sourceIpMask)
	}
	if { [info exists param(-sourceIpAddrMode)] } {
		set sourceIpAddrMode $param(-sourceIpAddrMode)
	}
	if { [info exists param(-sourceIpAddrRepeatCount)] } {
		set sourceIpAddrRepeatCount $param(-sourceIpAddrRepeatCount)
	}
	if { [info exists param(-destIpAddrRepeatCount)] } {
		set destIpAddrRepeatCount $param(-destIpAddrRepeatCount)
	}
	if { [info exists param(-destMacAddr)] } {
		set destMacAddr $param(-destMacAddr)
		set destMacAddr [join $destMacAddr &#34;:&#34;]
	}
	if { [info exists param(-destDutIpAddr)] } {
		set destDutIpAddr $param(-destDutIpAddr)
	}
	if { [info exists param(-ttl)] } {
		set ttl $param(-ttl)
	}
	if { [info exists param(-useValidChecksum)] } {
		set useValidChecksum $param(-useValidChecksum)
	}
	if { [info exists param(-fragment)] } {
		set fragment $param(-fragment)
	}
	if { [info exists param(-options)] } {
		set options [join $param(-options) &#34;&#34;]
	}
	if { [info exists param(-delay)] } {
		set delay $param(-delay)
	}
	if { [info exists param(-throughput)] } {
		set throughput $param(-throughput)
	}
	if { [info exists param(-reliability)] } {
		set reliability $param(-reliability)
	}
	if { [info exists param(-precedence)] } {
		set precedence $param(-precedence)
                if { $precedence == &#34;routine&#34;} {
                     set precedence &#34;000&#34;
                   } elseif {$precedence == &#34;priority&#34; } {
                     set precedence &#34;001&#34;
                   } elseif { $precedence == &#34;immediate&#34; } {
                     set precedence &#34;010&#34;
                   } elseif { $precedence == &#34;flash&#34; } {
                     set precedence &#34;011&#34;
                   } elseif { $precedence == &#34;flashOverride&#34; } {
                     set precedence &#34;100&#34;
                   } elseif { $precedence == &#34;criticEcp&#34; } {
                     set precedence &#34;101&#34;
                   } elseif { $precedence == &#34;internetControl&#34; } {
                     set precedence &#34;110&#34;
                   } else {
                     set precedence &#34;111&#34;
                   }
	}
	if { [info exists param(-lengthOverride)] } {
		set lengthOverride $param(-lengthOverride)
	}
	if { [info exists param(-totalLength)] } {
		set totalLength $param(-totalLength)
	}
	if { [info exists param(-identifier)] } {
		set identifier $param(-identifier)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    ipx                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a ipx stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ipx_903">proc <a href="ePTClient2.tcl-annot.html#::::ipx">::::ipx</a></a></strong> {config args} {

puts &#34;--------- Enter into ipx--------------&#34;
	global sourceNetwork sourceNetworkMaskSelect sourceNode sourceSocket\
		destNetwork destNode destSocket 

	array set param $args

	if { [info exists param(-sourceNetwork)] } {
		set sourceNetwork $param(-sourceNetwork)
			set sourceNetwork [join $sourceNetwork &#34;.&#34;]
	}
	if { [info exists param(-sourceNetworkMaskSelect)] } {
		set sourceNetworkMaskSelect $param(-sourceNetworkMaskSelect)
			set sourceNetworkMaskSelect [join $sourceNetworkMaskSelect &#34;&#34;]
	}
	if { [info exists param(-sourceNode)] } {
		set sourceNode $param(-sourceNode)
			set sourceNode [join $sourceNode &#34;&#34;]
	}
	if { [info exists param(-sourceSocket)] } {
		set sourceSocket $param(-sourceSocket)
			set sourceSocket [join $sourceSocket &#34;&#34;]
	}
	if { [info exists param(-destNetwork)] } {
		set destNetwork $param(-destNetwork)
			set destNetwork [join $destNetwork &#34;.&#34;]
	}
	if { [info exists param(-destNode)] } {
		set destNode $param(-destNode)
			set destNode [join $destNode &#34;&#34;]
	}
	if { [info exists param(-destSocket)] } {
		set destSocket $param(-destSocket)
			set destSocket [join $destSocket &#34;&#34;]
	}

}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    rip                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a rip stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::rip_954">proc <a href="ePTClient2.tcl-annot.html#::::rip">::::rip</a></a></strong> {config args} {

puts &#34;--------- Enter into rip--------------&#34;
	global command version

	array set param $args
	if { [info exists param(-command)] } {
		set command $param(-command)
	}
	if { [info exists param(-version)] } {
		set version $param(-version)
	}

}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    ripRoute                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a rip Route in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ripRoute_981">proc <a href="ePTClient2.tcl-annot.html#::::ripRoute">::::ripRoute</a></a></strong> {config args} {

puts &#34;--------- Enter into ripRoute--------------&#34;
	global familyId routeTag ipAddress subnetMask nextHop metric

	array set param $args

	if { [info exists param(-familyId)] } {
		set familyId $param(-familyId)
	}
	if { [info exists param(-routeTag)] } {
		set routeTag $param(-routeTag)
	}
	if { [info exists param(-ipAddress)] } {
		set ipAddress $param(-ipAddress)
	}
	if { [info exists param(-subnet)] } {
		set subnet $param(-subnet)
	}
	if { [info exists param(-MasnextHop)] } {
		set MasnextHop $param(-MasnextHop)
	}
	if { [info exists param(-metric)] } {
		set metric $param(-metric)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    dhcp                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a dhcp stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::dhcp_1020">proc <a href="ePTClient2.tcl-annot.html#::::dhcp">::::dhcp</a></a></strong> {config args} {

puts &#34;--------- Enter into dhcp--------------&#34;
	global opCode hwType transactionID seconds dhcp_flags clientIpAddr yourIpAddr\
		serverIpAddr relayAgentIpAddr clientHwAddr optionData

	array set param $args

	if { [info exists param(-opCode)] } {
		set opCode $param(-opCode)
                if { $opCode == &#34;dhcpBootRequest&#34;} {
                   set opCode &#34;01&#34;
                   }
	}
	if { [info exists param(-hwType)] } {
		set hwType $param(-hwType)
	}
	if { [info exists param(-transactionID)] } {
		set transactionID $param(-transactionID)
	}
	if { [info exists param(-seconds)] } {
		set seconds $param(-seconds)
	}
	if { [info exists param(-flags)] } {
		set dhcp_flags $param(-flags)
	}
	if { [info exists param(-clientIpAddr)] } {
		set clientIpAddr $param(-clientIpAddr)
	}
	if { [info exists param(-yourIpAddr)] } {
		set yourIpAddr $param(-yourIpAddr)
	}
	if { [info exists param(-serverIpAddr)] } {
		set serverIpAddr $param(-serverIpAddr)
	}
	if { [info exists param(-relayAgentIpAddr)] } {
		set relayAgentIpAddr $param(-relayAgentIpAddr)
	}
	if { [info exists param(-clientHwAddr)] } {
		set clientHwAddr [ join $param(-clientHwAddr) &#34;&#34;]
	}
	if { [info exists param(-optionData)] } {
		set optionData [join $param(-optionData) &#34;@&#34;]
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    igmp                    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a igmp stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::igmp_1078">proc <a href="ePTClient2.tcl-annot.html#::::igmp">::::igmp</a></a></strong> {config args} {

puts &#34;--------- Enter into igmp--------------&#34;
	global version igmp_type groupIpAddress maxResponseTime igmp_mode repeatCount

	array set param $args

	if { [info exists param(-version)] } {
		set version $param(-version)
	}
	if { [info exists param(-maxResponseTime)] } {
		set maxResponseTime [format %02x $param(-maxResponseTime)]
	}
	if { [info exists param(-type)] } {
		set igmp_type $param(-type)
                if {$igmp_type == 22} {
                    set igmp_type 16
                  }
	}
	if { [info exists param(-groupIpAddress)] } {
		set groupIpAddress $param(-groupIpAddress)
	}
	if { [info exists param(-mode)] } {
		set igmp_mode $param(-mode)
	}
	if { [info exists param(-repeatCount)] } {
		set repeatCount $param(-repeatCount)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    tcp                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a tcp stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::tcp_1120">proc <a href="ePTClient2.tcl-annot.html#::::tcp">::::tcp</a></a></strong> {config args} {

puts &#34;--------- Enter into tcp-------------&#34;
	global sourcePort destPort sequenceNumber synchronize finished resetConnection\
		acknowledgeValid pushFunctionValid urgentPointerValid

	array set param $args

        if { [info exists param(-sourcePort)] } {
		set sourcePort $param(-sourcePort)
               puts &#34;TCP SOURCE PORT : $sourcePort&#34;
 	}
	if { [info exists param(-destPort)] } {
		set destPort $param(-destPort)
               puts &#34;TCP DESTINATION PORT : $destPort&#34;
	}
	if { [info exists param(-sequenceNumber)] } {
		set sequenceNumber $param(-sequenceNumber)
	}
	if { [info exists param(-synchronize)] } {
		set synchronize $param(-synchronize)
                if {$synchronize == &#34;false&#34;} {
                   set synchronize 0 
                   } else {
                     set synchronize 1
                   }                   
	}
	if { [info exists param(-finished)] } {
		set finished $param(-finished)
                if {$finished == &#34;false&#34;} {
                   set finished 0 
                   } else {
                     set finished 1
                   }                   
	}
	if { [info exists param(-resetConnection)] } {
		set resetConnection $param(-resetConnection)
                if {$resetConnection == &#34;false&#34;} {
                   set resetConnection 0 
                   } else {
                     set resetConnection 1
                   }                   
	}
	if { [info exists param(-acknowledgeValid)] } {
		set acknowledgeValid $param(-acknowledgeValid)
                if {$acknowledgeValid == &#34;false&#34;} {
                   set acknowledgeValid 0 
                   } else {
                     set acknowledgeValid 1
                   }                   
	}
	if { [info exists param(-pushFunctionValid)] } {
		set pushFunctionValid $param(-pushFunctionValid)
                if {$pushFunctionValid == &#34;false&#34;} {
                   set pushFunctionValid 0 
                   } else {
                     set pushFunctionValid 1
                   }                   
	}
	if { [info exists param(-urgentPointerValid)] } {
		set urgentPointerValid $param(-urgentPointerValid)
                if {$urgentPointerValid == &#34;false&#34;} {
                   set urgentPointerValid 0 
                   } else {
                     set urgentPointerValid 1
                   }                   
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    icmp                    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a icmp stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::icmp_1201">proc <a href="ePTClient2.tcl-annot.html#::::icmp">::::icmp</a></a></strong> {config args} {

puts &#34;--------- Enter into icmp-----------&#34;
	global type code id sequence

	array set param $args

	if { [info exists param(-type)] } {
		set type [format %02x $param(-type)]
	}
	if { [info exists param(-code)] } {
		set code [format %02x $param(-code)]
	}
	if { [info exists param(-id)] } {
		set id [format %04x $param(-id)]
	}
	if { [info exists param(-sequence)] } {
		set sequence [format %04x $param(-sequence)]
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    arp                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a arp stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::arp_1234">proc <a href="ePTClient2.tcl-annot.html#::::arp">::::arp</a></a></strong> {config args} {

puts &#34;--------- Enter into arp-----------&#34;
	global sourceProtocolAddr destProtocolAddr sourceProtocolAddrMode destProtocolAddrMode\
           sourceHardwareAddr destHardwareAddr sourceProtocolAddrRepeatCount destProtocolAddrRepeatCount\
           operation sourceHardwareAddrMode sourceHardwareAddrRepeatCount destHardwareAddrMode\
		   destHardwareAddrRepeatCount

	array set param $args

	if { [info exists param(-sourceProtocolAddr)] } {
		set sourceProtocolAddr $param(-sourceProtocolAddr)
	}
	if { [info exists param(-destProtocolAddr)] } {
		set destProtocolAddr $param(-destProtocolAddr)
	}
	if { [info exists param(-sourceProtocolAddrMode)] } {
		set sourceProtocolAddrMode $param(-sourceProtocolAddrMode)
	}
	if { [info exists param(-destProtocolAddrMode)] } {
		set destProtocolAddrMode $param(-destProtocolAddrMode)
	}
	if { [info exists param(-sourceHardwareAddr)] } {
<span class="comment-line">#	set sourceHardwareAddr $param(-sourceHardwareAddr)</span>
                set sourceHardwareAddr [join [join [split $param(-sourceHardwareAddr) &#34;:&#34;] &#34;&#34;] &#34;&#34;]
               if {$sourceHardwareAddr == &#34;&#34;} {
                   set sourceHardwareAddr &#34;00a1f1000001&#34;
                }
	}
	if { [info exists param(-destHardwareAddr)] } {
<span class="comment-line">#		set destHardwareAddr $param(-destHardwareAddr)</span>
                set destHardwareAddr [join [join [split $param(-destHardwareAddr) &#34;:&#34;] &#34;&#34;] &#34;&#34;]
               if {$destHardwareAddr == &#34;&#34;} {
                   set destHardwareAddr &#34;00a1f2000001&#34;
                }
	}
	if { [info exists param(-sourceProtocolAddrRepeatCount)] } {
		set sourceProtocolAddrRepeatCount $param(-sourceProtocolAddrRepeatCount)
	}
	if { [info exists param(-destProtocolAddrRepeatCount)] } {
		set destProtocolAddrRepeatCount $param(-destProtocolAddrRepeatCount)
	}
	if { [info exists param(-operation)] } {
		set operation $param(-operation)
	}
	if { [info exists param(-sourceHardwareAddrMode)] } {
		set sourceHardwareAddrMode $param(-sourceHardwareAddrMode)
	}
	if { [info exists param(-sourceHardwareAddrRepeatCount)] } {
		set sourceHardwareAddrRepeatCount $param(-sourceHardwareAddrRepeatCount)
	}
	if { [info exists param(-destHardwareAddrMode)] } {
		set destHardwareAddrMode $param(-destHardwareAddrMode)
	}
	if { [info exists param(-destHardwareAddrRepeatCount)] } {
		set destHardwareAddrRepeatCount $param(-destHardwareAddrRepeatCount)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    ipV6                    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a ipV6 stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ipV6_1305">proc <a href="ePTClient2.tcl-annot.html#::::ipV6">::::ipV6</a></a></strong> {config args} {

puts &#34;--------- Enter into ipV6-----------&#34;
	global trafficClass flowLabel hopLimit sourceAddr sourceMask destAddr destMask\
		nextHeader sourceAddrMode sourceAddrRepeatCount destAddrMode\
		destAddrRepeatCount destMacAddr

	array set param $args

	if { [info exists param(-trafficClass)] } {
		set trafficClass $param(-trafficClass)
	}
	if { [info exists param(-flowLabel)] } {
		set flowLabel $param(-flowLabel)
	}
	if { [info exists param(-hopLimit)] } {
		set hopLimit $param(-hopLimit)
	}
	if { [info exists param(-sourceAddr)] } {
		set sourceAddr [<a name="::ePTGettingPrefix(1)"><a href="./ePTClient2.tcl.html#::ePTGettingPrefix_197">::ePTGettingPrefix</a></a> $param(-sourceAddr)]
               
	}
	if { [info exists param(-sourceMask)] } {
		set sourceMask $param(-sourceMask)
	}
	if { [info exists param(-destAddr)] } {
		set destAddr [<a name="::ePTGettingPrefix(2)"><a href="./ePTClient2.tcl.html#::ePTGettingPrefix_197">::ePTGettingPrefix</a></a> $param(-destAddr)]
	}
	if { [info exists param(-destMask)] } {
		set destMask $param(-destMask)
	}
	if { [info exists param(-nextHeader)] } {
		set nextHeader $param(-nextHeader)
	}
	if { [info exists param(-sourceAddrMode)] } {
		set sourceAddrMode $param(-sourceAddrMode)
	}
	if { [info exists param(-sourceAddrRepeatCount)] } {
		set sourceAddrRepeatCount $param(-sourceAddrRepeatCount)
	}
	if { [info exists param(-destAddrMode)] } {
		set destAddrMode $param(-destAddrMode)
	}
	if { [info exists param(-destAddrRepeatCount)] } {
		set destAddrRepeatCount $param(-destAddrRepeatCount)
	}
	if { [info exists param(-destMacAddr)] } {
		set destMacAddr $param(-destMacAddr)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    capture                 </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to capture the streams         </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::capture_1368">proc <a href="ePTClient2.tcl-annot.html#::::capture">::::capture</a></a></strong> {option args} {

        global clientSocket nPackets
puts &#34;--------- Enter into capture-----------&#34;
    switch $option {
        get {
	global capture_port_id
        set capture_port_id $args
	set capture_port_id [join $capture_port_id &#34;:&#34;]
        return $capture_port_id
        }
        cget {
	global nPackets capture_port_id
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == &#34;-nPackets&#34;} {
	set portList &#34;22#$capture_port_id&#34;
        set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set nPackets [<a name="::ePTServer_read(4)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set nPackets [lindex [split $nPackets &#34;#&#34;] 1]
	return $nPackets
         }         
       }
    }
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    captureBuffer                 </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to capture the streams         </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<span class="comment-line">#        return $captureBuffer_frame</span>
<strong><a name="::::captureBuffer_1408">proc <a href="ePTClient2.tcl-annot.html#::::captureBuffer">::::captureBuffer</a></a></strong> {option args} {

puts &#34;--------- Enter into captureBuffer-----------&#34;
	global captureBuffer_port_id captureBuffer stream_id num_of_frames clientSocket

switch $option {
    &#34;get&#34; {
            global captureBuffer
                set captureBuffer_data $args
		set retCode 0
		set captureBuffer_port_id [join [lrange $captureBuffer_data 0 2] &#34;:&#34;]
		set stream_id [lindex $captureBuffer_data 3]
		set num_of_frames [lindex $captureBuffer_data 4]
		set portList &#34;07#$captureBuffer_port_id&#34;
		set retCode [puts $clientSocket $portList]
		flush $clientSocket
                after 200
                set captureBuffer [<a name="::ePTServer_read(5)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
                return $captureBuffer
     } 
   &#34;getframe&#34; {
	global captureBuffer captureBuffer_frame
        set getframe_num $args
        set captureBuffer_frame [lindex $captureBuffer $getframe_num]
         puts &#34;Capture Buffer Frame : $captureBuffer_frame&#34;
        return 0
    }
    &#34;cget&#34; {
	global captureBuffer
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == &#34;-frame&#34;} {
        return $captureBuffer
     }
 }  
}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    stat                    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to get the port stattistics    </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::stat_1457">proc <a href="ePTClient2.tcl-annot.html#::::stat">::::stat</a></a></strong> {option args} {
puts &#34;--------- Enter into stat-----------&#34;

    switch $option {
        &#34;get&#34; {
	global statAllStats statFramesSent clientSocket statFramesSent_port
        set getvariable_list $args
	if {[lindex $getvariable_list 0] == &#34;statAllStats&#34;} {
		set statAllStats $getvariable_list
                puts &#34;StatAllStats1 : $statAllStats&#34;
                set statAllStats [join [lrange $statAllStats 1 3] &#34;:&#34;]
                puts &#34;StatAllStats2 : $statAllStats&#34;
	}
	if {[lindex $getvariable_list 0] == &#34;statFramesSent&#34;} {
	set statFramesSent_port [join [lrange $getvariable_list 1 3] &#34;:&#34;]
        return 0
	}
        }
        &#34;cget&#34; {
	global clientSocket tx_port framesSent framesReceived bytesSent bytesReceived\
               oversize userDefinedStat1 rx_port getstatAllStats statAllStats statFramesSent_port\
               getRatestatAllStats 
	set cgetvariable_list $args
puts &#34;-----------inside stream cget function--------&#34;
puts &#34;-----------Variable LIST : $cgetvariable_list&#34;
puts &#34;-----------Variable LIST1 : [lindex $cgetvariable_list 0]&#34;
	if {[lindex $cgetvariable_list 0] == &#34;-framesSent&#34;} {
           if {$getRatestatAllStats == 0} {
	set portList $statAllStats
        after 200
	set portList &#34;20#$portList&#34;
	set retCode [puts $clientSocket $portList]
        flush $clientSocket
        set framessent [<a name="::ePTServer_read(6)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set framessent [lindex [split $framessent &#34;#&#34;] 1]
        puts &#34;Frames SENT : $framessent&#34;
        return $framessent
        } else {
        set portList $getRatestatAllStats
        set portList &#34;20#$portList&#34;
        set retCode [puts $clientSocket $portList]
        flush $clientSocket
        after 200
        set framessent [<a name="::ePTServer_read(7)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set framessent [lindex [split $framessent &#34;#&#34;] 1]
        puts &#34;Frames SENT : $framessent&#34;
        return $framessent
        }
        }
        if {[lindex $cgetvariable_list 0] == &#34;-framesReceived&#34;} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;22#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set framesReceived [<a name="::ePTServer_read(8)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set framesReceived [lindex [split $framesReceived &#34;#&#34;] 1]
	return $framesReceived
        } else {
        set portList $getRatestatAllStats
	set portList &#34;22#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set framesReceived [<a name="::ePTServer_read(9)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set framesReceived [lindex [split $framesReceived &#34;#&#34;] 1]
	return $framesReceived
        }
       }
        if {[lindex $cgetvariable_list 0] == &#34;-counterVal&#34;} {
	set portList $statFramesSent_port
	set portList &#34;20#$portList&#34;
	set retCode [puts $clientSocket $portList]
        flush $clientSocket
        after 200
        set counterVal [<a name="::ePTServer_read(10)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set counterVal [lindex [split $counterVal &#34;#&#34;] 1]
        puts &#34;Counter Val : $counterVal&#34;
        return $counterVal
	}
        if {[lindex $cgetvariable_list 0] == &#34;-bitsSent&#34;} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;42#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(11)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;42#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(12)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-bytesSent&#34;} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;21#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(13)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;21#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(14)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-bytesReceived&#34;} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;23#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(15)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;23#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(16)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-bitsReceived&#34;} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;43#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(17)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;43#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(18)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-oversize&#34;} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;24#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(19)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;24#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(20)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-userDefinedStat1&#34;} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;22#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(21)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;22#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(22)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-vlanTaggedFramesRx&#34;} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;40#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(23)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;40#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(24)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == &#34;-rxArpRequest&#34;} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList &#34;39#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [<a name="::ePTServer_read(25)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList &#34;39#$portList&#34;
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [<a name="::ePTServer_read(26)"><a href="./ePTClient2.tcl.html#::ePTServer_read_178">::ePTServer_read</a></a> $clientSocket]
        set bytesSent [lindex [split $framesReceived &#34;#&#34;] 1]
	return $bytesSent
	}
        }
}
        &#34;getRate&#34; {
	global getRatestatAllStats
        set getRatevariable_list $args 
	if {[lindex $getRatevariable_list 0] == &#34;statAllStats&#34;} {
		set getRatestatAllStats $getRatevariable_list
                set getRatestatAllStats [join [lrange $getRatestatAllStats 1 3] &#34;:&#34;]
	}
         return 0
	}
        }
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    udp                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a udp stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::udp_1731">proc <a href="ePTClient2.tcl-annot.html#::::udp">::::udp</a></a></strong> {config args} {

puts &#34;--------- Enter into udp-----------&#34;
	global sourceudpPort destudpPort checksumMode

	array set param $args

	if { [info exists param(-sourcePort)] } {
		set sourceudpPort $param(-sourcePort)
               puts &#34;UDP SOURCE PORT : $sourceudpPort&#34;
	}
	if { [info exists param(-destPort)] } {
		set destudpPort $param(-destPort)
               puts &#34;UDP DEST PORT : $destudpPort&#34;
	}
	if { [info exists param(-checksumMode)] } {
		set checksumMode $param(-checksumMode)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    udf                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a udf in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::udf_1763">proc <a href="ePTClient2.tcl-annot.html#::::udf">::::udf</a></a></strong> {config args} {

puts &#34;--------- Enter into udf-----------&#34;
	global udf_enable continuousCount initval offset countertype

	array set param $args

	if { [info exists param(-enable)] } {
		set udf_enable $param(-enable)
	}
	if { [info exists param(-continuousCount)] } {
		set continuousCount $param(-continuousCount)
	}
	if { [info exists param(-initval)] } {
		set initval $param(-initval)
                set initval [join $initval &#34;&#34;]
	}
	if { [info exists param(-offset)] } {
		set offset $param(-offset)
	}
	if { [info exists param(-countertype)] } {
		set countertype $param(-countertype)
	}
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure : BintoHex</span>
<span class="comment-line"># </span>
<span class="comment-line"># Description : Used to convert binary to hex data</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input : args : Binary </span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns : Success : TCL return result</span>
<span class="comment-line">#           Failure : {}</span>
<span class="comment-line">#</span>
<span class="comment-line">#######################################################################################</span>
<strong><a name="::::bin2hex_1798">proc <a href="ePTClient2.tcl-annot.html#::::bin2hex">::::bin2hex</a></a></strong> {bin} {
	set result &#34;&#34;
		set prepend [string repeat 0 [expr (4-[string length $bin]%4)%4]]
		foreach g [regexp -all -inline {[01]{4}} $prepend$bin] {
			foreach {b3 b2 b1 b0} [split $g &#34;&#34;] {
				append result [format %X [expr {$b3*8+$b2*4+$b1*2+$b0}]]
			}
		}
	return $result
}
<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTConnectToTclServer</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This procedure connects a Server</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    serverName - Ip addr/name of Server</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">#    0 - if no error</span>
<span class="comment-line">#    1 - if any error found</span>
<span class="comment-line">########################################################################################</span>
	<strong><a name="::::ePTConnectToTclServer_1820">proc <a href="ePTClient2.tcl-annot.html#::::ePTConnectToTclServer">::::ePTConnectToTclServer</a></a></strong> {serverName} \
{
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;INSIDE CONNECT FN SERVER NAME : $serverName&#34;
          puts &#34;##################### INSIDE EPT CLIENT 2 FILE ###############################&#34;
          puts &#34;##################### INSIDE EPT CLIENT 2 FILE ###############################&#34;
          puts &#34;##################### INSIDE EPT CLIENT 2 FILE ###############################&#34;
          puts &#34;##################### INSIDE EPT CLIENT 2 FILE ###############################&#34;
          puts &#34;##################### INSIDE EPT CLIENT 2 FILE ###############################&#34;
          puts &#34;##################### INSIDE EPT CLIENT 2 FILE ###############################&#34;
	global clientSocket
		set client_port 8888
		set clientSocket [socket -async $serverName $client_port]
                puts &#34;CLIENT SOCKET : $clientSocket&#34; 
		if {$clientSocket == {}} {
			return 1
		} else {
                               fileevent  $clientSocket readable [list ePTServer_read $clientSocket]
                               fconfigure $clientSocket -translation auto -blocking 0 -buffering line
<span class="comment-line">#                               fconfigure $clientSocket -translation auto -blocking 0</span>
				set mac_address [exec ifconfig eth0 | grep -i &#34;HWaddr&#34;]
				set mac_address [lindex $mac_address 4]
				set ip_address [exec ifconfig eth0 | grep -i &#34;inet addr:&#34;]
				set ip_address [lindex [split [lindex $ip_address 1] &#34;:&#34;] 1]
                set chassisList1 &#34;1:1:1#1:1:2#1:1:3#1:1:4#1:1:5#1:1:6#1:1:7#1:1:8&#34;
				set portmap_List &#34;01#$chassisList1#$clientSocket#$ip_address#$mac_address&#34;
				set portList &#34;02#$chassisList1&#34;
				set retCode [puts $clientSocket $portmap_List]
				after 200
				flush $clientSocket
				set retCode [puts $clientSocket $portList]
				after 200 
				flush $clientSocket
		}
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTLogin</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command logs in a user.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   userName    - name of the user to login</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTLogin_1875">proc <a href="ePTClient2.tcl-annot.html#::::ePTLogin">::::ePTLogin</a></a></strong> {userName} \
{
<span class="comment-line">#	global clientSocket</span>
<span class="comment-line">#		if {[info exists clientSocket]} {</span>
<span class="comment-line">#			set retCode [puts $clientSocket $userName]</span>
<span class="comment-line">#				flush $clientSocket</span>
<span class="comment-line">#		}</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTLogout</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command logs out the current user.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   None</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTLogout_1894">proc <a href="ePTClient2.tcl-annot.html#::::ePTLogout">::::ePTLogout</a></a></strong> {} \
{
	global clientSocket

		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket logout]
				flush $clientSocket
                        after 200 
		}
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTTakeOwnership</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command attempts to take ownership of all the ports in the list</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   txRxList    - list of ports to take ownership</span>
<span class="comment-line">#   takeType    - if &#34;force&#34; take regardless of whether</span>
<span class="comment-line">#                 the port is previously owned by someone else</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTTakeOwnership_1917">proc <a href="ePTClient2.tcl-annot.html#::::ePTTakeOwnership">::::ePTTakeOwnership</a></a></strong> {txRxList {takeType &#34;&#34;}} \
{
		set portList $txRxList
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		global clientSocket
		set portList &#34;02#$portList&#34;
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#        set ePTTakeOwnership_output [ePTServer_read $clientSocket]</span>
	return 0 
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTPortTakeOwnership</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command attempts to take ownership of this port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    chassis</span>
<span class="comment-line">#    lm</span>
<span class="comment-line">#    port</span>
<span class="comment-line">#   takeType    - if &#34;force&#34; take regardless of whether</span>
<span class="comment-line">#                 the port is previously owned by someone else</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTPortTakeOwnership_1946">proc <a href="ePTClient2.tcl-annot.html#::::ePTPortTakeOwnership">::::ePTPortTakeOwnership</a></a></strong> {chassis lm port {takeType &#34;&#34;}} \
{
	global clientSocket
		set portList &#34;$chassis:$lm:$port&#34;
		set portList &#34;02#$portList&#34;
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#        set ePTPortTakeOwnership_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTClearOwnership</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command clears ownership of all the ports in the list</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   txRxList    - list of ports to take ownership</span>
<span class="comment-line">#   takeType    - if &#34;force&#34; take regardless of whether</span>
<span class="comment-line">#                 the port is previously owned by someone else</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTClearOwnership_1972">proc <a href="ePTClient2.tcl-annot.html#::::ePTClearOwnership">::::ePTClearOwnership</a></a></strong> {{txRxList &#34;&#34; } {takeType &#34;&#34;}} \
{
		set portList $txRxList
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set portList &#34;05#$portList&#34;
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTClearOwnership_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTPortClearOwnership</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command clears ownership of this port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    chassis</span>
<span class="comment-line">#    lm</span>
<span class="comment-line">#    port</span>
<span class="comment-line">#   takeType    - if &#34;force&#34; take regardless of whether</span>
<span class="comment-line">#                 the port is previously owned by someone else</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTPortClearOwnership_2001">proc <a href="ePTClient2.tcl-annot.html#::::ePTPortClearOwnership">::::ePTPortClearOwnership</a></a></strong> {chassis lm port {takeType &#34;&#34;}} \
{
	global clientSocket
		set portList &#34;$chassis:$lm:$port&#34;
		set portList &#34;05#$portList&#34;
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTPortClearOwnership_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTCheckOwnership</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command checks ownership of all the ports in the list</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   TxRxList    - list of ports to take ownership</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTCheckOwnership_2026">proc <a href="ePTClient2.tcl-annot.html#::::ePTCheckOwnership">::::ePTCheckOwnership</a></a></strong> {txRxList} \
{
		set portList $txRxList
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTPortCheckOwnership_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTGetChassisID</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This procedure gets the chassis ID of the specified chassis name. It is</span>
<span class="comment-line">#              useful when multiple chassis are chained together.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    chassisName - chassis name for which ID is to be obtained</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">#    -1 - if error found</span>
<span class="comment-line">#    chasissID - ID number of the chassis</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTGetChassisID_2054">proc <a href="ePTClient2.tcl-annot.html#::::ePTGetChassisID">::::ePTGetChassisID</a></a></strong> {chassisName} \
{
	if [chassis get $chassisName] {
		puts &#34;Error getting parameters for chassis $chassisName&#34;
			return -1
	}
	set chassisID [chassis cget -id]
		return $chassisID
}

<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTDisconnectFromChassis</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Disconnects from input chassis or list of chassis; if no arg given, then</span>
<span class="comment-line">#              will removeAll.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    args - list of chassis to del; if empty, removeAll</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">#    0 - if no error</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTDisconnectFromChassis_2077">proc <a href="ePTClient2.tcl-annot.html#::::ePTDisconnectFromChassis">::::ePTDisconnectFromChassis</a></a></strong> {args} \
{
	global clientSocket
		set retCode 0
		set chassisList &#34;08#$chassisList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $chassisList]
				flush $clientSocket
                        after 200 
		}
	return 0
<span class="comment-line">#                        set ePTDisconnectFromChassis_output [ePTServer_read $clientSocket]</span>
}


<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTStartTransmit</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Starts transmission on the specific ports</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:</span>
<span class="comment-line">#    PortList - Represented in Chassis Card Port and can be a list also, example {1,1,1 1,1,2}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTStartTransmit_2102">proc <a href="ePTClient2.tcl-annot.html#::::ePTStartTransmit">::::ePTStartTransmit</a></a></strong> {PortList} \
{
	set portList $PortList
		global clientSocket
		set retCode 0
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
             
		set portList &#34;04#$portList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                after 200 
		}
<span class="comment-line">#                        set ePTStartTransmit_output [ePTServer_read $clientSocket]</span>
<span class="comment-line">#                        puts &#34;Inside ePTStartTransmit OUTPUT : $ePTStartTransmit_output&#34;</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:   ePTStartPortTransmit</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This command starts Transmit on a single port; it will also stop transmit &amp;</span>
<span class="comment-line">#              zero stats on this port before transmitting.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    chassis</span>
<span class="comment-line">#    lm</span>
<span class="comment-line">#    port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#    0 if OK, 1 if port not configured</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTStartPortTransmit_2135">proc <a href="ePTClient2.tcl-annot.html#::::ePTStartPortTransmit">::::ePTStartPortTransmit</a></a></strong> {chassis lm port} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;04#$port&#34;
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $port]
		flush $clientSocket
                after 200 
		}
<span class="comment-line">#                        set ePTStartPortTransmit_output [ePTServer_read $clientSocket]</span>
<span class="comment-line">#                        puts &#34;Inside ePTStartPortTransmit OUTPUT : $ePTStartPortTransmit_output&#34;</span>
	return 0
}

<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure:   ePTStopTransmit</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Stops transmission on the specific ports</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:</span>
<span class="comment-line">#    PortList - Represented in Chassis Card Port and can be a list also, for ex. {1,1,1 1,1,2}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTStopTransmit_2160">proc <a href="ePTClient2.tcl-annot.html#::::ePTStopTransmit">::::ePTStopTransmit</a></a></strong> {PortList} \
{

		global clientSocket
		set PortList [join [join $PortList &#34;#&#34;] &#34;:&#34;]
		set PortList &#34;15#$PortList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $PortList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTStopTransmit_output [ePTServer_read $clientSocket]</span>
	return 0

}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:   ePTStopPortTransmit</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This command stops Tx on a single port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    chassis</span>
<span class="comment-line">#    lm</span>
<span class="comment-line">#    port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:      0 if OK, 1 if port not configured</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTStopPortTransmit_2187">proc <a href="ePTClient2.tcl-annot.html#::::ePTStopPortTransmit">::::ePTStopPortTransmit</a></a></strong> {chassis lm port} \
{
        puts &#34;Inside Stop Port transmit&#34;
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;15#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
	return 0
<span class="comment-line">#                        set ePTStopPortTransmit_output [ePTServer_read $clientSocket]</span>
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:   ePTStartCapture</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This command turns on capture for each Rx port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:</span>
<span class="comment-line">#    PortList - Represented in Chassis Card Port and can be a list also for ex. {1,1,1 1,1,2}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTStartCapture_2212">proc <a href="ePTClient2.tcl-annot.html#::::ePTStartCapture">::::ePTStartCapture</a></a></strong> {PortList} \
{
	set portList $PortList
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set portList &#34;25#$portList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTStartCapture_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTStopCapture</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command stops capture for each Rx port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:</span>
<span class="comment-line">#      PortList  - Represented in Chassis Card Port and can be a list also</span>
<span class="comment-line">#                  for ex. {1,1,1 1,1,2}</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTStopCapture_2237">proc <a href="ePTClient2.tcl-annot.html#::::ePTStopCapture">::::ePTStopCapture</a></a></strong> {PortList} \
{
	    set portList $PortList
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set PortList &#34;35#$portList&#34;
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $PortList]
		flush $clientSocket
                after 200 
		}
		set PortList1 &#34;15#$portList&#34;
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $PortList1]
		flush $clientSocket
                after 200 
		}
<span class="comment-line">#                        set ePTStopCapture_output [ePTServer_read $clientSocket]</span>
	return 0
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTStartPortCapture</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command starts capture on a single port;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    chassis</span>
<span class="comment-line">#    lm</span>
<span class="comment-line">#    port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#    0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTStartPortCapture_2271">proc <a href="ePTClient2.tcl-annot.html#::::ePTStartPortCapture">::::ePTStartPortCapture</a></a></strong> {chassis lm port} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;25#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTStartPortCapture_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTStopPortCapture</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command stops capture on a single port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    chassis</span>
<span class="comment-line">#    lm</span>
<span class="comment-line">#    port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#    1 if OK, 0 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTStopPortCapture_2299">proc <a href="ePTClient2.tcl-annot.html#::::ePTStopPortCapture">::::ePTStopPortCapture</a></a></strong> {chassis lm port {groupId 710} {create create} {destroy destroy}} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set Port &#34;35#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $Port]
				flush $clientSocket
                        after 200 
		}
		set PortList1 &#34;15#$port&#34;
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $PortList1]
		flush $clientSocket
                after 200 
		}
<span class="comment-line">#                        set ePTStopCapture_output [ePTServer_read $clientSocket]</span>
<span class="comment-line">#                        set ePTStopPortCapture_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################################</span>
<span class="comment-line">#  Procedure  :  ePTClearStats</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Description:  Clear statistics counters on the specific ports</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Arguments  :</span>
<span class="comment-line">#      ports     - Represented in Chassis Card Port and can be a list also</span>
<span class="comment-line">#                  for ex. {1,1,1 1,1,2}</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTClearStats_2331">proc <a href="ePTClient2.tcl-annot.html#::::ePTClearStats">::::ePTClearStats</a></a></strong> {PortList} \
{

	puts &#34;------------------------ PortList ********************* ================ $PortList&#34;
	    set portList $PortList
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set portList &#34;18#$portList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTClearStats_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTClearPortStats</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command zeros all stats &amp; stops the specified port if transmitting</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    chassis     chassis ID</span>
<span class="comment-line">#    lm          Load Module number</span>
<span class="comment-line">#    port        port number</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTClearPortStats_2360">proc <a href="ePTClient2.tcl-annot.html#::::ePTClearPortStats">::::ePTClearPortStats</a></a></strong> {chassis lm port} \
{
	global clientSocket
		set retCode 0
		set port &#34;$chassis:$lm:$port&#34;
		set port &#34;18#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTClearPortStats_output [ePTServer_read $clientSocket]</span>

	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTDisablePortArpResponse</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command disables the arp response engine for the specified port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   chassis</span>
<span class="comment-line">#   lm</span>
<span class="comment-line">#   port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTDisablePortArpResponse_2390">proc <a href="ePTClient2.tcl-annot.html#::::ePTDisablePortArpResponse">::::ePTDisablePortArpResponse</a></a></strong> {chassis lm port {write write}} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;57#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTDisablePortArpResponse_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTTransmitPortArpRequest</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command transmits an Arp request via the protocol server on a</span>
<span class="comment-line"># single port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#       chassis</span>
<span class="comment-line">#       lm</span>
<span class="comment-line">#       port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTTransmitPortArpRequest_2419">proc <a href="ePTClient2.tcl-annot.html#::::ePTTransmitPortArpRequest">::::ePTTransmitPortArpRequest</a></a></strong> {chassis lm port} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;13#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTTransmitPortArpRequest_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTSetPacketStreamMode</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command sets all the TX ports in the list or array to packet</span>
<span class="comment-line"># stream mode</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   TxRxArray       - list or array of TX ports to change</span>
<span class="comment-line">#   write           - write ports to hw as they are modified</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTSetPacketStreamMode_2444">proc <a href="ePTClient2.tcl-annot.html#::::ePTSetPacketStreamMode">::::ePTSetPacketStreamMode</a></a></strong> {TxRxArray {write nowrite}} \
{
	    set portList $TxRxArray
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set portList &#34;59#$portList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTSetPacketStreamMode_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTSetPortPacketStreamMode</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command sets specified port to packet stream mode</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   chassis</span>
<span class="comment-line">#   lm</span>
<span class="comment-line">#   port</span>
<span class="comment-line">#   write           - write port to hw</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTSetPortPacketStreamMode_2472">proc <a href="ePTClient2.tcl-annot.html#::::ePTSetPortPacketStreamMode">::::ePTSetPortPacketStreamMode</a></a></strong> {chassis lm port {write nowrite}} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;59#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTSetPortPacketStreamMode_output [ePTServer_read $clientSocket]</span>
	return 0
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTWritePortsToHardware</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command writes the ports, including speed, etc into hardware. It</span>
<span class="comment-line"># differs from writeConfigToHardware because this command writes all</span>
<span class="comment-line"># the phy as well as the configuration.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    PortArray      either list of ports or array of ports</span>
<span class="comment-line">#    args           options include:</span>
<span class="comment-line">#                   -verbose             &lt;turn on messages&gt;</span>
<span class="comment-line">#                   -noVerbose           &lt;turn off messages, default&gt;</span>
<span class="comment-line">#                   -writeProtocolServer &lt;stops protocol server &amp; writes</span>
<span class="comment-line">#                                         all associated objects, default&gt;</span>
<span class="comment-line">#                   -noProtocolServer    &lt;no effect on protocol server,</span>
<span class="comment-line">#                                         doesn't update protocol server objects&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTWritePortsToHardware_2503">proc <a href="ePTClient2.tcl-annot.html#::::ePTWritePortsToHardware">::::ePTWritePortsToHardware</a></a></strong> {PortArray args} \
{
		global clientSocket
		set stream [<a name="::stream_construct(1)"><a href="./ePTClient2.tcl.html#::stream_construct_2837">::stream_construct</a></a>]
        set stream &#34;03#$stream&#34;
		if {[info exists clientSocket]} {
      	set retCode [puts $clientSocket $stream]
	flush $clientSocket
                    after 200 
<span class="comment-line">#                 set output [ePTServer_read $clientSocket]</span>
		}
	return 0
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTWriteConfigToHardware</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command writes the port array into hardware</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    PortArray      either list of ports or array of ports</span>
<span class="comment-line">#    args           options include:</span>
<span class="comment-line">#                   -verbose             &lt;turn on messages&gt;</span>
<span class="comment-line">#                   -noVerbose           &lt;turn off messages, default&gt;</span>
<span class="comment-line">#                   -writeProtocolServer &lt;stops protocol server &amp; writes</span>
<span class="comment-line">#                                         all associated objects, default&gt;</span>
<span class="comment-line">#                   -noProtocolServer    &lt;no effect on protocol server,</span>
<span class="comment-line">#                                         doesn't update protocol server objects&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTWriteConfigToHardware_2532">proc <a href="ePTClient2.tcl-annot.html#::::ePTWriteConfigToHardware">::::ePTWriteConfigToHardware</a></a></strong> {PortArray args} \
{
		global clientSocket
		set stream [<a name="::stream_construct(2)"><a href="./ePTClient2.tcl.html#::stream_construct_2837">::stream_construct</a></a>]
        set stream &#34;03#$stream&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $stream]
				flush $clientSocket
                        after 200 
<span class="comment-line">#                 set output [ePTServer_read $clientSocket]</span>
		}
	return 0
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTCheckTransmitDone</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command polls the TX rate counters &amp; returns when done transmitting</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    PortArray                either list of ports or array of ports</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTCheckTransmitDone_2554">proc <a href="ePTClient2.tcl-annot.html#::::ePTCheckTransmitDone">::::ePTCheckTransmitDone</a></a></strong> {PortArray} \
{
     	set portList $PortArray
		global clientSocket
		set portList [join [join $portList &#34;#&#34;] &#34;:&#34;]
		set portList &#34;28#$portList&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTCheckPortTransmitDone</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command polls the TX rate counters &amp; returns the number of frames</span>
<span class="comment-line"># transmitted</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#    chassis        chassis ID</span>
<span class="comment-line">#    lm            Load Module number</span>
<span class="comment-line">#    port        port number</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTCheckPortTransmitDone_2581">proc <a href="ePTClient2.tcl-annot.html#::::ePTCheckPortTransmitDone">::::ePTCheckPortTransmitDone</a></a></strong> {chassis lm port} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set port &#34;28#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTCheckPortTransmitDone_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTCheckLinkState</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command checks the link state of all ports in parallel and labels</span>
<span class="comment-line"># the ones that are down. Then it polls the links that are down for two</span>
<span class="comment-line"># seconds and returns 1 if any port is still down and a 0 if all ports are</span>
<span class="comment-line"># up.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#    PortArray    array or list of ports, ie, ePTgSortMap</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTCheckLinkState_2608">proc <a href="ePTClient2.tcl-annot.html#::::ePTCheckLinkState">::::ePTCheckLinkState</a></a></strong> {PortArray {message messageOn}} \
{
    	set portArray $PortArray
		global clientSocket
		set portArray [join [join $portArray &#34;#&#34;] &#34;:&#34;]
		set portArray &#34;19#$portArray&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portArray]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTCheckLinkState_output [ePTServer_read $clientSocket]</span>
	return 0
}
<span class="comment-line">########################################################################################</span>
<span class="comment-line"># Procedure: ePTRequestStats</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This command combines the statGroup w/a portList or map array to request</span>
<span class="comment-line">#              stats for a list of ports. statList command must be used to retrieve stats</span>
<span class="comment-line">#              after call completion.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:</span>
<span class="comment-line">#    TxRxArray - either list of ports or array of ports</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:</span>
<span class="comment-line">#       TCL_OK or TCL_ERROR</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::ePTRequestStats_2636">proc <a href="ePTClient2.tcl-annot.html#::::ePTRequestStats">::::ePTRequestStats</a></a></strong> {TxRxArray} \
{
     	set txRxArray $TxRxArray
		global clientSocket
		set txRxArray [join [join $txRxArray &#34;#&#34;] &#34;:&#34;]
		set txRxArray &#34;15#$txRxArray&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $txRxArray]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTRequestStats_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTEnableArpResponse</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command gets the MAC &amp; IP addresses for that port, sets up the</span>
<span class="comment-line"># address table and enables the arp response engine for all ports in</span>
<span class="comment-line"># the portlist</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   mapType - either oneIpToOneMAC or manyIpToOneMAC</span>
<span class="comment-line">#   PortMap - list or array of ports, ie. ePTgSortMap</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTEnableArpResponse_2666">proc <a href="ePTClient2.tcl-annot.html#::::ePTEnableArpResponse">::::ePTEnableArpResponse</a></a></strong> { mapType PortMap } \
{
	    set portMap $PortMap
		global clientSocket
		set portMap [join [join $portMap &#34;#&#34;] &#34;:&#34;]
		set portMap &#34;12#$portMap&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTEnableArpResponse_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTEnablePortArpResponse</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command gets the MAC &amp; IP addresses for that port, sets up the</span>
<span class="comment-line"># address table and enables the arp response engine for the specified port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   mapType - either oneIpToOneMAC or manyIpToOneMAC</span>
<span class="comment-line">#   chassis</span>
<span class="comment-line">#   lm</span>
<span class="comment-line">#   port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTEnablePortArpResponse_2698">proc <a href="ePTClient2.tcl-annot.html#::::ePTEnablePortArpResponse">::::ePTEnablePortArpResponse</a></a></strong> { mapType chassis lm port {write write}} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set portMap &#34;12#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTEnablePortArpResponse_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTDisableArpResponse</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command disables the arp response engine for all ports in</span>
<span class="comment-line"># the portlist</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   PortMap - list or array of ports, ie. ePTgSortMap</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTDisableArpResponse_2725">proc <a href="ePTClient2.tcl-annot.html#::::ePTDisableArpResponse">::::ePTDisableArpResponse</a></a></strong> { PortMap } \
{
	    set portMap $PortMap
		global clientSocket
		set portMap [join [join $portMap &#34;#&#34;] &#34;:&#34;]
		set portMap &#34;27#$portMap&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTDisableArpResponse_output [ePTServer_read $clientSocket]</span>
	return 0
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTTransmitArpRequest</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command transmits an Arp request via the protocol server.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:</span>
<span class="comment-line">#   TxRxArray       - either array or list containing ports to transmit</span>
<span class="comment-line">#                     arp request on</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTTransmitArpRequest_2751">proc <a href="ePTClient2.tcl-annot.html#::::ePTTransmitArpRequest">::::ePTTransmitArpRequest</a></a></strong> {TxRxArray} \
{
	    set txRxArray $TxRxArray
		global clientSocket
		set portMap [join [join $txRxArray &#34;#&#34;] &#34;:&#34;]
		set portMap &#34;13#$txRxArray&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTTransmitArpRequest_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTDisablePortArpResponse</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command disables the arp response engine for the specified port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   chassis</span>
<span class="comment-line">#   lm</span>
<span class="comment-line">#   port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTDisablePortArpResponse_2780">proc <a href="ePTClient2.tcl-annot.html#::::ePTDisablePortArpResponse">::::ePTDisablePortArpResponse</a></a></strong> {chassis lm port {write write}} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set portMap &#34;36#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
	return 0
<span class="comment-line">#                        set ePTDisablePortArpResponse_output [ePTServer_read $clientSocket]</span>
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ePTTransmitPortArpRequest</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command transmits an Arp request via the protocol server on a</span>
<span class="comment-line"># single port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#       chassis</span>
<span class="comment-line">#       lm</span>
<span class="comment-line">#       port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#       0 if OK, 1 if port not configured</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ePTTransmitPortArpRequest_2810">proc <a href="ePTClient2.tcl-annot.html#::::ePTTransmitPortArpRequest">::::ePTTransmitPortArpRequest</a></a></strong> {chassis lm port} \
{
	global clientSocket
		set port  &#34;$chassis:$lm:$port&#34;
		set portMap &#34;13#$port&#34;
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
<span class="comment-line">#                        set ePTTransmitPortArpRequest_output [ePTServer_read $clientSocket]</span>
	return 0
}

<span class="comment-line">#######################################################################################</span>
<span class="comment-line"># Procedure:    stream_construct                     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Used to create a stream in client side</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        args:        TCL command to evaluate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Success:    TCL Return result</span>
<span class="comment-line">#               Failure:    {}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Remarks:  TCL procs can embed i/o.</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################################</span>
<strong><a name="::::stream_construct_2837">proc <a href="ePTClient2.tcl-annot.html#::::stream_construct">::::stream_construct</a></a></strong> {} \
{

    global clientSocket tx_port rx_port numFrames stream_name framesize frameSizeType frameSizeMAX\
        frameSizeMIN rateMode percentPacketRate fcs fir patternType dataPattern sa da\
        saRepeatCounter daRepeatCounter	numSA numDA frameType protocol_name enable802dot1qTag\
        ethernetType appName cfi vlan_mode vlan_repeat vlan_id userPriority protocolTagId protocoloffset_enable\
        protocol_offset userDefinedTag ipProtocol destClass destIpAddr destIpMask destIpAddrMode sourceClass\
        sourceIpAddr sourceIpMask sourceIpAddrMode sourceIpAddrRepeatCount destIpAddrRepeatCount\
        destMacAddr destDutIpAddr ttl useValidChecksum fragment options delay throughput reliability\
        precedence lengthOverride totalLength identifier command version familyId routeTag ipAddress\
        subnet MasnextHop metric opCode hwType transactionID seconds dhcp_flags clientIpAddr yourIpAddr\
        serverIpAddr relayAgentIpAddr clientHwAddr optionData version maxResponseTime igmp_type\
        groupIpAddress maxResponseTime igmp_mode repeatCount sourcePort destPort sequenceNumber\
        synchronize finished resetConnection type code id sequence sourceProtocolAddr\
	acknowledgeValid pushFunctionValid urgentPointerValid \
        destProtocolAddr sourceProtocolAddrMode destProtocolAddrMode sourceHardwareAddr\
        destHardwareAddr sourceProtocolAddrRepeatCount destProtocolAddrRepeatCount operation\
        sourceHardwareAddrMode sourceHardwareAddrRepeatCount destHardwareAddrMode\
        destHardwareAddrRepeatCount sourceudpPort\
        destudpPort checksumMode trafficClass flowLabel hopLimit sourceAddr sourceMask destAddr\
        destMask nextHeader sourceAddrMode sourceAddrRepeatCount destAddrMode destAddrRepeatCount\
        destMacAddr sourceProtocolAddr destProtocolAddr sourceProtocolAddrMode destProtocolAddrMode\
        sourceHardwareAddr destHardwareAddr sourceProtocolAddrRepeatCount destProtocolAddrRepeatCount\
        operation sourceHardwareAddrMode sourceHardwareAddrRepeatCount destHardwareAddrMode\
        destHardwareAddrRepeatCount direction udf_enable continuousCount initval offset countertype dma\
	sourceNetwork sourceNetworkMaskSelect sourceNode sourceSocket destNetwork destNode destSocket 

<span class="comment-line">###################Stream construction STRTS HERE####################################### </span>
 puts &#34;Inside stream_construct -----&gt;cfi : $cfi------------&gt;&#34;
 puts &#34;Inside stream_construct -----&gt;vlan_mode : $vlan_mode-------------&gt;&#34;
 puts &#34;Inside stream_construct -----&gt;vlan_Id : $vlan_id-------------&gt;&#34;
 puts &#34;Inside stream_construct -----&gt;vlan_repeat : $vlan_repeat-------------&gt;&#34;
 puts &#34;Inside stream_construct -----&gt;userPriority: $userPriority------------&gt;&#34;
 puts &#34;Inside stream_construct -----&gt;protocolTagId: $protocolTagId------------&gt;&#34;
 puts &#34;Inside stream_construct -----&gt;ipProtocol: $ipProtocol------------&gt;&#34;

        if {![info exists protocoloffset_enable]} {
              set protocoloffset_enable &#34;false&#34;
           }
        if {![info exists udf_enable]} {
              set udf_enable &#34;false&#34;
           }
        if {![info exists continuousCount]} {
              set continuousCount &#34;0&#34;
           }
        if {![info exists initval]} {
              set initval &#34;0&#34;
           }
        if {![info exists offset]} {
              set offset &#34;14&#34;
           }
        if {![info exists countertype]} {
              set countertype &#34;c8&#34;
           }
        if { [string tolower $sa] == [string tolower $da] } {
               set da &#34;00DEBB000001&#34;
           }
        switch $protocol_name {
            mac {
                if {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34;} {
                        puts &#34;INSIDE VLAN_ID MAC PROC&#34;
                        set stream_name &#34;VLAN&#34;
                        set vlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$protocolTagId$userPriority$cfi$vlan_id$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $vlan_stream
               } elseif {$frameType != &#34;null&#34; &amp;&amp; $frameType != &#34;0800&#34;} { 
                        puts &#34;INSIDE FRAMETYPE  MAC PROC&#34;
                        set stream_name &#34;MAC&#34;
                        set mac_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $mac_stream 
               } elseif {$protocoloffset_enable == &#34;true&#34;} { 
                set stream_name &#34;DoubleVLAN&#34;
                    set qinq_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                    return $qinq_stream
               } else {
                        puts &#34;INSIDE MAC PROC&#34;
                        set stream_name &#34;MAC&#34;
                        set mac_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $mac_stream 
                       }
                }
                <a name="::ip(1)"><a href="./ePTClient2.tcl.html#::ip_789">::ip</a></a> { 
                    if {$appName == &#34;Arp&#34; &amp;&amp; $vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34;} {
                        set frameType &#34;8100&#34;
                            set protocol_name &#34;0806&#34;
                            set hw_type &#34;0001&#34;
                            set protocol_type &#34;0800&#34;
                            set hw_size &#34;06&#34;
                            set protocol_size &#34;04&#34;
                            set stream_name &#34;ARPVLAN&#34;
                            if {$operation == &#34;arpRequest&#34;} {
                                set operation &#34;0001&#34;
                            } else {
                                set operation &#34;0002&#34;
                            }
                        set arpvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destHardwareAddr$sourceHardwareAddr$frameType$userPriority$cfi$vlan_id$protocol_name$hw_type$protocol_type$hw_size$protocol_size$operation$sourceHardwareAddr@$sourceProtocolAddr@$destHardwareAddr@$destProtocolAddr@#$sourceHardwareAddrMode#$sourceHardwareAddrRepeatCount#$destHardwareAddrMode#$destHardwareAddrRepeatCount#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceProtocolAddrMode#$sourceProtocolAddrRepeatCount#$destProtocolAddrMode#$destProtocolAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $arpvlan_stream
                   } elseif {$appName == &#34;Arp&#34;} {
                            set frameType &#34;0806&#34;
                            set hw_type &#34;0001&#34;
                            set protocol_type &#34;0800&#34;
                            set hw_size &#34;06&#34;
                            set protocol_size &#34;04&#34;
                            set stream_name &#34;ARPSTREAM&#34;
                            if {$operation == &#34;arpRequest&#34;} {
                                set operation &#34;0001&#34;
                            } else {
                                set operation &#34;0002&#34;
                            }
                        set arpip_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destHardwareAddr$sourceHardwareAddr$frameType$hw_type$protocol_type$hw_size$protocol_size$operation$sourceHardwareAddr@$sourceProtocolAddr@$destHardwareAddr@$destProtocolAddr@#$destHardwareAddrMode#$destHardwareAddrRepeatCount#$sourceHardwareAddrMode#$sourceHardwareAddrRepeatCount#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceProtocolAddrMode#$sourceProtocolAddrRepeatCount#$destProtocolAddrMode#$destProtocolAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $arpip_stream
                   } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $ipProtocol == &#34;igmp&#34;} {
                        set frameType &#34;8100&#34;
                        set ip_frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set protocol_name &#34;02&#34;
                        set igmp_checksum &#34;0000&#34;
                        set router_alert &#34;94040000&#34;
                        set stream_name &#34;IGMPVLAN&#34;
                        set igmpvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$igmp_type$maxResponseTime$igmp_checksum@$groupIpAddress@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $igmpvlan_stream
                } elseif {$ipProtocol == &#34;igmp&#34;} {
                    set frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set protocol_name &#34;02&#34;
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set igmp_checksum &#34;0000&#34;
                        set router_alert &#34;94040000&#34;
                        set stream_name &#34;IGMP&#34;
                        set ipigmp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$igmp_type$maxResponseTime$igmp_checksum@$groupIpAddress@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipigmp_stream
                   } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $ipProtocol == &#34;icmp&#34;} {
                        set frameType &#34;8100&#34;
                        set ip_frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set protocol_name &#34;01&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set icmp_checksum &#34;0000&#34;
                        set stream_name &#34;ICMPVLAN&#34;
                        set icmpvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $icmpvlan_stream
                } elseif {$ipProtocol == &#34;icmp&#34;} {
                    set protocol_name &#34;01&#34;
                        set frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set icmp_checksum &#34;0000&#34;
                        set stream_name &#34;ICMP&#34;
                        set ipicmp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x $ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipicmp_stream
                  } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $ipProtocol == &#34;udp&#34; &amp;&amp; $appName == &#34;Dhcp&#34;} {
                    set frameType &#34;8100&#34;
                        set ip_frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set protocol_name &#34;11&#34;
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;0134&#34; 
                        set hwType &#34;01&#34;
                        set hwlength &#34;06&#34;
                        set hops &#34;00&#34;
                        set flags &#34;0000&#34;
                        set udp_checksum &#34;0000&#34;
                        set opCode &#34;01&#34;
                        set reserved &#34;00000000000000000000&#34; 
                        set magic_cookie &#34;63825363&#34; 
                        set server_name &#34;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;
                        set bootfile_name &#34;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;
                        set stream_name &#34;DHCPVLAN&#34;
                        set dhcpvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$opCode$hwType$hwlength$hops$transactionID$seconds$dhcp_flags@$clientIpAddr@$yourIpAddr@$serverIpAddr@$relayAgentIpAddr@$clientHwAddr$reserved$server_name$bootfile_name$magic_cookie*$optionData*#$daRepeatCounter#$numDA#$saRepeatCounter#$vlan_mode#$vlan_repeat#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $dhcpvlan_stream
                } elseif {$ipProtocol == &#34;udp&#34; &amp;&amp; $appName == &#34;Dhcp&#34;} {
                    set frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set protocol_name &#34;11&#34;
                        set length &#34;0134&#34; 
                        set hwlength &#34;06&#34;
                        set hops &#34;00&#34;
                        set flags &#34;0000&#34;
                        set opCode &#34;01&#34;
                        set udp_checksum &#34;0000&#34;
                        set stream_name &#34;DHCP&#34;
                        set reserved &#34;00000000000000000000&#34; 
                        set magic_cookie &#34;63825363&#34; 
                        set bootfile_name &#34;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;
                        set server_name &#34;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#34;
                        set ipdhcp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$opCode$hwType$hwlength$hops$transactionID$seconds$dhcp_flags@$clientIpAddr@$yourIpAddr@$serverIpAddr@$relayAgentIpAddr@$clientHwAddr$reserved$server_name$bootfile_name$magic_cookie*$optionData*#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipdhcp_stream
                  } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $ipProtocol == &#34;udp&#34;} {
                    set frameType &#34;8100&#34;
                        set ip_frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set protocol_name &#34;11&#34;
                        set length &#34;001a&#34; 
                        set udp_checksum &#34;0000&#34;
                        set stream_name &#34;UDPVLAN&#34;
                        set udpvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $udpvlan_stream
                } elseif {$protocoloffset_enable == &#34;true&#34; &amp;&amp; $ipProtocol == &#34;udp&#34;} {
                    set frameType &#34;0800&#34;
                        set protocol_name &#34;11&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;001a&#34; 
                        set udp_checksum &#34;0000&#34;
                        set stream_name &#34;DoubleUDP&#34;
                        set qinqudp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $qinqudp_stream
                } elseif {$ipProtocol == &#34;udp&#34;} {
                    set frameType &#34;0800&#34;
                        set protocol_name &#34;11&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;001a&#34; 
                        set udp_checksum &#34;0000&#34;
                        set stream_name &#34;UDP&#34;
                        set ipudp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipudp_stream
                  } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $ipProtocol == &#34;tcp&#34;} {
                    set frameType &#34;8100&#34;
                        set ip_frameType &#34;0800&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;50&#34; 
                        set window_size &#34;0fa0&#34;
                        set protocol_name &#34;06&#34;
                        set tcp_checksum &#34;0000&#34;
                        set stream_name &#34;TCPVLAN&#34;
                        set tcp_flags &#34;$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize&#34;
                        set tcp_flags [<a name="::bin2hex(1)"><a href="./ePTClient2.tcl.html#::bin2hex_1798">::bin2hex</a></a> $tcp_flags]
                        set ack_num $sequenceNumber
                        set tcpvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$tcp_flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                       return $tcpvlan_stream
                } elseif {$protocoloffset_enable == &#34;true&#34; &amp;&amp; $ipProtocol == &#34;tcp&#34;} {
                    set frameType &#34;0800&#34;
                        set protocol_name &#34;06&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;50&#34; 
                        set window_size &#34;0fa0&#34;
                        set tcp_checksum &#34;0000&#34;
                        set tcp_flags &#34;$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize&#34;
                        set tcp_flags [<a name="::bin2hex(2)"><a href="./ePTClient2.tcl.html#::bin2hex_1798">::bin2hex</a></a> $tcp_flags]
                        set ack_num $sequenceNumber
                        set stream_name &#34;DoubleTCP&#34;
                        set qinqtcp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$tcp_flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $qinqtcp_stream
                } elseif {$ipProtocol == &#34;tcp&#34;} {
                        set frameType &#34;0800&#34;
                        set protocol_name &#34;06&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;50&#34; 
                        set window_size &#34;0fa0&#34;
                        set tcp_checksum &#34;0000&#34;
                        set tcp_flags &#34;$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize&#34;
                        set tcp_flags [<a name="::bin2hex(3)"><a href="./ePTClient2.tcl.html#::bin2hex_1798">::bin2hex</a></a> $tcp_flags]
                        set ack_num $sequenceNumber
                        set stream_name &#34;TCP&#34;
                        set iptcp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$tcp_flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $iptcp_stream
                } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34;} {
                            set headerlength &#34;45&#34; 
                            set dscp &#34;e0&#34;
                            set flags &#34;4000&#34;
                            set ipProtocol &#34;04&#34;
                            set frameType1 &#34;8100&#34;
                            set Checksum &#34;0000&#34;
                            set stream_name &#34;IPVLAN&#34;
                            set ipvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType1$userPriority$cfi$vlan_id$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$ipProtocol$Checksum@$sourceIpAddr@$destIpAddr@$options$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $ipvlan_stream
                } elseif {$protocoloffset_enable == &#34;true&#34;} {
                        set headerlength &#34;45&#34; 
                            set dscp &#34;e0&#34;
                            set flags &#34;4000&#34;
                            set Checksum &#34;0000&#34;
                            set protocol &#34;04&#34;
                            set stream_name &#34;DoubleIP&#34;
                            set qinqip_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol$Checksum@$sourceIpAddr@$destIpAddr@$options$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $qinqip_stream
                 } else {
                        set headerlength &#34;45&#34; 
                            set dscp &#34;e0&#34;
                            set flags &#34;4000&#34;
                            set Checksum &#34;0000&#34;
                            set protocol &#34;04&#34;
                            set stream_name &#34;IP&#34;
                            set ip_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol$Checksum@$sourceIpAddr@$destIpAddr@$options$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                            return $ip_stream
                    }
            }
            <a name="::ipV6(1)"><a href="./ePTClient2.tcl.html#::ipV6_1305">::ipV6</a></a>  {
                if {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp;  $nextHeader == &#34;udp&#34;} {
                    set frameType &#34;8100&#34;
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set nextHeader &#34;11&#34;
                        set payloadlength &#34;0072&#34;
                        set stream_name &#34;UDPVLANv6&#34;
                        set length &#34;001a&#34; 
                        set udp_checksum &#34;0000&#34;
                        set vlanipv6udp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destMacAddr$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $vlanipv6udp_stream
                } elseif {$nextHeader == &#34;udp&#34;} {
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set nextHeader &#34;11&#34;
                        set payloadlength &#34;0072&#34;
                        set stream_name &#34;UDPv6&#34;
                        set length &#34;001a&#34; 
                        set udp_checksum &#34;0000&#34;
                        set ipv6udp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destMacAddr$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$length$udp_checksum#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipv6udp_stream
                } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $nextHeader == &#34;tcp&#34;} {
                        set frameType &#34;8100&#34;
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set payloadlength &#34;0072&#34;
                        set nextHeader &#34;06&#34;
                        set length &#34;50&#34; 
                        set window_size &#34;0fa0&#34;
                        set tcp_checksum &#34;0000&#34;
                        set flags &#34;$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize&#34;
                        set flags [<a name="::bin2hex(4)"><a href="./ePTClient2.tcl.html#::bin2hex_1798">::bin2hex</a></a> $flags]
                        set ack_num $sequenceNumber
                        set stream_name &#34;TCPVLANv6&#34;
                        set vlanipv6tcp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $vlanipv6tcp_stream
                } elseif {$nextHeader == &#34;tcp&#34;} {
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set payloadlength &#34;0072&#34;
                        set nextHeader &#34;06&#34;
                        set length &#34;50&#34; 
                        set window_size &#34;0fa0&#34;
                        set tcp_checksum &#34;0000&#34;
                        set flags &#34;$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize&#34;
                        set flags [<a name="::bin2hex(5)"><a href="./ePTClient2.tcl.html#::bin2hex_1798">::bin2hex</a></a> $flags]
                        set ack_num $sequenceNumber
                        set stream_name &#34;TCPv6&#34;
                        set ipv6tcp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipv6tcp_stream
                } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34; &amp;&amp; $nextHeader == &#34;icmpV6&#34;} {
                        set frameType &#34;8100&#34;
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set payloadlength &#34;0072&#34;
                        set nextHeader &#34;01&#34;
                        set stream_name &#34;ICMPVLANv6&#34;
                        set icmp_checksum &#34;0000&#34;
                        set vlanipv6icmp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $vlanipv6icmp_stream
                } elseif {$nextHeader == &#34;icmpV6&#34;} {
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set payloadlength &#34;0072&#34;
                        set nextHeader &#34;01&#34;
                        set stream_name &#34;ICMPVLANv6&#34;
                        set icmp_checksum &#34;0000&#34;
                        set stream_name &#34;ICMPv6&#34;
                        set ipv6icmp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipv6icmp_stream
                } elseif {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34;} {
                        set frameType &#34;8100&#34;
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set payloadlength &#34;0072&#34;
                        set nextHeader &#34;3b&#34;
                        set stream_name &#34;IPVLANv6&#34;
                        set vlanipv6_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numS#$vlan_mode#$vlan_repeatA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $vlanipv6_stream
                } else {
                        set ipv6_frameType &#34;86dd&#34;
                        set version &#34;60&#34;
                        set Checksum &#34;0000&#34;
                        set payloadlength &#34;0072&#34;
                        set nextHeader &#34;3b&#34;
                        set stream_name &#34;IPv6&#34;
                        set ipv6_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipv6_stream
            }
           }  
            <a name="::ipx(1)"><a href="./ePTClient2.tcl.html#::ipx_903">::ipx</a></a> {
                if {$vlan_id !=0 &amp;&amp; $vlan_id != &#34;none&#34;} {
                    set frameType &#34;8100&#34;
                        set ipx_frameType &#34;8137&#34;
                        set stream_name &#34;IPXVLAN&#34;
                        set ipx_checksum &#34;0000&#34;
                        set length &#34;03ee&#34;
                        set transport_control &#34;00&#34;
                        set packet_type &#34;04&#34;
                        set ipxvlan_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipx_frameType$ipx_checksum$length$transport_control$packet_type@$destNetwork@$destNode$destSocket@$sourceNetwork@$sourceNode$sourceSocket$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipxvlan_stream
                } else {
                    set frameType &#34;8137&#34;
                        set stream_name &#34;IPX&#34;
                        set ipx_checksum &#34;0000&#34;
                        set length &#34;03ee&#34;
                        set transport_control &#34;00&#34;
                        set packet_type &#34;04&#34;
                        set ipx_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$ipx_checksum$length$transport_control$packet_type@$destNetwork@$destNode$destSocket@$sourceNetwork@$sourceNode$sourceSocket$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipx_stream
                }
            } 
            default {
                    set frameType &#34;0800&#34;
                        set protocol_name &#34;11&#34;
                        set headerlength &#34;45&#34; 
                        set dscp &#34;e0&#34;
                        set flags &#34;4000&#34;
                        set Checksum &#34;0000&#34;
                        set length &#34;001a&#34; 
                        set udp_checksum &#34;0000&#34;
                        set stream_name &#34;UDP&#34;
                        set ipudp_stream &#34;$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port&#34;
                        return $ipudp_stream
            } 
        }
}
<span class="comment-line">###################Stream construction ENDS HERE#########################################</span>

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
