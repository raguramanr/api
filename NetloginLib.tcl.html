<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>NetloginLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#NetloginLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>NetloginLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="NetloginLib.tcl-annot.html">annotations</a> | <a href="NetloginLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line">############################ IXIA SPECIFIC FUNCTIONS #######################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures that issue commands only to IXIA</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc nl_ixInit</span>
<span class="comment-line"># proc nl_ixGetLogs</span>
<span class="comment-line"># proc nl_ixGetIfMacs</span>
<span class="comment-line"># proc nl_ixGetPortIdMacs</span>
<span class="comment-line"># proc nl_ixCreatePortIfs</span>
<span class="comment-line"># proc nl_ixConfigDot1xPorts </span>
<span class="comment-line"># proc nl_ixConfigDot1xPortOnly</span>
<span class="comment-line"># proc nl_ixAddSupplicantToPort</span>
<span class="comment-line"># proc nl_ixStartSupAuth</span>
<span class="comment-line"># proc nl_ixStopSupAuth</span>
<span class="comment-line"># proc nl_ixDestroyDot1xPorts</span>
<span class="comment-line"># proc nl_ixCheckPortGroupStats </span>
<span class="comment-line"># proc nl_ixStartAuth</span>
<span class="comment-line"># proc nl_ixStopAuth</span>
<span class="comment-line"># proc nl_ixDumpInterfaceInfo</span>
<span class="comment-line"># proc nl_ixVerifySupplicantAccess</span>
<span class="comment-line"># proc nl_ixVerifyMultiSupplicantAccess</span>
<span class="comment-line"># proc nl_ixSendIpTraffic</span>
<span class="comment-line"># proc nl_ixStartEapolFlood </span>
<span class="comment-line"># proc nl_ixStopTx</span>
<span class="comment-line"># proc nl_ixStopEapolFlood</span>
<span class="comment-line"># proc nl_ixDumpSupplicantStats</span>
<span class="comment-line"># proc nl_ixCheckPing</span>
<span class="comment-line"># proc nl_ixSendPing</span>
<span class="comment-line"># proc nl_ixCheckDHCPBroadcastBlocked</span>
<span class="comment-line"># proc nl_ixDelSupMac</span>

<span class="comment-line"># ########################## EXTREME SPECIFIC SWITCH FUNCTIONS #######################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures that issue commands only to DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc nl_exEnableNetloginPort</span>
<span class="comment-line"># proc nl_exGetNetloginVal</span>
<span class="comment-line"># proc nl_exVerifyPortAuth</span>
<span class="comment-line"># proc nl_exVerifyMacAuth</span>
<span class="comment-line"># proc nl_exVerifyShowNetlogin</span>
<span class="comment-line"># proc nl_exVerifyShowNetloginPorts</span>
<span class="comment-line"># proc nl_exVerifyShowSession</span>
<span class="comment-line"># proc nl_exStandardVlanConfig </span>
<span class="comment-line"># proc nl_exRestartPort</span>
<span class="comment-line">#</span>
<span class="comment-line"># ########################## EXTREME + IXIA ############################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures that issue commands to DUT and IXIA</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc nl_CheckARPBroadcastBlocked</span>
<span class="comment-line"># proc nl_VerifyProtocol</span>
<span class="comment-line"># proc nl_VerifyDHCPBootPRelay</span>


<span class="comment-line"># ########################## GENERAL FUNCTIONS ############################</span>
<span class="comment-line">#</span>
<span class="comment-line"># General purpose procedures that do not issue commands to either DUT or Ixia</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc nl_stripMac</span>
<span class="comment-line"># proc nl_VerifySupplicantPackets</span>
<span class="comment-line"># proc nl_VerifySupplicantEAPPackets</span>
<span class="comment-line"># proc nl_VerifyTaggedPackets</span>
<span class="comment-line"># proc nl_SkipTestBasedOnPlatform</span>
<span class="comment-line"># proc nl_CheckDot1xTaskCrash</span>

<span class="comment-line"># ############################## INTERNAL LIBRARY FUNCTIONS ###########################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures internal to NetloginLib that should not be called by the user </span>
<span class="comment-line">#</span>
<span class="comment-line"># proc _ixStreamConfig</span>
<span class="comment-line"># proc _ixSeedFdbTable</span>
<span class="comment-line"># proc _ixCreateMultiSupplicantStreams</span>
<span class="comment-line"># proc _ixVerifyMultiSupplicantAccess</span>
<span class="comment-line"># proc _ixVerifySupplicantAccess</span>
<span class="comment-line"># proc _ixWaitForAuth</span>
<span class="comment-line"># proc _ixWaitForDeauth</span>
<span class="comment-line"># proc _ixWaitForSupAuth</span>
<span class="comment-line"># proc _reportVerifyProtocolResult</span>
<span class="comment-line"># proc _verifyEDP</span>
<span class="comment-line"># proc _verifySTP</span>
<span class="comment-line"># proc _verifyRIP</span>
<span class="comment-line"># proc _verifyOSPF</span>
<span class="comment-line"># proc _verifyIGMP</span>
<span class="comment-line"># proc _exCheckMatch</span>
<span class="comment-line"># proc _exMacMatch</span>
<span class="comment-line"># proc _exVerifyShowNetlogin</span>
<span class="comment-line"># proc _exVerifyShowNetloginPorts</span>


<span class="comment-line">#                           TYPICAL TOPOLOGY</span>
<span class="comment-line">#                           ----------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># We verify traffic by sending IP frames from supplicants to</span>
<span class="comment-line"># target and back.</span>
<span class="comment-line">#</span>
<span class="comment-line">#        IXIA</span>
<span class="comment-line">#   supMac1/supIp1                                    DUT1</span>
<span class="comment-line">#   supMac2/supIp2                       +--------------------------+  </span>
<span class="comment-line">#   supMac3/supIp3 -----------supPortId--| gwIp           (vlan_1)  |</span>
<span class="comment-line">#   supMacX/supIpX                       |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line"># targetMac/targetIp ------targetPortId--| targetPortGwIp (vlan_2)  |</span>
<span class="comment-line">#                                        |   t1  t2                 |  </span>
<span class="comment-line">#                                        +----+--+-----+------------+</span>
<span class="comment-line">#                                             |  |     |       </span>
<span class="comment-line">#                                             |  |     |</span>
<span class="comment-line">#                                             |  |     +--commvlan------&gt; RADIUS</span>
<span class="comment-line">#                                             |  |           |</span>
<span class="comment-line">#                                             |  |     DUT2  |</span>
<span class="comment-line">#                                        +----+--+-----------+------+</span>
<span class="comment-line">#                                        |   t1  t2                 |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        +--------------------------+</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTES: Writing Port Configuration to Ixia causes port to go down, and</span>
<span class="comment-line">#        thus Deauthenticate port. Writing Stream Config does not </span>
<span class="comment-line">#        bring port down.</span>


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixInit</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Connects to IXIA chassis and defaults the ports.</span>
<span class="comment-line">#              Chassis must be running IxOS 3.65 or higher</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: chassis: IP Address of Ixia chassis to connect to</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixInit_134">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixInit">::::nl_ixInit</a></a></strong> { chassis } {

    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nIxTclHAL version   :[<a name="::version(1)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> cget -ixTclHALVersion]&#34;
    <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Product version    :[<a name="::version(2)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> cget -productVersion]&#34;
    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Installed version  :[<a name="::version(3)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> cget -installVersion]&#34;

    if {[ isUNIX ]} {
        set errMsg &#34;&#34;
        dot1xUtil::connectToTclServer  $chassis errMsg
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixGetLogs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retreives DOT1x Logs for a set of ports.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: ID of ports to retrieve logs from</span>
<span class="comment-line">#             filename:   Filename to store logs in</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTES: 02/03/04: This does NOT work when running script outside</span>
<span class="comment-line">#                  of Ixia chassis.  Ixia to fix.</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixGetLogs_160">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixGetLogs">::::nl_ixGetLogs</a></a></strong> { portIdList filename } {
    
    set portList [list]

    foreach portId $portIdList {
	<a name="::MapIxiaPortId(1)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
	lappend portList &#34;$chassis $card $port&#34;
    }

    <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Retrieving logs for $portList and putting in [pwd]/$filename&#34;

    dot1xGetLogs portList $filename
    
    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Exiting nl_ixGetLogs&#34;
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixGetIfMacs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retreives all the Macs on a ch/ca/po</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: ch(assis) ca(rd) po(rt)</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: List of MAC interfaces created on this port.</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixGetIfMacs_188">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixGetIfMacs">::::nl_ixGetIfMacs</a></a></strong> { ch ca po } {

    set macList [list]

    interfaceTable select $ch $ca $po

    ;<span class="comment-line"># Walk through interfaceTable!</span>
    for {set curIf [interfaceTable getFirstInterface]} \
	    {$curIf == 0 } {set curIf [interfaceTable getNextInterface]} {
	set mac [interfaceEntry cget -macAddress]
	lappend macList $mac
    }
    return $macList
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixGetPortIdMacs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retreives all the Macs on a given portID</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portId: Which port Id to retreive</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: List of MAC interfaces created on this port.</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixGetPortIdMacs_213">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixGetPortIdMacs">::::nl_ixGetPortIdMacs</a></a></strong> { portId } {

    <a name="::MapIxiaPortId(2)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    return [<a name="::nl_ixGetIfMacs(1)"><a href="./NetloginLib.tcl.html#::nl_ixGetIfMacs_188">::nl_ixGetIfMacs</a></a> $ch $ca $po]
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixCreatePortIfs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configure port interfaces.  Each interface (or supplicant)</span>
<span class="comment-line">#              has a MAC and IP address. Before you can configure supplicants</span>
<span class="comment-line">#              and supTable, you need to create the &#34;virtual&#34; interfaces</span>
<span class="comment-line">#              representing these supplicants.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: -portInfoList: List of ports to create interfaces on</span>
<span class="comment-line">#                 &lt;portId&gt; &lt;startIp&gt; &lt;gw&gt; &lt;numSupplicants&gt; &lt;vlanId*&gt;</span>
<span class="comment-line">#                    *vlanId is optional </span>
<span class="comment-line">#             -startMacAddr: First 3 octets of MAC.  Last three are </span>
<span class="comment-line">#                            generated as card:port:count  </span>
<span class="comment-line">#               *If 6 octets are given, we just increment starting from there</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#    lappend portInfoList &#34;1 10.1.1.1 10.1.1.254 8&#34;</span>
<span class="comment-line">#    lappend portInfoList &#34;2 10.1.1.1 10.1.1.254 1&#34;</span>
<span class="comment-line">#    nl_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr &#34;00 00 01&#34;</span>
<span class="comment-line">#    nl_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr &#34;00 00 01 11 22 33&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixCreatePortIfs_246">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixCreatePortIfs">::::nl_ixCreatePortIfs</a></a></strong> {args} {
    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_setupPortInterfaces $args {
	portInfoList &#34;1  10.1.1.1  10.1.1.254  1&#34;
	startMacAddr &#34;00 00 01&#34;    ;<span class="comment-line"># Last 3 octets are CARD:PORT:COUNT </span>
	protocolServer &#34;disable&#34;
    }

    set portList [list]

    ;<span class="comment-line"># List of port intf {{&lt;port&gt; &lt;IP&gt; &lt;MAC&gt;} ... }</span>
    set ifInfoList [list]

    ;<span class="comment-line"># Configure interfaces for each port</span>
    foreach port $portInfoList {

	set portId [lindex $port 0]
	<a name="::MapIxiaPortId(3)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> [lindex $portId 0] ch ca po

	set portStartIpAddr [lindex $port 1]
	set portGwIpAddr [lindex $port 2]
	set numSupplicants [lindex $port 3]
	set vlanId [lindex $port 4]

	;<span class="comment-line"># Create a portList</span>
	lappend portList &#34;$ch $ca $po&#34;

	<a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;portStartIpAddr:$portStartIpAddr  \
		portGwIpAddr:$portGwIpAddr numSupplicants:$numSupplicants&#34; 

	;<span class="comment-line"># Default each port before configuring</span>
         <span class="comment-line"># commented as it affects the fiber ports and brings them up</span>
         <span class="comment-line"># as copper ports and links go down; In watch state Subrat</span>
        if {0} { 
        if [<a name="::port(1)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setFactoryDefaults $ch $ca $po] {
            <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;WARNING: port setFactoryDefaults $ch $ca $po failed&#34;
	    continue
        }
            <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;WARNING: port setFactoryDefaults $ch $ca $po &#34;
        }

	set incrOctet 4
	interfaceTable  select  $ch $ca $po
	
	interfaceTable clearAllInterfaces
	interfaceEntry clearAllItems addressTypeIpV6
	interfaceEntry clearAllItems addressTypeIpV4
	
	set ipAddressForThisInterface $portStartIpAddr

	set gCount 1
	for {set count 1} {$count &lt;= $numSupplicants} {incr count} {

	    if {[string length $startMacAddr] == 8} {
		;<span class="comment-line"># Normal case</span>
		set curMac &#34;$startMacAddr [format &#34;%02x %02x %02x&#34; $ca $po $gCount]&#34;
	    } else {
		set curMac [<a name="::IncMacByOne(1)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $startMacAddr &#34; &#34;]
		set startMacAddr $curMac
	    }
	    set ifInfoEntry [list $portId $ipAddressForThisInterface $curMac]
	    lappend ifInfoList $ifInfoEntry

	    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ipAddressForThisInterface: $ipAddressForThisInterface MAC: $curMac&#34;
	    
	    interfaceIpV4   setDefault
	    interfaceIpV4   config      -gatewayIpAddress  $portGwIpAddr
	    interfaceIpV4   config      -maskWidth         24
	    interfaceIpV4   config      -ipAddress         $ipAddressForThisInterface

	    interfaceEntry  addItem     addressTypeIpV4	    
	    interfaceEntry  setDefault
	    interfaceEntry  config      -enable            $::true
	    interfaceEntry  config      -description       [format &#34;%02d:%02d - $count&#34; $ca $po]
	    interfaceEntry  config      -macAddress        $curMac

	    if {$vlanId != &#34;&#34; } {
		interfaceEntry  config      -enableVlan         $::true
		interfaceEntry  config      -vlanId             $vlanId
	    } else {
		interfaceEntry  config      -enableVlan         $::false
		interfaceEntry  config      -vlanId             0
	    }
	    interfaceTable  addInterface
	    
	    if {$protocolServer == &#34;enable&#34;} {
		protocolServer  config      -enableArpResponse  $::true
		protocolServer  config      -enablePingResponse $::true
		if [protocolServer  set $ch $ca $po] {
		    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR : protocolServer  set $ch $ca $po&#34;
		}
	    }

	    set ipAddressForThisInterface [<a name="::incrIpField(1)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipAddressForThisInterface $incrOctet]
	    incr gCount
	}
    }
    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Writing portList $portList to hardware.&#34;

    <a name="::ixWritePortsToHardware(1)"><a href="./mapping.tcl.html#::ixWritePortsToHardware_145">::ixWritePortsToHardware</a></a> portList

    ;<span class="comment-line"># Dump some info for debugging.</span>
    ;<span class="comment-line"># nl_ixDumpInterfaceInfo</span>

    return $ifInfoList
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixDestroyPortIfs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Destroy all port interface on a port.  Actually we just</span>
<span class="comment-line">#              default the entire port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: -portInfoList: List of ports to default</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################## </span>
<strong><a name="::::nl_ixDestroyPortIfs_362">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixDestroyPortIfs">::::nl_ixDestroyPortIfs</a></a></strong> {args} {
    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_setupPortInterfaces $args {
	portInfoList &#34;1&#34;
    }

    set portList [list]

    ;<span class="comment-line"># Configure interfaces for each port</span>
    foreach port $portInfoList {

	set portId [lindex $port 0]
        set ipAddr [lindex $port 1]
	<a name="::MapIxiaPortId(4)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> [lindex $portId 0] ch ca po
        <a name="::DisableProtocolServer(1)"><a href="./CheckArp.tcl.html#::DisableProtocolServer_371">::DisableProtocolServer</a></a> $portId $ipAddr

	;<span class="comment-line"># Default each port</span>
        if {0} {
        if [<a name="::port(2)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setFactoryDefaults $ch $ca $po] {
            <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;WARNING: port setFactoryDefaults $ch $ca $po failed&#34;
	    continue
        }
        }
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixConfigDot1xPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configures Ports for Dot1X.  Uses interfaces created on each </span>
<span class="comment-line">#              port to configure supplicants.  All supplicants for a particular </span>
<span class="comment-line">#              port group will have the same parameters. </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#	portGroupId        ;# Dot1x port group</span>
<span class="comment-line">#	portIdList         ;# Port mapping ID</span>
<span class="comment-line">#	authPeriod         ;# Secs to wait for DUT response 1-3600</span>
<span class="comment-line">#	heldPeriod         ;# Secs after timeout before sending next auth 1-3600</span>
<span class="comment-line">#	startPeriod        ;# Secs between successive EAPOL-Start msgs 1-3600</span>
<span class="comment-line">#	maxStart           ;# Number of EAPOL-Starts before deeming failure 1-10000</span>
<span class="comment-line"># 	fragmentSize       ;# Max frag for EAP TLS packet 500-1400</span>
<span class="comment-line">#	maxSessions        ;# Number sessions for this port</span>
<span class="comment-line">#	setupDelay         ;# Millsec between start of 1 auth to next. 0-4,294,967,295</span>
<span class="comment-line">#	establishDelay     ;# Millsec between completed/failed auth to next multiauth</span>
<span class="comment-line">#	logoffDelay        ;# Millsec delay between successive logoff msgs at teardown</span>
<span class="comment-line">#	dutTestMode        ;# 0 =&gt; Single-Host, 1 =&gt; Multi-Host, 2=&gt; Multi Auth</span>
<span class="comment-line">#	enableSessionOnly  ;# 0 =&gt; Only session, no stream.  We can manually gen stream</span>
<span class="comment-line">#	holdTime           ;# Secs between auth and logoff 0-1,000,000</span>
<span class="comment-line">#	enableRandomHold   ;# 1-Set holdTime to random values</span>
<span class="comment-line">#	enableOnlyMulticastDestMac  ;# 1-Use multicast MAC instead of auth MAC </span>
<span class="comment-line">#	enableAuthOnNoResponse      ;# 1-Supplicant consider itself auth if no response</span>
<span class="comment-line">#	enableStateMachineDebug     ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableConfigurationDebug    ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableEapolFramesDebug      ;# 1- Generate DEBUG LOG  </span>
<span class="comment-line">#	testDuration            ;# Duration of entire test</span>
<span class="comment-line">#	authPass                ;# Password sent for auth	</span>
<span class="comment-line">#	authUser                ;# Username sent for auth</span>
<span class="comment-line">#	dot1xAuth      ;# dot1xAuthMD5,1  dot1xAuthTLS,0</span>
<span class="comment-line">#	dot1xUser      ;# dot1xUserNormal,0 dot1xUserFailing,1 Expect failure.</span>
<span class="comment-line">#	supHoldTime               ;# -1 use port holdTime</span>
<span class="comment-line">#	supNumNoIdResponse        ;# Number of times to suppress EAP-ID msgs 0-100</span>
<span class="comment-line">#	supNumNoAuthResponse      ;# Number of times to suppress EAP-Auth msgs 0-100</span>
<span class="comment-line">#	supEnableWaitIdRequest    ;# &#34;true&#34;-Wait for DUT initiate EAP, rather than sending EAP-start</span>
<span class="comment-line">#       certificateDir            ;# Directory where certificates are located</span>
<span class="comment-line">#	maxSupplicants &#34;          ;# max number of suplicants to add, otherwise 1 per port MAC</span>
<span class="comment-line">#	destroy  &#34;no&#34;             ;# Destroy old port group first</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#    nl_ixConfigDot1xPorts -portIdList &#34;1&#34; -portGroupId &#34;1&#34; \</span>
<span class="comment-line">#	   -authUser $uname -authPass $upass</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixConfigDot1xPorts_436">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixConfigDot1xPorts">::::nl_ixConfigDot1xPorts</a></a></strong> {args} {
    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_ixConfigDot1x $args {
	portGroupId &#34;1&#34;        
	portIdList &#34;1&#34;         
	authPeriod &#34;15&#34;        
	heldPeriod &#34;10&#34;        
	startPeriod &#34;10&#34;       
	maxStart &#34;3&#34;           
 	fragmentSize &#34;640&#34;     
	maxSessions  &#34;64&#34;      
	setupDelay   &#34;0&#34;       
	establishDelay &#34;1000&#34;  
	logoffDelay &#34;120&#34;       
	dutTestMode  &#34;2&#34;       
	enableSessionOnly &#34;0&#34;
	holdTime &#34;0&#34;
	enableRandomHold &#34;0&#34;
	enableOnlyMulticastDestMac &#34;1&#34;
	enableAuthOnNoResponse &#34;0&#34;
	enableStateMachineDebug &#34;1&#34;
	enableConfigurationDebug &#34;1&#34;
	enableEapolFramesDebug &#34;1&#34;
	testDuration &#34;240&#34;
	authUser  &#34;md5_isp_1&#34;
	authPass  &#34;md5_isp_1&#34;
	dot1xAuth &#34;dot1xAuthMD5&#34;     
	dot1xUser &#34;dot1xUserNormal&#34;  
	supHoldTime &#34;-1&#34;             
	supNumNoIdResponse &#34;0&#34;       
	supNumNoAuthResponse &#34;0&#34;     
	supEnableWaitIdRequest &#34;0&#34;   
        certificateDir &#34;./certfiles&#34; 
	maxSupplicants &#34;0&#34;           
	destroy  &#34;no&#34;                
    }
    
    ;<span class="comment-line"># Generate Ixia portList from IDs</span>
    foreach portId $portIdList {
	<a name="::MapIxiaPortId(5)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
	lappend portList &#34;$chassis $card $port&#34;
    }
    <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Establishing communication with port CPUs $portList &#34;

    set status [dot1xSetup $portList]
    if {$status} {
	<a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR: Could not set up ports for dot1x status $status&#34;
	return 0
    }

    if {$destroy  == &#34;yes&#34;} {
	;<span class="comment-line"># Destroy old port group</span>
	dot1xPortGroup destroy $portGroupId
    }


    <span class="comment-line"># Create a port Group</span>


    dot1xPortGroup setDefault
    dot1xPortGroup create $portGroupId
    
    <span class="comment-line"># Setup generic port properties</span>


    dot1xPort setDefault
    dot1xPort config -authPeriod        $authPeriod
    dot1xPort config -heldPeriod        $heldPeriod
    dot1xPort config -startPeriod       $startPeriod
    dot1xPort config -maxStart          $maxStart
    dot1xPort config -fragmentSize      $fragmentSize
    dot1xPort config -maxSessions       $maxSessions
    dot1xPort config -setupDelay        $setupDelay
    dot1xPort config -establishDelay    $establishDelay
    dot1xPort config -logoffDelay       $logoffDelay
    dot1xPort config -dutTestMode       $dutTestMode
    dot1xPort config -enableSessionOnly $enableSessionOnly
    dot1xPort config -holdTime          $holdTime
    dot1xPort config -enableRandomHold           $enableRandomHold
    dot1xPort config -enableOnlyMulticastDestMac $enableOnlyMulticastDestMac
    dot1xPort config -enableAuthOnNoResponse     $enableAuthOnNoResponse
    dot1xPort config -enableStateMachineDebug    $enableStateMachineDebug
    dot1xPort config -enableConfigurationDebug   $enableConfigurationDebug
    dot1xPort config -enableEapolFramesDebug     $enableEapolFramesDebug
    dot1xPort config -testDuration               $testDuration
    
    <span class="comment-line"># Create configuration for each port we are interested in</span>


    foreach testPort $portList {
	
	<a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Creating dot1x configuration for the port $testPort&#34;
	
	<span class="comment-line"># Setup individual port</span>


	scan $testPort &#34;%d %d %d&#34; ch ca po
	dot1xPort set  $ch $ca $po
	dot1xPortGroup add $portGroupId $ch $ca $po
	
	<span class="comment-line"># Cleanup the supplicant table for this port</span>


	dot1xSupplicantTable select $ch $ca $po
	dot1xSupplicantTable delAll
	
	<span class="comment-line"># Add supplicants to this port</span>


	set supplicantMacList [<a name="::nl_ixGetIfMacs(2)"><a href="./NetloginLib.tcl.html#::nl_ixGetIfMacs_188">::nl_ixGetIfMacs</a></a> $ch $ca $po]
	if {$maxSupplicants &gt; 0} {
	    ;<span class="comment-line"># Only add max count</span>
	    set supplicantMacList [lrange $supplicantMacList 0 [expr $maxSupplicants - 1]]
	}
	
	foreach suppMac $supplicantMacList {

	    dot1xSupplicant setDefault
	    dot1xSupplicant config -macAddr $suppMac
	    dot1xSupplicant config -userType $dot1xUser
	    dot1xSupplicant config -authType $dot1xAuth
	    dot1xSupplicant config -userName $authUser
	    dot1xSupplicant config -passWord $authPass
	    dot1xSupplicant config -holdTime $supHoldTime
	    dot1xSupplicant config -numNoIdResponse $supNumNoIdResponse
	    dot1xSupplicant config -numNoAuthResponse $supNumNoAuthResponse
	    dot1xSupplicant config -enableWaitIdRequest $supEnableWaitIdRequest
	    dot1xSupplicantTable add
	    <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po) Adding MAC:$suppMac u:$authUser p:$authPass authType:$dot1xAuth userType:$dot1xUser&#34;
	    <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     numNoIdResponse:$supNumNoIdResponse numNoAuthResponse:$supNumNoAuthResponse&#34;
	    <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     enableWaitIdRequest:$supEnableWaitIdRequest&#34;
	}
	    
	<span class="comment-line"># Setup maxsessions</span>


	set aSupplicantCnt [llength $supplicantMacList]
	dot1xPort config -maxSessions $aSupplicantCnt
	dot1xPort set  $ch $ca $po
    }
	

    <span class="comment-line"># All ports have been added to a port group. Now write the entire group</span>


    dot1xPortGroup setCommand $portGroupId writeConfig
    
    <span class="comment-line"># Initialize the stat information for this group</span>


    dot1xPortGroup setCommand $portGroupId resetStats

    <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;AuthType is $dot1xAuth&#34;

    if {$dot1xAuth == &#34;dot1xAuthTLS&#34;} {    

	<a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Downloading certificates from $certificateDir to ports $portList&#34;

	<span class="comment-line"># Download Certificate files on the port for TLS authentication</span>
	
	<span class="comment-line"># Use this command for downloading all the cert in dir to all ports	</span>
	dot1xDownloadCertificates $portList $certificateDir
	
	<span class="comment-line"># set usernamelist {}</span>
	<span class="comment-line"># lappend usernamelist $authUser</span>
	<span class="comment-line"># Use the command below for individual certificates</span>
	<span class="comment-line"># dot1xDownloadUserSpecificCertificates $ch $ca $po \</span>
		<span class="comment-line">#    &#34;C:\\Program Files\\Ixia\\authfiles&#34; \</span>
		<span class="comment-line">#    &#34;C:\\Program Files\\Ixia\\authfiles&#34; \</span>
		<span class="comment-line">#    $usernamelist</span>
    }

    return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixConfigDot1xPortOnly</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configures Ports for Dot1X.  DOES NOT configure</span>
<span class="comment-line">#              supplicants.  Allows us to configure the ports,</span>
<span class="comment-line">#              THEN configure &#34;custom&#34; supplicants.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#	portGroupId         ;# Dot1x port group</span>
<span class="comment-line">#	portIdList          ;# Port mapping ID</span>
<span class="comment-line">#	authPeriod          ;# Secs to wait for DUT response 1-3600</span>
<span class="comment-line">#	heldPeriod          ;# Secs after timeout before sending next auth 1-3600</span>
<span class="comment-line">#	startPeriod         ;# Secs between successive EAPOL-Start msgs 1-3600</span>
<span class="comment-line">#	maxStart            ;# Number of EAPOL-Starts before deeming failure 1-10000</span>
<span class="comment-line"># 	fragmentSize        ;# Max frag for EAP TLS packet 500-1400</span>
<span class="comment-line">#	maxSessions         ;# Number sessions for this port</span>
<span class="comment-line">#	setupDelay          ;# Millsec between start of 1 auth to next. 0-4,294,967,295</span>
<span class="comment-line">#	establishDelay      ;# Millsec between completed/failed auth to next multiauth</span>
<span class="comment-line">#	logoffDelay         ;# Millsec delay between successive logoff msgs at teardown</span>
<span class="comment-line">#	dutTestMode         ;# 0 =&gt; Single-Host, 1 =&gt; Multi-Host, 2=&gt; Multi Auth</span>
<span class="comment-line">#	enableSessionOnly   ;# 0 =&gt; Only session, no stream.  We can manually gen stream</span>
<span class="comment-line">#	holdTime            ;# Secs between auth and logoff 0-1,000,000</span>
<span class="comment-line">#	enableRandomHold    ;# 1-Set holdTime to random values</span>
<span class="comment-line">#	enableOnlyMulticastDestMac   ;# 1-Use multicast MAC instead of auth MAC </span>
<span class="comment-line">#	enableAuthOnNoResponse    ;# 1-Supplicant consider itself auth if no response</span>
<span class="comment-line">#	enableStateMachineDebug   ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableConfigurationDebug  ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableEapolFramesDebug    ;# 1- Generate DEBUG LOG  </span>
<span class="comment-line">#	testDuration              ;# Duration of entire test</span>
<span class="comment-line">#       certificateDir            ;# Directory where certificates are located</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#    nl_ixConfigDot1xPortOnly -portIdList &#34;1&#34; -portGroupId &#34;1&#34; \</span>
<span class="comment-line">#	   -authUser $uname -authPass $upass</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixConfigDot1xPortOnly_650">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixConfigDot1xPortOnly">::::nl_ixConfigDot1xPortOnly</a></a></strong> {args} {
    <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_ixConfigDot1x $args {
	portGroupId &#34;1&#34;
	portIdList &#34;1&#34;
	authPeriod &#34;15&#34;
	heldPeriod &#34;10&#34;
	startPeriod &#34;10&#34;
	maxStart &#34;3&#34;
 	fragmentSize &#34;640&#34;
	maxSessions  &#34;64&#34;
	setupDelay   &#34;0&#34;
	establishDelay &#34;1000&#34;
	logoffDelay &#34;20&#34;
	dutTestMode  &#34;2&#34;
	enableSessionOnly &#34;0&#34;
	holdTime &#34;0&#34;
	enableRandomHold &#34;0&#34;
	enableOnlyMulticastDestMac &#34;1&#34;
	enableAuthOnNoResponse &#34;0&#34;
	enableStateMachineDebug &#34;1&#34;
	enableConfigurationDebug &#34;1&#34;
	enableEapolFramesDebug &#34;1&#34;
	testDuration &#34;3600&#34;
        certificateDir &#34;./certfiles&#34;
    }
    
    ;<span class="comment-line"># Generate Ixia portList from IDs</span>
    foreach portId $portIdList {
	<a name="::MapIxiaPortId(6)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
	lappend portList &#34;$chassis $card $port&#34;
    }
    <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Establishing communication with port CPUs $portList &#34;

    set status [dot1xSetup $portList]
    if {$status} {
	<a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR: Could not set up ports for dot1x status $status&#34;
	return 0
    }

    <span class="comment-line"># Create a port Group</span>


    dot1xPortGroup setDefault
    dot1xPortGroup create $portGroupId
    
    <span class="comment-line"># Setup generic port properties</span>


    dot1xPort setDefault
    dot1xPort config -authPeriod        $authPeriod
    dot1xPort config -heldPeriod        $heldPeriod
    dot1xPort config -startPeriod       $startPeriod
    dot1xPort config -maxStart          $maxStart
    dot1xPort config -fragmentSize      $fragmentSize
    dot1xPort config -maxSessions       $maxSessions
    dot1xPort config -setupDelay        $setupDelay
    dot1xPort config -establishDelay    $establishDelay
    dot1xPort config -logoffDelay       $logoffDelay
    dot1xPort config -dutTestMode       $dutTestMode
    dot1xPort config -enableSessionOnly $enableSessionOnly
    dot1xPort config -holdTime          $holdTime
    dot1xPort config -enableRandomHold           $enableRandomHold
    dot1xPort config -enableOnlyMulticastDestMac $enableOnlyMulticastDestMac
    dot1xPort config -enableAuthOnNoResponse     $enableAuthOnNoResponse
    dot1xPort config -enableStateMachineDebug    $enableStateMachineDebug
    dot1xPort config -enableConfigurationDebug   $enableConfigurationDebug
    dot1xPort config -enableEapolFramesDebug     $enableEapolFramesDebug
    dot1xPort config -testDuration               $testDuration
    
    <span class="comment-line"># Create configuration for each port we are interested in</span>


    foreach testPort $portList {
	
	<a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Creating dot1x configuration for the port $testPort&#34;
	
	<span class="comment-line"># Setup individual port</span>


	scan $testPort &#34;%d %d %d&#34; ch ca po
	dot1xPort set  $ch $ca $po
	dot1xPortGroup add $portGroupId $ch $ca $po	
    }
	
    <span class="comment-line"># Cleanup the supplicant table for this port</span>


    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable delAll

    <span class="comment-line"># All ports have been added to a port group. Now write the entire group</span>


    dot1xPortGroup setCommand $portGroupId writeConfig
    
    <span class="comment-line"># Initialize the stat information for this group</span>


    dot1xPortGroup setCommand $portGroupId resetStats

}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixAddSupplicantToPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Once dot1xPort is configured, this procedure can be</span>
<span class="comment-line">#              used to add 1 or more supplicants to that port.</span>
<span class="comment-line">#              Each supplicant can be configured with different</span>
<span class="comment-line">#              parameters</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#	portId                  ;# Port mapping ID</span>
<span class="comment-line">#	suppMac                 ;# Supplicant MAC</span>
<span class="comment-line">#	authUser                ;# Username</span>
<span class="comment-line">#	authPass                ;# Password</span>
<span class="comment-line">#	dot1xAuth               ;# dot1xAuthMD5,1  dot1xAuthTLS,0</span>
<span class="comment-line">#	dot1xUser               ;# dot1xUserNormal,0 dot1xUserFailing,1 Expect failure.</span>
<span class="comment-line">#	supHoldTime             ;# -1 use port holdTime</span>
<span class="comment-line">#	supNumNoIdResponse      ;# Number of times to suppress EAP-ID msgs (0-100)</span>
<span class="comment-line">#	supNumNoAuthResponse    ;# Number of times to suppress EAP-Auth msgs (0-100)</span>
<span class="comment-line">#	supEnableWaitIdRequest  ;# 1-Wait for DUT initiate EAP, rather than sending EAP-start</span>
<span class="comment-line">#	doWriteHw               ;# Option to write to to Ixia hw now.  Gives user</span>
<span class="comment-line">#                               ;# to do several adds then a single write.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixAddSupplicantToPort_780">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixAddSupplicantToPort">::::nl_ixAddSupplicantToPort</a></a></strong> {args} {
    <a name="::parse_args(5)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_ixAddSupplicantToPort $args {
	portId    1
	suppMac   &#34;00 00 00 00 00 01&#34;
	authUser  &#34;md5_isp_1&#34;
	authPass  &#34;md5_isp_1&#34;
	dot1xAuth &#34;dot1xAuthMD5&#34;
	dot1xUser &#34;dot1xUserNormal&#34;
	supHoldTime &#34;-1&#34;
	supNumNoIdResponse &#34;0&#34;
	supNumNoAuthResponse &#34;0&#34;
	supEnableWaitIdRequest &#34;0&#34;
	doWriteHw  &#34;1&#34;
    }

    <a name="::MapIxiaPortId(7)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po
    <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Adding Supplicant to $ch $ca $po&#34;

    dot1xSupplicantTable select $ch $ca $po
	
    <span class="comment-line"># Add supplicant to this port</span>


    dot1xSupplicant setDefault
    dot1xSupplicant config -macAddr $suppMac
    dot1xSupplicant config -userType $dot1xUser
    dot1xSupplicant config -authType $dot1xAuth
    dot1xSupplicant config -userName $authUser
    dot1xSupplicant config -passWord $authPass
    dot1xSupplicant config -holdTime $supHoldTime
    dot1xSupplicant config -numNoIdResponse $supNumNoIdResponse
    dot1xSupplicant config -numNoAuthResponse $supNumNoAuthResponse
    dot1xSupplicant config -enableWaitIdRequest $supEnableWaitIdRequest
    dot1xSupplicantTable add
    <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po) Adding MAC:$suppMac u:$authUser p:$authPass authType:$dot1xAuth userType:$dot1xUser&#34;
    <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     numNoIdResponse:$supNumNoIdResponse numNoAuthResponse:$supNumNoAuthResponse&#34;
    <a name="::result_debug(27)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     enableWaitIdRequest:$supEnableWaitIdRequest&#34;
    
    if { $doWriteHw == &#34;1&#34; } {
	dot1xSupplicantTable write
    }

}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForSupAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that loops waiting  for a particular </span>
<span class="comment-line">#              supplicant to authenticate.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 0 - Failed to authenticate</span>
<span class="comment-line">#              1 - Authenticate successful</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForSupAuth_839">proc <a href="NetloginLib.tcl-annot.html#::::_ixWaitForSupAuth">::::_ixWaitForSupAuth</a></a></strong> { portId mac maxAuthWait } {

    <a name="::MapIxiaPortId(8)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    set curDuration 0
    
    while {$curDuration &lt; $maxAuthWait} {
	puts &#34;Waiting for mac $mac to Auth (max:$maxAuthWait)... $curDuration&#34;
	after 1000

	dot1xSupplicantStats get $ch $ca $po $mac
	if { [dot1xSupplicantStats cget -totalSuccess] &gt;= 1 } {
	    break
	}
	incr curDuration 1
    }

    if {$curDuration == $maxAuthWait} {
	<a name="::result_debug(28)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication could not be completed for $mac =====&#34;
	return 0
    }

    <a name="::nl_ixDumpSupplicantStats(1)"><a href="./NetloginLib.tcl.html#::nl_ixDumpSupplicantStats_2230">::nl_ixDumpSupplicantStats</a></a> $portId $mac 
    return 1

}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStartSupAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Wait for a particular supplicant to authenticate.</span>
<span class="comment-line">#              This assumes we reset counters prior to starting since </span>
<span class="comment-line">#              we check that totalSuccess is greater than 1.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 0 - Failed to authenticate</span>
<span class="comment-line">#              1 - Authenticate successful</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStartSupAuth_883">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStartSupAuth">::::nl_ixStartSupAuth</a></a></strong> { portId mac {maxAuthWait 10} } {

    <a name="::MapIxiaPortId(9)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    ;<span class="comment-line"># Reset stats before starting.</span>
    dot1xSupplicantStats reset $ch $ca $po $mac

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable start $mac
    <a name="::result_debug(29)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Starting sup $mac&#34;

    if { $maxAuthWait != 0 } {
	if { [<a name="::_ixWaitForSupAuth(1)"><a href="./NetloginLib.tcl.html#::_ixWaitForSupAuth_839">::_ixWaitForSupAuth</a></a> $portId $mac $maxAuthWait] == 0 } { 
	    <a name="::result_debug(30)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Authentication failed for mac $mac...test exiting.&#34;
	    return 0
	}
    } else {
	<a name="::result_debug(31)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not waiting for authentication of mac $mac...&#34;
    }

    return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStopSupAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Stop a particular supplicant's authenticated session.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStopSupAuth_917">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStopSupAuth">::::nl_ixStopSupAuth</a></a></strong> { portId mac {maxAuthWait 4} } {

    <a name="::MapIxiaPortId(10)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    ;<span class="comment-line"># Reset stats before starting.</span>
    dot1xSupplicantStats reset $ch $ca $po $mac

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable stop $mac
    <a name="::result_debug(32)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stopping sup $mac&#34;

    <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $maxAuthWait

    return 1
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixDelSupMac</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Delete a particular supplicant from supplicant table.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixDelSupMac_943">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixDelSupMac">::::nl_ixDelSupMac</a></a></strong> { portId mac {maxAuthWait 4} {doWriteHw 1}} {

    <a name="::MapIxiaPortId(11)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable del $mac
    <a name="::result_debug(33)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Deleting sup $mac&#34;

    if { $doWriteHw == &#34;1&#34; } {
	dot1xSupplicantTable write
    }

    <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $maxAuthWait

    return 1
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixDestroyDot1xPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Wait for a particular supplicant to authenticate.</span>
<span class="comment-line">#              This assumes we reset counters prior to starting since </span>
<span class="comment-line">#              we check that totalSuccess is greater than 1.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: -portGroupId: Dot1x port group</span>
<span class="comment-line">#             -portIdList: Port IDs in group to destroy </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixDestroyDot1xPorts_973">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixDestroyDot1xPorts">::::nl_ixDestroyDot1xPorts</a></a></strong> {args} {
    <a name="::parse_args(6)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_ixDestroyDot1x $args {
	portGroupId &#34;1&#34;
	portIdList &#34;1&#34;
    }
    
    ;<span class="comment-line"># Generate Ixia portList from IDs</span>
    foreach portId $portIdList {
	<a name="::MapIxiaPortId(12)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
	lappend portList &#34;$chassis $card $port&#34;
    }

    <a name="::result_debug(34)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Cleaning up DOT1x $portList &#34;

    dot1xPortGroup destroy $portGroupId
    dot1xCleanup $portList
}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixCheckPortGroupStats</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Check the dot1x port group stats against a particular </span>
<span class="comment-line">#              value.  Posts actual pass/fail.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             stat: Which stat to compare. See below for values</span>
<span class="comment-line">#             operator: ==, &gt;, &lt;, etc.</span>
<span class="comment-line">#             value: Value to compare against</span>
<span class="comment-line">#</span>
<span class="comment-line"># VALID IXIA stat PARAMETER:</span>
<span class="comment-line">#   allSessionsEstablished, lastStats, </span>
<span class="comment-line">#   eapolStartSent, eapIdResponseSent, eapolLogoffSent, eapNonIdResponseSent, </span>
<span class="comment-line">#   eapIdRequestReceived, eapNonIdRequestReceived, eapSuccessReceived, </span>
<span class="comment-line">#   eapFailureReceived, eapAlertReceived, eapUnExpFailure, </span>
<span class="comment-line">#   md5Sessions, md5Success, md5FailTimeout, md5FailEap, md5MaxLatency</span>
<span class="comment-line">#   md5MinLatency, md5AvgLatency</span>
<span class="comment-line">#   tlsSessions, tlsSuccess, tlsFailTimeout, tlsFailEap, tlsMaxLatency</span>
<span class="comment-line">#   tlsMinLatency, tlsAvgLatency</span>
<span class="comment-line">#   invSessions, invSuccess, invFailTimeout, invFailEap</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixCheckPortGroupStats_1019">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixCheckPortGroupStats">::::nl_ixCheckPortGroupStats</a></a></strong> {dot1xPortGroupId stat operator value} {

    dot1xPortGroup setCommand $dot1xPortGroupId getStats
    set curStats [dot1xPortStats cget -$stat]

    <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Check Port GroupStats $stat:$curStats $operator $value&#34;

    if {! [expr $curStats $operator $value]} {
	<a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Stats check failed $stat..$curStats $operator $value&#34;
    }
    <a name="::result_debug(35)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stat:$stat:$curStats     $operator $value&#34;
    <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForMacAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to wait for all MACs in a group</span>
<span class="comment-line">#              to authenticate.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: mac: Source mac to check for</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForMacAuth_1049">proc <a href="NetloginLib.tcl-annot.html#::::_ixWaitForMacAuth">::::_ixWaitForMacAuth</a></a></strong> {maclist maxAuthWait {DUT &#34;1&#34;}} {

    set authStatus &#34;Yes&#34;
    set command &#34;show netlogin&#34;
    set parameterList &#34;&#34;
    foreach mac $maclist {
	lappend parameterList &#34;$mac.*$authStatus exist&#34;
    }
    set okOrError [<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;$command&#34; $parameterList \
	    -reportResults 0 -dut $DUT -time &#34;s: 3 i: 1 d: $maxAuthWait f: $maxAuthWait&#34;]

    if {$okOrError == &#34;ok&#34;} {
	<a name="::result_debug(36)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication completed successfully =====&#34;
	set success 1
    } else {
	<a name="::result_debug(37)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication could not be completed =====&#34;
	set success 0
    }
        
    return $success
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to wait for all supplicants in a group</span>
<span class="comment-line">#              to authenticate.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForAuth_1083">proc <a href="NetloginLib.tcl-annot.html#::::_ixWaitForAuth">::::_ixWaitForAuth</a></a></strong> {dot1xPortGroupId maxAuthWait} {

    set curDuration 0
    set success 0

    while {$curDuration &lt; $maxAuthWait} {
	puts -nonewline &#34;Waiting(max:$maxAuthWait)... $curDuration                           \r &#34;
	flush stdout
	after 1000
	dot1xPortGroup setCommand $dot1xPortGroupId getStats
	if {[dot1xPortStats cget -allSessionEstablished]} {
	    <a name="::result_debug(38)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication completed successfully =====&#34;
	    set success 1
	    break
	}
	incr curDuration 1
    }

    if {$curDuration == $maxAuthWait} {
	<a name="::result_debug(39)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication could not be completed =====&#34;
	set success 0
    }
    
    ;<span class="comment-line"># Dump out some stats</span>
    dot1xPortGroup setCommand $dot1xPortGroupId getStats
    set eapolStartSent [dot1xPortStats cget -eapolStartSent]
    set eapolLogoffSent [dot1xPortStats cget -eapolLogoffSent]
    set eapolSuccessReceived [dot1xPortStats cget -eapSuccessReceived]
    set eapolFailureReceived [dot1xPortStats cget -eapFailureReceived]
    set eapolAlertReceived [dot1xPortStats cget -eapAlertReceived]
    
    <a name="::result_debug(40)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolStartSent:       $eapolStartSent&#34;
    <a name="::result_debug(41)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolLogoffSent:      $eapolLogoffSent&#34;
    <a name="::result_debug(42)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolSuccessReceived: $eapolSuccessReceived&#34;
    <a name="::result_debug(43)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolFailureReceived: $eapolFailureReceived&#34;
    <a name="::result_debug(44)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolAlertReceived:   $eapolAlertReceived&#34;
    
    return $success
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForDeauth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to wait for all supplicants in a group</span>
<span class="comment-line">#              to become unauthenticated.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForDeauth_1136">proc <a href="NetloginLib.tcl-annot.html#::::_ixWaitForDeauth">::::_ixWaitForDeauth</a></a></strong> {dot1xPortGroupId maxDeauthWait} {

    set curDuration 0
    set success 0

    while {$curDuration &lt; $maxDeauthWait} {
	puts &#34;Waiting(max:$maxDeauthWait)... $curDuration&#34;
	after 1000
	dot1xPortGroup setCommand $dot1xPortGroupId getStats
	if {[dot1xPortStats cget -lastStats]} {
	    <a name="::result_debug(45)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Deauthentication completed normally =====&#34;
	    set success 1
	    break
	}
	incr curDuration 1
    }

    if {$curDuration == $maxDeauthWait} {
	<a name="::result_debug(46)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Deauthentication timed out =====&#34;
	set success 0
    }

    return $success
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStartAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Start authentication for netlogin</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: type: mac | dot1x</span>
<span class="comment-line">#             dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#             expectFailure: Don't dump debug info if we expect auth to fail and it does</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStartAuth_1176">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStartAuth">::::nl_ixStartAuth</a></a></strong> { maclist args } {
   <a name="::parse_args(7)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_ixStartAuth $args {
       type &#34;mac&#34;
       txPortId  &#34;1&#34;
       destMac &#34;default&#34;
       tag &#34;none&#34;
       dot1xPortGroupId &#34;1&#34;
       maxAuthWait  &#34;30&#34;
       expectFailure &#34;no&#34;
   }

   set rc 0
   <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear counter&#34;

   if {$maxAuthWait == 0} {
       <a name="::result_debug(47)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not waiting for authentication...&#34;
       return 1
   }
   
   <a name="::result_debug(48)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Started $type Authentications..Max Wait: $maxAuthWait secs.&#34;

    if { $type == &#34;dot1x&#34; } {
	dot1xPortGroup setCommand $dot1xPortGroupId resetStats
	dot1xPortGroup setCommand $dot1xPortGroupId startTest
	
	if { $maxAuthWait != 0 } {
	    if { [<a name="::_ixWaitForAuth(1)"><a href="./NetloginLib.tcl.html#::_ixWaitForAuth_1083">::_ixWaitForAuth</a></a> $dot1xPortGroupId $maxAuthWait] == 0 } { 
		<a name="::result_debug(49)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Authentication failed...test exiting.&#34;
		if {$expectFailure == &#34;no&#34;} {
		    <a name="::nl_exDumpDebugInfo(1)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>	
		}	
		return $rc
	    } else {
		set rc 1
	    }
	}

    } elseif { $type == &#34;mac&#34; } {
	;<span class="comment-line"># For some reason, sometimes if Ixia port is doing something prior to SendFrame</span>
	;<span class="comment-line"># the Tx doesn't work.  This is the reason for the short sleep.</span>

	;<span class="comment-line"># Send a single L2 frame to authenticate port</span>
	foreach mac $maclist {
	    <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
	    <a name="::result_debug(50)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sending frame to $destMac from $mac&#34;
	    set frameSent [<a name="::SendFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendFrame_402">::SendFrame</a></a> -txPortId $txPortId -destMac $destMac -sourceMac $mac \
		    -numFrames 10 -percentage 2.0 -tag $tag]
	}
	;<span class="comment-line"># Wait for Radius </span>
	if { $maxAuthWait != 0 } {
	    if { [set rc [<a name="::_ixWaitForMacAuth(1)"><a href="./NetloginLib.tcl.html#::_ixWaitForMacAuth_1049">::_ixWaitForMacAuth</a></a> $maclist $maxAuthWait]] == 0 } { 
		<a name="::result_debug(51)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Authentication failed...test exiting.&#34;
		if {$expectFailure == &#34;no&#34;} {
		    <a name="::nl_exDumpDebugInfo(2)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>	
		}	
		return $rc
	    } else {
		set rc 1
	    }
	}

    } else {
	<a name="::result_debug(52)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unsupported type:$type for ixStartAuth&#34;
	return $rc
    }
    
    return $rc
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStopAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Deauthenticate a dot1x port group</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStopAuth_1257">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStopAuth">::::nl_ixStopAuth</a></a></strong> {args} {
   <a name="::parse_args(8)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_ixStopAuth $args {
       type &#34;mac&#34;
       dot1xPortGroupId &#34;1&#34;
       maxAuthWait  &#34;30&#34; 
   }

    <a name="::result_debug(53)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stopping Authentications...&#34;

    if { $type == &#34;dot1x&#34; } {

	dot1xPortGroup setCommand $dot1xPortGroupId stopTest
	
	if {[<a name="::_ixWaitForDeauth(1)"><a href="./NetloginLib.tcl.html#::_ixWaitForDeauth_1136">::_ixWaitForDeauth</a></a> $dot1xPortGroupId $maxAuthWait] == 0} {
	    <a name="::result_debug(54)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Deauthentication timeout...test exiting.&#34;
	    return 0
	}
    }

}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixDumpInterfaceInfo</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Debug routine to dump interface info for a port ID</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID.  No port ID dumps ALL ports info</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixDumpInterfaceInfo_1289">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixDumpInterfaceInfo">::::nl_ixDumpInterfaceInfo</a></a></strong> {{portId 0}} {

    global portMappingList

    if {$portId == 0} {
	;<span class="comment-line"># Get ALL</span>
	set numIxiaPorts [array size portMappingList]
	set ixiaPortId 1
    } else {
	set numIxiaPorts 1
	set ixiaPortId $portId
    }
 
    ;<span class="comment-line"># Walk through each port to get interface info</span>

    while {$numIxiaPorts} {
	
	<a name="::MapIxiaPortId(13)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $ixiaPortId ch ca po

	interfaceTable select $ch $ca $po

	;<span class="comment-line"># Walk through interfaceTable to see what we got!</span>
	for {set curIf [interfaceTable getFirstInterface]} \
		{$curIf == 0 } {set curIf [interfaceTable getNextInterface]} {
	    
	    puts &#34;($ch:$ca:$po) InterfaceMac: [interfaceEntry cget -macAddress]&#34;
	    ;<span class="comment-line"># Walk through IPv4 entries</span>
	    for {set curIPv4 [interfaceEntry getFirstItem addressTypeIpV4]} \
		    {$curIPv4 == 0} {set curIPv4 [interfaceEntry getNextItem addresTypeIpV4] } {
		puts &#34;     IP:[interfaceIpV4 cget -ipAddress] GW:[interfaceIpV4 cget -gatewayIpAddress]&#34;
	    }
	}
	
	incr ixiaPortId
	incr numIxiaPorts -1
    }    
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixVerifySupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to verify supplicant has access to </span>
<span class="comment-line">#              network by sending L2 (ARP) traffic and IP traffic </span>
<span class="comment-line">#              in both directions.</span>
<span class="comment-line">#              This procedure assumes a default topology similiar</span>
<span class="comment-line">#              to the show at start of file.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       txPortId - Transmistting port </span>
<span class="comment-line">#       supMac   - MAC address of supplicant</span>
<span class="comment-line">#       supIp    - IP Address of supplicant</span>
<span class="comment-line">#       gwIp     - Gateway address of supplicant</span>
<span class="comment-line">#       rxPortId - Receiving port.  This is port we capture packets on.</span>
<span class="comment-line">#       rxPortIp - IP Address on receiving port to send to.  We assume </span>
<span class="comment-line">#                  this is been setup already on the Ixia.</span>
<span class="comment-line">#       rxPortGwIp - Gateway address of interface on receive side.  Needed </span>
<span class="comment-line">#                    to test traffic going in opposite direction.</span>
<span class="comment-line">#       portFlag - &#34;forwarded&#34; | &#34;notForwarded | egress | ingress&#34;</span>
<span class="comment-line">#       DUT      - DUT we're talking about.  Need to get MAC of DUT, so </span>
<span class="comment-line">#                  we specify which DUT to use here.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixVerifySupplicantAccess_1355">proc <a href="NetloginLib.tcl-annot.html#::::_ixVerifySupplicantAccess">::::_ixVerifySupplicantAccess</a></a></strong> { txPortId supMac supIp gwIp rxPortId rxPortIp \
	rxPortGwIp {portFlag &#34;forwarded&#34;} {DUT &#34;1&#34;} {tag &#34;none&#34;}} {

    global DUTs_info
    global DUT1_CONNECT
    global DUT2_CONNECT
    global bcmLynx
    set numIpPacketsToSend 15
    set blockTolerance 3

    if {$DUT == &#34;1&#34;} {
	<a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT1_CONNECT
	set dutMac $DUTs_info(DUT1,sysMAC)
    } else {
	<a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT2_CONNECT
	set dutMac $DUTs_info(DUT2,sysMAC)
    }

    ;<span class="comment-line"># We allow a tolerance when blocking.  It's okay if up to 3 packets go through</span>
    if {$portFlag == &#34;notForwarded&#34;} {
	set portFlag &#34;forwarded $blockTolerance down&#34;
    }

    ;<span class="comment-line"># This is MAC of the DUT</span>
    set cookedDutMac [<a name="::cookMacForIxia(1)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $dutMac]
    
    ;<span class="comment-line"># Only check ARP if we have access</span>
    if {$portFlag == &#34;forwarded&#34;} {
	<a name="::result_debug(55)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Check for ARP...&#34;
	if {[<a name="::CheckArpReply(1)"><a href="./CheckArp.tcl.html#::CheckArpReply_22">::CheckArpReply</a></a> -txPortId $txPortId -sIpAddr $supIp -dIpAddr $gwIp \
		-replySendHwAddr &#34;$cookedDutMac&#34; -sMacAddr $supMac -percentage 0.0672 \
		-numArpFrames 2 -comment &#34;MAC:$supMac IP:$supIp &#34; -tag $tag] == 0} {

	    <a name="::nl_exDumpDebugInfo(3)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>
	}
    }
    
    ;<span class="comment-line"># Seed ARP table on other port to minimize dropped packets</span>
    ;<span class="comment-line"># due to sending initial ARPs in CheckForwarding</span>
    <a name="::SendArpFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendArpFrame_959">::SendArpFrame</a></a> -txPortId $rxPortId -sourceIp $rxPortIp -destIp $rxPortGwIp 

    ;<span class="comment-line"># Save original value</span>
    set originalPortFlag $portFlag
    if {$portFlag == &#34;ingress&#34;} {
	set portFlag &#34;forwarded&#34;
    } elseif {$portFlag == &#34;egress&#34;} {
	set portFlag &#34;notForwarded&#34;
    }
    <a name="::result_debug(56)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Send $numIpPacketsToSend IP Packets MAC:$supMac \
	    IP:$supIp Tag: $tag==&gt; IP:$rxPortIp $portFlag&#34;

    if [regexp -nocase &#34;$bcmLynx&#34; [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT1]] {
    lappend checkPortList &#34;$rxPortId 0&#34;
 
    } else {
    lappend checkPortList &#34;$rxPortId $portFlag&#34;

    }
    if {[<a name="::CheckForwarding(1)"><a href="./ePTForwarding.tcl.html#::CheckForwarding_269">::CheckForwarding</a></a> -txPortId $txPortId -checkPortList $checkPortList \
	    -numIpFrame $numIpPacketsToSend -protocol &#34;ip&#34; -inSaMac $supMac \
	    -inDaMac $cookedDutMac -dIpAddr $rxPortIp -generateArpReq 0 \
	    -gIpAddr $gwIp -sIpAddr $supIp \
	    -comment &#34;MAC:$supMac IP:$supIp ==&gt; IP:$rxPortIp $portFlag&#34; \
            -tag $tag] == 0} {
	
	<a name="::nl_exDumpDebugInfo(4)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>
    }
    unset checkPortList

    ;<span class="comment-line"># Restore original value</span>
    set portFlag $originalPortFlag

    if {$portFlag == &#34;ingress&#34;} {
	set portFlag &#34;notForwarded&#34;
    } elseif {$portFlag == &#34;egress&#34;} {
	set portFlag &#34;forwarded&#34;
    }
    <a name="::result_debug(57)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Send $numIpPacketsToSend IP Packets IP:$rxPortIp ==&gt; \
	    MAC:$supMac IP:$supIp $portFlag&#34;


 if [regexp -nocase &#34;$bcmLynx&#34; [<a name="::GetPlatform(2)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT1]] {
    lappend checkPortList &#34;$txPortId 0&#34;
 
    } else {
    
    lappend checkPortList &#34;$txPortId $portFlag&#34;
    }    

     if {[<a name="::CheckForwarding(2)"><a href="./ePTForwarding.tcl.html#::CheckForwarding_269">::CheckForwarding</a></a> -txPortId $rxPortId -checkPortList $checkPortList \
	    -numIpFrame $numIpPacketsToSend -protocol &#34;ip&#34; -dIpAddr $supIp \
	    -inDaMac $cookedDutMac -generateArpReq 0 \
	    -gIpAddr $rxPortGwIp -sIpAddr $rxPortIp \
	    -comment &#34;IP:$rxPortIp ==&gt; MAC:$supMac IP:$supIp $portFlag&#34; \
            ] == 0} {

	<a name="::nl_exDumpDebugInfo(5)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>

    }
    unset checkPortList
} 



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixVerifySupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to verify supplicants have access to </span>
<span class="comment-line">#              network by sending L2 (ARP) traffic and IP traffic </span>
<span class="comment-line">#              in both directions.  startSupMac and startSupIp</span>
<span class="comment-line">#              is incremented and each mac/ip pair is validated</span>
<span class="comment-line">#              independently.</span>
<span class="comment-line">#              This procedure assumes a default topology similiar</span>
<span class="comment-line">#              to the show at start of file.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       txPortId    - Transmistting port </span>
<span class="comment-line">#       startSupMac - MAC address of supplicant in &#34;:&#34; delimited format</span>
<span class="comment-line">#       startSupIp  - IP Address of supplicant</span>
<span class="comment-line">#       gwIp     - Gateway address of supplicant</span>
<span class="comment-line">#       rxPortId - Receiving port.  This is port we capture packets on.</span>
<span class="comment-line">#       rxPortIp - IP Address on receiving port to send to.  We assume </span>
<span class="comment-line">#                  this is been setup already on the Ixia.</span>
<span class="comment-line">#       rxPortGwIp - Gateway address of interface on receive side.  Needed </span>
<span class="comment-line">#                    to test traffic going in opposite direction.</span>
<span class="comment-line">#       numSupplicants - Number of supplicants</span>
<span class="comment-line">#       portFlag - &#34;forwarded&#34; | &#34;notForwarded&#34; | &#34;egress&#34; | &#34;ingress&#34;</span>
<span class="comment-line">#       DUT      - DUT we're talking about.  Need to get MAC of DUT, so </span>
<span class="comment-line">#                  we specify which DUT to use here.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixVerifySupplicantAccess_1488">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixVerifySupplicantAccess">::::nl_ixVerifySupplicantAccess</a></a></strong> {txPortId startSupMac startSupIp \
	gwIp rxPortId rxPortIp rxPortGwIp {numSupplicants &#34;1&#34;} \
	{portFlag &#34;forwarded&#34;} {DUT &#34;1&#34;} {tag &#34;none&#34;}} {

    set curIp $startSupIp
    set curMac [<a name="::nl_stripMac(1)"><a href="./NetloginLib.tcl.html#::nl_stripMac_4549">::nl_stripMac</a></a> $startSupMac]

    while { $numSupplicants } {
	<a name="::result_debug(58)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Verify traffic from \
		supMac:$curMac supIp:$curIp Tag:$tag &lt;---&gt; \ 
                target:$rxPortIp $portFlag&#34;

	<a name="::_ixVerifySupplicantAccess(1)"><a href="./NetloginLib.tcl.html#::_ixVerifySupplicantAccess_1355">::_ixVerifySupplicantAccess</a></a> $txPortId $curMac  \
		$curIp $gwIp $rxPortId $rxPortIp $rxPortGwIp $portFlag $DUT $tag
	
	;<span class="comment-line"># Increment IP and MAC</span>
	set curIp [<a name="::IncrIpAddr(1)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	set curMac [<a name="::IncMacByOne(2)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]

	incr numSupplicants -1
    }

}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixStreamConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to configure an Ixia stream</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: See IXIA doc for explanation of each!</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixStreamConfig_1523">proc <a href="NetloginLib.tcl-annot.html#::::_ixStreamConfig">::::_ixStreamConfig</a></a></strong> { args } {
    <a name="::parse_args(9)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _ixStreamConfig $args {
	chassis       1
	<a name="::card(1)"><a href="./ePTClient.tcl.html#::card_424">::card</a></a>          1
	<a name="::port(3)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>          1
	streamId      1
	numBursts     1
	numFrames     10
	preambleSize  8
	srcMac        {00 00 00 00 00 01}
	dstMac        {00 00 00 00 00 00}
	saStep        1
	saMaskValue   {00 00 00 00 00 00}
	saMaskSelect  {00 00 00 00 00 00}
	saRepeatCnt   &#34;idle&#34;
	numSA         16
	daStep        1
	daMaskValue   {00 00 00 00 00 00}
	daMaskSelect  {00 00 00 00 00 00}
	daRepeatCnt   &#34;daArp&#34;
 	numDA         16
	percentRate   100.0
	frameSize     64
	frameSizeType &#34;sizeFixed&#34;
	frameSizeMin  64
	frameSizeMax  1518
	frameSizeStep 1
	frameType     {08 00}
	patternType   &#34;fixed&#34;
	dataPattern   x00010203
	pattern       {00 01 02 03}
	dma           &#34;advance&#34;   ;<span class="comment-line"># stopStream</span>
	returnToId    1
	<a name="::protocol(1)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>          &#34;none&#34;
	protEthernetType  &#34;ethernetII&#34;
	prot802dot1qTag   &#34;false&#34;
	protAppName       0
	arpSrcProtAddr  {10.1.1.2}
	arpDstProtAddr  {10.1.1.1}
	arpOp           &#34;arpRequest&#34;
	arpSrcHwAddr    {00 00 01 02 01 01}
	arpDstHwAddr    {FF FF FF FF FF FF}
	arpSrcProtAddrMode       &#34;arpIdle&#34; ;<span class="comment-line"># arpIncrement</span>
	arpSrcProtAddrRepeatCnt  1 ;<span class="comment-line"># 63 </span>
	arpDestProtAddrMode      &#34;arpIdle&#34;
	arpDestProtAddrRepeatCnt 1
	arpSrcHwAddrMode         &#34;arpIdle&#34;
	arpSrcHwAddrRepeatCnt    1
	arpHwAddrMode            &#34;arpIdle&#34;
	arpHwAddreRepeatCnt      1
	vlanTagNo         &#34;000&#34;
	vlanTagCfi        &#34;resetCFI&#34;
	vlanTagMode       &#34;vIdle&#34;
	vlanTagRepeat     &#34;1&#34;
	vlanTagPriority   &#34;0&#34;	  
	ipProtocol    &#34;tcp&#34;
	ipSrcAddr     {10.1.1.2}
	ipSrcMask     {255.255.255.0}
	ipDstAddr     {172.16.16.2}
	ipDstMask     {255.255.255.0}
	tcpOffset     5
	tcpSrcPort    0
	tcpDstPort    0
	writeToHw       &#34;false&#34;
    }

    set portList [list $chassis,$card,$port]

    <a name="::stream(1)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   setDefault        
    <a name="::stream(2)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -name                    &#34;S_$streamId&#34;
    <a name="::stream(3)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -enable                  true
    <a name="::stream(4)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numBursts               $numBursts
    <a name="::stream(5)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numFrames               $numFrames
    <a name="::stream(6)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -rateMode                usePercentRate
    <a name="::stream(7)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -percentPacketRate       $percentRate
    <a name="::stream(8)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -preambleSize            $preambleSize
    <a name="::stream(9)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -sa                      $srcMac
    <a name="::stream(10)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saRepeatCounter         $saRepeatCnt
    <a name="::stream(11)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saStep                  $saStep
    <a name="::stream(12)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saMaskValue             $saMaskValue
    <a name="::stream(13)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saMaskSelect            $saMaskSelect
    <a name="::stream(14)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -da                      $dstMac
    <a name="::stream(15)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daRepeatCounter         $daRepeatCnt
    <a name="::stream(16)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daStep                  $daStep
    <a name="::stream(17)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daMaskValue             $daMaskValue
    <a name="::stream(18)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daMaskSelect            $daMaskSelect
    <a name="::stream(19)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numDA                   $numDA
    <a name="::stream(20)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numSA                   $numSA
    <a name="::stream(21)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -framesize               $frameSize
    <a name="::stream(22)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeType           $frameSizeType
    <a name="::stream(23)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeMIN            $frameSizeMin
    <a name="::stream(24)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeMAX            $frameSizeMax
    <a name="::stream(25)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeStep           $frameSizeStep
    <a name="::stream(26)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -fir                     false
    <a name="::stream(27)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -fcs                     good
    <a name="::stream(28)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -patternType             $patternType
    <a name="::stream(29)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -dataPattern             $dataPattern
    <a name="::stream(30)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -pattern                 &#34;$pattern&#34;
    <a name="::stream(31)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameType               &#34;$frameType&#34;
    <a name="::stream(32)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -dma                     $dma
    <a name="::stream(33)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -returnToId               $returnToId
<span class="comment-line">#    stream   config            -rxTriggerEnable         false</span>
<span class="comment-line">#    stream   config            -asyncIntEnable          true</span>
<span class="comment-line">#    stream   config            -loopCount               1</span>
<span class="comment-line">#    stream   config            -enforceMinGap           12</span>

    <a name="::protocol(2)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  setDefault        
    <a name="::protocol(3)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -name               $protocol
    <a name="::protocol(4)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -appName            $protAppName
    <a name="::protocol(5)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -ethernetType       $protEthernetType
    <a name="::protocol(6)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -enable802dot1qTag  $prot802dot1qTag
    <a name="::protocol(7)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -enableISLtag       false
    <a name="::protocol(8)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -dutStripTag        true
    <a name="::protocol(9)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -enableMPLS         false

    if { $prot802dot1qTag != &#34;false&#34;} {
	<a name="::vlan(1)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -cfi            $vlanTagCfi
	<a name="::vlan(2)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -mode           $vlanTagMode
	<a name="::vlan(3)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -repeat         $vlanTagRepeat
	<a name="::vlan(4)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID         $vlanTagNo
	<a name="::vlan(5)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -userPriority   $vlanTagPriority
	<a name="::vlan(6)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set                    $chassis $card $port
    }

    if {[regexp -nocase &#34;arp&#34; $protAppName]} {
	
	<a name="::arp(1)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  setDefault        
	<a name="::arp(2)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceProtocolAddr             $arpSrcProtAddr ;<span class="comment-line"># {10.1.1.2}</span>
	<a name="::arp(3)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destProtocolAddr               $arpDstProtAddr ;<span class="comment-line"># {10.1.1.1}</span>
	<a name="::arp(4)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -operation                      $arpOp ;<span class="comment-line"># arpRequest</span>
	<a name="::arp(5)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceHardwareAddr             $arpSrcHwAddr ;<span class="comment-line"># {00 00 01 02 01 01}</span>
	<a name="::arp(6)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destHardwareAddr               $arpDstHwAddr ;<span class="comment-line"># {FF FF FF FF FF FF}</span>
	<a name="::arp(7)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceProtocolAddrMode         $arpSrcProtAddrMode       ;<span class="comment-line"># arpIncrement</span>
	<a name="::arp(8)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceProtocolAddrRepeatCount  $arpSrcProtAddrRepeatCnt  ;<span class="comment-line"># 63 </span>
	<a name="::arp(9)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destProtocolAddrMode           $arpDestProtAddrMode      ;<span class="comment-line"># arpIdle</span>
	<a name="::arp(10)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destProtocolAddrRepeatCount    $arpDestProtAddrRepeatCnt ;<span class="comment-line"># 1</span>
	<a name="::arp(11)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceHardwareAddrMode         $arpSrcHwAddrMode         ;<span class="comment-line"># arpIncrement</span>
	<a name="::arp(12)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceHardwareAddrRepeatCount  $arpSrcHwAddrRepeatCnt    ;<span class="comment-line"># 63</span>
	<a name="::arp(13)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destHardwareAddrMode           $arpHwAddrMode            ;<span class="comment-line"># arpIdle</span>
	<a name="::arp(14)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destHardwareAddrRepeatCount    $arpHwAddreRepeatCnt      ;<span class="comment-line"># 1</span>
	<a name="::arp(15)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  set     $chassis $card $port
    }
    
    if { ([regexp -nocase &#34;ip&#34; $protocol]) &amp;&amp; \
	    (! [regexp -nocase &#34;Arp&#34; $protAppName]) } {
	<a name="::ip(1)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> setDefault        
	<a name="::ip(2)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -precedence              routine
	<a name="::ip(3)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -delay                   normalDelay
	<a name="::ip(4)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -throughput              normalThruput
	<a name="::ip(5)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -reliability             normalReliability
	<a name="::ip(6)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -identifier              0
	<a name="::ip(7)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -cost                    0
	<a name="::ip(8)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -reserved                0
	<a name="::ip(9)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -totalLength             46
	<a name="::ip(10)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -lengthOverride          false
	<a name="::ip(11)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -fragment                may
	<a name="::ip(12)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -lastFragment            last
	<a name="::ip(13)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -fragmentOffset          0
	<a name="::ip(14)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -ttl                     64
	<a name="::ip(15)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -ipProtocol              $ipProtocol
	<a name="::ip(16)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -sourceIpAddr            $ipSrcAddr
	<a name="::ip(17)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -sourceIpMask            $ipSrcMask
	<a name="::ip(18)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -destIpAddr              $ipDstAddr
	<a name="::ip(19)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -destIpMask              $ipDstMask
	<span class="comment-line">#    ip config  -useValidChecksum        true</span>
	<span class="comment-line">#    ip config  -sourceIpAddrMode        ipIdle</span>
	<span class="comment-line">#    ip config  -sourceIpAddrRepeatCount 10</span>
	<span class="comment-line">#    ip config  -sourceClass             classA</span>
	<span class="comment-line">#    ip config  -destIpAddrMode          ipIdle</span>
	<span class="comment-line">#    ip config  -destIpAddrRepeatCount   10</span>
	<span class="comment-line">#    ip config  -destClass               classA</span>
	<span class="comment-line">#    ip config  -destMacAddr             {00 DE BB 00 00 02}</span>
	<span class="comment-line">#    ip config  -destDutIpAddr           {0.0.0.0}</span>
	<span class="comment-line">#    ip config  -options                 {}</span>
	<a name="::ip(20)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> set $chassis $card $port
    }

    if {[regexp -nocase &#34;tcp&#34; $ipProtocol]} {
	<a name="::tcp(1)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   setDefault        
	<a name="::tcp(2)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   config            -offset                             $tcpOffset
	<a name="::tcp(3)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   config            -sourcePort                         $tcpSrcPort
	<a name="::tcp(4)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   config            -destPort                           $tcpDstPort
<span class="comment-line">#	tcp   config            -sequenceNumber                     0</span>
<span class="comment-line">#	tcp   config            -acknowledgementNumber              0</span>
<span class="comment-line">#	tcp   config            -window                             0</span>
<span class="comment-line">#	tcp   config            -urgentPointer                      0</span>
<span class="comment-line">#	tcp   config            -options                            {}</span>
<span class="comment-line">#	tcp   config            -urgentPointerValid                 false</span>
<span class="comment-line">#	tcp   config            -acknowledgeValid                   false</span>
<span class="comment-line">#	tcp   config            -pushFunctionValid                  false</span>
<span class="comment-line">#	tcp   config            -resetConnection                    false</span>
<span class="comment-line">#	tcp   config            -synchronize                        false</span>
<span class="comment-line">#	tcp   config            -finished                           false</span>
<span class="comment-line">#	tcp   config            -useValidChecksum                   true</span>
	<a name="::tcp(5)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   set               $chassis $card $port
    }

    <a name="::stream(34)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>  set               $chassis $card $port $streamId
    
    protocolServer  config      -enableArpResponse  $::true
    protocolServer  config      -enablePingResponse $::true
    protocolServer  set $chassis $card $port

    if {$writeToHw != &#34;false&#34;} {
	<a name="::result_debug(59)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Writing config to $portList&#34;
	<a name="::writeConfigToHardware(1)"><a href="./mapping.tcl.html#::writeConfigToHardware_148">::writeConfigToHardware</a></a> portList
    }

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixSeedFdbTable</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Seeds the FDB table with set of MAC addresses </span>
<span class="comment-line">#              and a single target.  See typical topology below.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: supPortId: PortId that supplicant(s) are connected to</span>
<span class="comment-line">#             startSupMac, startSupIp: Starting MAC/IP Address of supplicants</span>
<span class="comment-line">#                    We assume supplicant MAC/IP are created in increasing order</span>
<span class="comment-line">#	      gwIp: Default GW of supplicants.  Usually IP Address of DUT port to</span>
<span class="comment-line">#                   which supplicants are connected </span>
<span class="comment-line">#             dutMac: Cooked MAC address of DUT. i.e.&#34;00 00 01 DE 98 34&#34;</span>
<span class="comment-line">#	      numSup: Number of supplicants to seed </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixSeedFdbTable_1748">proc <a href="NetloginLib.tcl-annot.html#::::_ixSeedFdbTable">::::_ixSeedFdbTable</a></a></strong> { supPortId startSupMac startSupIp gwIp \
	dutMac {numMac &#34;1&#34;} } {

    <a name="::result_debug(60)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Seeding FDB table with $numMac supplicant MACs&#34;

    <a name="::MapIxiaPortId(14)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $supPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]

    ;<span class="comment-line"># ##### Seed the FDB table #####    </span>
    set streamId       1
    set curIp          $startSupIp
    set curMac         $startSupMac
    ;<span class="comment-line"># create 1 stream to send out ARP_Requests for ALL supplicants</span>
    <a name="::_ixStreamConfig(1)"><a href="./NetloginLib.tcl.html#::_ixStreamConfig_1523">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
	    -numBursts 1 -numFrames $numMac \
	    -srcMac $startSupMac -saRepeatCnt &#34;increment&#34; -numSA $numMac \
	    -daRepeatCnt &#34;idle&#34; -dstMac {FF FF FF FF FF FF} \
	    -percentRate 50.0 -frameSize 64 -dma &#34;stopStream&#34; -protocol &#34;ipV4&#34; -protAppName &#34;Arp&#34; \
	    -protEthernetType &#34;ethernetII&#34; \
	    -arpSrcProtAddr  $startSupIp  -arpDstProtAddr $gwIp \
	    -arpOp &#34;arpRequest&#34; -arpSrcHwAddr $startSupMac \
	    -arpDstHwAddr  {FF FF FF FF FF FF} \
	    -arpSrcProtAddrMode &#34;arpIncrement&#34; -arpSrcProtAddrRepeatCnt $numMac \
	    -arpSrcHwAddrMode  &#34;arpIncrement&#34;  -arpSrcHwAddrRepeatCnt   $numMac \
	    -writeToHw &#34;true&#34;	
    
    <a name="::result_debug(61)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Transmitting on $portList&#34;
    <a name="::ixStartTransmit(1)"><a href="./mapping.tcl.html#::ixStartTransmit_91">::ixStartTransmit</a></a> portList
    sleep 2
    <a name="::result_debug(62)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Checking if Tx done...&#34;
    if {[<a name="::ixCheckTransmitDone(1)"><a href="./mapping.tcl.html#::ixCheckTransmitDone_154">::ixCheckTransmitDone</a></a> portList]} {
	<a name="::result_debug(63)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in transmitting&#34;
    }   
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixCreateMultiSupplicantStreams</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to create IP data streams for</span>
<span class="comment-line">#              multiple supplicants.  Multiple streams are</span>
<span class="comment-line">#              created, and all written once to Ixia at the</span>
<span class="comment-line">#              end.  This speeds up tests that require 64</span>
<span class="comment-line">#              supplicants.</span>
<span class="comment-line">#</span>
<span class="comment-line">#              Traffic flow is usually based on topology indicated</span>
<span class="comment-line">#              at start of file.  Supplicants send to single </span>
<span class="comment-line">#              unprotected target.  Target sends traffic back to</span>
<span class="comment-line">#              supplicant.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      supPortId:     Supplicant port Id </span>
<span class="comment-line">#      startSupMac:   Starting MAC address</span>
<span class="comment-line">#      startSupIp:    Starting IP Address</span>
<span class="comment-line">#      gwIp:          GW IP of the supplicants</span>
<span class="comment-line">#      unprotPortId:  Target port Id </span>
<span class="comment-line">#      unprotPortIp   Target IP</span>
<span class="comment-line">#      unprotPortGwIp Target GW</span>
<span class="comment-line">#      dutMac:        MAC of DUT</span>
<span class="comment-line">#      numSup:        Number of supplicants</span>
<span class="comment-line">#      numFrames:     Number of frames to send</span>
<span class="comment-line">#      txDirection:   Direction to send traffic</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixCreateMultiSupplicantStreams_1814">proc <a href="NetloginLib.tcl-annot.html#::::_ixCreateMultiSupplicantStreams">::::_ixCreateMultiSupplicantStreams</a></a></strong> { supPortId startSupMac startSupIp \
	gwIp unprotPortId unprotPortIp unprotPortGwIp dutMac {numSup &#34;1&#34;} \
	{numFrames 1} {txDirection &#34;out&#34;} }  {

    if { $txDirection == &#34;out&#34; } {
	<a name="::MapIxiaPortId(15)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $supPortId chassis card port
    } else {
	<a name="::MapIxiaPortId(16)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $unprotPortId chassis card port
	set unprotMacList [<a name="::nl_ixGetPortIdMacs(1)"><a href="./NetloginLib.tcl.html#::nl_ixGetPortIdMacs_213">::nl_ixGetPortIdMacs</a></a> $unprotPortId]
	set unprotMac [<a name="::cookMacForIxia(2)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> [lindex $unprotMacList 0]]
	<a name="::result_debug(64)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;unprotMac: $unprotMac&#34;
    }

    ;<span class="comment-line"># ##### Create the Streams #####</span>
    set streamId       1
    set dma            &#34;advance&#34;
    set writeToHw      &#34;false&#34;
    set curIp          $startSupIp
    set curMac         $startSupMac
    set numSupplicants $numSup
    while { $numSupplicants } {

	;<span class="comment-line"># Configure last stream to stop and also make sure to write to</span>
	if {$numSupplicants == 1} {
	    set dma  &#34;stopStream&#34;
	    set writeToHw  &#34;true&#34;
	}
	if { $txDirection == &#34;out&#34; } {

	    <a name="::result_debug(65)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Setting up stream for \
		    supMac:$curMac supIp:$curIp ---&gt; target:$unprotPortIp&#34;

	    <a name="::_ixStreamConfig(2)"><a href="./NetloginLib.tcl.html#::_ixStreamConfig_1523">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
		    -numBursts 1 -numFrames $numFrames -srcMac $curMac -dstMac $dutMac \
		    -daRepeatCnt &#34;idle&#34; -percentRate 50.0 \
		    -frameSize 64 -dma $dma -protocol &#34;ipV4&#34; \
		    -protEthernetType &#34;ethernetII&#34; -ipProtocol &#34;tcp&#34; \
		    -ipSrcAddr $curIp -ipSrcMask {255.255.255.0} \
		    -ipDstAddr $unprotPortIp -ipDstMask {255.255.255.0} \
		    -writeToHw $writeToHw
	} else {

	    <a name="::result_debug(66)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Setting up stream for \
		    target:$unprotPortIp --&gt; supMac:$curMac supIp:$curIp&#34;

	    <a name="::_ixStreamConfig(3)"><a href="./NetloginLib.tcl.html#::_ixStreamConfig_1523">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
		    -numBursts 1 -numFrames $numFrames -srcMac $unprotMac -dstMac $dutMac \
		    -daRepeatCnt &#34;idle&#34; -percentRate 50.0 \
		    -frameSize 64 -dma $dma -protocol &#34;ipV4&#34; \
		    -protEthernetType &#34;ethernetII&#34; -ipProtocol &#34;tcp&#34; \
		    -ipSrcAddr $unprotPortIp  -ipSrcMask {255.255.255.0} \
		    -ipDstAddr $curIp -ipDstMask {255.255.255.0} \
		    -writeToHw $writeToHw
	}

	;<span class="comment-line"># Increment IP and MAC</span>
	set curIp [<a name="::IncrIpAddr(2)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	set curMac [<a name="::IncMacByOne(3)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]

	incr numSupplicants -1
	incr streamId
    }
    <a name="::result_debug(67)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ALL STREAMS CONFIGURED...&#34;
    
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixVerifyMultiSupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to verify traffic for multi</span>
<span class="comment-line">#              supplicants.  Proc assumes streams and DUT are</span>
<span class="comment-line">#              already configured.  This procedure starts and captures</span>
<span class="comment-line">#              traffic and confirms uni-directional traffic is</span>
<span class="comment-line">#              sent correctly.</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      supPortId:     Supplicant port Id </span>
<span class="comment-line">#      startSupIp:    Starting IP Address</span>
<span class="comment-line">#      unprotPortId:  Target port Id </span>
<span class="comment-line">#      numSup:        Number of supplicants</span>
<span class="comment-line">#      numFramesThreshold:    Number of frames requ'd to receive for success</span>
<span class="comment-line">#      txDirection:   Direction to send traffic</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixVerifyMultiSupplicantAccess_1898">proc  <a href="NetloginLib.tcl-annot.html#::::_ixVerifyMultiSupplicantAccess">::::_ixVerifyMultiSupplicantAccess</a></a></strong> { supPortId unprotPortId numSup startSupIp \
	numFramesThreshold {txDirection &#34;out&#34;} } {
    
    <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify $numSup Supplicant Access $txDirection&#34;

    ;<span class="comment-line"># ##### Send and Capture the traffic #####</span>
    <a name="::StopPortsCapture(1)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> [list $supPortId $unprotPortId]
    sleep 2
    
    if {$txDirection == &#34;out&#34;} {
	set txPortId $supPortId
	set rxPortId $unprotPortId
    } else {
	set txPortId $unprotPortId
	set rxPortId $supPortId
    }

    ;<span class="comment-line"># Start capture</span>
    <a name="::StartPortsCapture(1)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> [list $rxPortId]
    sleep 1

    ;<span class="comment-line"># Start streams</span>
    <a name="::MapIxiaPortId(17)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]
    <a name="::ixStartTransmit(2)"><a href="./mapping.tcl.html#::ixStartTransmit_91">::ixStartTransmit</a></a> portList

    if {[<a name="::ixCheckTransmitDone(2)"><a href="./mapping.tcl.html#::ixCheckTransmitDone_154">::ixCheckTransmitDone</a></a> portList]} {
	<a name="::result_debug(68)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in transmitting&#34;
	<a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	return
    }
    <a name="::result_debug(69)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DONE TRANSMITTING ********************************&#34;

    <a name="::StopPortsCapture(2)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> [list $rxPortId]
    sleep 2

    ;<span class="comment-line"># ##### Parse the received data  #####</span>
    ;<span class="comment-line"># Parse Rx Port Capture Buffer to verify we received packets. </span>
    set numSupplicants $numSup
    set curIp $startSupIp

    ;<span class="comment-line"># ASSUME CAPTURE BUFFER IS IN ORDER OF supIp ADDRESSES!</span>
    set rawPortDataList [<a name="::GetCapturedFrames(1)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $rxPortId]

    while { $numSupplicants } {

	set numFramesMatched 0
	foreach frame $rawPortDataList {

	    if {$txDirection == &#34;out&#34;} {
		set curIpRx [<a name="::GetSourceIPAddress(1)"><a href="./MessageDecoding.tcl.html#::GetSourceIPAddress_411">::GetSourceIPAddress</a></a> $frame]
	    } else {
		set curIpRx [<a name="::GetDestIPAddress(1)"><a href="./MessageDecoding.tcl.html#::GetDestIPAddress_447">::GetDestIPAddress</a></a> $frame]
	    }

	    if {$curIpRx == $curIp} {
		incr numFramesMatched
	    }
	    if {$numFramesMatched == $numFramesThreshold} {
		<a name="::result_debug(70)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found $numFramesMatched packets from $curIp&#34;
		break
	    }
	}

	if {$numFramesMatched != $numFramesThreshold} {
	    <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Found only $numFramesMatched packets from $curIp...test failed&#34;
	    <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	    return
	}

	;<span class="comment-line"># Increment IP and MAC</span>
	set curIp [<a name="::IncrIpAddr(3)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]

	incr numSupplicants -1
    }
    
    <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Access Okay for $numSup Supplicants&#34;
    <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixVerifyMultiSupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to verify traffic for multi-supplicants.  </span>
<span class="comment-line">#              Seeds FDB table for both ends, creates streams</span>
<span class="comment-line">#              sends and verifies traffic flow.  Repeats for</span>
<span class="comment-line">#              opposite direction.</span>
<span class="comment-line">#              Assumes topology similiar to the one shown above.</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      supPortId:       Supplicant Port Mapping ID</span>
<span class="comment-line">#      startSupMac:     Supplicant starting MAC</span>
<span class="comment-line">#      startSupIp:      Supplicant starting IP</span>
<span class="comment-line">#      gwIp:            GW IP of supplicants</span>
<span class="comment-line">#      unprotPortId:    Unprotected target port ID</span>
<span class="comment-line">#      unprotMac:       Unprotected target MAC</span>
<span class="comment-line">#      unprotPortIp:    Unprotected target IP</span>
<span class="comment-line">#      unprotPortGwIp:  Unprotected target port GW </span>
<span class="comment-line">#      dutMac:          DUT MAC</span>
<span class="comment-line">#      numSup:          Number of supplicants to verify</span>
<span class="comment-line">#      portFlag:        &#34;forwarded&#34; | &#34;notForwarded&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixVerifyMultiSupplicantAccess_2002">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixVerifyMultiSupplicantAccess">::::nl_ixVerifyMultiSupplicantAccess</a></a></strong> { supPortId startSupMac startSupIp \
	gwIp unprotPortId unprotMac unprotPortIp unprotPortGwIp dutMac \
	{numSup &#34;1&#34;} {portFlag &#34;forwarded&#34;} } {

    set numFrames           10   ;<span class="comment-line"># Send 10</span>
    set numFramesThreshold  5    ;<span class="comment-line"># As long as other end receives 5, we're okay for this test.</span>
    
    ;<span class="comment-line"># Cook MAC</span>
    set startSupMac [<a name="::cookMacForIxia(3)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $startSupMac]
    set unprotMac   [<a name="::cookMacForIxia(4)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $unprotMac]
    set dutMac      [<a name="::cookMacForIxia(5)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $dutMac]


    ;<span class="comment-line"># Seed supplicant end</span>
    <a name="::_ixSeedFdbTable(1)"><a href="./NetloginLib.tcl.html#::_ixSeedFdbTable_1748">::_ixSeedFdbTable</a></a> $supPortId $startSupMac $startSupIp $gwIp \
	    $dutMac $numSup

    <a name="::exSleep(4)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2

    ;<span class="comment-line"># Seed target end</span>
    <a name="::_ixSeedFdbTable(2)"><a href="./NetloginLib.tcl.html#::_ixSeedFdbTable_1748">::_ixSeedFdbTable</a></a> $unprotPortId $unprotMac $unprotPortIp $unprotPortGwIp \
	    $dutMac 1

    ;<span class="comment-line"># Debug to check FDB is poplulated</span>
    ;<span class="comment-line">#    SendACmd &#34;show fdb po [MapDUTPortId 1]&#34;</span>

    <a name="::_ixCreateMultiSupplicantStreams(1)"><a href="./NetloginLib.tcl.html#::_ixCreateMultiSupplicantStreams_1814">::_ixCreateMultiSupplicantStreams</a></a> $supPortId $startSupMac $startSupIp $gwIp \
	    $unprotPortId $unprotPortIp $unprotPortGwIp \
	    $dutMac $numSup $numFrames &#34;out&#34;

    <a name="::_ixVerifyMultiSupplicantAccess(1)"><a href="./NetloginLib.tcl.html#::_ixVerifyMultiSupplicantAccess_1898">::_ixVerifyMultiSupplicantAccess</a></a> $supPortId $unprotPortId $numSup $startSupIp \
	    $numFramesThreshold &#34;out&#34;

    <a name="::_ixCreateMultiSupplicantStreams(2)"><a href="./NetloginLib.tcl.html#::_ixCreateMultiSupplicantStreams_1814">::_ixCreateMultiSupplicantStreams</a></a> $supPortId $startSupMac $startSupIp $gwIp \
	    $unprotPortId $unprotPortIp $unprotPortGwIp \
	    $dutMac $numSup $numFrames &#34;in&#34;

    <a name="::_ixVerifyMultiSupplicantAccess(2)"><a href="./NetloginLib.tcl.html#::_ixVerifyMultiSupplicantAccess_1898">::_ixVerifyMultiSupplicantAccess</a></a> $supPortId $unprotPortId $numSup $startSupIp \
	    $numFramesThreshold &#34;in&#34;

}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixSendIpTraffic</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to send IP Traffic to another port.</span>
<span class="comment-line">#              Each MAC (when more than 1) initiates traffic </span>
<span class="comment-line">#              destined to target rxPortIp.  No checking is done.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      txPortId:    Supplicant Port Mapping ID</span>
<span class="comment-line">#      startSupMac: Supplicant starting MAC</span>
<span class="comment-line">#      startSupIp:  Supplicant starting IP</span>
<span class="comment-line">#      gwIp:        GW IP of supplicants</span>
<span class="comment-line">#      rxPortId:    Unprotected target port ID</span>
<span class="comment-line">#      rxPortIp:    Unprotected target IP</span>
<span class="comment-line">#      rxPortGwIp:  Unprotected target port GW </span>
<span class="comment-line">#      numSupplicants:     Number of supplicants</span>
<span class="comment-line">#      numPacketsToSend:   Number of packets to transmit</span>
<span class="comment-line">#      DUT:         1 | 2</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixSendIpTraffic_2068">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixSendIpTraffic">::::nl_ixSendIpTraffic</a></a></strong> { txPortId startSupMac startSupIp gwIp rxPortId \
	rxPortIp rxPortGwIp {numSupplicants 1} {numPacketsToSend 10} \
	{DUT &#34;1&#34;}} {

    global DUTs_info
    global DUT1_CONNECT
    global DUT2_CONNECT

    if {$DUT == &#34;1&#34;} {
	<a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT1_CONNECT
	set dutMac $DUTs_info(DUT1,sysMAC)
    } else {
	<a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT2_CONNECT
	set dutMac $DUTs_info(DUT2,sysMAC)
    }

    ;<span class="comment-line"># This is MAC of the DUT</span>
    set cookedDutMac [<a name="::cookMacForIxia(6)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $dutMac]

    set curIp $startSupIp
    set curMac [<a name="::nl_stripMac(2)"><a href="./NetloginLib.tcl.html#::nl_stripMac_4549">::nl_stripMac</a></a> $startSupMac]

    while { $numSupplicants } {
	;<span class="comment-line"># This should generate entry in table.</span>
	<a name="::SendArpFrame(2)"><a href="./ePTSendPacket.tcl.html#::SendArpFrame_959">::SendArpFrame</a></a> -txPortId $txPortId -sourceMac $curMac -sourceIp $curIp \
		-destIp $gwIp -numFrames 2 
	

	;<span class="comment-line"># Send some IP traffic</span>
	<a name="::SendIpFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendIpFrame_587">::SendIpFrame</a></a> -txPortId $txPortId -sourceIp $curIp \
		-destMac $cookedDutMac -gatewayIp $gwIp \
		-destIp $rxPortIp -numFrames $numPacketsToSend

	;<span class="comment-line"># Increment IP and MAC</span>
	if {$curIp != &#34;&#34;} {
	    set curIp [<a name="::IncrIpAddr(4)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	}
	if {$curMac != &#34;&#34;} {
	    set curMac [<a name="::IncMacByOne(4)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]
	}


	incr numSupplicants -1

    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStartEapolFlood</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to create an L2 stream of a particular EAPOL </span>
<span class="comment-line">#              packet type.  Then start transmitting at that rate.</span>
<span class="comment-line">#              Used for EAPOL flooding tests</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        txPortId: Supplicant Port Mapping ID </span>
<span class="comment-line">#        type:     &#34;start&#34; | &#34;response-identity&#34; | &#34;logoff&#34;  </span>
<span class="comment-line">#        dstMac:   dstMac to send to...usually DUT </span>
<span class="comment-line">#        rate:     % rate to send traffic.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStartEapolFlood_2132">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStartEapolFlood">::::nl_ixStartEapolFlood</a></a></strong> {txPortId type dstMac {rate 100.0}} {

    set eapolType {88 8E}
    set srcMac {00 00 01 AB CD EF}


    if {$type == &#34;start&#34;} {

	set pattern {01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}

    } elseif { $type == &#34;response-identity&#34; } {

	set pattern {01 00 00 0C 02 03 00 0C 01 64 6F 74 31 78 31 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}


    } elseif { $type == &#34;logoff&#34; } {
	
	set pattern {01 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    } else {

	<a name="::result_debug(71)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unsupported EAPOL type $type&#34; 
	return 0
    }

    <a name="::MapIxiaPortId(18)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]

    set streamId       1
    set dma            &#34;contPacket&#34;
    set srcMac         {00 00 01 BE EF BA}

    puts &#34;EAPOL stream type $type $chassis:$card:$port&#34;

    <a name="::_ixStreamConfig(4)"><a href="./NetloginLib.tcl.html#::_ixStreamConfig_1523">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
	    -srcMac $srcMac -dstMac $dstMac \
	    -daRepeatCnt &#34;idle&#34; -percentRate &#34;$rate&#34; \
	    -pattern $pattern -patternType &#34;nonRepeat&#34; -dataPattern &#34;userpattern&#34; \
	    -frameSize 64 -frameType $eapolType -dma $dma -protocol &#34;mac&#34; \
	    -protEthernetType &#34;ethernetII&#34;  -writeToHw &#34;true&#34;

    <a name="::ixStartTransmit(3)"><a href="./mapping.tcl.html#::ixStartTransmit_91">::ixStartTransmit</a></a> portList

    return 1

}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStopTx</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to stop transmitting on a Ixia port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        txPortId: Port Mapping ID </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStopTx_2190">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStopTx">::::nl_ixStopTx</a></a></strong> {txPortId} {

    <a name="::MapIxiaPortId(19)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]

    <a name="::ixStopTransmit(1)"><a href="./mapping.tcl.html#::ixStopTransmit_100">::ixStopTransmit</a></a> portList

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixStopEapolFlood</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to stop transmitting on an Ixia port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        txPortId: Port Mapping ID </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixStopEapolFlood_2210">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixStopEapolFlood">::::nl_ixStopEapolFlood</a></a></strong> {txPortId} {

    <a name="::nl_ixStopTx(1)"><a href="./NetloginLib.tcl.html#::nl_ixStopTx_2190">::nl_ixStopTx</a></a> $txPortId

}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixDumpSupplicantStats</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Dump supplicant statistics to STDOUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        portId: Port Mapping ID </span>
<span class="comment-line">#        mac:    Supplicant mac to dump</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixDumpSupplicantStats_2230">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixDumpSupplicantStats">::::nl_ixDumpSupplicantStats</a></a></strong> { portId mac } {

    <a name="::MapIxiaPortId(20)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    dot1xSupplicantStats get $ch $ca $po $mac

    set totalSuccess [dot1xSupplicantStats cget -totalSuccess]
    set totalSessions [dot1xSupplicantStats cget -totalSessions]
    set avgLatency [dot1xSupplicantStats cget -avgLatency]
    set minLatency [dot1xSupplicantStats cget -minLatency]
    set totalFailEap [dot1xSupplicantStats cget -totalFailEap]
    set totalFailTimeout [dot1xSupplicantStats cget -totalFailTimeout]
    
    <a name="::result_debug(72)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stats for Supplicant $mac&#34;
    <a name="::result_debug(73)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalSuccess:     $totalSuccess&#34;
    <a name="::result_debug(74)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalSessions:    $totalSessions&#34;
    <a name="::result_debug(75)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  avgLatency:       $avgLatency&#34;
    <a name="::result_debug(76)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  minLatency:       $minLatency&#34;
    <a name="::result_debug(77)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalFailEap:     $totalFailEap&#34;
    <a name="::result_debug(78)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalFailTimeout: $totalFailTimeout&#34;
    
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixCheckPing</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Check that we can ping from supplicant to target. Reports</span>
<span class="comment-line">#              pass of fail.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dstIp </span>
<span class="comment-line">#             srcIp </span>
<span class="comment-line">#             gwIp </span>
<span class="comment-line">#             txPortId </span>
<span class="comment-line">#             status </span>
<span class="comment-line">#             srcMac </span>
<span class="comment-line">#             dstMac</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: cooked MAC with no : seperators</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixCheckPing_2271">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixCheckPing">::::nl_ixCheckPing</a></a></strong> {dstIp srcIp gwIp txPortId status srcMac dstMac} {

    <a name="::_ixSeedFdbTable(3)"><a href="./NetloginLib.tcl.html#::_ixSeedFdbTable_1748">::_ixSeedFdbTable</a></a> $txPortId $srcMac $srcIp $gwIp $dstMac 1
    <a name="::check_ping(1)"><a href="./ping.tcl.html#::check_ping_13">::check_ping</a></a> $dstIp $srcIp $txPortId $status &#34;NULL&#34; $srcMac $dstMac
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixSendPing</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Proc that sends a PING frame from Ixia.  Does NOT report</span>
<span class="comment-line">#              success or failure.  </span>
<span class="comment-line">#              Sent to start EAP exchange from DUT.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  dstIp </span>
<span class="comment-line">#              srcIp </span>
<span class="comment-line">#              gwIp </span>
<span class="comment-line">#              txPortId </span>
<span class="comment-line">#              srcMac </span>
<span class="comment-line">#              dstMac</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixSendPing_2295">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixSendPing">::::nl_ixSendPing</a></a></strong> {dstIp srcIp gwIp txPortId srcMac dstMac} {

    <a name="::result_debug(79)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Seeding fdb table&#34;
    <a name="::_ixSeedFdbTable(4)"><a href="./NetloginLib.tcl.html#::_ixSeedFdbTable_1748">::_ixSeedFdbTable</a></a> $txPortId $srcMac $srcIp $gwIp $dstMac 1
    
    set pPattern  &#34;feedbeef&#34;
    set frameSize 64

    <a name="::result_debug(80)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sending ICMP frame&#34;
    set frameSent [<a name="::SendIpFrame(2)"><a href="./ePTSendPacket.tcl.html#::SendIpFrame_587">::SendIpFrame</a></a> -txPortId $txPortId -protocol &#34;icmp&#34; \
                  -dataPattern $pPattern -frameSize $frameSize \
                  -sourceMac $srcMac -destMac $dstMac -sourceIp $srcIp -destIp $dstIp \
                  -type 8 -code 0 -id 1234 -sequence 5678 ]

   <a name="::result_debug(81)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;(802.1x) Frame (icmp) sent on portId $txPortId:&#34;
   <a name="::result_debug(82)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$frameSent&#34;

}

<span class="comment-line">#</span>
<span class="comment-line"># ############################## EXTREME SWITCH FUNCTIONS ###########################</span>
<span class="comment-line"># </span>

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exConfigStandardVlan</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Standard 2 port vlan configuration for dot1x tests</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exConfigStandardVlan_2325">proc <a href="NetloginLib.tcl-annot.html#::::nl_exConfigStandardVlan">::::nl_exConfigStandardVlan</a></a></strong> {protectedPort unprotectedPort \
	protectedIP unprotectedIP \
	{protectedVlanName &#34;vlan_1&#34;} {unprotectedVlanName &#34;vlan_2&#34;}} {

    <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan $protectedVlanName&#34;
    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $protectedVlanName add port $protectedPort&#34;
    <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $protectedVlanName ipaddress $protectedIP/24&#34;
    
    ;<span class="comment-line"># vlan_2 contains the normal port which we send to and from.</span>
    <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan $unprotectedVlanName&#34;
    <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $unprotectedVlanName add port $unprotectedPort&#34;
    <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $unprotectedVlanName ipaddress $unprotectedIP/24&#34;
    
    <a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable ipforwarding&#34;
    
}

<strong><a name="::::nl_exUnconfigStandardVlan_2342">proc <a href="NetloginLib.tcl-annot.html#::::nl_exUnconfigStandardVlan">::::nl_exUnconfigStandardVlan</a></a></strong> {{protectedVlanName &#34;vlan_1&#34;} \
	{unprotectedVlanName &#34;vlan_2&#34;}} {

    <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete $protectedVlanName&#34;
    <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete $unprotectedVlanName&#34;
    <a name="::SendACmd(11)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable ipforwarding&#34;


}

<strong><a name="::::nl_exConfigDhcpServer_2352">proc <a href="NetloginLib.tcl-annot.html#::::nl_exConfigDhcpServer">::::nl_exConfigDhcpServer</a></a></strong> { {dhcpVlan &#34;vlan_1&#34;} \
	{startIpRange &#34;10.1.1.2&#34;} \
	{endIpRange &#34;10.1.1.254&#34;} \
	{gateway &#34;10.1.1.1&#34;} \
	{leaseTimer &#34;1200&#34;} \
	{dns &#34;10.0.0.1&#34;} \
	{wins &#34;10.0.0.85&#34;} }	{

    <a name="::SendACmd(12)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure $dhcpVlan dhcp-address-range $startIpRange - $endIpRange&#34;
    <a name="::SendACmd(13)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure $dhcpVlan dhcp-lease-timer $leaseTimer&#34;
    <a name="::SendACmd(14)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure $dhcpVlan dhcp-options default-gateway $gateway&#34;
    <a name="::SendACmd(15)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure $dhcpVlan dhcp-options dns-server $dns&#34;
    <a name="::SendACmd(16)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure $dhcpVlan dhcp-options wins-server $wins&#34;
}

<strong><a name="::::nl_exUnconfigDhcpServer_2367">proc <a href="NetloginLib.tcl-annot.html#::::nl_exUnconfigDhcpServer">::::nl_exUnconfigDhcpServer</a></a></strong> { {dhcpVlan &#34;vlan_1&#34;} } {
    
    <a name="::SendACmd(17)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig $dhcpVlan dhcp-address-range&#34;
    <a name="::SendACmd(18)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig $dhcpVlan dhcp-options&#34;
}

<strong><a name="::::nl_exEnableDhcpOnPort_2373">proc <a href="NetloginLib.tcl-annot.html#::::nl_exEnableDhcpOnPort">::::nl_exEnableDhcpOnPort</a></a></strong> { <a name="::port(4)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan } {
    <a name="::SendACmd(19)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable dhcp port $port vlan $vlan&#34;
}

<strong><a name="::::nl_exDisableDhcpOnPort_2377">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDisableDhcpOnPort">::::nl_exDisableDhcpOnPort</a></a></strong> { <a name="::port(5)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan } {
    <a name="::SendACmd(20)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable dhcp port $port vlan $vlan&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exConfigRadius</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configure and enable radius server</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exConfigRadius_2391">proc <a href="NetloginLib.tcl-annot.html#::::nl_exConfigRadius">::::nl_exConfigRadius</a></a></strong> {serverIP serverPort clientIP {sharedSecret &#34;extreme&#34;} \
	{which &#34;primary&#34;} } {

    ;<span class="comment-line"># NOTE: shared secret is required before enabling.</span>

    <a name="::SendACmd(21)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable radius&#34;

    set vr [<a name="::GetVrString(1)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> 1]
    <span class="comment-line">#set vr &#34;VR-mgmt&#34;</span>

    <a name="::SendACmd(22)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config radius $which server $serverIP $serverPort \
	    client-ip $clientIP vr $vr&#34;
    
    <a name="::SendACmd(23)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config radius $which shared-secret $sharedSecret&#34;
    
    <a name="::SendACmd(24)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable radius&#34;

    <a name="::SendACmd(25)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable radius mgmt-access&#34;
}

<strong><a name="::::nl_exUnconfigRadius_2411">proc <a href="NetloginLib.tcl-annot.html#::::nl_exUnconfigRadius">::::nl_exUnconfigRadius</a></a></strong> {} {

    <a name="::SendACmd(26)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig radius&#34;
    <a name="::SendACmd(27)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable radius&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exEnableDebugLogFilter</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Turn on debug logs.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exEnableDebugLogFilter_2425">proc <a href="NetloginLib.tcl-annot.html#::::nl_exEnableDebugLogFilter">::::nl_exEnableDebugLogFilter</a></a></strong> {} {

    <a name="::SendACmd(28)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure log filter \&#34;DefaultFilter\&#34; del event all&#34;
    <a name="::SendACmd(29)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure log filter \&#34;DefaultFilter\&#34; add events nl severity debug-data&#34;
    <a name="::SendACmd(30)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure log filter \&#34;DefaultFilter\&#34; add events aaa severity debug-data&#34;
    <a name="::SendACmd(31)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable log debug&#34;
    <a name="::SendACmd(32)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;cl log&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exDisableDebugLogFilter</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Turn off debug logs.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exDisableDebugLogFilter_2441">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDisableDebugLogFilter">::::nl_exDisableDebugLogFilter</a></a></strong> {} {

    SebdACnd &#34;disable log debug&#34;
    <a name="::SendACmd(33)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfigure log filter \&#34;DefaultFilter\&#34;&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exDumpDebugInfo</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Dump all debug info</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exDumpDebugInfo_2455">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDumpDebugInfo">::::nl_exDumpDebugInfo</a></a></strong> { {<a name="::vlan(7)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;&#34;} } {

    <a name="::result_debug(83)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;================ START DEBUG DUMP ===============&#34;
    <a name="::SendACmd(34)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show config vlan&#34;
    <a name="::SendACmd(35)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show config fdb&#34;
    <a name="::SendACmd(36)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show config netlogin&#34;
    <a name="::SendACmd(37)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34;
    <a name="::SendACmd(38)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show vlan $vlan&#34;
    <a name="::SendACmd(39)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show radius&#34;
    <a name="::SendACmd(40)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show fdb&#34;
    <a name="::SendACmd(41)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show iparp&#34;

    <a name="::EnableDebugMode(1)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>


    if {[<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34;] &#34;12.1.0.47&#34;]&lt;=0} {

    <a name="::SendACmd(42)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;jerry show vlan vpif&#34;
    <a name="::SendACmd(43)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;jerry netlogin show dot1x-clients&#34;
    <a name="::SendACmd(44)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;jerry netlogin show vr&#34;
    <a name="::SendACmd(45)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;jerry netlogin show pif&#34;
    <a name="::SendACmd(46)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;jerry netlogin show vpif clients details&#34;
    <a name="::SendACmd(47)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;jerry netlogin show mac-cache&#34;
    } else {
    <a name="::SendACmd(48)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug vlan show vpif&#34;
    <a name="::SendACmd(49)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug netlogin show dot1x-clients&#34;
    <a name="::SendACmd(50)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug netlogin show vr&#34;
    <a name="::SendACmd(51)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug netlogin show pif&#34;
    <a name="::SendACmd(52)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug netlogin show vpif clients details&#34;
    <a name="::SendACmd(53)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug netlogin show mac-cache&#34;
    }
    
    <a name="::SendACmd(54)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show log&#34;

    <a name="::DisableDebugMode(1)"><a href="./misc.tcl.html#::DisableDebugMode_2957">::DisableDebugMode</a></a>
    <a name="::result_debug(84)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;================ END DEBUG DUMP ===============&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exConfigNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configure and enable netlogin</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exConfigNetlogin_2503">proc <a href="NetloginLib.tcl-annot.html#::::nl_exConfigNetlogin">::::nl_exConfigNetlogin</a></a></strong> {{<a name="::vlan(8)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;defNetloginVlan&#34;} {type &#34;mac&#34;}}  {

    <a name="::SendACmd(55)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan $vlan&#34;
    <a name="::SendACmd(56)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config netlogin vlan $vlan&#34;
    <a name="::SendACmd(57)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable netlogin $type&#34;    
}

<strong><a name="::::nl_exUnconfigNetlogin_2510">proc <a href="NetloginLib.tcl-annot.html#::::nl_exUnconfigNetlogin">::::nl_exUnconfigNetlogin</a></a></strong> { {<a name="::vlan(9)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;defNetloginVlan&#34;} {type &#34;mac&#34;} }  {

    <a name="::SendACmd(58)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable netlogin $type&#34;
    <a name="::SendACmd(59)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig netlogin vlan&#34;
    <a name="::SendACmd(60)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;delete $vlan&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exEnableNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Enable/Disable netlogin</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exEnableNetlogin_2528">proc <a href="NetloginLib.tcl-annot.html#::::nl_exEnableNetlogin">::::nl_exEnableNetlogin</a></a></strong> {{type &#34;mac&#34;}}  {

    <a name="::SendACmd(61)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable netlogin $type&#34;    
}

<strong><a name="::::nl_exDisableNetlogin_2533">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDisableNetlogin">::::nl_exDisableNetlogin</a></a></strong> { {type &#34;mac&#34;} }  {

    <a name="::SendACmd(62)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable netlogin $type&#34;
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exEnableNetloginPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Enable netlogin on a port.  We wrap it because of we've seen</span>
<span class="comment-line">#              lots of command truncation after executing this command.  To </span>
<span class="comment-line">#              deal with this we added a delay after executing.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port:  Port to activate</span>
<span class="comment-line">#              type: dot1x/mac/web-based</span>
<span class="comment-line">#              delay: Seconds to wait before returning</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  nl_exEnableNetloginPort [MaptDUTPortId 1] &#34;dot1x&#34; 5</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exEnableNetloginPort_2555">proc <a href="NetloginLib.tcl-annot.html#::::nl_exEnableNetloginPort">::::nl_exEnableNetloginPort</a></a></strong> {<a name="::port(6)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> {type &#34;mac&#34;} {delay 1}} {
    
    <a name="::SendACmd(63)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable netlogin port $port $type&#34;
    <a name="::exSleep(5)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $delay

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exDisableNetloginPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Disable netlogin on a port.  We wrap it because of we've seen</span>
<span class="comment-line">#              lots of command truncation after executing this command.  To </span>
<span class="comment-line">#              deal with this we added a delay after executing.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port:  Port to deactivate</span>
<span class="comment-line">#              type: /mac/web/dot1x</span>
<span class="comment-line">#              delay: Seconds to wait before returning</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  nl_exDisableNetloginPort [MaptDUTPortId 1] &#34;ispVlan&#34; 5</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exDisableNetloginPort_2578">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDisableNetloginPort">::::nl_exDisableNetloginPort</a></a></strong> {<a name="::port(7)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> {type &#34;mac&#34;} {delay 1}} {
    
    <a name="::SendACmd(64)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable netlogin port $port $type&#34;
    <a name="::exSleep(6)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $delay
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exAddMacList </span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Add entries to mac list</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  mac:  mac | &#34;default&#34;</span>
<span class="comment-line">#              mask: bitmask              </span>
<span class="comment-line">#              encrypted: true | false</span>
<span class="comment-line">#              passwd: &#34;string&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  nl_exAddMacList </span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exAddMacList_2600">proc <a href="NetloginLib.tcl-annot.html#::::nl_exAddMacList">::::nl_exAddMacList</a></a></strong> {{mac &#34;default&#34;} {maskbits &#34;&#34;} {encrypted &#34;0&#34;} {passwd &#34;&#34;}} {
    
    <a name="::result_debug(85)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;mac:$mac  maskbits:$maskbits encrypted:$encrypted  pwd:$passwd&#34;
    if {$encrypted != 0} {
	set encrypt &#34;encrypt&#34;
    } else {
	set encrypt &#34;&#34;
    }

    if {$maskbits == &#34;&#34;} {
	<a name="::SendACmd(65)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure netlogin add mac-list $mac $encrypt $passwd&#34;
    } else {
	<a name="::SendACmd(66)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure netlogin add mac-list $mac $maskbits $encrypt $passwd&#34;
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exDelMacList </span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Del entries to mac list</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  mac:  mac | &#34;default&#34;</span>
<span class="comment-line">#              mask: bitmask              </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  nl_exDelMacList </span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exDelMacList_2630">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDelMacList">::::nl_exDelMacList</a></a></strong> {{mac &#34;default&#34;} {mask &#34;&#34;}} {
        ;<span class="comment-line"># Only supported Default for now...</span>
    <a name="::SendACmd(67)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure netlogin del mac-list $mac $mask&#34;
} 


<strong><a name="::::nl_exAddMacListSet_2636">proc <a href="NetloginLib.tcl-annot.html#::::nl_exAddMacListSet">::::nl_exAddMacListSet</a></a></strong> { maclistSet } {

    <a name="::result_debug(86)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;nl_exAddMacListSet: There are [llength $maclistSet] entries to add&#34;

    foreach macentry $maclistSet {

	set mac [lindex $macentry 0]
	set maskbits [lindex $macentry 1]
	set encrypted [lindex $macentry 2]
	set passwd [lindex $macentry 3]

	<a name="::nl_exAddMacList(1)"><a href="./NetloginLib.tcl.html#::nl_exAddMacList_2600">::nl_exAddMacList</a></a> $mac $maskbits $encrypted $passwd
    }

}


<strong><a name="::::nl_exDelMacListSet_2653">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDelMacListSet">::::nl_exDelMacListSet</a></a></strong> { maclistSet } {

    <a name="::result_debug(87)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;nl_exDelMacListSet: There are [llength $maclistSet] entries to delete&#34;

    foreach macentry $maclistSet {

	set mac [lindex $macentry 0]
	set maskbits [lindex $macentry 1]

	<a name="::nl_exDelMacList(1)"><a href="./NetloginLib.tcl.html#::nl_exDelMacList_2630">::nl_exDelMacList</a></a> $mac $maskbits
    }

}

<strong><a name="::::nl_exRestartPort_2667">proc <a href="NetloginLib.tcl-annot.html#::::nl_exRestartPort">::::nl_exRestartPort</a></a></strong> { <a name="::port(8)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> {delay 2} } {

    <a name="::SendACmd(68)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable port $port&#34;
    <a name="::exSleep(7)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $delay
    <a name="::SendACmd(69)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable port $port&#34;
    <a name="::exSleep(8)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $delay
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyMacList </span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verifies entries in the mac list</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  mac:  macPasswordList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Partial show netlogin output for MAC List. NOTE: yaqu is encrypted form for &#34;test&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># MAC Address/Mask      Password (encrypted)</span>
<span class="comment-line"># --------------------  --------------------------</span>
<span class="comment-line"># Default               &lt;not configured&gt;</span>
<span class="comment-line"># Default               yaqu</span>
<span class="comment-line"># 00:DE:AD:BE:EF:01/48  &lt;not configured&gt;</span>
<span class="comment-line"># 00:DE:AD:BE:EF:01/48  yaqu</span>
<span class="comment-line"># 00:DE:AD:00:00:00/24  &lt;not configured&gt;</span>
<span class="comment-line"># 00:DE:AD:00:00:00/24  yaqu</span>
<span class="comment-line"># </span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<strong><a name="::::nl_exVerifyMacList_2697">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyMacList">::::nl_exVerifyMacList</a></a></strong> { {macPasswordList &#34;&#34;} {mode &#34;&#34;} } {
    
    
    <a name="::CheckKeyValue(2)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin $mode&#34; $macPasswordList

}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyNetloginAuthMode</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify global netlogin authentication mode</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  mode:  mac | 802 | web</span>
<span class="comment-line">#              state: disabled | enabled</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  nl_exVerifyNetloginAuthMode &#34;mac&#34; &#34;disabled&#34;</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyNetloginAuthMode_2718">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyNetloginAuthMode">::::nl_exVerifyNetloginAuthMode</a></a></strong> { {mode &#34;mac&#34;} {state &#34;enabled&#34;} } {
    
    set state [string toupper $state]

    lappend parameterList &#34;{NetLogIn Auth.*\ *:.*.*$mode.*\ $state\(;|\n|\ )}&#34;
    <a name="::CheckKeyValue(3)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList
    unset parameterList
    
    
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyMacList </span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify netlogin mac list </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  port:  Port to verify</span>
<span class="comment-line">#              status: enabled/disabled</span>
<span class="comment-line">#              type: dot1x/mac/web</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  lappend mList {&#34;Default\ *\&lt;not configured&#34; exist}</span>
<span class="comment-line">#  nl_exVerifyMacList $mList</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyMacList_2744">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyMacList">::::nl_exVerifyMacList</a></a></strong> { {macList &#34;&#34;} {mode &#34;&#34;} } {
    
    <a name="::CheckKeyValue(4)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin $mode&#34; $macList \
	    -comment &#34;Verify Netlogin MAC list&#34;
    
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyNetloginOnPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify netlogin on a port. </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  port:  Port to verify</span>
<span class="comment-line">#              status: enabled/disabled</span>

<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  nl_exVerifyNetloginOnPort [MaptDUTPortId 1] &#34;ispVlan&#34; 5</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyNetloginOnPort_2765">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyNetloginOnPort">::::nl_exVerifyNetloginOnPort</a></a></strong> { <a name="::port(9)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> status type {typeStatus &#34;enabled&#34;}} {
    
    <span class="comment-line"># show port 2:7 info detail</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># NetLogIn:    Enabled </span>
    <span class="comment-line"># NetLogIn mode:    802.1X, Mac based, Web login</span>
    
    set parameterList &#34;&#34;

    if [regexp -nocase &#34;enable&#34; $status] {
	lappend parameterList &#34;{NetLogIn:.*Enabled} exist&#34;
    } elseif [regexp -nocase $status &#34;disable&#34;] {
	lappend parameterList &#34;{NetLogIn:.*Disabled} exist&#34;
    }
 

    if [regexp -nocase &#34;enable&#34; $typeStatus ] {
	set tStatus &#34;exist&#34;
    } else {
	set tStatus &#34;notExist&#34;
    }
    
    if {$status == &#34;enabled&#34;} {
	if [regexp -nocase &#34;dot1x&#34; $type] {
	    lappend parameterList &#34;{NetLogin.*mode:.*802.1x} $tStatus&#34;
	}
	
	if [regexp -nocase &#34;web&#34; $type] {
	    lappend parameterList &#34;{NetLogin.*mode:.*Web} $tStatus&#34;
	}
	
	if [regexp -nocase &#34;mac&#34; $type] {
	    lappend parameterList &#34;{NetLogin.*mode:.*Mac} $tStatus&#34;
	}
	
	<a name="::CheckKeyValue(5)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show port $port info detail&#34; $parameterList
	unset parameterList
    }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exGetNetloginVal</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retrieve the value for a particular MAC Address.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  mac:   Mac address to look for</span>
<span class="comment-line">#              param: Parameter to retrieve</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: paramter or NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># VALID param VALUES: IP address, Auth, Type, ReAuth-Timer User</span>
<span class="comment-line">#  i.e.</span>
<span class="comment-line">#  Port: 21,   Vlan: vlan_1,  State: Enabled</span>
<span class="comment-line">#  MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line">#  00:00:01:02:01:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  set reauth [nl_exGetNetloginVal &#34;00:00:01:02:01:01&#34; ReAuth-Timer]</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exGetNetloginVal_2824">proc <a href="NetloginLib.tcl-annot.html#::::nl_exGetNetloginVal">::::nl_exGetNetloginVal</a></a></strong> { <a name="::port(10)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan supMac param } {

   global tmpPath
   set tmp &#34;Tmp&#34;
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile &#34;$tmp/tmp_Dot1X$pid&#34;

    set _mac NULL
    set _ip NULL 
    set _auth NULL
    set _type NULL
    set _reauth NULL
    set _user NULL

    ;<span class="comment-line"># Execute show netlogin and put output into a file</span>
    set fd_in [open $tempFile &#34;w&#34;]
    <a name="::SendACmd(70)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34; NULL $fd_in

    close $fd_in

    ;<span class="comment-line"># Open for reading</span>
    set fd_in [open $tempFile &#34;r&#34;]
    
    set portVlanMatchLine  &#34;&#34;
    set macMatchLine       &#34;&#34;
    ;<span class="comment-line"># Find correct port/vlan and MAC lines </span>
    while {[gets $fd_in line] != -1} {

	;<span class="comment-line"># Look for Port/Vlan Match.</span>
	if {[regexp -nocase -indices -- Port:.*$port.*Vlan:.*$vlan $line matchedRange] == 1} {
	    set portVlanMatchLine $line
	    <a name="::result_debug(88)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND Port:$port Vlan:$vlan on line:$line&#34;

	    ;<span class="comment-line"># Now look for MAC Match</span>
	    while {[gets $fd_in line] != -1} {
		
		if {[regexp -nocase &#34;/-/-/-/-/-/-&#34; $line] == 1} {
		    ;<span class="comment-line"># Found end of port section delimiter...MAC not found in the section.</span>
		    <a name="::result_debug(89)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit delimiter without finding MAC&#34;
		    break;
		}
		
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    <a name="::result_debug(90)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND MAC:$supMac on line:$line&#34;
		    set macMatchLine $line
		    break
		}
	    }
	    break;
	}
    }
    close $fd_in
    file delete $tempFile
    
    
    if {$portVlanMatchLine == &#34;&#34;} {
	<a name="::result_debug(91)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port:$port Vlan:$vlan NOT FOUND&#34;
	return NULL
    }

    if { [string length $macMatchLine] &gt; 0 } {
	regexp {(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)}  \
		$macMatchLine \
		ignore _mac _ip _auth _type _reauth _user
	<a name="::result_debug(92)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;mac: $_mac&#34;
	<a name="::result_debug(93)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ip: $_ip&#34;
	<a name="::result_debug(94)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;auth: $_auth&#34;
	<a name="::result_debug(95)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;type: $_type&#34;
	<a name="::result_debug(96)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;reauth: $_reauth&#34;
	<a name="::result_debug(97)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;user: $_user&#34;
    }

    ;<span class="comment-line"># Default _reauth to 0 if not found or not an int</span>
    if {! [string is integer -strict $_reauth] } {
	set _reauth 0
    }
    switch -exact -- $param \
	    &#34;mac&#34;    {return $_mac} \
	    &#34;ip&#34;     {return $_ip} \
	    &#34;auth&#34;   {return $_auth} \
	    &#34;type&#34;   {return $_type} \
	    &#34;reauth&#34; {return $_reauth} \
	    &#34;user&#34;   {return $_user} \
	    default  {return NULL} \
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyPortAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a port is authenticated/unauthenticated</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port: DUT port</span>
<span class="comment-line">#              vlan: DUT vlan</span>
<span class="comment-line">#              authStatus: &#34;Auth&#34; | &#34;Unauth | &#34;notExist&#34;&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyPortAuth_2928">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyPortAuth">::::nl_exVerifyPortAuth</a></a></strong> {<a name="::port(11)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan authStatus} {    

    set parameterList [list]
 
    if {$authStatus == &#34;notExist&#34;} {
	if {$vlan != &#34;&#34;} {
	    lappend parameterList &#34;{Port:.* $port.*Vlan:.*$vlan.* State:} notExist&#34;
	    set returnCode [<a name="::CheckKeyValue(6)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList  \
		    -comment &#34;Verifying Port:$port Vlan:$vlan doesn't exist&#34;]
	} else {
	    ;<span class="comment-line"># Not exist at all on ANY vlan</span>
	    lappend parameterList &#34;{Port:.* $port.*Vlan:} notExist&#34;
	    set returnCode [<a name="::CheckKeyValue(7)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList  \
		    -comment &#34;Checking if Port:$port doesn't exist&#34;]	    
	}
    } else {
	lappend parameterList &#34;{Port:.* $port.*Vlan:.*$vlan.* State: $authStatus} exist&#34;
	set returnCode [<a name="::CheckKeyValue(8)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList  \
		-comment &#34;Checking if Port:$port Vlan:$vlan is $authStatus&#34;]
    }
    return $returnCode

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyMacAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a particular MAC is authenticated/unauthenticated</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port: DUT port</span>
<span class="comment-line">#              vlan: DUT vlan</span>
<span class="comment-line">#              mac:  MAC address of supplicant</span>
<span class="comment-line">#              authStatus: &#34;Auth&#34; | &#34;Unauth&#34; | &#34;none&#34;</span>
<span class="comment-line">#                 *authStatus of &#34;none&#34; means MAC is NOT listed at all</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyMacAuth_2966">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyMacAuth">::::nl_exVerifyMacAuth</a></a></strong> { <a name="::port(12)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan mac authStatus } { 

    set parameterList [list]
    
    if {$authStatus == &#34;none&#34;} {
	lappend parameterList &#34;$mac.* notExist&#34;
	set returnCode [<a name="::CheckKeyValue(9)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList \
		-comment &#34;Checking $mac is NOT present&#34;]
    } else {
	lappend parameterList &#34;$mac.*$authStatus exist&#34;
	set returnCode [<a name="::CheckKeyValue(10)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList \
		-comment &#34;Checking $mac IS present&#34;]
    }

    return $returnCode
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exCheckMatch</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a port is authenticated/unauthenticated</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  actual:</span>
<span class="comment-line">#              expected:</span>
<span class="comment-line">#                 *If expected is &#34;&#34;, we're NOT interested in it, so just return 1.</span>
<span class="comment-line">#              matchType: &#34;greater&#34; | &#34;less&#34; | &#34;equal&#34; | &#34;ge&#34; | &#34;le&#34; | &#34;string</span>
<span class="comment-line">#              nocase: &#34;true&#34; | &#34;false&#34; Case sensitive</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1-match 0-no match</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exCheckMatch_2997">proc <a href="NetloginLib.tcl-annot.html#::::_exCheckMatch">::::_exCheckMatch</a></a></strong> { actual expected {matchType &#34;string&#34;} {nocase &#34;true&#34;} } {
    
    set nc &#34;&#34;

    if {$nocase == &#34;true&#34;} {
	set nc &#34;-nocase&#34;
    }
	
    if [string length $expected] {
	if {$matchType == &#34;string&#34;} {
	    if [regexp $nc $expected $actual] {
		<a name="::result_debug(98)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;string match of $actual vs. $expected OK&#34;
		return 1
	    } else {
		<a name="::result_debug(99)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;string match of $actual vs. $expected FAIL&#34;
		return 0
	    }
	    
	} elseif {$matchType == &#34;greater&#34;} {
	    if {$actual &gt; $expected} {
		<a name="::result_debug(100)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater match of $actual &gt; $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(101)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater match of $actual &gt; $expected FAIL&#34;
	} elseif {$matchType == &#34;less&#34;} {
	    if {$actual &lt; $expected} {
		return 1
	    }
	    <a name="::result_debug(102)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;less match of $actual &lt; $expected FAIL&#34;
	} elseif {$matchType == &#34;equal&#34;} {
	    if {$actual == $expected} {
		<a name="::result_debug(103)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;equal match of $actual ==  $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(104)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;equal match of $actual ==  $expected FAIL&#34;
	} elseif {$matchType == &#34;ge&#34;} {
	    if {$actual &gt;= $expected} {
		<a name="::result_debug(105)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater or equal match of $actual &gt;= $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(106)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater or equal match of $actual &gt;= $expected FAIL&#34;
	} elseif {$matchType == &#34;le&#34;} {
	    if {$actual &lt;= $expected} {
		<a name="::result_debug(107)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;less or equal match of $actual &lt;= $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(108)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;less or equal match of $actual &lt;= $expected FAIL&#34;
	}

    } else {
	<a name="::result_debug(109)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NOT Interested in $expected vs $actual&#34;
	;<span class="comment-line"># We're not interested in this parameter, so just return 1.</span>
	return 1
    }
    
    return 0
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exMacMatch</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Find a matching MAC in the line looking for supMac,supIp,</span>
<span class="comment-line">#              authVal, authType, user, and reauthTimer values</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  macMatchLine: Line to do comparison against</span>
<span class="comment-line">#              supMac: MAC of sup.</span>
<span class="comment-line">#              supIp: IP Addr of sup.  Only checked for WEB BASED!</span>
<span class="comment-line">#              authVal: &#34;No&#34; | &#34;Yes&#34;</span>
<span class="comment-line">#              authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#              reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#                 -1 : ignore</span>
<span class="comment-line">#                  0 : Looking for timer == 0</span>
<span class="comment-line">#               &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#              user: Username used to login with.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1-match 0-no match</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin. </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:94 # show netlogin </span>
<span class="comment-line"># Port: 21,   Vlan: vlan_1,  State: Authenticated</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5</span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exMacMatch_3086">proc <a href="NetloginLib.tcl-annot.html#::::_exMacMatch">::::_exMacMatch</a></a></strong> {macMatchLine supMac supIp authVal authServer authType reauthTimer user} {

    <a name="::result_debug(110)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Examining macMatchLine $macMatchLine&#34;

    set _supMac &#34;&#34;
    set _supIp &#34;&#34; 
    set _authVal &#34;&#34; 
    set _authServer &#34;&#34; 
    set _authType &#34;&#34; 
    set _reauthTimer &#34;&#34; 
    set _user &#34;&#34;
    
    ;<span class="comment-line"># MAC - IP - Auth - Type - ReAuth - User</span>
    if {[<a name="::CompareRelease(2)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34;] &#34;11.7.0.11&#34;]&gt;=0} {
        scan $macMatchLine {%s %s %s %s %s %s %s} _supMac _supIp _authVal _authServer _authType _reauthTimer _user
    } else {
        scan $macMatchLine {%s %s %s %s %s %s} _supMac _supIp _authVal _authType _reauthTimer _user
    }
<span class="comment-line">#    ;# Hack for empty IP Address.  Check if _supIp field picks up Yes/No from _authVal field</span>
<span class="comment-line">#   if {($_supIp == &#34;Yes&#34;) || ($_supIp == &#34;No&#34;)} {</span>
<span class="comment-line">#	scan $macMatchLine {%s %s %s %s %s} _supMac _authVal _authType _reauthTimer _user</span>
<span class="comment-line">#	set _supIp &#34;&#34;</span>
<span class="comment-line">#   }</span>
    if {[<a name="::CompareRelease(3)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(3)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34;] &#34;11.7.0.11&#34;]&gt;=0} {
       <a name="::result_debug(111)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;EXPECTED: $supMac $supIp $authVal $authServer $authType $reauthTimer $user&#34;	
       <a name="::result_debug(112)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ACTUAL    $_supMac $_supIp $_authVal $_authServer $_authType $_reauthTimer $_user&#34;
    } else {
       <a name="::result_debug(113)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;EXPECTED: $supMac $supIp $authVal $authType $reauthTimer $user&#34;	
       <a name="::result_debug(114)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ACTUAL    $_supMac $_supIp $_authVal $_authType $_reauthTimer $_user&#34;
    }
    
    ;<span class="comment-line"># IP Address is only valid for WEB Based.  Make sure we don't check it if</span>
    ;<span class="comment-line"># we expect auth type of 802.1x</span>
    if [regexp -nocase &#34;802.1x&#34; $authType] {
	set supIp &#34;&#34;
    }
    
    set macMatch 1
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(1)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_supIp $supIp]]
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(2)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_authVal $authVal]]
    if {[<a name="::CompareRelease(4)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(4)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34;] &#34;11.7.0.11&#34;]&gt;=0} {
       set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(3)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_authServer $authServer]]
    }
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(4)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_authType $authType]]
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(5)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_user $user &#34;string&#34; &#34;false&#34;]]

    ;<span class="comment-line"># DON'T CHECK FOR NOW</span>
    if {0} {
	if {$reauthTimer == &#34;0&#34;} {
	    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(6)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_reauthTimer $reauthTimer &#34;equal&#34;]]
	} elseif {$reauthTimer == &#34;-1&#34;} {
	    set macMatch 1
	} else {
	    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(7)"><a href="./NetloginLib.tcl.html#::_exCheckMatch_2997">::_exCheckMatch</a></a> $_reauthTimer $reauthTimer &#34;greater&#34;]]
	}
    }


    return $macMatch
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exVerifyShowNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that verifies show netlogin params.  Must pass</span>
<span class="comment-line">#              tempfile which contains output of sh netlogin.  This proc</span>
<span class="comment-line">#              just does the checking</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	portState: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#	supMac: supplicant MAC</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#	tempFile: File containing &#34;show netlogin&#34; output</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1-match 0-no match</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin. </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:94 # show netlogin </span>
<span class="comment-line"># Port: 21,   Vlan: vlan_1,  State: Authenticated</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5</span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: Did NOT use CheckKeyValue because it couldn't handle multi layer output of </span>
<span class="comment-line">#       Port, then MAC list</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exVerifyShowNetlogin_3183">proc <a href="NetloginLib.tcl-annot.html#::::_exVerifyShowNetlogin">::::_exVerifyShowNetlogin</a></a></strong> {args} {
    <a name="::parse_args(10)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _exVerifyShowNetlogin $args {
	<a name="::port(13)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(10)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	portState   &#34;&#34;
	supMac      &#34;&#34;
	supIp       &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	authServer  &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	tempFile    &#34;&#34;
    }

    ;<span class="comment-line"># Open for reading</span>
    set fd_in [open $tempFile &#34;r&#34;]
    
    set portVlanMatchLine  &#34;&#34;
    set macMatchLine       &#34;&#34;
    ;<span class="comment-line"># Find correct port/vlan and MAC lines </span>
    while {[gets $fd_in line] != -1} {
	;<span class="comment-line"># Look for Port/Vlan Match.</span>
	if {[regexp -nocase -indices -- Port:.*$port.*Vlan:.*$vlan $line matchedRange] == 1} {
	    set portVlanMatchLine $line
	    <a name="::result_debug(115)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND Port:$port Vlan:$vlan on line:$line&#34;
	    
	    if {[string length $supMac] == 0} {
		;<span class="comment-line"># Only looking for port/vlan state</span>
		<a name="::result_debug(116)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No MAC given.  Only needed port/vlan state.&#34;
		break
	    }
	    
	    ;<span class="comment-line"># Now look for MAC Match</span>
	    while {[gets $fd_in line] != -1} {
		
		<a name="::result_debug(117)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Looking for a MAC Match...$line&#34;
		if {[regexp -nocase &#34;/-/-/-/-/-/-&#34; $line] == 1} {
		    ;<span class="comment-line"># Found end of port section delimiter...MAC not found in the section.</span>
		    <a name="::result_debug(118)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit delimiter without finding MAC&#34;
		    break;
		}
		    
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    <a name="::result_debug(119)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND MAC:$supMac on line:$line&#34;
		    set macMatchLine $line
		    break
		}
	    }
	    break;
	}
    }
    close $fd_in
    
    
    if {$portVlanMatchLine == &#34;&#34;} {
	<a name="::result_debug(120)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port:$port Vlan:$vlan NOT FOUND&#34;
	return 0
    }

    set portVlanMatch 0

    ;<span class="comment-line"># Apply required key info matches</span>
    if { [string length $portVlanMatchLine] &gt; 0 } {
	if {$portState != &#34;&#34;} {
	    set portVlanMatch [regexp -nocase &#34;\ $portState&#34; $portVlanMatchLine]
	    if {$portVlanMatch} {
		<a name="::result_debug(121)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;portState $portState OK&#34;
	    } else {
		<a name="::result_debug(122)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;string match of $portState vs $portVlanMatchLine FAILED&#34;
	    }

	} else {
	    set portVlanMatch 1
	    <a name="::result_debug(123)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Ignoring portState $portState portVlanMatch: $portVlanMatch&#34;
	}
    }
    
    ;<span class="comment-line"># We don't care about supplicant MAC entry</span>
    if {[string length $supMac] == 0} {
	<a name="::result_debug(124)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SupMac $supMac was not given.  Returning portVlanMatch: $portVlanMatch&#34;
	return $portVlanMatch
    }
    

    set macMatch 0

    if { [string length $macMatchLine] &gt; 0 } {
	<a name="::result_debug(125)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Matching supMac $supMac with $macMatchLine&#34;
        set macMatch [<a name="::_exMacMatch(1)"><a href="./NetloginLib.tcl.html#::_exMacMatch_3086">::_exMacMatch</a></a> $macMatchLine $supMac $supIp $authVal \
               $authServer $authType $reauthTimer $user]
    } else {
	<a name="::result_debug(126)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$supMac not found&#34;
    }

    <a name="::result_debug(127)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;RETURNING port: $portVlanMatch  mac: $macMatch&#34;

    return [expr $portVlanMatch &amp; $macMatch]
    
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyShowNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verifies &#34;show netlogin&#34; parameters for 1 or more </span>
<span class="comment-line">#              supplicants.  Writes output to a temp file for which</span>
<span class="comment-line">#              is parsed by an internal proc.  Temp file is deleted</span>
<span class="comment-line">#              before exiting.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	portState: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#	supMac: supplicant MAC</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#	numSupplicants: 1 or more</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin. </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:94 # show netlogin </span>
<span class="comment-line"># Port: 21,   Vlan: vlan_1,  State: Authenticated</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5</span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: Did NOT use CheckKeyValue because it couldn't handle multi layer output of </span>
<span class="comment-line">#       Port, then MAC list</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyShowNetlogin_3323">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyShowNetlogin">::::nl_exVerifyShowNetlogin</a></a></strong> {args} {
    <a name="::parse_args(11)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_exVerifyShowNetlogin $args {
	<a name="::port(14)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(11)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	portState   &#34;&#34;
	supMac &#34;&#34;
	supIp  &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	authServer  &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	numSupplicants &#34;1&#34;
    }

    set curIp $supIp
    set curMac $supMac
    set numSup $numSupplicants

    <a name="::report_start_test(3)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify show netlogin for $numSup supplicant(s) $portState&#34;

   global tmpPath
   set tmp &#34;Tmp&#34;
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile &#34;$tmp/tmp_netlogin$pid&#34;

    ;<span class="comment-line"># Execute show netlogin and put output into a file</span>
    set fd_in [open $tempFile &#34;w&#34;]
    <a name="::SendACmd(71)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34; NULL $fd_in

    close $fd_in
    set numFail 0
    while { $numSup } {
	<a name="::result_debug(128)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSup) Verify show netlogin supMac:$curMac supIp:$curIp&#34;
    
	if {! [<a name="::_exVerifyShowNetlogin(1)"><a href="./NetloginLib.tcl.html#::_exVerifyShowNetlogin_3183">::_exVerifyShowNetlogin</a></a> -port $port \
		-vlan $vlan -portState $portState -supMac $curMac \
		-supIp $curIp -authVal $authVal -authServer $authServer \
                -authType $authType -reauthTimer $reauthTimer -user $user \
                -tempFile $tempFile]} {
	    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Verification of show netlogin parameters failed.&#34;
	    incr numFail
	}
	;<span class="comment-line"># Increment IP and MAC</span>
	if {$curIp != &#34;&#34;} {
	    set curIp [<a name="::IncrIpAddr(5)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	}
	if {$curMac != &#34;&#34;} {
	    set curMac [<a name="::IncMacByOne(5)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]
	}
	incr numSup -1
    }
    if {$numFail &gt; 0} {
	<a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$numFail of $numSupplicants supplicants failed to Authenticate&#34;
    }
    <a name="::report_end_test(5)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

    if {$numFail == 0} {
	file delete $tempFile
    } else {
	<a name="::result_debug(129)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FAILURES! Preserving $tempFile for review&#34;
	<a name="::result_debug(130)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;********** EXPECTED FILE CONTENTS ***********&#34;
	<a name="::SendACmd(72)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34;
    }
    return $numFail
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exVerifyShowNetloginPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that checks &#34;show netlogin ports &lt;x&gt; &lt;vlan&gt;&#34; </span>
<span class="comment-line">#              parameters for an individual port/vlan combination</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	auth:   mac-based | 802.1x | web-based</span>
<span class="comment-line">#	portState: &#34;Enabled&#34; | &#34;Disabled&#34;</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#       showMode: port | vlan | port_vlan</span>
<span class="comment-line">#              show netlogin port &lt;portNum&gt;</span>
<span class="comment-line">#              show netlogin vlan &lt;vlanName&gt;</span>
<span class="comment-line">#              show netlogin port &lt;portNum&gt; vlan &lt;vlanName&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># * BD-10808.321 # show netlogin ports 2:11</span>
<span class="comment-line"># Port           : 21        </span>
<span class="comment-line"># Vlan           : vlan_1</span>
<span class="comment-line"># Authentication : mac-based</span>
<span class="comment-line"># Port State     : Enabled</span>
<span class="comment-line">#</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># ------------------------------------------------------------------</span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         No     802.1x    2            Unknown         </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exVerifyShowNetloginPorts_3434">proc <a href="NetloginLib.tcl-annot.html#::::_exVerifyShowNetloginPorts">::::_exVerifyShowNetloginPorts</a></a></strong> {args} {
    <a name="::parse_args(12)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _exVerifyShowNetloginPorts $args {
	<a name="::port(15)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(12)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	auth        &#34;&#34;
	portState   &#34;&#34;
	supMac      &#34;&#34;
	supIp       &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
        authServer  &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	showMode    &#34;port_vlan&#34;
    }

    ;<span class="comment-line"># Not enough parameters</span>
    if {$port == &#34;&#34; &amp;&amp; $vlan == &#34;&#34;} {
	<a name="::result_debug(131)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;_exVerifyShowNetloginPorts{} Not enough parameters&#34;
	return 0
    }

   global tmpPath
   set tmp &#34;Tmp&#34;
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile &#34;$tmp/tmp_Dot1X$pid&#34;

    ;<span class="comment-line"># Execute show netlogin po and put output into a file</span>
    set fd_in [open $tempFile &#34;w&#34;]
   if {$showMode == &#34;port&#34;} {
       <a name="::SendACmd(73)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin port $port&#34; NULL $fd_in
   } elseif {$showMode == &#34;vlan&#34;} {
       <a name="::SendACmd(74)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin vlan $vlan&#34; NULL $fd_in
   } else {
       <a name="::SendACmd(75)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin port $port vlan $vlan&#34; NULL $fd_in
   }
   close $fd_in

   ;<span class="comment-line"># Open for reading</span>
   set fd_in [open $tempFile &#34;r&#34;]
    
   set portMatchLine  &#34;&#34;
   set vlanMatchLine  &#34;&#34;
   set authMatchLine  &#34;&#34;
   set portStateMatchLine &#34;&#34;
   set macMatchLine       &#34;&#34;
   ;<span class="comment-line"># Find correct port/vlan and MAC lines </span>
    while {[gets $fd_in line] != -1} {

	;<span class="comment-line"># Look for Port/Vlan Match.</span>
	if {[regexp -nocase -indices -- Port\ *:\ *$port.* $line matchedRange] == 1} {

	    set portMatchLine $line

	    ;<span class="comment-line"># Get next line for Vlan</span>
            while {[gets $fd_in line] != -1} {
		set vlanMatchLine $line
		if {[regexp -nocase -indices -- Vlan\ *:\ *$vlan.* $line matchedRange] != 1} {
		    ;<span class="comment-line"># No port/vlan match...get next line</span>
		    set vlanMatchLine &#34;&#34;
		    continue
		}
               break;
	    }

	    <a name="::result_debug(132)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND Port:$port Vlan:$vlan\n$portMatchLine\n$vlanMatchLine&#34;
	    
	    ;<span class="comment-line"># Get Auth ... We assume it's on next line vlan</span>
	    if {[gets $fd_in line] != -1} {
		set authMatchLine $line
	    }

	    ;<span class="comment-line"># Get Port State... We assume it's on next line following Auth</span>
	    if {[gets $fd_in line] != -1} {
		set portStateMatchLine $line
	    }    
	    
	    if {[string length $supMac] == 0} {
		;<span class="comment-line"># Only looking for port/vlan/auth/portState</span>
		break
	    }

	    ;<span class="comment-line"># Now look for MAC Match</span>
	    while {[gets $fd_in line] != -1} {
		
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    <a name="::result_debug(133)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND MAC:$supMac on line:$line&#34;
		    set macMatchLine $line
		    break
		}
	    }
	    if {$macMatchLine == &#34;&#34;} { <a name="::result_debug(134)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MAC:$supMac NOT FOUND&#34;}
	    break;
	}
    }

    close $fd_in
    file delete $tempFile
    
    if {$portMatchLine == &#34;&#34;} {
	<a name="::result_debug(135)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port:$port NOT FOUND&#34;
	return 0
    }

    set portVlanMatch 1

    ;<span class="comment-line"># Apply required key info matches</span>
    if {$portState != &#34;&#34;} {
	set portMatch [regexp -nocase &#34;Port State\ *:\ *$portState&#34; $portStateMatchLine]
	<a name="::result_debug(136)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Looking at portState $portState portVlanMatch: $portVlanMatch&#34;
	<a name="::result_debug(137)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$portVlanMatch  $portMatch&#34;
	set portVlanMatch [expr $portVlanMatch &amp; $portMatch]
	<a name="::result_debug(138)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;After &amp; operator $portVlanMatch&#34;
    }
    

    if {$auth != &#34;&#34;} {
	set authMatch [regexp -nocase &#34;Authentication\ *:\ *$auth&#34; $authMatchLine]
	<a name="::result_debug(139)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Looking at AuthMode:$auth authMatch: $authMatch&#34;
	<a name="::result_debug(140)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$portVlanMatch  $authMatch&#34;
	set portVlanMatch [expr $portVlanMatch &amp; $authMatch]
	<a name="::result_debug(141)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;After &amp; operator $portVlanMatch&#34;
    }
           
    ;<span class="comment-line"># We don't care about supplicant MAC entry</span>
    if {[string length $supMac] == 0} {
	<a name="::result_debug(142)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SupMac $supMac was not given.  Returning portVlanMatch: $portVlanMatch&#34;
	return $portVlanMatch
    }
    

    set macMatch 0
    if { [string length $macMatchLine] &gt; 0 } {

	   set macMatch [<a name="::_exMacMatch(2)"><a href="./NetloginLib.tcl.html#::_exMacMatch_3086">::_exMacMatch</a></a> $macMatchLine $supMac $supIp $authVal \
                $authServer $authType $reauthTimer $user]
    }

    <a name="::result_debug(143)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;RETURNING port: $portVlanMatch  mac: $macMatch&#34;
    return [expr $portVlanMatch &amp; $macMatch]
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyShowNetloginPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Proc that checks &#34;show netlogin ports &lt;x&gt; &lt;vlan&gt;&#34; </span>
<span class="comment-line">#              parameters for 1 or more supplicants.  We, of course,</span>
<span class="comment-line">#              assume all supplicants have the same values when </span>
<span class="comment-line">#              checking multiple supplicants.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#       auth:    mac-based | dot1x | web-based</span>
<span class="comment-line">#	portState: &#34;Disabled&#34; | &#34;Enabled&#34;</span>
<span class="comment-line">#	supMac: supplicant MAC</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#       numSupplicants: Number of supplicants to check.</span>
<span class="comment-line">#       showMode: port | vlan | port_vlan</span>
<span class="comment-line">#              show netlogin port &lt;portNum&gt;</span>
<span class="comment-line">#              show netlogin vlan &lt;vlanName&gt;</span>
<span class="comment-line">#              show netlogin port &lt;portNum&gt; vlan &lt;vlanName&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin ports </span>
<span class="comment-line">#</span>
<span class="comment-line"># * BD-10808.321 # show netlogin ports 2:11</span>
<span class="comment-line"># Port           : 21        </span>
<span class="comment-line"># Vlan           : vlan_1</span>
<span class="comment-line"># Authentication : mac-based</span>
<span class="comment-line"># Port State     : Enabled</span>
<span class="comment-line">#</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># ------------------------------------------------------------------</span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         No     802.1x    2            Unknown         </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyShowNetloginPorts_3626">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyShowNetloginPorts">::::nl_exVerifyShowNetloginPorts</a></a></strong> {args} {
    <a name="::parse_args(13)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_exVerifyShowNetloginPorts $args {
	<a name="::port(16)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(13)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	auth        &#34;&#34;
	portState   &#34;&#34;
	supMac      &#34;&#34;
	supIp       &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	authServer  &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	numSupplicants &#34;1&#34;
	showMode    &#34;port_vlan&#34;
    }

    set rc 1
    set curIp $supIp
    set curMac $supMac

    <a name="::report_start_test(4)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify show netlogin ports for $numSupplicants supplicant(s) $portState&#34;

    while { $numSupplicants } {
	<a name="::result_debug(144)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Verify show netlogin ports supMac:$curMac supIp:$curIp&#34;
	
	if {$authType == &#34;mac&#34; } {
	    ;<span class="comment-line"># username is same as MAC without the &#34;:&#34;</span>
	    set user [<a name="::nl_stripMac(3)"><a href="./NetloginLib.tcl.html#::nl_stripMac_4549">::nl_stripMac</a></a> $curMac &#34;&#34;] 
	    <a name="::result_debug(145)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Setting user to $user&#34;
	}

	if {! [<a name="::_exVerifyShowNetloginPorts(1)"><a href="./NetloginLib.tcl.html#::_exVerifyShowNetloginPorts_3434">::_exVerifyShowNetloginPorts</a></a> -port $port \
		-vlan $vlan -portState $portState -auth $auth -supMac $curMac \
		-supIp $curIp -authVal $authVal -authType $authType \
                -authServer $authServer -reauthTimer $reauthTimer -user $user \
                -showMode $showMode]} {
	    <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Verification of show netlogin ports parameters failed.&#34;
	    set rc 0
	}
	;<span class="comment-line"># Increment IP and MAC</span>
	if {$curIp != &#34;&#34;} {
	    set curIp [<a name="::IncrIpAddr(6)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	}
	if {$curMac != &#34;&#34;} {
	    set curMac [<a name="::IncMacByOne(6)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]
	}

	incr numSupplicants -1
    }

    <a name="::report_end_test(6)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

    return $rc
}

    


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_exVerifyShowSession</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Proc that checks &#34;show session&#34;</span>
<span class="comment-line">#              This actually just wraps CheckKeyValue so parameters</span>
<span class="comment-line">#              are checked based on min regexp.  For example, loginTime</span>
<span class="comment-line">#              can be entered as &#34;Dec&#34; or &#34;Thu Dec 16&#34; to yield a</span>
<span class="comment-line">#              good match.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#	id:        Login id. 0-n</span>
<span class="comment-line">#	loginTime: Date/Time of login</span>
<span class="comment-line">#	user:      Username of login</span>
<span class="comment-line">#	type:      &#34;console&#34; | &#34;netlogin&#34; | &#34;radius&#34;</span>
<span class="comment-line">#	auth:      &#34;local&#34; | &#34;radius&#34;</span>
<span class="comment-line">#	cliAuth:   &#34;enabled&#34; | &#34;disabled&#34;</span>
<span class="comment-line">#	location:  &#34;serial&#34; | &lt;ip&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show session</span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:12 # show session</span>
<span class="comment-line">#    # Login Time                 User     Type     Auth     CLI Auth Location</span>
<span class="comment-line"># ==============================================================================</span>
<span class="comment-line">#      0 Wed Dec 15 12:23:20 1999 admin    console  local    disabled serial</span>
<span class="comment-line">#      4 Thu Dec 16 16:20:27 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      5 Thu Dec 16 16:20:28 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      6 Thu Dec 16 16:20:29 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      7 Thu Dec 16 16:20:30 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      8 Thu Dec 16 16:20:32 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line"># * 1028 Thu Dec 16 16:20:56 1999 admin    telnet   radius   disabled 10.212.9.4</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exVerifyShowSession_3719">proc <a href="NetloginLib.tcl-annot.html#::::nl_exVerifyShowSession">::::nl_exVerifyShowSession</a></a></strong> {args} {
    <a name="::parse_args(14)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_exVerifyShowSession $args {
	id        &#34;&#34;
	loginTime &#34;&#34;
	user      &#34;&#34;
	type      &#34;&#34;
	auth      &#34;&#34;
	cliAuth   &#34;&#34;
	location  &#34;&#34;
    }
    <a name="::report_start_test(5)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify show session&#34;

    lappend parameterList &#34;$id.*$loginTime.*$user.*$type.*$auth.*cliAuth.*$location&#34;
    set rc [<a name="::CheckKeyValue(11)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show session&#34; $parameterList \
	    -comment &#34;Verify Show Session Params&#34;]

    <a name="::report_end_test(7)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    if {$rc == &#34;ok&#34;} {
	return 1
    } else {
	return 0
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _reportVerifyProtocolResult</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that merely prints error or ok on</span>
<span class="comment-line">#              whether desired traffic was received.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      traffic:    &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#      matchCnt:   Number of frames found that match</span>
<span class="comment-line">#      portId:     Logging purposes only</span>
<span class="comment-line">#      typeWanted: Logging purposes only</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_reportVerifyProtocolResult_3760">proc <a href="NetloginLib.tcl-annot.html#::::_reportVerifyProtocolResult">::::_reportVerifyProtocolResult</a></a></strong> { traffic matchCnt portId typeWanted } {
    
    if {$traffic == &#34;exist&#34;} {
	if {$matchCnt &lt;= 0} {
	    <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;PortId:$portId: Wanted $typeWanted but received $matchCnt&#34;
	    return ERROR
	}
    } elseif {$traffic == &#34;notExist&#34;} {
	if {$matchCnt &gt; 0} {
	    <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;PortId:$portId: DID NOT want $typeWanted but received $matchCnt&#34;
	    return ERROR
	}
    } else {
	<a name="::result_debug(146)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;PortId:$portId: Unknown state traffic $traffic specified&#34;
	return ERROR
    }

    <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;SUCCESS: PortId:$portId: Wanted $traffic. $matchCnt \
	    $typeWanted received as expected&#34;
    return OK

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyEDP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of EDP Traffic.  We enable EDP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             edpTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Decode EDP Packet</span>
<span class="comment-line"># EDP Packet is SNAP Encapsulated Frame.  EDP Header should start after</span>
<span class="comment-line"># SNAP header at location 0x0016 bytes from start of frame.</span>
<span class="comment-line"># EDP Header is followed by 1+ TLV blocks</span>
<span class="comment-line">#</span>
<span class="comment-line"># EDP Header (14 octets)</span>
<span class="comment-line"># ----------</span>
<span class="comment-line">#  1 Version</span>
<span class="comment-line">#  1 reserved</span>
<span class="comment-line">#  2 checksum</span>
<span class="comment-line">#  2 sequence#</span>
<span class="comment-line">#  8 device id (00 00 [mac address])</span>
<span class="comment-line">#</span>
<span class="comment-line"># TLV (Type - Length - Value) </span>
<span class="comment-line"># ---</span>
<span class="comment-line">#  1 Marker (0x99)</span>
<span class="comment-line">#  1 Type </span>
<span class="comment-line">#      0 NULL - End Signal</span>
<span class="comment-line">#      1 Display - (MIBII Display String)</span>
<span class="comment-line">#      2 Info - (Basic system info)</span>
<span class="comment-line">#      5 VLAN Info </span>
<span class="comment-line">#      8 ESRP</span>
<span class="comment-line">#  2 Length</span>
<span class="comment-line">#  n DATA</span>
<span class="comment-line">#</span>
<span class="comment-line"># INFO TLV</span>
<span class="comment-line"># --------</span>
<span class="comment-line">#   2  originating slot</span>
<span class="comment-line">#   2  originating port</span>
<span class="comment-line">#   2  Virtual Chassis ID (If connected to virtual chassis)</span>
<span class="comment-line">#   6  RESERVED</span>
<span class="comment-line">#   4  SW Version</span>
<span class="comment-line">#   16 Virtual Chassis ID Connections</span>
<span class="comment-line">#</span>
<span class="comment-line"># VLAN TLV</span>
<span class="comment-line"># --------</span>
<span class="comment-line">#   1  Flags (bit 8 - 1 means this vlan has IP interface) </span>
<span class="comment-line">#   3  RESERVED</span>
<span class="comment-line">#   2  VLAN ID (0 if untagged)</span>
<span class="comment-line">#   2  RESERVED</span>
<span class="comment-line">#   4  VLAN IP Addr</span>
<span class="comment-line">#   n  VLAN Name</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyEDP_3841">proc <a href="NetloginLib.tcl-annot.html#::::_verifyEDP">::::_verifyEDP</a></a></strong> {portIdList {edpTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(2)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    sleep 2
    
    ;<span class="comment-line"># Enable protocol</span>
    foreach portId $portIdList {
	<a name="::SendACmd(76)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command edp ports [<a name="::MapDUTPortId(1)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $portId]&#34;
    }


    ;<span class="comment-line"># Wait 65 seconds for an EDP Packet (Should arrive every minute)</span>
    <a name="::result_debug(147)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping 125 seconds&#34;
    <span class="comment-line">#exSleep 65</span>
    <a name="::exSleep(9)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 125

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(3)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList

    foreach portId $portIdList {
	<a name="::report_start_test(6)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId EDP $command EDP Traffic $edpTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(2)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    ;<span class="comment-line"># Look for Device ID MAC followed by TLV Marker.	</span>
	    if {[<a name="::GetMessageType(1)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame] == &#34;EDP&#34;} {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(1)"><a href="./NetloginLib.tcl.html#::_reportVerifyProtocolResult_3760">::_reportVerifyProtocolResult</a></a> $edpTraffic $matchCnt $portId &#34;EDP Packets&#34;
	<a name="::report_end_test(8)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifySTP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of STP Traffic.  We enable STP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             vlanList: List of vlans to enable STP on.</span>
<span class="comment-line">#             stpTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from nl_VerifyProtocol</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifySTP_3899">proc <a href="NetloginLib.tcl-annot.html#::::_verifySTP">::::_verifySTP</a></a></strong> {portIdList vlanList {stpTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {
    
    
    set portIndex 0

    foreach myVlan $vlanList {
	
	;<span class="comment-line"># Add vlan to default vlan domain s0</span>
	<a name="::SendACmd(77)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config stpd s0 add vlan $myVlan port all&#34;
    
	;<span class="comment-line"># Start port capture</span>
	<a name="::StartPortsCapture(3)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList
	
	;<span class="comment-line"># Enable/Disable STP</span>
	<a name="::SendACmd(78)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command stpd s0&#34;
	
	;<span class="comment-line"># Wait for some BPDUs to get sent</span>
	<a name="::result_debug(148)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 5 seconds for some BPDUs to get sent&#34;
	<a name="::exSleep(10)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
	
	;<span class="comment-line"># Stop Capture</span>
	<a name="::StopPortsCapture(4)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
	
	;<span class="comment-line"># Parse Buffer</span>
	set portId [lindex $portIdList $portIndex]
	if {$portId == &#34;&#34;} {
	    set portId 1
	}
	<span class="comment-line">#	foreach portId $portIdList {</span>
	    <a name="::report_start_test(7)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId STP $command BPDUs $stpTraffic&#34;
	    ;<span class="comment-line"># Parse output for packets</span>
	    set frameList [<a name="::GetCapturedFrames(3)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	    set matchCnt 0
	    foreach frame $frameList {
		if { [regexp -nocase &#34;BPDU&#34; [<a name="::GetMessageType(2)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		    incr matchCnt
		}
	    }
	    
	    <a name="::_reportVerifyProtocolResult(2)"><a href="./NetloginLib.tcl.html#::_reportVerifyProtocolResult_3760">::_reportVerifyProtocolResult</a></a> $stpTraffic $matchCnt $portId &#34;STP BPDUs&#34;
	    <a name="::report_end_test(9)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	    <span class="comment-line">#	}</span>
	    incr portIndex

	;<span class="comment-line"># Clean up</span>
	<a name="::SendACmd(79)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config stpd s0 delete vlan $myVlan port all&#34;
	<a name="::SendACmd(80)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig stpd&#34;
    }
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyRIP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of RIP Traffic.  We enable RIP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             ripTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from nl_VerifyProtocol</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyRIP_3968">proc <a href="NetloginLib.tcl-annot.html#::::_verifyRIP">::::_verifyRIP</a></a></strong> {portIdList {ripTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {


    <a name="::SendACmd(81)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable ipforwarding&#34;      
    <a name="::SendACmd(82)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config rip add vlan all&#34;
    <a name="::SendACmd(83)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config rip updatetime 10&#34;

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(4)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable RIP</span>
    <a name="::SendACmd(84)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command rip&#34;      

    ;<span class="comment-line"># Wait for some RIP packets to get sent</span>
    <a name="::result_debug(149)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 13 seconds for some RIP packets to get sent&#34;
    <a name="::exSleep(11)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 13

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(5)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(8)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId RIP $command RIP Packets $ripTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(4)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;RIP&#34; [<a name="::GetMessageType(3)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(3)"><a href="./NetloginLib.tcl.html#::_reportVerifyProtocolResult_3760">::_reportVerifyProtocolResult</a></a> $ripTraffic $matchCnt $portId &#34;RIP Packets&#34;
	<a name="::report_end_test(10)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
    
    ;<span class="comment-line"># Clean up</span>
    <a name="::SendACmd(85)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config rip delete vlan all&#34;
    <a name="::SendACmd(86)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable rip&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyOSPF</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of OSPF Traffic.  We enable OSPF</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             ospfTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from nl_VerifyProtocol</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyOSPF_4027">proc <a href="NetloginLib.tcl-annot.html#::::_verifyOSPF">::::_verifyOSPF</a></a></strong> {portIdList {ospfTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {

    <a name="::SendACmd(87)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;create ospf area 0.0.0.5&#34;
    <a name="::SendACmd(88)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable ipforwarding&#34;      
    
<span class="comment-line">#    SendACmd &#34;config ospf add vlan all area 0.0.0.5&#34;</span>

    set rtValue [<a name="::CheckCmdLegal(1)"><a href="./checkCmdLegality.tcl.html#::CheckCmdLegal_58">::CheckCmdLegal</a></a> &#34;config ospf add vlan all area 0.0.0.5&#34; NULL &#34;CheckCmdLegal&#34; 0]

    if { $rtValue == &#34;legal&#34;} {
    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(5)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable OSPF</span>
    <a name="::SendACmd(89)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command ospf&#34;      

    ;<span class="comment-line"># Wait for some OSPF packets to get sent</span>
    <a name="::result_debug(150)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 5 seconds for some OSPF packets to get sent&#34;
    <a name="::exSleep(12)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(6)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(9)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId OSPF $command OSPF Packets $ospfTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(5)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;OSPF&#34; [<a name="::GetMessageType(4)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(4)"><a href="./NetloginLib.tcl.html#::_reportVerifyProtocolResult_3760">::_reportVerifyProtocolResult</a></a> $ospfTraffic $matchCnt $portId &#34;OSPF Packets&#34;
	<a name="::report_end_test(11)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
} else {
    <a name="::result_debug(151)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;This platform does not support OSPF&#34;
}
    
    ;<span class="comment-line"># Clean up</span>
    <a name="::SendACmd(90)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig ospf&#34;
    <a name="::SendACmd(91)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable ospf&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyIGMP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of IGMP Traffic.  We enable IGMP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             igmpTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from nl_VerifyProtocol</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyIGMP_4090">proc <a href="NetloginLib.tcl-annot.html#::::_verifyIGMP">::::_verifyIGMP</a></a></strong> {portIdList {igmpTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(6)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable IGMP</span>
    <a name="::SendACmd(92)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable igmp&#34;
    <a name="::SendACmd(93)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config igmp 1 1 1&#34;  ;<span class="comment-line"># Shorten interval so we don't wait long for</span>
    <a name="::SendACmd(94)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command igmp&#34;      ;<span class="comment-line"># a packet to arrive</span>

    ;<span class="comment-line"># Wait for some IGMP Packets to get sent</span>
    <a name="::result_debug(152)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 30 seconds for some IGMP packets to get sent&#34;
    <a name="::exSleep(13)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 30

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(7)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(10)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId IGMP $command IGMP Packets $igmpTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(6)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;IGMP&#34; [<a name="::GetMessageType(5)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(5)"><a href="./NetloginLib.tcl.html#::_reportVerifyProtocolResult_3760">::_reportVerifyProtocolResult</a></a> $igmpTraffic $matchCnt $portId &#34;IGMP Packets&#34;
	<a name="::report_end_test(12)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }


    ;<span class="comment-line"># Clean up IGMP is enabled by default</span>
    <a name="::SendACmd(95)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig igmp&#34;
    <a name="::SendACmd(96)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable igmp&#34;
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_VerifyProtocol</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a particular protocol is blocked or unblocked</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#    portIdList:   Port IDs to check traffic on</span>
<span class="comment-line">#    command:      &#34;enable&#34; | &#34;disable&#34;</span>
<span class="comment-line">#    protocol:     &#34;edp&#34; | &#34;rip&#34; | &#34;ospf&#34; | &#34;stp&#34; | &#34;igmp&#34;</span>
<span class="comment-line">#    traffic:      &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#    optionalList: Currently used by &#34;stp&#34; for list of vlans</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    Login $DUT1_CONNECT</span>
<span class="comment-line">#    nl_VerifyProtocol [list 1 2] &#34;enable&#34; &#34;edp&#34; &#34;exist&#34;</span>
<span class="comment-line">#    nl_VerifyProtocol [list 1 2] &#34;disable&#34; &#34;edp&#34; &#34;notExist&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_VerifyProtocol_4150">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifyProtocol">::::nl_VerifyProtocol</a></a></strong> { portIdList command protocol traffic {optionalList [list]} } {
    
    switch -- $protocol \
      &#34;edp&#34; {
        <a name="::_verifyEDP(1)"><a href="./NetloginLib.tcl.html#::_verifyEDP_3841">::_verifyEDP</a></a> $portIdList $traffic $command
    } &#34;rip&#34; { 
	<a name="::_verifyRIP(1)"><a href="./NetloginLib.tcl.html#::_verifyRIP_3968">::_verifyRIP</a></a> $portIdList $traffic $command
    } &#34;ospf&#34; {
        <a name="::_verifyOSPF(1)"><a href="./NetloginLib.tcl.html#::_verifyOSPF_4027">::_verifyOSPF</a></a> $portIdList $traffic $command
    } &#34;stp&#34; {
	<a name="::_verifySTP(1)"><a href="./NetloginLib.tcl.html#::_verifySTP_3899">::_verifySTP</a></a> $portIdList $optionalList $traffic $command
    } &#34;igmp&#34; {
	<a name="::_verifyIGMP(1)"><a href="./NetloginLib.tcl.html#::_verifyIGMP_4090">::_verifyIGMP</a></a> $portIdList $traffic $command
    } default {
	<a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Unsupported protocol $protocol&#34;
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_ixCheckDHCPBroadcastBlocked</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that DHCP broadcasts don't go out protected port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#    protectedPortId: Port which should NOT receive broadcasts</span>
<span class="comment-line">#    dhcpPortId:      Informational only. Used for message. </span>
<span class="comment-line">#    srcMac:          Source MAC of DHCP request.  Usually supplicant.     </span>
<span class="comment-line">#    dhcpServer:      DHCP Server to send request to. Usually DUT </span>
<span class="comment-line">#    reqIP:           IP Address being requested.  This really doesn't matter.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#   nl_CheckDHCPBroadcastBlocked $protectedPortId $dhcpPortId \</span>
<span class="comment-line">#	  $supMacCampus &#34;10.1.1.1&#34; &#34;10.1.1.3&#34; </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_ixCheckDHCPBroadcastBlocked_4188">proc <a href="NetloginLib.tcl-annot.html#::::nl_ixCheckDHCPBroadcastBlocked">::::nl_ixCheckDHCPBroadcastBlocked</a></a></strong> { protectedPortId dhcpPortId \
	srcMac dhcpServer reqIP} {

    set broadcastMac &#34;FF FF FF FF FF FF&#34;

    <a name="::StartPortsCapture(7)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> [list $protectedPortId]
    set rawframe [<a name="::SendDHCPRequest(1)"><a href="./dhcp.tcl.html#::SendDHCPRequest_219">::SendDHCPRequest</a></a> $srcMac 2 $dhcpServer $reqIP 0]

    <a name="::StopPortsCapture(8)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> [list $protectedPortId]
    
    <a name="::report_start_test(11)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Check DHCP Broadcast from port:[<a name="::MapDUTPortId(2)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $dhcpPortId] does \
	    not reach protected port:[<a name="::MapDUTPortId(3)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId]&#34;

    set rawPortDataList [<a name="::GetCapturedFrames(7)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> 1]
    set fCnt 0
    foreach frame $rawPortDataList {
	;<span class="comment-line"># Check if we received any broadcast traffic.</span>
	set targetMac [<a name="::GetTargetMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetTargetMacAddress_159">::GetTargetMacAddress</a></a> $frame]
	if {$targetMac == $broadcastMac} {
	    incr fCnt
	    <a name="::result_debug(153)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Protected port [<a name="::MapDUTPortId(4)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId] received illegal broadcast $frame&#34;
	}
    }

    if {$fCnt == 0} {
	<a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;DHCP Broadcasts blocked on protected port [<a name="::MapDUTPortId(5)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId]&#34;
    } else {
	<a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Protected port [<a name="::MapDUTPortId(6)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId] received $fCnt broadcast packets&#34;
    }
    <a name="::report_end_test(13)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_CheckARPBroadcastBlocked</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Ping from DUT out unprotected port.  Verify that ARP </span>
<span class="comment-line">#              Broadcast is sent out unprotected port and NOT protected </span>
<span class="comment-line">#              port.   </span>
<span class="comment-line">#              We assume protected and unprotected ports ARE </span>
<span class="comment-line">#              ON THE SAME VLAN!  </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     protectedPortId    Port ID of netlogin port.</span>
<span class="comment-line">#     unprotectedPortId: Port ID of non-netlogin port.</span>
<span class="comment-line">#     destIp:            IP Address in ARP.  We use this to clear</span>
<span class="comment-line">#                        the entry to make sure we get a new ARP.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#     Login $DUT1_CONNECT</span>
<span class="comment-line">#     nl_CheckARPBroadcast $protectedPortId $pingPortId &#34;10.1.1.100&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_CheckARPBroadcastBlocked_4241">proc <a href="NetloginLib.tcl-annot.html#::::nl_CheckARPBroadcastBlocked">::::nl_CheckARPBroadcastBlocked</a></a></strong> { protectedPortId unprotectedPortId destIp } {
    
    set portIdList [list $protectedPortId $unprotectedPortId]
    
    ;<span class="comment-line"># Delete destIp entry from ARP table to make sure we generate ARP.</span>
    <a name="::SendACmd(97)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear iparp $destIp&#34;

    <a name="::report_start_test(12)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Sending ping from DUT to $destIp to generate ARP&#34;

    <a name="::StartPortsCapture(8)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    <a name="::SendACmd(98)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ping $destIp&#34;

    <a name="::StopPortsCapture(9)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    set rawPortDataProtected [<a name="::GetCapturedFrames(8)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $protectedPortId]
    set rawPortDataUnprotected [<a name="::GetCapturedFrames(9)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $unprotectedPortId]
    
    <a name="::result_debug(154)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;******************** PROTECTED PORT DATA ************************&#34;
    set protectedStatus   0
    set unprotectedStatus 0
    foreach frame $rawPortDataProtected {
	
	set msgType [<a name="::GetMessageType(6)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	<a name="::result_debug(155)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($msgType) Raw: $frame&#34;
	if [regexp &#34;ARP_REQUEST&#34; $msgType ] {
	    set protectedStatus 1
	}

    }

    <a name="::result_debug(156)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;******************** UNPROTECTED PORT DATA ************************&#34;
    foreach frame $rawPortDataUnprotected {
	
	set msgType [<a name="::GetMessageType(7)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	<a name="::result_debug(157)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($msgType) Raw: $frame&#34;
	if [regexp &#34;ARP_REQUEST&#34; $msgType] {
	    set unprotectedStatus 1  
	}

    }
    if {$protectedStatus} {
	<a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Broadcast ARP_REQUEST seen on Protected&#34;
    } else {
	<a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;No ARP_REQUEST seen on Protected($protectedStatus)&#34;
    }

    if {$unprotectedStatus} {
	<a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Broadcast ARP_REQUEST seen on Unprotected Port&#34;
    } else {
	<a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No ARP_REQUEST seen on Unprotected Port($unprotectedStatus)&#34;
    }

    <a name="::report_end_test(14)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_VerifyDHCPBootPRelay</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify we can reach external DHCP server.  We send DHCP </span>
<span class="comment-line">#              request from supplicant on txPortId with MAC srcMac</span>
<span class="comment-line">#              to external DHCP server after authenticating.</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: We only check that packet is forwarded by looking at </span>
<span class="comment-line">#       BootPRelay Stats.  We don't actually check for response.</span>
<span class="comment-line">#       That's left for a future exercise.  This actually only</span>
<span class="comment-line">#       an interim check.  Ideally, Ixia IxAuth should support</span>
<span class="comment-line">#       DHCP, to really validate.  Until then, this is good enough</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     txPortId: Port to transmit out of</span>
<span class="comment-line">#     srcMac:   Source address of supplicant MAC.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    Login $DUT1_CONNECT</span>
<span class="comment-line">#    .....802.1x Authenticated $cookedSupMac.....     </span>
<span class="comment-line">#    nl_VerifyDHCPBootPRelay 1 $cookedSupMac</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_VerifyDHCPBootPRelay_4323">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifyDHCPBootPRelay">::::nl_VerifyDHCPBootPRelay</a></a></strong> { txPortId srcMac } {

    <a name="::SendACmd(99)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear counters&#34;

    set frame [<a name="::SendDhcpFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendDhcpFrame_1045">::SendDhcpFrame</a></a> -txPortId $txPortId -destMac &#34;FF FF FF FF FF FF&#34; \
	    -sourceMac $srcMac -sourceIp &#34;0.0.0.0&#34; \
	    -destIp &#34;255.255.255.255&#34; -opCode &#34;dhcpBootRequest&#34; \
	    -optionCodeList [list dhcpMessageType dhcpDiscover] \
	    -clientHwAddr $srcMac];     	
    
    <a name="::result_debug(158)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;(802.1x) DHCP Discover frame: $frame&#34;
    
    ;<span class="comment-line"># Verify bootprelay stats increasing with show ipstats</span>
    ;<span class="comment-line"># DHCP/BOOTP relay statistics:</span>
    ;<span class="comment-line">#        Received to server: 0   Received to client: 0</span>
    ;<span class="comment-line">#        Requests relayed: 0     Responses relayed: 0</span>
    ;<span class="comment-line">#        DHCP Discover:  0       DHCP Offer:     0</span>
    ;<span class="comment-line">#        DHCP Request:   0       DHCP Decline:   0</span>
    ;<span class="comment-line">#        DHCP Ack:       0       DHCP NAck:      0</span>
    ;<span class="comment-line">#        DHCP Release:   0       DHCP Inform:    0</span>

    set parameterList [list]
    lappend parameterList &#34;{Received to server: 1} exist&#34;;
    lappend parameterList &#34;{Requests relayed: 1} exist&#34;;  
    <a name="::CheckKeyValue(12)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show bootprelay&#34; $parameterList -comment &#34;DHCP relay stats&#34;;
    unset parameterList;
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_VerifySupplicantPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#     rawPortData: Raw frames data</span>
<span class="comment-line">#     srcMac:      Source MAC that we're looking for</span>
<span class="comment-line">#     dstMac       Dest MAC that we're looking for</span>
<span class="comment-line">#     packetExpr:  Type of packet to look for. This should match msgTypes returned</span>
<span class="comment-line">#                  from MessageDecoding.tcl.  If MessageDecoding.tcl does not support</span>
<span class="comment-line">#                  a particular packet type, this procedure will not work.</span>
<span class="comment-line">#                  Use alternation &#34;|&#34; symbol (i.e. &#34;stringA|stringB&#34;) to match multiple strings</span>
<span class="comment-line">#     rx:          &#34;yes&#34; | &#34;no&#34;   yes-we should receive, no-we should NOT receive any</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    nl_VerifySupplicantPackets $rawPortData $cookedDutMac $cookedSupMac &#34;EAP.*REQ&#34;</span>
<span class="comment-line">#    nl_VerifySupplicantPackets $rawPortData $cookedDutMac $cookedSupMac &#34;EAP.*FAIL&#34;</span>
<span class="comment-line">#    nl_VerifySupplicantPackets $rawPortData $srcMac $dstMac &#34;EAP.*REQUEST_IDENTITY|EAP.*SUCC&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_VerifySupplicantPackets_4375">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifySupplicantPackets">::::nl_VerifySupplicantPackets</a></a></strong> { rawPortData srcMac dstMac packetExpr {rx &#34;yes&#34;} } {

    <a name="::report_start_test(13)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify we receive correct packets&#34;

    set statusCnt 0

    foreach frame $rawPortData {
	set msgType [<a name="::GetMessageType(8)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	set frameDstMac [<a name="::GetDestMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetDestMacAddress_19">::GetDestMacAddress</a></a> $frame]
	set frameSrcMac [<a name="::GetSourceMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetSourceMacAddress_40">::GetSourceMacAddress</a></a> $frame]

	<a name="::result_debug(159)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FRAME TYPE: $msgType src:$frameSrcMac dst:$frameDstMac&#34;
	<a name="::result_debug(160)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;LOOKING FOR src:$srcMac dst:$dstMac&#34;
	
	;<span class="comment-line"># Verify supplicant received Success/Fail Frame.</span>
	if {[regexp -nocase &#34;$packetExpr&#34; $msgType]} {
	    <a name="::result_debug(161)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;---&gt; Got $packetExpr Packet &lt;---&#34;
	    if { ($srcMac == $frameSrcMac) &amp;&amp; ($dstMac == $frameDstMac) } {
		incr statusCnt 
	    }
	}
    }
    
    if { ($statusCnt == 0) &amp;&amp; ($rx == &#34;no&#34;) } {
	<a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Supplicant received $statusCnt messages as expected ($packetExpr)&#34;
    } elseif { ($statusCnt == 0) &amp;&amp; ($rx == &#34;yes&#34;) } {
	<a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Supplicant received NO messages, but expected to. ($packetExpr)&#34;
    } elseif { ($statusCnt &gt; 0) &amp;&amp; ($rx == &#34;no&#34;) } {
	<a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Supplicant received $statusCnt messages, but expected NONE. ($packetExpr)&#34;
    } elseif { ($statusCnt &gt; 0) &amp;&amp; ($rx == &#34;yes&#34;) } {
	<a name="::result_ok(7)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Supplicant received $statusCnt message as expected ($packetExpr)&#34;
    }

    <a name="::report_end_test(15)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_VerifySupplicantEAPPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Looks at raw frame data from capture and verifies that </span>
<span class="comment-line">#              supplicant received the EAP REQUEST_IDENTITY and SUCCESS </span>
<span class="comment-line">#              packets.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     rawPortData: Raw port data from a packet capture </span>
<span class="comment-line">#     srcMac:      Src MAC to search for</span>
<span class="comment-line">#     dstMac:      Dst MAC to search for</span>
<span class="comment-line">#     status:      &#34;SUCCESS&#34; | &#34;FAIL&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#       nl_VerifySupplicantEAPPackets $rawPortData $cookedDutMac $cookedSupMac</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_VerifySupplicantEAPPackets_4431">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifySupplicantEAPPackets">::::nl_VerifySupplicantEAPPackets</a></a></strong> { rawPortData srcMac dstMac {status &#34;SUCCESS&#34;}} {


    <a name="::nl_VerifySupplicantPackets(1)"><a href="./NetloginLib.tcl.html#::nl_VerifySupplicantPackets_4375">::nl_VerifySupplicantPackets</a></a> $rawPortData $srcMac $dstMac \
	    &#34;EAP.*REQUEST_IDENTITY|EAP.*$status&#34;

    return


    <a name="::report_start_test(14)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify we receive correct EAP packets&#34;

    set eapRiCnt 0
    set eapStatusCnt 0

    foreach frame $rawPortData {
	set msgType [<a name="::GetMessageType(9)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	set frameDstMac [<a name="::GetDestMacAddress(2)"><a href="./MessageDecoding.tcl.html#::GetDestMacAddress_19">::GetDestMacAddress</a></a> $frame]
	set frameSrcMac [<a name="::GetSourceMacAddress(2)"><a href="./MessageDecoding.tcl.html#::GetSourceMacAddress_40">::GetSourceMacAddress</a></a> $frame]

	<a name="::result_debug(162)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FRAME TYPE: $msgType src:$frameSrcMac dst:$frameDstMac&#34;
	<a name="::result_debug(163)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;LOOKING FOR src:$srcMac dst:$dstMac&#34;
	
	;<span class="comment-line"># Verify supplicant received EAP-Request-Identity Frame</span>
	if {[regexp -nocase &#34;EAP.*REQUEST_IDENTITY&#34; $msgType]} {
	    if { ($srcMac == $frameSrcMac) &amp;&amp; ($dstMac == $frameDstMac) } {
		incr eapRiCnt 
	    }
	}

	;<span class="comment-line"># Verify supplicant received EAP Success/Fail Frame.</span>
	if {[regexp -nocase &#34;EAP.*$status&#34; $msgType]} {
	    if { ($srcMac == $frameSrcMac) &amp;&amp; ($dstMac == $frameDstMac) } {
		incr eapStatusCnt 
	    }
	}
    }
    
    if { ($eapRiCnt == 0) || ($eapStatusCnt == 0) } {
	if {$eapRiCnt == 0} {
	    <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No EAP Request Identity Packet received&#34;
	}
	if {$eapStatusCnt == 0} {
	    <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No EAP $status Packet received&#34;
	}
    } else {
	<a name="::result_ok(8)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Supplicant received correct EAP messages&#34;
    }

    <a name="::report_end_test(16)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_VerifyTaggedPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify whether we find any tagged frames in a raw</span>
<span class="comment-line">#              frame capture.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     rawFrameData:   Ixia packet capture frames</span>
<span class="comment-line">#     tag:            Tag number. No tag means we should NOT receive any</span>
<span class="comment-line">#     comment:        Normal comment to output to test</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    nl_VerifyTaggedPackets $rawData_1 &#34;&#34; &#34;Dot1x port [MapDUTPortId 1]&#34;    ;# No tag</span>
<span class="comment-line">#    nl_VerifyTaggedPackets $rawData_2 &#34;$tag&#34;  &#34;Tagged port [MapDUTPortId 2]&#34;  </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_VerifyTaggedPackets_4502">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifyTaggedPackets">::::nl_VerifyTaggedPackets</a></a></strong> { rawFrameData {tag &#34;&#34;} {comment &#34;&#34;}} {

    if {$tag == &#34;&#34;} {
	<a name="::report_start_test(15)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify packets are NOT tagged ($comment)&#34;

	;<span class="comment-line"># Stop as soon as we find a tagged packet</span>
	set curTag -1
	foreach frame $rawFrameData {
	    set curTag [<a name="::GetTagId(1)"><a href="./MessageDecoding.tcl.html#::GetTagId_482">::GetTagId</a></a> $frame]
	    if { $curTag &gt; -1 } {
		<a name="::result_error(16)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Expected no tagged packets. Got packet $frame with VLAN ID $curTag&#34;
		break;
	    }
	}
	if { $curTag == -1 } {
	    <a name="::result_ok(9)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;No tagged packets found&#34;
	}
	
    } else {
	<a name="::report_start_test(16)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify packets are tagged. VLAN ID $tag ($comment)&#34;

	;<span class="comment-line"># Check that NO PACKETS are tagged</span>
	foreach frame $rawFrameData {
	    set curTag [<a name="::GetTagId(2)"><a href="./MessageDecoding.tcl.html#::GetTagId_482">::GetTagId</a></a> $frame]
	    if {$curTag == $tag} {
		<a name="::result_ok(10)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Got a matching tagged packet with id $tag&#34;
		break;
	    }
	}
	if { $curTag != $tag } {
	    <a name="::result_error(17)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No tagged packets found.  Expected packets with VLAN ID $tag&#34;
	}
    }

    <a name="::report_end_test(17)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_stripMac</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Proc that strips MAC of &#34;:&#34; seperators</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  mac: MAC address with &#34;:&#34; to strip</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: cooked MAC with no : seperators</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_stripMac_4549">proc <a href="NetloginLib.tcl-annot.html#::::nl_stripMac">::::nl_stripMac</a></a></strong> { mac {newDelimiter &#34; &#34;}} {

    set cookedMac &#34;&#34;
    regsub -all &#34;:&#34; $mac $newDelimiter cookedMac

    return $cookedMac
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_delimitMac</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Proc that replaces MAC &#34; &#34; with &#34;:&#34; seperators</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  mac: MAC address</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: uncooked MAC with : seperators</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_delimitMac_4567">proc <a href="NetloginLib.tcl-annot.html#::::nl_delimitMac">::::nl_delimitMac</a></a></strong> { mac } {

    set uncookedMac &#34;&#34;
    regsub -all &#34; &#34; $mac &#34;:&#34; uncookedMac

    return $uncookedMac
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_getMacForIP </span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Retrieves MAC for a given IP from a list returned</span>
<span class="comment-line">#              by nl_ixCreatePortIfs.  Format is {port ip mac}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  ip, macList, cooked</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: MAC with : seperators, unless cooked != 0</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_getMacForIP_4586">proc <a href="NetloginLib.tcl-annot.html#::::nl_getMacForIP">::::nl_getMacForIP</a></a></strong> { <a name="::ip(21)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> macList {cooked 0}} {

    set mac &#34;&#34;

    <a name="::result_debug(164)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;nl_getMacForIP{} macList: $macList&#34;


    foreach entry $macList {
	;<span class="comment-line"># entry: &lt;port&gt; &lt;IP&gt; &lt;{MAC}&gt;</span>
	<a name="::result_debug(165)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;entry: $entry&#34;
	
	set ipAddr [lindex $entry 1]

	if {$ipAddr == $ip} {
	    set mac [lindex $entry 2]
	    break
	}
    }

    if {$cooked} {
	return $mac   ;<span class="comment-line"># Space delimited MAC</span>
    } else {
	return [<a name="::nl_delimitMac(1)"><a href="./NetloginLib.tcl.html#::nl_delimitMac_4567">::nl_delimitMac</a></a> $mac]    ;<span class="comment-line"># : delimited MAC</span>
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_SkipTestBasedOnPlatform </span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Skip a test because not supported for a platform</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  platformList as defined in..</span>
<span class="comment-line">#                 DUTs_info(DUT1,platform) &#34;Summit200-24&#34;</span>
<span class="comment-line">#              DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1 skip - 0 don't skip</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_SkipTestBasedOnPlatform_4625">proc <a href="NetloginLib.tcl-annot.html#::::nl_SkipTestBasedOnPlatform">::::nl_SkipTestBasedOnPlatform</a></a></strong> { platformList {DUTName &#34;DUT1&#34;}} {

    set platform [<a name="::GetPlatform(3)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> $DUTName]

    <a name="::result_debug(166)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;nl_SkipTestBasedOnPlatform $platform  list:$platformList&#34;
    foreach platformToSkip $platformList {
	<a name="::result_debug(167)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$platformToSkip&#34;
	if [regexp -nocase $platformToSkip $platform] {
	    <a name="::result_debug(168)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;nl_SkipTestBasedOnPlatform $platform  $platformToSkip returning 1&#34;
	    
	    return 1
	}
    }
    return 0
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_CheckTaskCrash</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Check logs for a task crash.  You must know the name</span>
<span class="comment-line">#              of the task.</span>
<span class="comment-line">#</span>
<span class="comment-line"># We look for a log entry similiar to ...</span>
<span class="comment-line"># 04/02/2004 21:45.58 &lt;CRIT:SYST&gt; Task tDot1xTask (a783d331) failed</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  taskName  vxWorks Task Name</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: ok    - no crash</span>
<span class="comment-line">#              error - found task failure</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_CheckTaskCrash_4657">proc <a href="NetloginLib.tcl-annot.html#::::nl_CheckTaskCrash">::::nl_CheckTaskCrash</a></a></strong> { taskName {DUTName &#34;DUT1&#34;} {exitOnFailure 1}} {
    
    global DUT1_CONNECT
    global DUT2_CONNECT
    global DUT3_CONNECT
    global DUT4_CONNECT
    global DUT5_CONNECT

    <a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set [set DUTName]_CONNECT]

    set paramList [list]

    lappend paramList &#34;{Task $taskName .* failed} notExist&#34;
    set returnVal [<a name="::CheckKeyValue(13)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show log&#34; $paramList]
    
    if {([regexp -nocase &#34;error&#34; $returnVal]) &amp;&amp; ($exitOnFailure)} {
	error &#34;ERROR: Task $taskName crashed...script terminating&#34;	
    } else {
	return $returnVal
    }
}


<strong><a name="::::nl_CheckDot1xTaskCrash_4680">proc <a href="NetloginLib.tcl-annot.html#::::nl_CheckDot1xTaskCrash">::::nl_CheckDot1xTaskCrash</a></a></strong> {} {
    
    <a name="::nl_CheckTaskCrash(1)"><a href="./NetloginLib.tcl.html#::nl_CheckTaskCrash_4657">::nl_CheckTaskCrash</a></a> &#34;tDot1xTask&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_CreateLocalUser</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Creates a Netlogin local user.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  login - Login Name</span>
<span class="comment-line">#              passward - Password</span>
<span class="comment-line">#              vlan     - vlan information for the user</span>
<span class="comment-line">#              tag - Whether the port will be tagged port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_CreateLocalUser_4698">proc <a href="NetloginLib.tcl-annot.html#::::nl_CreateLocalUser">::::nl_CreateLocalUser</a></a></strong> {login {passwd &#34;&#34;} {<a name="::vlan(14)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;&#34;} {tag &#34;&#34;}} {
    
   if {$vlan == &#34;&#34;} {
      send &#34;create netlogin local-user $login\r&#34;
   } else {
      send &#34;create netlogin local-user $login vlan-vsa $tag $vlan\r&#34;
   }
   expect {
     &#34;password: &#34; {
         if {$passwd == &#34;&#34;} {
            send &#34;\r&#34;
            expect {
               &#34;Reenter password: &#34; {
                send &#34;\r&#34;
                <a name="::result_debug(169)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;password is $passwd&#34;
               }
            }
         } else {
            send &#34;$passwd\r&#34;
            expect {
               &#34;Reenter password:&#34; {
                send &#34;$passwd\r&#34;
                <a name="::result_debug(170)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;password is $passwd&#34;
               }
            }
         }
      }
   }
  <a name="::exSleep(14)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_DeleteLocalUser</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Deletes a Netlogin local user.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  login - Login Name</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_DeleteLocalUser_4739">proc <a href="NetloginLib.tcl-annot.html#::::nl_DeleteLocalUser">::::nl_DeleteLocalUser</a></a></strong> {login} {
   <a name="::SendACmd(100)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;delete netlogin local-user $login&#34;
}

<strong><a name="::::nl_ChangeLocalUser_4743">proc <a href="NetloginLib.tcl-annot.html#::::nl_ChangeLocalUser">::::nl_ChangeLocalUser</a></a></strong> {login {passwd &#34;&#34;} {<a name="::vlan(15)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;&#34;} {tag &#34;&#34;}} {
    
   <span class="comment-line">#send &#34;configure netlogin local-user $login\r&#34;</span>
   if {$vlan == &#34;&#34;} {
      send &#34;configure netlogin local-user $login\r&#34;
   } else {
      send &#34;configure netlogin local-user $login vlan-vsa $tag $vlan\r&#34;
   }
   expect {
     &#34;password: &#34; {
         if {$passwd == &#34;&#34;} {
            send &#34;\r&#34;
            expect {
               &#34;Reenter password: &#34; {
                send &#34;\r&#34;
               }
            }
         } else {
            send &#34;$passwd\r&#34;
            expect {
               &#34;Reenter password:&#34; {
                send &#34;$passwd\r&#34;
               }
            }
         }
      }
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nl_VerifyDuplicateLocalUser</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Verifies the login password vlan and tag information</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  login - Login Name</span>
<span class="comment-line">#              passward - Password</span>
<span class="comment-line">#              vlan     - vlan information for the user</span>
<span class="comment-line">#              tag - Whether the port will be tagged port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_VerifyDuplicateLocalUser_4785">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifyDuplicateLocalUser">::::nl_VerifyDuplicateLocalUser</a></a></strong> {login {passwd &#34;&#34;} {<a name="::vlan(16)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;&#34;} {tag &#34;&#34;} \
              {comment &#34;Verifying Error message is returned when duplicate \
                        local-user is configured&#34;}} {
    
   <a name="::report_start_test(17)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$comment&#34;

   set retVal 0
   if {$vlan == &#34;&#34;} {
      send &#34;create netlogin local-user $login\r&#34;
   } else {
      send &#34;create netlogin local-user $login vlan-vsa $tag $vlan\r&#34;
   }
   expect {
     &#34;password: &#34; {
         if {$passwd == &#34;&#34;} {
            send &#34;\r&#34;
            expect {
               &#34;Reenter password: &#34; {
                send &#34;\r&#34;
               }
            }
         } else {
            send &#34;$passwd\r&#34;
            expect {
               &#34;Reenter password:&#34; {
                   send &#34;$passwd\r&#34;
                   expect {
                     &#34;Error: User already exists&#34; {
                        set retVal &#34;ok&#34;
                        <a name="::result_ok(11)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Error returned as User already exists&#34;
                     }
                     timeout {
                        set retVal &#34;error&#34;
                        <a name="::result_error(18)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No Error returned but Error expected&#34;
                     }
                   }
               }
            }
         }
      }
   }

   if {($retVal != &#34;ok&#34;) &amp;&amp; ($retVal != &#34;error&#34;)} {
      <a name="::result_error(19)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Command did not execute properly&#34;
   }

   <a name="::report_end_test(18)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

   return $retVal
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure Name: nl_VerifyChangeLocalUser</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Verifies the change of password for a Netlogin local user</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  user  - Login Name</span>
<span class="comment-line">#              var1  - String containing login and password information </span>
<span class="comment-line">#                      before the password is changed.</span>
<span class="comment-line">#              var2  - String containing login and password information </span>
<span class="comment-line">#                      after the password is changed.</span>
<span class="comment-line">#              status - The passwords are expected to be equal or unequal</span>
<span class="comment-line">#              commnet - Comment</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::nl_VerifyChangeLocalUser_4852">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifyChangeLocalUser">::::nl_VerifyChangeLocalUser</a></a></strong> {user var1 var2 {status &#34;equal&#34;} \
        {comment &#34;Verifying the change of password for the user $user&#34;}} {

   <a name="::report_start_test(18)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$comment&#34;

   regexp &#34;(.*$user)( .*)( .*)( .*not.*configured)&#34; $var1 res0 res1 res2 

   regexp &#34;(.*$user)( .*)( .*)( .*not.*configured)&#34; $var2 res4 res5 res6

   if {[string tolower $status] == &#34;equal&#34;} {
      if {$res2 == $res6} {
         <a name="::result_ok(12)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Password is same as expected&#34;
      } else {
         <a name="::result_error(20)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Password is different but expected to be same&#34;
      }
   } else {
      if {$res2 == $res6} {
         <a name="::result_error(21)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Password is same but expected to be different&#34;
      } else {
         <a name="::result_ok(13)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Password is different as expected&#34;
      }
   }
   <a name="::report_end_test(19)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure Name: nl_VerifyNetLoginPort</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Verifies the Netlogin port information for various attributes</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  user        - Login Name</span>
<span class="comment-line">#              port        - Port for which netlogin attributes are verified</span>
<span class="comment-line">#              portState   - Netlogin state expected</span>
<span class="comment-line">#              vlan        - Vlan in which the port is expected</span>
<span class="comment-line">#              mac         - Mac Address whose autnetication information</span>
<span class="comment-line">#                            is verified</span>
<span class="comment-line">#              user        - User for which authentication is done</span>
<span class="comment-line">#              authType    - Autentication type. mac-based</span>
<span class="comment-line">#              authStatus  - Verification of authentication status for the</span>
<span class="comment-line">#                            specified Mac address. Yes/No</span>
<span class="comment-line">#              guestVlan   - Guest Vlan status. Enabled/Disabled</span>
<span class="comment-line">#              ipAddr      - IP address of the Mac client which is authenticated</span>
<span class="comment-line">#              macLine     - Line number in which the Mac address autnetication</span>
<span class="comment-line">#                            information is expected.</span>
<span class="comment-line">#              commnet     - Comment</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::nl_VerifyNetLoginPort_4901">proc <a href="NetloginLib.tcl-annot.html#::::nl_VerifyNetLoginPort">::::nl_VerifyNetLoginPort</a></a></strong> { args } {
    <a name="::parse_args(15)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_VerifyNetLoginPort $args {
       <a name="::port(17)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>           &#34;&#34;
       portState      &#34;Enabled&#34;
       <a name="::vlan(17)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>           &#34;&#34;
       mac            &#34;&#34;
       user           &#34;&#34;
       authType       &#34;mac-based&#34;
       authStatus     &#34;yes&#34;
       guestVlan      &#34;Disabled&#34;
       ipAddr         &#34;0.0.0.0&#34;
       macLine        &#34;1&#34;
       comment        &#34;nl_VerifyNetLoginPort&#34;
    }

set ver [<a name="::GetVersion(5)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1]
set ver_val [<a name="::CompareRelease(5)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> $ver 11.6.0.0]
set mat_val [regexp -nocase .*fuji.* $ver]

if {($ver_val == 1) || ($mat_val == 1)} {
   set baseLine 1
} else {
   set baseLine 0
}

set version [<a name="::GetVersion(6)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 majmin]

if {$version &lt; &#34;12.0&#34;} {
    set portLine [expr $baseLine+1]
} else {
    set portLine [expr $baseLine+2]
}


set mList &#34;&#34;
lappend mList &#34;{.*Port.* $port} {.*Vlan.* $vlan} inLine exist $portLine&#34;
lappend mList &#34;{.*Vlan.* $vlan} {.*Authentication.*$authType} inLine exist 1&#34;
lappend mList &#34;{.*Vlan.* $vlan} {.*Port State.*$portState} inLine exist 2&#34;
if {$version &lt; &#34;12.1&#34; || [regexp -nocase $authStatus &#34;yes&#34;]} { 
   lappend mList &#34;{.*Vlan.* $vlan} exist&#34;
   lappend mList &#34;{.*$mac .*$ipAddr.* $authStatus.* MAC .* $user} exist&#34;
}
if {[<a name="::CheckKeyValue(14)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin port $port&#34; $mList -comment $comment] != &#34;ok&#34;} {
  <a name="::nl_exDumpDebugInfo(6)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>
}
}

<strong><a name="::::nl_resetIxiaPort_4948">proc <a href="NetloginLib.tcl-annot.html#::::nl_resetIxiaPort">::::nl_resetIxiaPort</a></a></strong> { {<a name="::port(18)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> &#34;1&#34;}} {

    global portMappingList
    <a name="::globalSetDefault(1)"><a href="./ePTUtils.tcl.html#::globalSetDefault_1">::globalSetDefault</a></a>
    global phyMode

    set TxRxPortList {}
    set portId [lindex $port 0]
    <a name="::MapIxiaPortId(21)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chid c p	 
    <a name="::result_debug(171)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Setting portId $portId to factory defaults...&#34;
    <a name="::port(19)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setFactoryDefaults $chid $c $p
    if {[info exists phyMode]} {
        if {[llength $phyMode]==1} {
            if {[regexp -nocase &#34;fiber&#34; $phyMode]} {
                <a name="::port(20)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setPhyMode $::portPhyModeFiber $chid $c $p
                puts &#34;Seeting Fiber mode  $chid $c $p&#34;
            }
            if {[regexp -nocase &#34;fibernoauto&#34; $phyMode]} {
                <a name="::port(21)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> config -autonegotiate false
                <a name="::port(22)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> set $chid $c $p
            }
        } else {
            if {$portId != 9} {
                foreach phyPortInfo $phyMode {
                    set phyPortId [lindex $phyPortInfo 0]
                    set phyPortMode [lindex $phyPortInfo 1]
                    if {$phyPortId == $portId} {
                        if {[regexp -nocase &#34;fiber&#34; $phyPortMode]} {
                            <a name="::port(23)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setPhyMode $::portPhyModeFiber $chid $c $p
                            if {[regexp -nocase &#34;fibernoauto&#34; $phyPortMode]} {
                                <a name="::result_debug(172)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Setting $c $p to Fiber mode with auto negotiaton off&#34;
                                <a name="::port(24)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> config -autonegotiate false
                                <a name="::port(25)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> set $chid $c $p
                            } else {
                                <a name="::result_debug(173)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Setting $c $p to Fiber mode&#34;
                            }
                        } else {
                            <a name="::port(26)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setPhyMode $::portPhyModeCopper $chid $c $p
                        }
                    }
                }
            }
        }
    }
    <a name="::StopPortsTransmit(1)"><a href="./ePTRx.tcl.html#::StopPortsTransmit_893">::StopPortsTransmit</a></a> $portId  ;<span class="comment-line"># setFactoryDefaults dont stop the xmit.</span>
    if {[<a name="::ixPortClearOwnership(1)"><a href="./mapping.tcl.html#::ixPortClearOwnership_76">::ixPortClearOwnership</a></a> $chid $c $p force]!=0} {
        <a name="::result_error(22)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Can not clear ixia port ownership:$chid $c $p&#34;
    }
    <a name="::port(27)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> config -MacAddress [<a name="::GetPortIdMac(1)"><a href="./misc.tcl.html#::GetPortIdMac_405">::GetPortIdMac</a></a> $portId]
    <a name="::port(28)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> set $chid $c $p
    <a name="::port(29)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> write $chid $c $p

    <span class="comment-line">#   ixiaGenMap $numIxiaCd $startCardNum &#34;standard&#34; &#34;2Way&#34; $chid</span>

    <span class="comment-line"># Make sure link is up</span>
    if [<a name="::ixInitLinks(1)"><a href="./ixGenProcs.tcl.html#::ixInitLinks_12">::ixInitLinks</a></a> one2oneArray $TxRxPortList] {
        <span class="comment-line">#      cleanUp </span>
        return 1
    }
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure Name: nl_waitForReauth</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Verifies whether a auth request is sent to the Radius server</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: time = Initial time to wait before starting the check</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::nl_waitForReauth_5018">proc  <a href="NetloginLib.tcl-annot.html#::::nl_waitForReauth">::::nl_waitForReauth</a></a></strong> {time} {
global DUT1_CONNECT

set version [<a name="::GetVersion(7)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 majmin]
puts &#34;The version is $version&#34;
  <a name="::SendACmd(101)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34;
  <a name="::SendACmd(102)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear counters&#34;
  set radList [list]
  if { $version &gt;= 16.1 } {
     lappend radList &#34;{Primary Netlogin Radius server} {Access Requests.*1} inLine exists 8&#34;
     <a name="::CheckKeyValue(15)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show radius&#34; $radList \
         -comment &#34;Verify reauth is initiated&#34; -time &#34;s: $time  i: 2 d: 20 f: 20&#34;
      return 1

  } else {
     lappend radList &#34;{Primary Netlogin Radius server} {Access Requests.*1} inLine exists 6&#34;
     <a name="::CheckKeyValue(16)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show radius&#34; $radList \
         -comment &#34;Verify reauth is initiated&#34; -time &#34;s: $time  i: 2 d: 20 f: 20&#34;
      return 1
  }

}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exCheckAuthFail</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Configuring NL authentication failure VLAN</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exConfigAuthFail_5052">proc <a href="NetloginLib.tcl-annot.html#::::nl_exConfigAuthFail">::::nl_exConfigAuthFail</a></a></strong> {args } {
 <a name="::parse_args(16)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_exConfigAuthFail $args {
    <a name="::port(30)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>           &#34;&#34;
    <a name="::vlan(18)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>           &#34;&#34;
    ipAddr         &#34;0.0.0.0&#34;
    vlanExist      0
    comment        &#34;nl_exConfigAuthFail&#34;
 }
 if { !$vlanExist } {
  <a name="::SendACmd(103)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;create vlan $vlan&#34;
  if { $ipAddr != &#34;0.0.0.0&#34; } {
    <a name="::SendACmd(104)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config vlan $vlan ipaddress $ipAddr/24&#34;
    <a name="::SendACmd(105)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable ipforwarding&#34;
  }
 }
 <a name="::SendACmd(106)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config netlogin authentication failure vlan $vlan \
           ports $port &#34;
 <a name="::SendACmd(107)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable netlogin authentication failure vlan ports $port&#34; 

}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exDeleteAuthFail</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Unconfiguring the Authentication Failure VLAN config</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exDeleteAuthFail_5085">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDeleteAuthFail">::::nl_exDeleteAuthFail</a></a></strong> { } {

 <a name="::SendACmd(108)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable netlogin authentication failure vlan ports all&#34;
 <a name="::SendACmd(109)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfigure netlogin authentication failure vlan&#34;

}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exCheckPortStatus</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: To check the Netlogin status for a specific port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#          vlan     VLAN name </span>
<span class="comment-line">#          status   Values - &#34;exist&#34; or &#34;notExist&#34; </span>
<span class="comment-line">#          auth     Authenticated or unauthenticated: Vlaues &#34;a&#34; or &#34;u&#34; </span>
<span class="comment-line">#          tag      Vlan Tag </span>
<span class="comment-line">#          port     Port </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exCheckPortStatus_5108">proc <a href="NetloginLib.tcl-annot.html#::::nl_exCheckPortStatus">::::nl_exCheckPortStatus</a></a></strong> {args} {
    <a name="::parse_args(17)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_exCheckPortStatus $args {
          <a name="::vlan(19)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>     &#34;&#34;
          status   &#34;exist&#34;
          auth     &#34;&#34;
          tag      &#34;&#34;
          <a name="::port(31)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>     &#34;&#34;
     }

   set checkPortList [list]
   if { $auth == &#34;&#34; } { 
     if {$tag == &#34;&#34; } {
        lappend checkPortList &#34;{\\*$port.*} $status&#34;
     } else {
        lappend checkPortList &#34;{$tag:.*\\*$port.*} $status&#34;
     }
   } else { 
     lappend checkPortList &#34;{$tag:.*\\*$port.*$auth} $status&#34;
   } 
   set result [<a name="::CheckKeyValue(17)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show vlan $vlan&#34; $checkPortList \
               -comment &#34;Verify port $port $status in $vlan&#34; \
               -time &#34;s: 0  i: 1 d: 5 f: 5&#34;]
   unset checkPortList
   return $result
} 
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exCheckFDBStatus</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: To Check for a supplicant MAC in the FDB table with </span>
<span class="comment-line">#              right flags </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: mac - MAC address of the Supplicant</span>
<span class="comment-line">#             port - Netlogin Port </span>
<span class="comment-line">#             status - exist/notExist </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exCheckFDBStatus_5148">proc <a href="NetloginLib.tcl-annot.html#::::nl_exCheckFDBStatus">::::nl_exCheckFDBStatus</a></a></strong> {mac port {status {exist}} {tag {untag}}} {

  set fdbMacList [list]
  puts &#34;YESS&#34;
  if { $tag == &#34;tag&#34; } {
   lappend fdbMacList &#34;{$mac.*npm} $status&#34;
  } else {
   lappend fdbMacList &#34;{$mac.*n.*m} $status&#34;
  }
  set result [<a name="::CheckKeyValue(18)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show fdb port $port&#34; $fdbMacList \
              -comment &#34;Verify FDB Table for the Client MAC $status&#34;]
  return $result

}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exConfigServiceUnavail </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: To configure the Authentication Service Unavailable</span>
<span class="comment-line">#              VLAN</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: Port   - Netlogin Port </span>
<span class="comment-line">#             vlan   - Service Unavailable VLAN  </span>
<span class="comment-line">#             ipAddr - IP Address for the Service Unavailable VLAN </span>
<span class="comment-line">#             vlanExist - Flag toggle Service Unavailable VLAN create      </span>
<span class="comment-line">#             comment - Comments</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nl_exConfigServiceUnavail_5180">proc <a href="NetloginLib.tcl-annot.html#::::nl_exConfigServiceUnavail">::::nl_exConfigServiceUnavail</a></a></strong> {args } {
 <a name="::parse_args(18)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> nl_exConfigAuthFail $args {
    <a name="::port(32)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>           &#34;&#34;
    <a name="::vlan(20)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>           &#34;&#34;
    ipAddr         &#34;0.0.0.0&#34;
    vlanExist      0
    comment        &#34;nl_exConfigServiceUnavail&#34;
 }
 if { !$vlanExist } {
  <a name="::SendACmd(110)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;create vlan $vlan&#34;
  if { $ipAddr != &#34;0.0.0.0&#34; } {
    <a name="::SendACmd(111)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config vlan $vlan ipaddress $ipAddr/24&#34;
    <a name="::SendACmd(112)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable ipforwarding&#34;
  }
 }
 <a name="::SendACmd(113)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config netlogin authentication service-unavailable vlan $vlan \
           ports $port &#34;
 <a name="::SendACmd(114)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable netlogin authentication service-unavailable vlan ports $port&#34;

}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exDeleteServiceUnavail </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: To disable the Authentication Service Unavailable </span>
<span class="comment-line">#              VLAN  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::nl_exDeleteServiceUnavail_5216">proc <a href="NetloginLib.tcl-annot.html#::::nl_exDeleteServiceUnavail">::::nl_exDeleteServiceUnavail</a></a></strong> { } {

 <a name="::SendACmd(115)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable netlogin authentication service-unavailable vlan ports all&#34;
 <a name="::SendACmd(116)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfigure netlogin authentication service-unavailable vlan&#34;

}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_exClearNetlogin </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This will the wrapper procedure to provide multiple</span>
<span class="comment-line">#              ways to clear the Netlogin port state </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: port - Netlogin port </span>
<span class="comment-line">#             type - method used to clear the netlogin state</span>
<span class="comment-line">#                  1 -&gt; &#34;clear netlogin state port &lt;&gt;&#34;      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::nl_exClearNetlogin_5239">proc <a href="NetloginLib.tcl-annot.html#::::nl_exClearNetlogin">::::nl_exClearNetlogin</a></a></strong> { <a name="::port(33)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> {type &#34;1&#34;}} { 

 switch $type {
  &#34;1&#34; { <a name="::SendACmd(117)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear netlogin state port $port&#34;}
 }
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: nl_SetupRadius </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Configured the Radius Server for the Netlogin TestCases </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: None </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::nl_SetupRadius_5260">proc <a href="NetloginLib.tcl-annot.html#::::nl_SetupRadius">::::nl_SetupRadius</a></a></strong> { } {

global DUT1_IP
global Netloginv2RadiusServer
global sharedSecret

set priRadiusServer    $Netloginv2RadiusServer
set priRadiusPort      1645
set clientIP           $DUT1_IP

<a name="::nl_exConfigRadius(1)"><a href="./NetloginLib.tcl.html#::nl_exConfigRadius_2391">::nl_exConfigRadius</a></a> $priRadiusServer $priRadiusPort $clientIP $sharedSecret
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: Mac_CreateRadiusUser</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: _CreateRadiusUser - Creates user name in </span>
<span class="comment-line">#              the necessary tables if user is not. If no username is </span>
<span class="comment-line">#              given then dafault user name md5_isp_$DUT1_IP </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::Mac_CreateRadiusUser_5286">proc <a href="NetloginLib.tcl-annot.html#::::Mac_CreateRadiusUser">::::Mac_CreateRadiusUser</a></a></strong> {args} {
    global DUT1_IP
    global radius_handler
    global radVersion

    <a name="::parse_args(19)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> Mac_CreateRadiusUser $args {
        username  &#34;&#34;
        password &#34;&#34;
        authType &#34;Local&#34;
   }

   if {$username == &#34;&#34;} {
       set username &#34;unknown_$DUT1_IP&#34;
}

if { $radVersion == 0 } {
    <span class="comment-line">#for radius version &lt; 3.0</span>
    set PasswdStr &#34;Password&#34;
} else {
    set PasswdStr &#34;Cleartext-Password&#34;
}

set present [mysqlsel $radius_handler &#34;select *  from radusergroup where username = '$username'&#34;]


if {$present == 0} {
	mysqlexec $radius_handler &#34;INSERT into radusergroup (username, groupname) VALUES ('$username', 'sup')&#34;

		mysqlexec $radius_handler &#34;INSERT into radcheck (username,attribute,value,op) VALUES ('$username',\
		'$PasswdStr', '$password',':=')&#34;

		if {$radVersion == 0} {
			mysqlexec $radius_handler &#34;INSERT into radcheck (username,attribute,value,op) VALUES ('$username',\
				'Auth-Type', '$authType',':=')&#34;
		}
	set value [<a name="::dot1x_GetUserAttribute(1)"><a href="./Dot1XLib.tcl.html#::dot1x_GetUserAttribute_4389">::dot1x_GetUserAttribute</a></a> $username &#34;$PasswdStr&#34;]


	if {$value != $password} {
			return &#34;error&#34;
		}

	if {$radVersion == 0} {
		set value [<a name="::dot1x_GetUserAttribute(2)"><a href="./Dot1XLib.tcl.html#::dot1x_GetUserAttribute_4389">::dot1x_GetUserAttribute</a></a> $username &#34;Auth-Type&#34;]
		if {$value != $authType} {
				return &#34;error&#34;
		}
	}
} else {
	return &#34;duplicate&#34;
}

return &#34;ok&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: Policy_Check</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Policy_Check - Verify the Platform Support Policy or </span>
<span class="comment-line">#               Not</span>
<span class="comment-line"># Return 1 for True , Else return False</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::Policy_Check_5350">proc <a href="NetloginLib.tcl-annot.html#::::Policy_Check">::::Policy_Check</a></a></strong> { {DUT_No &#34;1&#34;}  } {

global Policy_Platform
global DUTs_info
set policy_flag 0

set version [<a name="::GetVersion(8)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$DUT_No majmin]
if { $version &gt;= 21.1 } {
	set policy_flag 1
} else {
	set platform [<a name="::GetPlatform(4)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT$DUT_No]
	set plat $platform
	if { $plat == &#34;Stack&#34; } {
		set blade $DUTs_info(DUT$DUT_No,sysType)
		puts &#34;The blade that is used : $blade&#34;
		if  {[regexp -nocase &#34;$Policy_Platform&#34; $blade] &amp;&amp; $version &gt;= 16.1} {
			set policy_flag 1
		}
	} elseif {[regexp -nocase &#34;$Policy_Platform&#34; $plat] &amp;&amp; $version &gt;= 16.1} {
		set policy_flag 1
	}
}

return $policy_flag
}
<span class="comment-line">################################################################</span>
<span class="comment-line">#  Procedure Name: RadiusProcessCheck</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Description:</span>
<span class="comment-line">#    This procedure verify radius process is running in specified</span>
<span class="comment-line">#    Radius server</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#    RadiusServer - Name of the radius server</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Optional Args:</span>
<span class="comment-line">#    None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#     None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Variables:</span>
<span class="comment-line">#    -1 - on failure</span>
<span class="comment-line">#    Process ID - on success</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Possible Usage:</span>
<span class="comment-line">#    RadiusProcessCheck RadiusServer</span>
<span class="comment-line">###############################################################</span>
<strong><a name="::::RadiusProcessCheck_5398">proc <a href="NetloginLib.tcl-annot.html#::::RadiusProcessCheck">::::RadiusProcessCheck</a></a></strong> { RadiusServer } {

set radiusPID [<a name="::radiusUtilGetPID(1)"><a href="./NetloginLib.tcl.html#::radiusUtilGetPID_5436">::radiusUtilGetPID</a></a> radiusd $RadiusServer]
   if { $radiusPID != -1 } {
      <a name="::result_debug(174)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;/usr/sbin/radiusd is running with pid $radiusPID&#34;
      <a name="::result_debug(175)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;radiusd($radiusPID) is running&#34;
	  return 1
   } else {
      <span class="comment-line"># radiusd is not running</span>
      <a name="::result_debug(176)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;radiusd is not running&#34;
	  return 0
   }  
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  Procedure Name: radiusUtilGetPID</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Description:</span>
<span class="comment-line">#    This procedure returns the process identifier of a specific</span>
<span class="comment-line">#    process. If the process is not running, it returns -1 as </span>
<span class="comment-line">#    process id.</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#    pName - Name of the process</span>
<span class="comment-line">#    RadServer - Radius server to check</span>
<span class="comment-line">#  Optional Args:</span>
<span class="comment-line">#    None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#     None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Variables:</span>
<span class="comment-line">#    -1 - on failure</span>
<span class="comment-line">#    Process ID - on success</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Possible Usage:</span>
<span class="comment-line">#    radiusUtilGetPID radiusd RadServer</span>
<span class="comment-line">###############################################################</span>
<strong><a name="::::radiusUtilGetPID_5436">proc <a href="NetloginLib.tcl-annot.html#::::radiusUtilGetPID">::::radiusUtilGetPID</a></a></strong> { pName RadServer } {

   <a name="::login_linux(1)"><a href="./linux.tcl.html#::login_linux_16">::login_linux</a></a> $RadServer &#34;autotest&#34; &#34;autotest&#34; ;
   set output [ <a name="::linuxSendACmd(1)"><a href="./linux.tcl.html#::linuxSendACmd_268">::linuxSendACmd</a></a> &#34;\/bin\/ps -e |grep \&#34;$pName\&#34;&#34; ]
   <a name="::linuxSendACmd(2)"><a href="./linux.tcl.html#::linuxSendACmd_268">::linuxSendACmd</a></a> &#34;exit\r&#34;
   if {[info exists output]} {
      foreach item [split $output &#34;\n&#34;] {
         if { [regexp $pName $item] &amp;&amp; ![regexp &#34;grep&#34; $item] } {
            return [lindex $item 0]
         }
      }
  }
  <span class="comment-line"># Process id not found </span>
  return -1
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nlweb_login</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: create python script for client login</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  nlweb_login $testNo $user $pass </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nlweb_login_5461">proc <a href="NetloginLib.tcl-annot.html#::::nlweb_login">::::nlweb_login</a></a></strong> {testNo user pass {dut &#34;2&#34;} {auth &#34;http&#34;}} {

	<a name="::DHCP_check(1)"><a href="./NetloginLib.tcl.html#::DHCP_check_5541">::DHCP_check</a></a>
	
	global verflag
	global verflag1
    set filesToUpload &#34;&#34;
	set filesToDownload &#34;&#34;
	set version [<a name="::GetVersion(9)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$dut majmin]
	set DUT1_version [<a name="::GetVersion(10)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 whole]
	
	lappend filesToUpload &#34;Tmp/$testNo&#34;
	lappend filesToDownload &#34;$testNo&#34;
	set fd [open &#34;Tmp/$testNo&#34; &#34;w&#34;]
	if {$version&gt;=30.1} {
	puts $fd &#34;import os&#34;
	puts $fd &#34;os.environ\[\'EXOS_VR_ID\'\]=\'2\'&#34;
	if {$auth == &#34;https&#34;} {
	puts $fd &#34;os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'&#34;
	}
	} else {
	puts $fd &#34;f = open('/proc/self/ns_id', 'w')&#34;
	puts $fd &#34;f.write('2\\n')&#34;
	puts $fd &#34;f.close()&#34;
	}
	puts $fd &#34;import urllib2, base64&#34;
	if {$verflag != 0} {
	<span class="comment-line"># the check is add for 21.1 and 16.2 release</span>
	if {$DUT1_version&gt;=&#34;22.5.0.34&#34;} {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com/login\?url\=20.1.1.1\&#34;)&#34;
	} else {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://20.1.1.1/\&#34;)&#34;
	}
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result1 = urllib2.urlopen(request1)&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	}
	puts $fd &#34;request = urllib2.Request(\&#34;$auth://20.1.1.1/hello\&#34;)&#34;
	puts $fd &#34;request2 = urllib2.Request(\&#34;$auth://20.1.1.1/login\&#34;)&#34;
	puts $fd &#34;basestr = base64.encodestring('%s:%s' % (\&#34;$user\&#34;, \&#34;$pass\&#34;)).replace('\\n',' ')&#34;
	puts $fd &#34;request.add_header(\&#34;Authorization\&#34;, \&#34;Basic %s\&#34; % basestr)&#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result2 = urllib2.urlopen(request2)&#34;
	puts $fd &#34;    print(result2.read())&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result = urllib2.urlopen(request)&#34;
	puts $fd &#34;    print(result.read())&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	close $fd
	
	<a name="::CheckTftpPutMulti(1)"><a href="./SendSwCmd.tcl.html#::CheckTftpPutMulti_2488">::CheckTftpPutMulti</a></a> &#34;$filesToUpload&#34;
	
	if {[<a name="::CheckTftpGetMulti(1)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
	<a name="::result_debug(177)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_start_test(19)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_end_test(20)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a> 
	
	}
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DHCP_check</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: To show the client acquired the DHCP IP</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  DHCP_check </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::DHCP_check_5541">proc <a href="NetloginLib.tcl-annot.html#::::DHCP_check">::::DHCP_check</a></a></strong> { } {

global DUT2_CONNECT

<a name="::Login(6)"><a href="./login.tcl.html#::Login_24">::Login</a></a>   $DUT2_CONNECT

<a name="::SendACmd(118)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show dhcp-client state&#34;

}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nlweb_login1</span>
<span class="comment-line"># </span>
<span class="comment-line"># Description: python script creation for login</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             nlweb_login1 $testNo $user $pass</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nlweb_login1_5561">proc <a href="NetloginLib.tcl-annot.html#::::nlweb_login1">::::nlweb_login1</a></a></strong> {testNo user pass {dut &#34;2&#34;} {auth &#34;http&#34;} {retry &#34;1&#34;}} {
	
	<a name="::DHCP_check(2)"><a href="./NetloginLib.tcl.html#::DHCP_check_5541">::DHCP_check</a></a>
	
    set filesToUpload &#34;&#34;
	set filesToDownload &#34;&#34;
	global verflag
	set version [<a name="::GetVersion(11)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$dut majmin]
	set DUT1_version [<a name="::GetVersion(12)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 whole]
	
	lappend filesToUpload &#34;Tmp/$testNo&#34;
	lappend filesToDownload &#34;$testNo&#34;
	set fd [open &#34;Tmp/$testNo&#34; &#34;w&#34;]
	if {$version&gt;=30.1} {
	puts $fd &#34;import os&#34;
	puts $fd &#34;os.environ\[\'EXOS_VR_ID\'\]=\'2\'&#34;
	if {$auth == &#34;https&#34;} {
	puts $fd &#34;os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'&#34;
	}
	} else {
	puts $fd &#34;f = open('/proc/self/ns_id', 'w')&#34;
	puts $fd &#34;f.write('2\\n')&#34;
	puts $fd &#34;f.close()&#34;
	}
	puts $fd &#34;import urllib2, base64 &#34;
	puts $fd &#34;import urllib, time &#34;
	if {$verflag != 0} {
	puts $fd &#34;import ctypes&#34;
	puts $fd &#34;libc = ctypes.cdll.LoadLibrary('libc.so.6') &#34;
	puts $fd &#34;res_init = libc.__res_init &#34;
	puts $fd &#34;res_init() &#34;
	if {$DUT1_version&gt;=&#34;22.5.0.34&#34;} {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com/login\?url\=20.1.1.1\&#34;)&#34;
	} else {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com\&#34;) &#34;
	}
	for {set i 0} {$i &lt; $retry} {incr i} {
    puts $fd &#34;request3 = urllib2.Request(\&#34;$auth://network-access.com/login\&#34;) &#34;
	}
	puts $fd &#34;request = urllib2.Request(\&#34;$auth://network-access.com/hello\&#34;) &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    print \&#34;\\nThe Start page is as follows:--------------------\\n\&#34; &#34;
	puts $fd &#34;    result1 = urllib2.urlopen(request1) &#34;
	puts $fd &#34;    print(result1.read()) &#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	} else {
	if {$DUT1_version&gt;=&#34;22.5.0.34&#34;} {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com/login\?url\=20.1.1.1\&#34;)&#34;
	} else {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://20.1.1.1/\&#34;)&#34;
	}
	for {set i 0} {$i &lt; $retry} {incr i} {
    puts $fd &#34;request3 = urllib2.Request(\&#34;$auth://20.1.1.1/login\&#34;) &#34;
	}
	puts $fd &#34;request = urllib2.Request(\&#34;$auth://20.1.1.1/hello\&#34;) &#34;
	}
<span class="comment-line">#	puts $fd &#34;values = {'extremenetloginuser' : '$user', &#34;</span>
<span class="comment-line">#	puts $fd &#34;          'extremenetloginpassword' : '$pass', &#34;</span>
	puts $fd &#34;          } &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;data = urllib.urlencode(values) &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    print \&#34;\\nThe Login page is as follows:--------------------\\n\&#34; &#34;
	puts $fd &#34;    result3 = urllib2.urlopen(request3) &#34;
	puts $fd &#34;    print(result3.read()) &#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	puts $fd &#34;	 &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    print \&#34;\\nThe Login Success Page is as follows---------------\\n\&#34; &#34;
	puts $fd &#34;    result = urllib2.urlopen(request, data) &#34;
	puts $fd &#34;    print(result.read()) &#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	puts $fd &#34; &#34;
	puts $fd &#34; &#34;
	close $fd
	
	<a name="::CheckTftpPutMulti(2)"><a href="./SendSwCmd.tcl.html#::CheckTftpPutMulti_2488">::CheckTftpPutMulti</a></a> &#34;$filesToUpload&#34;
	
	if {[<a name="::CheckTftpGetMulti(2)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
	<a name="::result_debug(178)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_start_test(20)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_end_test(21)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	}
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nlweb_logout</span>
<span class="comment-line"># </span>
<span class="comment-line"># Description: python script creation for logout</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             nlweb_logout </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nlweb_logout_5665">proc <a href="NetloginLib.tcl-annot.html#::::nlweb_logout">::::nlweb_logout</a></a></strong> {testNo user pass {dut &#34;2&#34;} {auth &#34;http&#34;}} {
	
    set filesToUpload &#34;&#34;
	set filesToDownload &#34;&#34;
	set version [<a name="::GetVersion(13)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$dut majmin]
	
	lappend filesToUpload &#34;Tmp/$testNo$user&#34;
	lappend filesToDownload &#34;$testNo$user&#34;
	set fd [open &#34;Tmp/$testNo$user&#34; &#34;w&#34;]
	if {$version&gt;=30.1} {
	puts $fd &#34;import os&#34;
	puts $fd &#34;os.environ\[\'EXOS_VR_ID\'\]=\'2\'&#34;
	if {$auth == &#34;https&#34;} {
	puts $fd &#34;os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'&#34;
	}
	} else {
	puts $fd &#34;f = open('/proc/self/ns_id', 'w')&#34;
	puts $fd &#34;f.write('2\\n')&#34;
	puts $fd &#34;f.close()&#34;
	}
	puts $fd &#34;import urllib2, base64&#34;
	puts $fd &#34;request2 = urllib2.Request(\&#34;$auth://192.168.1.1/goodbye\&#34;) &#34;
	puts $fd &#34;basestr = base64.encodestring('%s:%s' % (\&#34;$user\&#34;, \&#34;$pass\&#34;)).replace('\\n',' ')&#34;
	puts $fd &#34;request2.add_header(\&#34;Authorization\&#34;, \&#34;Basic %s\&#34; % basestr)&#34;
	puts $fd &#34; &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    print \&#34;\\nThe Logout Success Page is as follows---------------\\n\&#34; &#34;
	puts $fd &#34;    result2 = urllib2.urlopen(request2) &#34;
	puts $fd &#34;    print(result2.read()) &#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	puts $fd &#34; &#34;
	close $fd
	
	<a name="::CheckTftpPutMulti(3)"><a href="./SendSwCmd.tcl.html#::CheckTftpPutMulti_2488">::CheckTftpPutMulti</a></a> &#34;$filesToUpload&#34;
	
	if {[<a name="::CheckTftpGetMulti(3)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
	<a name="::result_debug(179)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_start_test(21)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_end_test(22)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	}
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nlweb_login3</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: create python script for clinet login</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  nlweb_login3 $testNo $user $pass </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nlweb_login3_5719">proc <a href="NetloginLib.tcl-annot.html#::::nlweb_login3">::::nlweb_login3</a></a></strong> {testNo user pass {dut &#34;2&#34;} {auth &#34;http&#34;} {browser &#34;Firefox&#34;}} {
	
	<a name="::DHCP_check(3)"><a href="./NetloginLib.tcl.html#::DHCP_check_5541">::DHCP_check</a></a>
	
	global verflag
    set filesToUpload &#34;&#34;
	set filesToDownload &#34;&#34;
	set agent [<a name="::browser_agent(1)"><a href="./NetloginLib.tcl.html#::browser_agent_5799">::browser_agent</a></a> $browser]
	set version [<a name="::GetVersion(14)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$dut majmin]
	set DUT1_version [<a name="::GetVersion(15)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 whole]
	<span class="comment-line">#puts &#34;agent:&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;$agent&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &#34;</span>
	lappend filesToUpload &#34;Tmp/$testNo&#34;
	lappend filesToDownload &#34;$testNo&#34;
	set fd [open &#34;Tmp/$testNo&#34; &#34;w&#34;]
	if {$version&gt;=30.1} {
	puts $fd &#34;import os&#34;
	puts $fd &#34;os.environ\[\'EXOS_VR_ID\'\]=\'2\'&#34;
	if {$auth == &#34;https&#34;} {
	puts $fd &#34;os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'&#34;
	}
	} else {
	puts $fd &#34;f = open('/proc/self/ns_id', 'w')&#34;
	puts $fd &#34;f.write('2\\n')&#34;
	puts $fd &#34;f.close()&#34;
	}
	puts $fd &#34;import urllib2, base64&#34;
	if {$verflag != 0} {
	<span class="comment-line"># the check is add for 21.1 and 16.2 release</span>
	if {$DUT1_version&gt;=&#34;22.5.0.34&#34;} {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com/login\?url\=20.1.1.1\&#34;)&#34;
	} else {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://20.1.1.1/\&#34;)&#34;
	}
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result1 = urllib2.urlopen(request1)&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	}
	puts $fd &#34;request = urllib2.Request(\&#34;$auth://20.1.1.1/hello\&#34;)&#34;
	puts $fd &#34;request2 = urllib2.Request(\&#34;$auth://20.1.1.1/login\&#34;)&#34;
	puts $fd &#34;basestr = base64.encodestring('%s:%s' % (\&#34;$user\&#34;, \&#34;$pass\&#34;)).replace('\\n',' ')&#34;
	puts $fd &#34;request.add_header(\&#34;Authorization\&#34;, \&#34;Basic %s\&#34; % basestr)&#34;
	puts $fd &#34;request.add_header(\&#34;User-Agent\&#34; , \&#34;$agent\&#34;)&#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result2 = urllib2.urlopen(request2)&#34;
	puts $fd &#34;    print(result2.read())&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result = urllib2.urlopen(request)&#34;
	puts $fd &#34;    print(result.read())&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	close $fd
	
	<a name="::CheckTftpPutMulti(4)"><a href="./SendSwCmd.tcl.html#::CheckTftpPutMulti_2488">::CheckTftpPutMulti</a></a> &#34;$filesToUpload&#34;
	
	if {[<a name="::CheckTftpGetMulti(4)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
	<a name="::result_debug(180)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_start_test(22)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_end_test(23)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	}
}
<span class="comment-line">#</span>
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: browser_agent</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: set user agent fot different browser</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  browser_agent $browser_name </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::browser_agent_5799">proc <a href="NetloginLib.tcl-annot.html#::::browser_agent">::::browser_agent</a></a></strong> { broswer } {
	set agent &#34;&#34;
	if {$broswer == &#34;Firefox&#34;} {
		set agent &#34;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko&#34;
	} elseif {$broswer == &#34;Chrome&#34;} {
		set agent &#34;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36&#34;
	} elseif {$broswer == &#34;Opera&#34;} {
		set agent &#34;Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14&#34;
	} elseif {$broswer == &#34;Safari&#34;} {
		set agent &#34;Mozilla/5.0 (Windows; U; Windows NT 6.1; tr-TR) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27&#34;
	} elseif {$broswer == &#34;InternetExplorer&#34;} {
		set agent &#34;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko&#34;
	} elseif {$broswer == &#34;Apple&#34;} {
		set agent &#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A&#34;
	}
	return $agent
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: nlweb_login</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: create python script for clinet login</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  nlweb_login $testNo $user $pass </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::nlweb_login_URL_5826">proc <a href="NetloginLib.tcl-annot.html#::::nlweb_login_URL">::::nlweb_login_URL</a></a></strong> {testNo user pass {dut &#34;2&#34;} {auth &#34;http&#34;}} {
	
	<a name="::DHCP_check(4)"><a href="./NetloginLib.tcl.html#::DHCP_check_5541">::DHCP_check</a></a>
	
	global verflag
	global verflag1
    set filesToUpload &#34;&#34;
	set filesToDownload &#34;&#34;
	set version [<a name="::GetVersion(16)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$dut majmin]
	set DUT1_version [<a name="::GetVersion(17)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 whole]
	
	lappend filesToUpload &#34;Tmp/$testNo&#34;
	lappend filesToDownload &#34;$testNo&#34;
	set fd [open &#34;Tmp/$testNo&#34; &#34;w&#34;]
	if {$version&gt;=30.1} {
	puts $fd &#34;import os&#34;
	puts $fd &#34;os.environ\[\'EXOS_VR_ID\'\]=\'2\'&#34;
	} else {
	puts $fd &#34;f = open('/proc/self/ns_id', 'w')&#34;
	puts $fd &#34;f.write('2\\n')&#34;
	puts $fd &#34;f.close()&#34;
	}
	puts $fd &#34;import urllib2, base64&#34;
	if {$verflag != 0} {
	<span class="comment-line"># the check is add for 21.1 and 16.2 release</span>
	if {$DUT1_version&gt;=&#34;22.5.0.34&#34;} {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com/login\?url\=20.1.1.1\&#34;)&#34;
	} else {
	puts $fd &#34;request1 = urllib2.Request(\&#34;$auth://network-access.com/\&#34;)&#34;
	}
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result1 = urllib2.urlopen(request1)&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	}
	puts $fd &#34;request = urllib2.Request(\&#34;$auth://network-access.com/hello\&#34;)&#34;
	puts $fd &#34;request2 = urllib2.Request(\&#34;$auth://network-access.com/login\&#34;)&#34;
	puts $fd &#34;basestr = base64.encodestring('%s:%s' % (\&#34;$user\&#34;, \&#34;$pass\&#34;)).replace('\\n',' ')&#34;
	puts $fd &#34;request.add_header(\&#34;Authorization\&#34;, \&#34;Basic %s\&#34; % basestr)&#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result2 = urllib2.urlopen(request2)&#34;
	puts $fd &#34;    print(result2.read())&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    result = urllib2.urlopen(request)&#34;
	puts $fd &#34;    print(result.read())&#34;
	puts $fd &#34;except urllib2.HTTPError, e: &#34;
	puts $fd &#34;    print e &#34;
	puts $fd &#34;except urllib2.URLError, e: &#34;
	puts $fd &#34;    print e.args &#34;
	close $fd
	
	<a name="::CheckTftpPutMulti(5)"><a href="./SendSwCmd.tcl.html#::CheckTftpPutMulti_2488">::CheckTftpPutMulti</a></a> &#34;$filesToUpload&#34;
	
	if {[<a name="::CheckTftpGetMulti(5)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
	<a name="::result_debug(181)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_start_test(23)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Skipped: Python Files Did Not Download Correctly&#34;
	<a name="::report_end_test(24)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
	}
}
<span class="comment-line">###########################################################################</span>
<span class="comment-line">## Procedure Name: Dot1x_Client</span>
<span class="comment-line">##</span>
<span class="comment-line">## Description: Creates a Python script to simulate Dot1x Client from EXOS</span>
<span class="comment-line">##</span>
<span class="comment-line">## Sample Usage:</span>
<span class="comment-line">##  Dot1x_Client $testNo </span>
<span class="comment-line">##</span>
<span class="comment-line">##  Output args: NULL</span>
<span class="comment-line">##</span>
<span class="comment-line">##  Usage of Python script: </span>
<span class="comment-line">#    </span>
<span class="comment-line">##  1.load script &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line">##  2.load script &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt; \</span>
<span class="comment-line">#                             &lt;operation name: logout\reauth&gt; &lt;time interval&gt;    </span>
<span class="comment-line">#############################################################################</span>

<strong><a name="::::Dot1x_Client_5909">proc <a href="NetloginLib.tcl-annot.html#::::Dot1x_Client">::::Dot1x_Client</a></a></strong> {testNo {dut &#34;2&#34;}} {

    set filesToUpload &#34;&#34;
    set filesToDownload &#34;&#34;
    lappend filesToUpload &#34;Tmp/$testNo&#34;
    lappend filesToDownload &#34;$testNo&#34;
    set fd [open &#34;Tmp/$testNo&#34; &#34;w&#34;]
    puts $fd &#34;######################################################################################################## &#34;
	puts $fd &#34;######################################################################################################## &#34;
	puts $fd &#34;# &#34;
	puts $fd &#34;#                                        DOT1X Client Program &#34;
	puts $fd &#34;# &#34;
	puts $fd &#34;# -----------------------------------------Pre Requirements -------------------------------------------- &#34;
	puts $fd &#34;# &#34;
	puts $fd &#34;#            **Generate the name of the Interface with vlan_name\[5\]_{snmpvalue in hex} &#34;
	puts $fd &#34;#            **Ensure the Vlan is created prior and an active port is added &#34;
	puts $fd &#34;#            **Assign IP to the vlan and enable ip forwarding - Though we are dealing with L2 packets &#34;
	puts $fd &#34;#            **the CPU will LIFT the packet only for a L3 interface hence assign an IP to the Vlan &#34;
	puts $fd &#34;#            ****** The CPU lifts the L2 packets when DHCP is enabled in the interface -Update 20 Jan &#34;
	puts $fd &#34;######################################################################################################## &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;#!/usr/bin/python &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;from socket import * &#34;
	puts $fd &#34;from struct import * &#34;
	puts $fd &#34;from md5 import * &#34;
	puts $fd &#34;from sys import * &#34;
	puts $fd &#34;import time &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Argument Settings &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    Username = argv\[1\] &#34;
	puts $fd &#34;    Password = argv\[2\] &#34;
	puts $fd &#34;    interface = argv\[3\] &#34;
	puts $fd &#34;except: &#34;
	puts $fd &#34;    print \&#34;The Username or Password or Interface is not specified correctly: exiting !!!\&#34; &#34;
	puts $fd &#34;    print \&#34;Usage: python &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt;\&#34; &#34;
	puts $fd &#34;    exit() &#34;
	puts $fd &#34;logoff = 0 &#34;
   puts $fd &#34;reauth = 0 &#34;
	puts $fd &#34;if len(argv) &gt; 4: &#34;
	puts $fd &#34;    try: &#34;
	puts $fd &#34;        operation = argv\[4\] &#34;
	puts $fd &#34;        timer = argv\[5\] &#34;
	puts $fd &#34;        if operation == \&#34;logout\&#34;: &#34;
	puts $fd &#34;            print \&#34;Dot1x process start with logout operation at interval:\&#34;,timer &#34;
	puts $fd &#34;### LOGOFF Scenario &#34;
	puts $fd &#34;            logontime = timer &#34;
	puts $fd &#34;            logoff = 1 &#34;
	puts $fd &#34;        elif operation == \&#34;reauth\&#34;: &#34;
	puts $fd &#34;            print \&#34;Dot1x process start with reauthentication operation at interval:\&#34;,timer &#34;
	puts $fd &#34;### Re Authentication &#34;
	puts $fd &#34;            reauth = 1 &#34;
	puts $fd &#34;            reauth_time = timer &#34;
	puts $fd &#34;        else: &#34;
	puts $fd &#34;            print \&#34;Invalid Operation Exiting\&#34; &#34;
	puts $fd &#34;            print \&#34;Usage: load script &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt; &lt;operation name: logout\\reauth&gt; &lt;time interval&gt;\&#34; &#34;
	puts $fd &#34;            exit() &#34;
	puts $fd &#34;    except: &#34;
	puts $fd &#34;        print \&#34;Wrong Usage: Arguments &lt;Operation&gt; and &lt;Timer&gt; are not specified correctly !!!\&#34; &#34;
	puts $fd &#34;        print \&#34;Usage: load script &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt; &lt;operation name: logout\\reauth&gt; &lt;time interval&gt;\&#34; &#34;
	puts $fd &#34;        exit() &#34;
	puts $fd &#34;         &#34;
	puts $fd &#34;else: &#34;
	puts $fd &#34;    print \&#34;Proceeding with Dot1x authtication with no special operation like logout or reauth\&#34; &#34;
	puts $fd &#34;               &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;###  Authentication parameters &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;USER = Username &#34;
	puts $fd &#34;PASS = Password &#34;
	puts $fd &#34;DEV = interface &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Constants &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;ETHERTYPE_PAE = 0x888e &#34;
	puts $fd &#34;PAE_GROUP_ADDR = \&#34;\\x01\\x80\\xc2\\x00\\x00\\x03\&#34; &#34;
	puts $fd &#34;ETH_P_ALL=0x0003 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;EAPOL_VERSION = 1 &#34;
	puts $fd &#34;EAPOL_EAPPACKET = 0 &#34;
	puts $fd &#34;EAPOL_START = 1 &#34;
	puts $fd &#34;EAPOL_LOGOFF = 2 &#34;
	puts $fd &#34;EAPOL_KEY = 3 &#34;
	puts $fd &#34;EAPOL_ASF = 4 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;EAP_REQUEST = 1 &#34;
	puts $fd &#34;EAP_RESPONSE = 2 &#34;
	puts $fd &#34;EAP_SUCCESS = 3 &#34;
	puts $fd &#34;EAP_FAILURE = 4 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;EAP_TYPE_ID = 1 &#34;
	puts $fd &#34;EAP_TYPE_MD5 = 4 &#34;
	puts $fd &#34;EAP_TYPE_TLS = 4 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;count1 = 0 &#34;
   puts $fd &#34;count2 = 0 &#34;
   puts $fd &#34;count3 = 0 &#34;
   puts $fd &#34; &#34;
   puts $fd &#34;EXTREME_SO_VRID = 37 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Packet builders &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;def EAPOL(type, payload=\&#34;\&#34;): &#34;
	puts $fd &#34;    return pack(\&#34;!BBH\&#34;, EAPOL_VERSION, type, len(payload))+payload &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;def EAP(code, id, type=0, data=\&#34;\&#34;): &#34;
	puts $fd &#34;    if code in \[EAP_SUCCESS, EAP_FAILURE\]: &#34;
	puts $fd &#34;        return pack(\&#34;!BBH\&#34;, code, id, 4) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;    else: &#34;
	puts $fd &#34;        return pack(\&#34;!BBHB\&#34;, code, id, 5+len(data), type)+data &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;def ethernet_header(src, dst, type): &#34;
	puts $fd &#34;    return dst+src+pack(\&#34;!H\&#34;,type) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Main program &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### L2 RAW Socket Creation and EXOS tweak to work in VR-DEFAULT &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;s=socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) &#34;
	puts $fd &#34;s.setsockopt(SOL_SOCKET, EXTREME_SO_VRID, 2) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Interface binding to listen to the socket&#34;
	puts $fd &#34;s.settimeout(60)&#34;
	puts $fd &#34;s.bind((DEV, 0)) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Sending EAPOL Start Packet &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;mymac=s.getsockname()\[4\] &#34;
	puts $fd &#34;llhead=ethernet_header(mymac, PAE_GROUP_ADDR, ETHERTYPE_PAE) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;print \&#34;--&gt; Sent EAPOL Start\&#34; &#34;
	puts $fd &#34;s.send(llhead+EAPOL(EAPOL_START)) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### EAP Transaction Start based on the EAP TYPE &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;try:&#34;
	puts $fd &#34;    while 1:  &#34;
	puts $fd &#34;        p = s.recv(1600) &#34;
	puts $fd &#34;        ether1, ether2 = unpack(\&#34;!BB\&#34;,p\[16:18\]) &#34;
	puts $fd &#34;        ether = str(hex(ether1)) + str(hex(ether2))\[2:\] &#34;
	puts $fd &#34;        print \&#34;The Ethertype is \&#34;, ether &#34;
	puts $fd &#34;        if ether == hex(ETHERTYPE_PAE): &#34;
	puts $fd &#34;            print \&#34;&lt;-- Got 802.1x Packet with Ethertype\&#34;,ether &#34;
	puts $fd &#34;            p = p\[18:\] &#34;
	puts $fd &#34;            vers,type,eapollen  = unpack(\&#34;!BBH\&#34;,p\[:4\]) &#34;
	puts $fd &#34;            if type == EAPOL_EAPPACKET: &#34;
	puts $fd &#34;                    code, id, eaplen = unpack(\&#34;!BBH\&#34;, p\[4:8\]) &#34;
	puts $fd &#34;### EAP SUCCESS TYPE &#34;
	puts $fd &#34;                    if code == EAP_SUCCESS: &#34;
	puts $fd &#34;                          print \&#34;&lt;-- Got EAP Success\&#34; &#34;
	puts $fd &#34;                          count1 = 0 &#34;
   puts $fd &#34;                          count2 = 0 &#34;
   puts $fd &#34;                          if logoff == 1: &#34;
	puts $fd &#34;                              time.sleep(float(logontime))&#34;
	puts $fd &#34;                              s.send(llhead+EAPOL(EAPOL_LOGOFF)) &#34;
   puts $fd &#34;                              print \&#34;--&gt; Operation: Logout --&gt; Sent EAP Logout after delay\&#34;&#34;  
   puts $fd &#34;                              break&#34;     
   puts $fd &#34;                          elif reauth == 1: &#34;    
   puts $fd &#34;                              print \&#34;Operation: Reauthentication &lt;-- Listening until Reauth expires\&#34;&#34;
   puts $fd &#34;                              time.sleep(float(reauth_time)) &#34;           
   puts $fd &#34;                              print \&#34;--&gt; Reauthentication started -- Waiting for Reauth Packet\&#34;&#34;
   puts $fd &#34;                              reauth = 0&#34;
   puts $fd &#34;                          else: &#34;
	puts $fd &#34;                              break &#34;
	puts $fd &#34;### EAP FAILURE TYPE &#34;
	puts $fd &#34;                    elif code == EAP_FAILURE:&#34;
	puts $fd &#34;                          print \&#34;&lt;-- Got EAP Failure\&#34; &#34;
   puts $fd &#34;                          count1 = 0 &#34;
   puts $fd &#34;                          count2 = 0 &#34;
	puts $fd &#34;                          break &#34;
	puts $fd &#34;                    elif code == EAP_RESPONSE:  &#34;
	puts $fd &#34;                          print \&#34;?? Got EAP Response\&#34; &#34;
	puts $fd &#34;### EAP IDENTITY REQUEST &#34;
	puts $fd &#34;                    elif code == EAP_REQUEST:&#34;
	puts $fd &#34;                          reqtype = unpack(\&#34;!B\&#34;, p\[8:9\])\[0\] &#34;
	puts $fd &#34;                          reqdata = p\[9:4+eaplen\]  &#34;
	puts $fd &#34;                          if reqtype == EAP_TYPE_ID: &#34;
	puts $fd &#34;                                print \&#34;&lt;--Got EAP Request for identity\&#34;  &#34;
   puts $fd &#34;                                count1 = count1 + 1 &#34;
   puts $fd &#34;                                if count1 &lt; 2: &#34;      
	puts $fd &#34;                                    s.send(llhead+ &#34;
	puts $fd &#34;                                       EAPOL(EAPOL_EAPPACKET, &#34;
	puts $fd &#34;                                              EAP(EAP_RESPONSE, &#34;
	puts $fd &#34;                                                            id,  &#34;
	puts $fd &#34;                                                       reqtype,  &#34;
	puts $fd &#34;                                                          USER))) &#34;
	puts $fd &#34;                                    print \&#34;--&gt; Sent EAP response with identity = \[%s\]\&#34; % USER &#34;
   puts $fd &#34;                                else: &#34;
   puts $fd &#34;                                    print \&#34;&lt;-- Duplicate Packet Received - EAP Identity Request\&#34;&#34;  
	puts $fd &#34;                          elif reqtype == EAP_TYPE_MD5: &#34;
	puts $fd &#34;### EAP MD5 Challenge and Response Handling &#34;
	puts $fd &#34;                              print \&#34;&lt;-- Got EAP Request for MD5 challenge\&#34; &#34;
   puts $fd &#34;                              count2 = count2 + 1 &#34;
   puts $fd &#34;                              if count2 &lt; 2: &#34;
	puts $fd &#34;                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]&#34;
	puts $fd &#34;                                resp=md5(challenge).digest() &#34;
	puts $fd &#34;                                resp=chr(len(resp))+resp &#34;
	puts $fd &#34;                                s.send(llhead+   &#34;
	puts $fd &#34;                                       EAPOL(EAPOL_EAPPACKET,&#34;
	puts $fd &#34;                                       EAP(EAP_RESPONSE, &#34;
	puts $fd &#34;                                                     id,&#34;
	puts $fd &#34;                                                reqtype,&#34;
	puts $fd &#34;                                              resp+USER)))&#34;
	puts $fd &#34;                                print \&#34;--&gt; Send EAP response with MD5 challenge\&#34; &#34;
   puts $fd &#34;                              else: &#34;
   puts $fd &#34;                                print \&#34;&lt;-- Duplicate Packet Received - EAP MD5 Challenge Request\&#34; &#34;
	puts $fd &#34;                          elif reqtype == EAP_TYPE_TLS: &#34;
	puts $fd &#34;### EAP TLS - Under Research &#34;
	puts $fd &#34;                                print \&#34;Got EAP Request for TLS Handshake\&#34; &#34;
	puts $fd &#34;                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]  &#34;
	puts $fd &#34;                                resp=md5(challenge).digest() &#34;
	puts $fd &#34;                                resp=chr(len(resp))+resp &#34;
	puts $fd &#34;                                s.send(llhead+   &#34;
	puts $fd &#34;                                       EAPOL(EAPOL_EAPPACKET,   &#34;
	puts $fd &#34;                                       EAP(EAP_RESPONSE,    &#34;
	puts $fd &#34;                                                     id,   &#34;
	puts $fd &#34;                                                reqtype,   &#34;
	puts $fd &#34;                                              resp+USER))) &#34;
	puts $fd &#34;                                print \&#34;--&gt; Send EAP response with TLS Handshake\&#34; &#34;
	puts $fd &#34;                          else: &#34;
	puts $fd &#34;                                print \&#34;?? Got unknown Request type (%i)\&#34; % reqtype&#34;
	puts $fd &#34;                    else: &#34;
	puts $fd &#34;                          print \&#34;?? Got unknown EAP code (%i)\&#34; % code&#34;
	puts $fd &#34;            else: &#34;
	puts $fd &#34;                print \&#34;Got EAPOL type %i\&#34; % type &#34;
	puts $fd &#34;        else: &#34;
	puts $fd &#34;            print \&#34;------&gt; Neglecting - Got Packet with Different Ethertype\&#34;,ether &#34;
   puts $fd &#34;            count3 = count3 + 1&#34;
   puts $fd &#34;            if count3 &gt; 20:&#34;
   puts $fd &#34;                break&#34;         
	puts $fd &#34;except KeyboardInterrupt:&#34;
	puts $fd &#34;    print \&#34;Interrupted by user\&#34;&#34;
	puts $fd &#34;except timeout: &#34;
	puts $fd &#34;    print \&#34;!!!  Exiting due to timeout - No response received\&#34;&#34;
    close $fd
    <a name="::CheckTftpPut(1)"><a href="./SendSwCmd.tcl.html#::CheckTftpPut_2435">::CheckTftpPut</a></a> &#34;$filesToUpload&#34;
    if {[<a name="::CheckTftpGetMulti(6)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
    <a name="::result_debug(182)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Dot1x Client Python File Did Not Download Correctly&#34;
   }
}

<span class="comment-line">##################### REAUTHENTICATION Scenario</span>

<strong><a name="::::Dot1x_Reauth_Client_6156">proc <a href="NetloginLib.tcl-annot.html#::::Dot1x_Reauth_Client">::::Dot1x_Reauth_Client</a></a></strong> {testNo {dut &#34;2&#34;}} {

    set filesToUpload &#34;&#34;
    set filesToDownload &#34;&#34;
    lappend filesToUpload &#34;Tmp/$testNo&#34;
    lappend filesToDownload &#34;$testNo&#34;
    set fd [open &#34;Tmp/$testNo&#34; &#34;w&#34;]
    puts $fd &#34;######################################################################################################## &#34;
	puts $fd &#34;######################################################################################################## &#34;
	puts $fd &#34;# &#34;
	puts $fd &#34;#                                        DOT1X Client Program &#34;
	puts $fd &#34;# &#34;
	puts $fd &#34;# -----------------------------------------Pre Requirements -------------------------------------------- &#34;
	puts $fd &#34;# &#34;
	puts $fd &#34;#            **Generate the name of the Interface with vlan_name\[5\]_{snmpvalue in hex} &#34;
	puts $fd &#34;#            **Ensure the Vlan is created prior and an active port is added &#34;
	puts $fd &#34;#            **Assign IP to the vlan and enable ip forwarding - Though we are dealing with L2 packets &#34;
	puts $fd &#34;#            **the CPU will LIFT the packet only for a L3 interface hence assign an IP to the Vlan &#34;
	puts $fd &#34;#            ****** The CPU lifts the L2 packets when DHCP is enabled in the interface -Update 20 Jan &#34;
	puts $fd &#34;######################################################################################################## &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;#!/usr/bin/python &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;from socket import * &#34;
	puts $fd &#34;from struct import * &#34;
	puts $fd &#34;from md5 import * &#34;
	puts $fd &#34;from sys import * &#34;
	puts $fd &#34;import time &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Argument Settings &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;try: &#34;
	puts $fd &#34;    Username = argv\[1\] &#34;
	puts $fd &#34;    Password = argv\[2\] &#34;
	puts $fd &#34;    interface = argv\[3\] &#34;
	puts $fd &#34;except: &#34;
	puts $fd &#34;    print \&#34;The Username or Password or Interface is not specified correctly: exiting !!!\&#34; &#34;
	puts $fd &#34;    print \&#34;Usage: python &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt;\&#34; &#34;
	puts $fd &#34;    exit() &#34;
	puts $fd &#34;logoff = 0 &#34;
   puts $fd &#34;reauth = 0 &#34;
	puts $fd &#34;if len(argv) &gt; 4: &#34;
	puts $fd &#34;    try: &#34;
	puts $fd &#34;        operation = argv\[4\] &#34;
	puts $fd &#34;        timer = argv\[5\] &#34;
	puts $fd &#34;        if operation == \&#34;logout\&#34;: &#34;
	puts $fd &#34;            print \&#34;Dot1x process start with logout operation at interval:\&#34;,timer &#34;
	puts $fd &#34;### LOGOFF Scenario &#34;
	puts $fd &#34;            logontime = timer &#34;
	puts $fd &#34;            logoff = 1 &#34;
	puts $fd &#34;        elif operation == \&#34;reauth\&#34;: &#34;
	puts $fd &#34;            print \&#34;Dot1x process start with reauthentication operation at interval:\&#34;,timer &#34;
	puts $fd &#34;### Re Authentication &#34;
	puts $fd &#34;            reauth = 1 &#34;
	puts $fd &#34;            reauth_time = timer &#34;
	puts $fd &#34;        else: &#34;
	puts $fd &#34;            print \&#34;Invalid Operation Exiting\&#34; &#34;
	puts $fd &#34;            print \&#34;Usage: load script &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt; &lt;operation name: logout\\reauth&gt; &lt;time interval&gt;\&#34; &#34;
	puts $fd &#34;            exit() &#34;
	puts $fd &#34;    except: &#34;
	puts $fd &#34;        print \&#34;Wrong Usage: Arguments &lt;Operation&gt; and &lt;Timer&gt; are not specified correctly !!!\&#34; &#34;
	puts $fd &#34;        print \&#34;Usage: load script &lt;script_name&gt; &lt;username&gt; &lt;password&gt; &lt;interface_name&gt; &lt;operation name: logout\\reauth&gt; &lt;time interval&gt;\&#34; &#34;
	puts $fd &#34;        exit() &#34;
	puts $fd &#34;         &#34;
	puts $fd &#34;else: &#34;
	puts $fd &#34;    print \&#34;Proceeding with Dot1x authtication with no special operation like logout or reauth\&#34; &#34;
	puts $fd &#34;               &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;###  Authentication parameters &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;USER = Username &#34;
	puts $fd &#34;PASS = Password &#34;
	puts $fd &#34;DEV = interface &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Constants &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;ETHERTYPE_PAE = 0x888e &#34;
	puts $fd &#34;PAE_GROUP_ADDR = \&#34;\\x01\\x80\\xc2\\x00\\x00\\x03\&#34; &#34;
	puts $fd &#34;ETH_P_ALL=0x0003 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;EAPOL_VERSION = 1 &#34;
	puts $fd &#34;EAPOL_EAPPACKET = 0 &#34;
	puts $fd &#34;EAPOL_START = 1 &#34;
	puts $fd &#34;EAPOL_LOGOFF = 2 &#34;
	puts $fd &#34;EAPOL_KEY = 3 &#34;
	puts $fd &#34;EAPOL_ASF = 4 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;EAP_REQUEST = 1 &#34;
	puts $fd &#34;EAP_RESPONSE = 2 &#34;
	puts $fd &#34;EAP_SUCCESS = 3 &#34;
	puts $fd &#34;EAP_FAILURE = 4 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;EAP_TYPE_ID = 1 &#34;
	puts $fd &#34;EAP_TYPE_MD5 = 4 &#34;
	puts $fd &#34;EAP_TYPE_TLS = 4 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;count1 = 0 &#34;
   puts $fd &#34;count2 = 0 &#34;
   puts $fd &#34;count3 = 0 &#34;
   puts $fd &#34; &#34;
   puts $fd &#34;EXTREME_SO_VRID = 37 &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Packet builders &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;def EAPOL(type, payload=\&#34;\&#34;): &#34;
	puts $fd &#34;    return pack(\&#34;!BBH\&#34;, EAPOL_VERSION, type, len(payload))+payload &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;def EAP(code, id, type=0, data=\&#34;\&#34;): &#34;
	puts $fd &#34;    if code in \[EAP_SUCCESS, EAP_FAILURE\]: &#34;
	puts $fd &#34;        return pack(\&#34;!BBH\&#34;, code, id, 4) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;    else: &#34;
	puts $fd &#34;        return pack(\&#34;!BBHB\&#34;, code, id, 5+len(data), type)+data &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;def ethernet_header(src, dst, type): &#34;
	puts $fd &#34;    return dst+src+pack(\&#34;!H\&#34;,type) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Main program &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### L2 RAW Socket Creation and EXOS tweak to work in VR-DEFAULT &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;s=socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) &#34;
	puts $fd &#34;s.setsockopt(SOL_SOCKET, EXTREME_SO_VRID, 2) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Interface binding to listen to the socket&#34;
	puts $fd &#34;s.settimeout(60)&#34;
	puts $fd &#34;s.bind((DEV, 0)) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### Sending EAPOL Start Packet &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;mymac=s.getsockname()\[4\] &#34;
	puts $fd &#34;llhead=ethernet_header(mymac, PAE_GROUP_ADDR, ETHERTYPE_PAE) &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;print \&#34;--&gt; Not Sending EAPOL Start for Reauthention Scenario !!\&#34; &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;### EAP Transaction Start based on the EAP TYPE &#34;
	puts $fd &#34; &#34;
	puts $fd &#34;try:&#34;
	puts $fd &#34;    while 1:  &#34;
	puts $fd &#34;        p = s.recv(1600) &#34;
	puts $fd &#34;        ether1, ether2 = unpack(\&#34;!BB\&#34;,p\[16:18\]) &#34;
	puts $fd &#34;        ether = str(hex(ether1)) + str(hex(ether2))\[2:\] &#34;
	puts $fd &#34;        print \&#34;The Ethertype is \&#34;, ether &#34;
	puts $fd &#34;        if ether == hex(ETHERTYPE_PAE): &#34;
	puts $fd &#34;            print \&#34;&lt;-- Got 802.1x Packet with Ethertype\&#34;,ether &#34;
	puts $fd &#34;            p = p\[18:\] &#34;
	puts $fd &#34;            vers,type,eapollen  = unpack(\&#34;!BBH\&#34;,p\[:4\]) &#34;
	puts $fd &#34;            if type == EAPOL_EAPPACKET: &#34;
	puts $fd &#34;                    code, id, eaplen = unpack(\&#34;!BBH\&#34;, p\[4:8\]) &#34;
	puts $fd &#34;### EAP SUCCESS TYPE &#34;
	puts $fd &#34;                    if code == EAP_SUCCESS: &#34;
	puts $fd &#34;                          print \&#34;&lt;-- Got EAP Success\&#34; &#34;
	puts $fd &#34;                          count1 = 0 &#34;
   puts $fd &#34;                          count2 = 0 &#34;
   puts $fd &#34;                          if logoff == 1: &#34;
	puts $fd &#34;                              time.sleep(float(logontime))&#34;
	puts $fd &#34;                              s.send(llhead+EAPOL(EAPOL_LOGOFF)) &#34;
   puts $fd &#34;                              print \&#34;--&gt; Operation: Logout --&gt; Sent EAP Logout after delay\&#34;&#34;  
   puts $fd &#34;                              break&#34;     
   puts $fd &#34;                          elif reauth == 1: &#34;    
   puts $fd &#34;                              print \&#34;Operation: Reauthentication &lt;-- Listening until Reauth expires\&#34;&#34;
   puts $fd &#34;                              time.sleep(float(reauth_time)) &#34;           
   puts $fd &#34;                              print \&#34;--&gt; Reauthentication started -- Waiting for Reauth Packet\&#34;&#34;
   puts $fd &#34;                              reauth = 0&#34;
   puts $fd &#34;                          else: &#34;
	puts $fd &#34;                              break &#34;
	puts $fd &#34;### EAP FAILURE TYPE &#34;
	puts $fd &#34;                    elif code == EAP_FAILURE:&#34;
	puts $fd &#34;                          print \&#34;&lt;-- Got EAP Failure\&#34; &#34;
   puts $fd &#34;                          count1 = 0 &#34;
   puts $fd &#34;                          count2 = 0 &#34;
	puts $fd &#34;                          break &#34;
	puts $fd &#34;                    elif code == EAP_RESPONSE:  &#34;
	puts $fd &#34;                          print \&#34;?? Got EAP Response\&#34; &#34;
	puts $fd &#34;### EAP IDENTITY REQUEST &#34;
	puts $fd &#34;                    elif code == EAP_REQUEST:&#34;
	puts $fd &#34;                          reqtype = unpack(\&#34;!B\&#34;, p\[8:9\])\[0\] &#34;
	puts $fd &#34;                          reqdata = p\[9:4+eaplen\]  &#34;
	puts $fd &#34;                          if reqtype == EAP_TYPE_ID: &#34;
	puts $fd &#34;                                print \&#34;&lt;--Got EAP Request for identity\&#34;  &#34;
   puts $fd &#34;                                count1 = count1 + 1 &#34;
   puts $fd &#34;                                if count1 &lt; 2: &#34;      
	puts $fd &#34;                                    s.send(llhead+ &#34;
	puts $fd &#34;                                       EAPOL(EAPOL_EAPPACKET, &#34;
	puts $fd &#34;                                              EAP(EAP_RESPONSE, &#34;
	puts $fd &#34;                                                            id,  &#34;
	puts $fd &#34;                                                       reqtype,  &#34;
	puts $fd &#34;                                                          USER))) &#34;
	puts $fd &#34;                                    print \&#34;--&gt; Sent EAP response with identity = \[%s\]\&#34; % USER &#34;
   puts $fd &#34;                                else: &#34;
   puts $fd &#34;                                    print \&#34;&lt;-- Duplicate Packet Received - EAP Identity Request\&#34;&#34;  
	puts $fd &#34;                          elif reqtype == EAP_TYPE_MD5: &#34;
	puts $fd &#34;### EAP MD5 Challenge and Response Handling &#34;
	puts $fd &#34;                              print \&#34;&lt;-- Got EAP Request for MD5 challenge\&#34; &#34;
   puts $fd &#34;                              count2 = count2 + 1 &#34;
   puts $fd &#34;                              if count2 &lt; 2: &#34;
	puts $fd &#34;                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]&#34;
	puts $fd &#34;                                resp=md5(challenge).digest() &#34;
	puts $fd &#34;                                resp=chr(len(resp))+resp &#34;
	puts $fd &#34;                                s.send(llhead+   &#34;
	puts $fd &#34;                                       EAPOL(EAPOL_EAPPACKET,&#34;
	puts $fd &#34;                                       EAP(EAP_RESPONSE, &#34;
	puts $fd &#34;                                                     id,&#34;
	puts $fd &#34;                                                reqtype,&#34;
	puts $fd &#34;                                              resp+USER)))&#34;
	puts $fd &#34;                                print \&#34;--&gt; Send EAP response with MD5 challenge\&#34; &#34;
   puts $fd &#34;                              else: &#34;
   puts $fd &#34;                                print \&#34;&lt;-- Duplicate Packet Received - EAP MD5 Challenge Request\&#34; &#34;
	puts $fd &#34;                          elif reqtype == EAP_TYPE_TLS: &#34;
	puts $fd &#34;### EAP TLS - Under Research &#34;
	puts $fd &#34;                                print \&#34;Got EAP Request for TLS Handshake\&#34; &#34;
	puts $fd &#34;                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]  &#34;
	puts $fd &#34;                                resp=md5(challenge).digest() &#34;
	puts $fd &#34;                                resp=chr(len(resp))+resp &#34;
	puts $fd &#34;                                s.send(llhead+   &#34;
	puts $fd &#34;                                       EAPOL(EAPOL_EAPPACKET,   &#34;
	puts $fd &#34;                                       EAP(EAP_RESPONSE,    &#34;
	puts $fd &#34;                                                     id,   &#34;
	puts $fd &#34;                                                reqtype,   &#34;
	puts $fd &#34;                                              resp+USER))) &#34;
	puts $fd &#34;                                print \&#34;--&gt; Send EAP response with TLS Handshake\&#34; &#34;
	puts $fd &#34;                          else: &#34;
	puts $fd &#34;                                print \&#34;?? Got unknown Request type (%i)\&#34; % reqtype&#34;
	puts $fd &#34;                    else: &#34;
	puts $fd &#34;                          print \&#34;?? Got unknown EAP code (%i)\&#34; % code&#34;
	puts $fd &#34;            else: &#34;
	puts $fd &#34;                print \&#34;Got EAPOL type %i\&#34; % type &#34;
	puts $fd &#34;        else: &#34;
	puts $fd &#34;            print \&#34;------&gt; Neglecting - Got Packet with Different Ethertype\&#34;,ether &#34;
   puts $fd &#34;            count3 = count3 + 1&#34;
   puts $fd &#34;            if count3 &gt; 20:&#34;
   puts $fd &#34;                break&#34;         
	puts $fd &#34;except KeyboardInterrupt:&#34;
	puts $fd &#34;    print \&#34;Interrupted by user\&#34;&#34;
	puts $fd &#34;except timeout: &#34;
	puts $fd &#34;    print \&#34;!!!  Exiting due to timeout - No response received\&#34;&#34;
    close $fd
    <a name="::CheckTftpPut(2)"><a href="./SendSwCmd.tcl.html#::CheckTftpPut_2435">::CheckTftpPut</a></a> &#34;$filesToUpload&#34;
    if {[<a name="::CheckTftpGetMulti(7)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$filesToDownload&#34; py ] == &#34;illegal&#34;} {
    <a name="::result_debug(183)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipped: Dot1x Client Python File Did Not Download Correctly&#34;
   }
}

<span class="comment-line">###########################################################################</span>
<span class="comment-line">### Procedure Name: Interface</span>
<span class="comment-line">###</span>
<span class="comment-line">### Description: Retrieves the Interface name for the resp Vlan created</span>
<span class="comment-line">###</span>
<span class="comment-line">### Sample Usage:</span>
<span class="comment-line">###  Interface &lt;Vlan Name&gt;</span>
<span class="comment-line">###</span>
<span class="comment-line">###  Output : returns the Interface name for the respective Vlan</span>
<span class="comment-line">###</span>
<span class="comment-line">###  Usage of Python script: Interface v1</span>
<span class="comment-line">##</span>
<span class="comment-line">##############################################################################</span>

<strong><a name="::::Interface_6414">proc <a href="NetloginLib.tcl-annot.html#::::Interface">::::Interface</a></a></strong> { Vlan } {

set parameterList &#34;&#34;
lappend parameterList &#34;{vlanNameInkernel:} 1&#34;
set interface [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;debug vlan show vlan $Vlan&#34; $parameterList]
return $interface
unset parameterList
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
