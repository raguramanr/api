
############################ IXIA SPECIFIC FUNCTIONS #######################
#
# Procedures that issue commands only to IXIA
#
# proc nl_ixInit
# proc nl_ixGetLogs
# proc nl_ixGetIfMacs
# proc nl_ixGetPortIdMacs
# proc nl_ixCreatePortIfs
# proc nl_ixConfigDot1xPorts 
# proc nl_ixConfigDot1xPortOnly
# proc nl_ixAddSupplicantToPort
# proc nl_ixStartSupAuth
# proc nl_ixStopSupAuth
# proc nl_ixDestroyDot1xPorts
# proc nl_ixCheckPortGroupStats 
# proc nl_ixStartAuth
# proc nl_ixStopAuth
# proc nl_ixDumpInterfaceInfo
# proc nl_ixVerifySupplicantAccess
# proc nl_ixVerifyMultiSupplicantAccess
# proc nl_ixSendIpTraffic
# proc nl_ixStartEapolFlood 
# proc nl_ixStopTx
# proc nl_ixStopEapolFlood
# proc nl_ixDumpSupplicantStats
# proc nl_ixCheckPing
# proc nl_ixSendPing
# proc nl_ixCheckDHCPBroadcastBlocked
# proc nl_ixDelSupMac

# ########################## EXTREME SPECIFIC SWITCH FUNCTIONS #######################
#
# Procedures that issue commands only to DUT
#
# proc nl_exEnableNetloginPort
# proc nl_exGetNetloginVal
# proc nl_exVerifyPortAuth
# proc nl_exVerifyMacAuth
# proc nl_exVerifyShowNetlogin
# proc nl_exVerifyShowNetloginPorts
# proc nl_exVerifyShowSession
# proc nl_exStandardVlanConfig 
# proc nl_exRestartPort
#
# ########################## EXTREME + IXIA ############################
#
# Procedures that issue commands to DUT and IXIA
#
# proc nl_CheckARPBroadcastBlocked
# proc nl_VerifyProtocol
# proc nl_VerifyDHCPBootPRelay


# ########################## GENERAL FUNCTIONS ############################
#
# General purpose procedures that do not issue commands to either DUT or Ixia
#
# proc nl_stripMac
# proc nl_VerifySupplicantPackets
# proc nl_VerifySupplicantEAPPackets
# proc nl_VerifyTaggedPackets
# proc nl_SkipTestBasedOnPlatform
# proc nl_CheckDot1xTaskCrash

# ############################## INTERNAL LIBRARY FUNCTIONS ###########################
#
# Procedures internal to NetloginLib that should not be called by the user 
#
# proc _ixStreamConfig
# proc _ixSeedFdbTable
# proc _ixCreateMultiSupplicantStreams
# proc _ixVerifyMultiSupplicantAccess
# proc _ixVerifySupplicantAccess
# proc _ixWaitForAuth
# proc _ixWaitForDeauth
# proc _ixWaitForSupAuth
# proc _reportVerifyProtocolResult
# proc _verifyEDP
# proc _verifySTP
# proc _verifyRIP
# proc _verifyOSPF
# proc _verifyIGMP
# proc _exCheckMatch
# proc _exMacMatch
# proc _exVerifyShowNetlogin
# proc _exVerifyShowNetloginPorts


#                           TYPICAL TOPOLOGY
#                           ----------------
#
# We verify traffic by sending IP frames from supplicants to
# target and back.
#
#        IXIA
#   supMac1/supIp1                                    DUT1
#   supMac2/supIp2                       +--------------------------+  
#   supMac3/supIp3 -----------supPortId--| gwIp           (vlan_1)  |
#   supMacX/supIpX                       |                          |
#                                        |                          |
# targetMac/targetIp ------targetPortId--| targetPortGwIp (vlan_2)  |
#                                        |   t1  t2                 |  
#                                        +----+--+-----+------------+
#                                             |  |     |       
#                                             |  |     |
#                                             |  |     +--commvlan------> RADIUS
#                                             |  |           |
#                                             |  |     DUT2  |
#                                        +----+--+-----------+------+
#                                        |   t1  t2                 |
#                                        |                          |
#                                        |                          |
#                                        |                          |
#                                        |                          |
#                                        +--------------------------+
#
# NOTES: Writing Port Configuration to Ixia causes port to go down, and
#        thus Deauthenticate port. Writing Stream Config does not 
#        bring port down.


################################################################## 
# Procedure Name: nl_ixInit
#   
# Description: Connects to IXIA chassis and defaults the ports.
#              Chassis must be running IxOS 3.65 or higher
# 
# Input args: chassis: IP Address of Ixia chassis to connect to
#
# Output args: none
##################################################################
proc nl_ixInit { chassis } {

    result_debug "\nIxTclHAL version   :[version cget -ixTclHALVersion]"
    result_debug "Product version    :[version cget -productVersion]"
    result_debug "Installed version  :[version cget -installVersion]"

    if {[ isUNIX ]} {
        set errMsg ""
        dot1xUtil::connectToTclServer  $chassis errMsg
    }
}


################################################################## 
# Procedure Name: nl_ixGetLogs
#   
# Description: Retreives DOT1x Logs for a set of ports.
# 
# Input args: portIdList: ID of ports to retrieve logs from
#             filename:   Filename to store logs in
#
# Output args: none
#
# NOTES: 02/03/04: This does NOT work when running script outside
#                  of Ixia chassis.  Ixia to fix.
##################################################################
proc nl_ixGetLogs { portIdList filename } {
    
    set portList [list]

    foreach portId $portIdList {
	MapIxiaPortId $portId chassis card port
	lappend portList "$chassis $card $port"
    }

    result_debug "Retrieving logs for $portList and putting in [pwd]/$filename"

    dot1xGetLogs portList $filename
    
    result_debug "Exiting nl_ixGetLogs"
}



################################################################## 
# Procedure Name: nl_ixGetIfMacs
#   
# Description: Retreives all the Macs on a ch/ca/po
# 
# Input args: ch(assis) ca(rd) po(rt)
#
# Output args: List of MAC interfaces created on this port.
#
##################################################################
proc nl_ixGetIfMacs { ch ca po } {

    set macList [list]

    interfaceTable select $ch $ca $po

    ;# Walk through interfaceTable!
    for {set curIf [interfaceTable getFirstInterface]} \
	    {$curIf == 0 } {set curIf [interfaceTable getNextInterface]} {
	set mac [interfaceEntry cget -macAddress]
	lappend macList $mac
    }
    return $macList
}

################################################################## 
# Procedure Name: nl_ixGetPortIdMacs
#   
# Description: Retreives all the Macs on a given portID
# 
# Input args: portId: Which port Id to retreive
#
# Output args: List of MAC interfaces created on this port.
#
##################################################################
proc nl_ixGetPortIdMacs { portId } {

    MapIxiaPortId $portId ch ca po

    return [nl_ixGetIfMacs $ch $ca $po]
}



################################################################## 
# Procedure Name: nl_ixCreatePortIfs
#   
# Description: Configure port interfaces.  Each interface (or supplicant)
#              has a MAC and IP address. Before you can configure supplicants
#              and supTable, you need to create the "virtual" interfaces
#              representing these supplicants.
# 
# Input args: -portInfoList: List of ports to create interfaces on
#                 <portId> <startIp> <gw> <numSupplicants> <vlanId*>
#                    *vlanId is optional 
#             -startMacAddr: First 3 octets of MAC.  Last three are 
#                            generated as card:port:count  
#               *If 6 octets are given, we just increment starting from there
#
# Output args: None
#
#  Typical Usage:
#    lappend portInfoList "1 10.1.1.1 10.1.1.254 8"
#    lappend portInfoList "2 10.1.1.1 10.1.1.254 1"
#    nl_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr "00 00 01"
#    nl_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr "00 00 01 11 22 33"
#
##################################################################
proc nl_ixCreatePortIfs {args} {
    parse_args nl_setupPortInterfaces $args {
	portInfoList "1  10.1.1.1  10.1.1.254  1"
	startMacAddr "00 00 01"    ;# Last 3 octets are CARD:PORT:COUNT 
	protocolServer "disable"
    }

    set portList [list]

    ;# List of port intf {{<port> <IP> <MAC>} ... }
    set ifInfoList [list]

    ;# Configure interfaces for each port
    foreach port $portInfoList {

	set portId [lindex $port 0]
	MapIxiaPortId [lindex $portId 0] ch ca po

	set portStartIpAddr [lindex $port 1]
	set portGwIpAddr [lindex $port 2]
	set numSupplicants [lindex $port 3]
	set vlanId [lindex $port 4]

	;# Create a portList
	lappend portList "$ch $ca $po"

	result_debug "portStartIpAddr:$portStartIpAddr  \
		portGwIpAddr:$portGwIpAddr numSupplicants:$numSupplicants" 

	;# Default each port before configuring
         # commented as it affects the fiber ports and brings them up
         # as copper ports and links go down; In watch state Subrat
        if {0} { 
        if [port setFactoryDefaults $ch $ca $po] {
            result_debug "WARNING: port setFactoryDefaults $ch $ca $po failed"
	    continue
        }
            result_debug "WARNING: port setFactoryDefaults $ch $ca $po "
        }

	set incrOctet 4
	interfaceTable  select  $ch $ca $po
	
	interfaceTable clearAllInterfaces
	interfaceEntry clearAllItems addressTypeIpV6
	interfaceEntry clearAllItems addressTypeIpV4
	
	set ipAddressForThisInterface $portStartIpAddr

	set gCount 1
	for {set count 1} {$count <= $numSupplicants} {incr count} {

	    if {[string length $startMacAddr] == 8} {
		;# Normal case
		set curMac "$startMacAddr [format "%02x %02x %02x" $ca $po $gCount]"
	    } else {
		set curMac [IncMacByOne $startMacAddr " "]
		set startMacAddr $curMac
	    }
	    set ifInfoEntry [list $portId $ipAddressForThisInterface $curMac]
	    lappend ifInfoList $ifInfoEntry

	    result_debug "ipAddressForThisInterface: $ipAddressForThisInterface MAC: $curMac"
	    
	    interfaceIpV4   setDefault
	    interfaceIpV4   config      -gatewayIpAddress  $portGwIpAddr
	    interfaceIpV4   config      -maskWidth         24
	    interfaceIpV4   config      -ipAddress         $ipAddressForThisInterface

	    interfaceEntry  addItem     addressTypeIpV4	    
	    interfaceEntry  setDefault
	    interfaceEntry  config      -enable            $::true
	    interfaceEntry  config      -description       [format "%02d:%02d - $count" $ca $po]
	    interfaceEntry  config      -macAddress        $curMac

	    if {$vlanId != "" } {
		interfaceEntry  config      -enableVlan         $::true
		interfaceEntry  config      -vlanId             $vlanId
	    } else {
		interfaceEntry  config      -enableVlan         $::false
		interfaceEntry  config      -vlanId             0
	    }
	    interfaceTable  addInterface
	    
	    if {$protocolServer == "enable"} {
		protocolServer  config      -enableArpResponse  $::true
		protocolServer  config      -enablePingResponse $::true
		if [protocolServer  set $ch $ca $po] {
		    result_debug "ERROR : protocolServer  set $ch $ca $po"
		}
	    }

	    set ipAddressForThisInterface [incrIpField $ipAddressForThisInterface $incrOctet]
	    incr gCount
	}
    }
    result_debug "Writing portList $portList to hardware."

    ixWritePortsToHardware portList

    ;# Dump some info for debugging.
    ;# nl_ixDumpInterfaceInfo

    return $ifInfoList
}


################################################################## 
# Procedure Name: nl_ixDestroyPortIfs
#   
# Description: Destroy all port interface on a port.  Actually we just
#              default the entire port
#
# Input args: -portInfoList: List of ports to default
#
################################################################## 
proc nl_ixDestroyPortIfs {args} {
    parse_args nl_setupPortInterfaces $args {
	portInfoList "1"
    }

    set portList [list]

    ;# Configure interfaces for each port
    foreach port $portInfoList {

	set portId [lindex $port 0]
        set ipAddr [lindex $port 1]
	MapIxiaPortId [lindex $portId 0] ch ca po
        DisableProtocolServer $portId $ipAddr

	;# Default each port
        if {0} {
        if [port setFactoryDefaults $ch $ca $po] {
            result_debug "WARNING: port setFactoryDefaults $ch $ca $po failed"
	    continue
        }
        }
    }
}


################################################################## 
# Procedure Name: nl_ixConfigDot1xPorts
#   
# Description: Configures Ports for Dot1X.  Uses interfaces created on each 
#              port to configure supplicants.  All supplicants for a particular 
#              port group will have the same parameters. 
#
# Input args: 
#	portGroupId        ;# Dot1x port group
#	portIdList         ;# Port mapping ID
#	authPeriod         ;# Secs to wait for DUT response 1-3600
#	heldPeriod         ;# Secs after timeout before sending next auth 1-3600
#	startPeriod        ;# Secs between successive EAPOL-Start msgs 1-3600
#	maxStart           ;# Number of EAPOL-Starts before deeming failure 1-10000
# 	fragmentSize       ;# Max frag for EAP TLS packet 500-1400
#	maxSessions        ;# Number sessions for this port
#	setupDelay         ;# Millsec between start of 1 auth to next. 0-4,294,967,295
#	establishDelay     ;# Millsec between completed/failed auth to next multiauth
#	logoffDelay        ;# Millsec delay between successive logoff msgs at teardown
#	dutTestMode        ;# 0 => Single-Host, 1 => Multi-Host, 2=> Multi Auth
#	enableSessionOnly  ;# 0 => Only session, no stream.  We can manually gen stream
#	holdTime           ;# Secs between auth and logoff 0-1,000,000
#	enableRandomHold   ;# 1-Set holdTime to random values
#	enableOnlyMulticastDestMac  ;# 1-Use multicast MAC instead of auth MAC 
#	enableAuthOnNoResponse      ;# 1-Supplicant consider itself auth if no response
#	enableStateMachineDebug     ;# 1- Generate DEBUG LOG
#	enableConfigurationDebug    ;# 1- Generate DEBUG LOG
#	enableEapolFramesDebug      ;# 1- Generate DEBUG LOG  
#	testDuration            ;# Duration of entire test
#	authPass                ;# Password sent for auth	
#	authUser                ;# Username sent for auth
#	dot1xAuth      ;# dot1xAuthMD5,1  dot1xAuthTLS,0
#	dot1xUser      ;# dot1xUserNormal,0 dot1xUserFailing,1 Expect failure.
#	supHoldTime               ;# -1 use port holdTime
#	supNumNoIdResponse        ;# Number of times to suppress EAP-ID msgs 0-100
#	supNumNoAuthResponse      ;# Number of times to suppress EAP-Auth msgs 0-100
#	supEnableWaitIdRequest    ;# "true"-Wait for DUT initiate EAP, rather than sending EAP-start
#       certificateDir            ;# Directory where certificates are located
#	maxSupplicants "          ;# max number of suplicants to add, otherwise 1 per port MAC
#	destroy  "no"             ;# Destroy old port group first
#
# Output args:  None
#
#  Typical Usage:
#    nl_ixConfigDot1xPorts -portIdList "1" -portGroupId "1" \
#	   -authUser $uname -authPass $upass
#
##################################################################
proc nl_ixConfigDot1xPorts {args} {
    parse_args nl_ixConfigDot1x $args {
	portGroupId "1"        
	portIdList "1"         
	authPeriod "15"        
	heldPeriod "10"        
	startPeriod "10"       
	maxStart "3"           
 	fragmentSize "640"     
	maxSessions  "64"      
	setupDelay   "0"       
	establishDelay "1000"  
	logoffDelay "120"       
	dutTestMode  "2"       
	enableSessionOnly "0"
	holdTime "0"
	enableRandomHold "0"
	enableOnlyMulticastDestMac "1"
	enableAuthOnNoResponse "0"
	enableStateMachineDebug "1"
	enableConfigurationDebug "1"
	enableEapolFramesDebug "1"
	testDuration "240"
	authUser  "md5_isp_1"
	authPass  "md5_isp_1"
	dot1xAuth "dot1xAuthMD5"     
	dot1xUser "dot1xUserNormal"  
	supHoldTime "-1"             
	supNumNoIdResponse "0"       
	supNumNoAuthResponse "0"     
	supEnableWaitIdRequest "0"   
        certificateDir "./certfiles" 
	maxSupplicants "0"           
	destroy  "no"                
    }
    
    ;# Generate Ixia portList from IDs
    foreach portId $portIdList {
	MapIxiaPortId $portId chassis card port
	lappend portList "$chassis $card $port"
    }
    result_debug "Establishing communication with port CPUs $portList "

    set status [dot1xSetup $portList]
    if {$status} {
	result_debug "ERROR: Could not set up ports for dot1x status $status"
	return 0
    }

    if {$destroy  == "yes"} {
	;# Destroy old port group
	dot1xPortGroup destroy $portGroupId
    }


    # Create a port Group
    #--------------------
    dot1xPortGroup setDefault
    dot1xPortGroup create $portGroupId
    
    # Setup generic port properties
    #------------------------------
    dot1xPort setDefault
    dot1xPort config -authPeriod        $authPeriod
    dot1xPort config -heldPeriod        $heldPeriod
    dot1xPort config -startPeriod       $startPeriod
    dot1xPort config -maxStart          $maxStart
    dot1xPort config -fragmentSize      $fragmentSize
    dot1xPort config -maxSessions       $maxSessions
    dot1xPort config -setupDelay        $setupDelay
    dot1xPort config -establishDelay    $establishDelay
    dot1xPort config -logoffDelay       $logoffDelay
    dot1xPort config -dutTestMode       $dutTestMode
    dot1xPort config -enableSessionOnly $enableSessionOnly
    dot1xPort config -holdTime          $holdTime
    dot1xPort config -enableRandomHold           $enableRandomHold
    dot1xPort config -enableOnlyMulticastDestMac $enableOnlyMulticastDestMac
    dot1xPort config -enableAuthOnNoResponse     $enableAuthOnNoResponse
    dot1xPort config -enableStateMachineDebug    $enableStateMachineDebug
    dot1xPort config -enableConfigurationDebug   $enableConfigurationDebug
    dot1xPort config -enableEapolFramesDebug     $enableEapolFramesDebug
    dot1xPort config -testDuration               $testDuration
    
    # Create configuration for each port we are interested in
    #--------------------------------------------------------
    foreach testPort $portList {
	
	result_debug "Creating dot1x configuration for the port $testPort"
	
	# Setup individual port
	#----------------------
	scan $testPort "%d %d %d" ch ca po
	dot1xPort set  $ch $ca $po
	dot1xPortGroup add $portGroupId $ch $ca $po
	
	# Cleanup the supplicant table for this port
	#-------------------------------------------
	dot1xSupplicantTable select $ch $ca $po
	dot1xSupplicantTable delAll
	
	# Add supplicants to this port
	#-----------------------------
	set supplicantMacList [nl_ixGetIfMacs $ch $ca $po]
	if {$maxSupplicants > 0} {
	    ;# Only add max count
	    set supplicantMacList [lrange $supplicantMacList 0 [expr $maxSupplicants - 1]]
	}
	
	foreach suppMac $supplicantMacList {

	    dot1xSupplicant setDefault
	    dot1xSupplicant config -macAddr $suppMac
	    dot1xSupplicant config -userType $dot1xUser
	    dot1xSupplicant config -authType $dot1xAuth
	    dot1xSupplicant config -userName $authUser
	    dot1xSupplicant config -passWord $authPass
	    dot1xSupplicant config -holdTime $supHoldTime
	    dot1xSupplicant config -numNoIdResponse $supNumNoIdResponse
	    dot1xSupplicant config -numNoAuthResponse $supNumNoAuthResponse
	    dot1xSupplicant config -enableWaitIdRequest $supEnableWaitIdRequest
	    dot1xSupplicantTable add
	    result_debug "($ch:$ca:$po) Adding MAC:$suppMac u:$authUser p:$authPass authType:$dot1xAuth userType:$dot1xUser"
	    result_debug "($ch:$ca:$po)     numNoIdResponse:$supNumNoIdResponse numNoAuthResponse:$supNumNoAuthResponse"
	    result_debug "($ch:$ca:$po)     enableWaitIdRequest:$supEnableWaitIdRequest"
	}
	    
	# Setup maxsessions
	#------------------
	set aSupplicantCnt [llength $supplicantMacList]
	dot1xPort config -maxSessions $aSupplicantCnt
	dot1xPort set  $ch $ca $po
    }
	

    # All ports have been added to a port group. Now write the entire group
    #----------------------------------------------------------------------
    dot1xPortGroup setCommand $portGroupId writeConfig
    
    # Initialize the stat information for this group
    #-----------------------------------------------
    dot1xPortGroup setCommand $portGroupId resetStats

    result_debug "AuthType is $dot1xAuth"

    if {$dot1xAuth == "dot1xAuthTLS"} {    

	result_debug "Downloading certificates from $certificateDir to ports $portList"

	# Download Certificate files on the port for TLS authentication
	
	# Use this command for downloading all the cert in dir to all ports	
	dot1xDownloadCertificates $portList $certificateDir
	
	# set usernamelist {}
	# lappend usernamelist $authUser
	# Use the command below for individual certificates
	# dot1xDownloadUserSpecificCertificates $ch $ca $po \
		#    "C:\\Program Files\\Ixia\\authfiles" \
		#    "C:\\Program Files\\Ixia\\authfiles" \
		#    $usernamelist
    }

    return 1
}


################################################################## 
# Procedure Name: nl_ixConfigDot1xPortOnly
#   
# Description: Configures Ports for Dot1X.  DOES NOT configure
#              supplicants.  Allows us to configure the ports,
#              THEN configure "custom" supplicants.
#
# Input args:
#	portGroupId         ;# Dot1x port group
#	portIdList          ;# Port mapping ID
#	authPeriod          ;# Secs to wait for DUT response 1-3600
#	heldPeriod          ;# Secs after timeout before sending next auth 1-3600
#	startPeriod         ;# Secs between successive EAPOL-Start msgs 1-3600
#	maxStart            ;# Number of EAPOL-Starts before deeming failure 1-10000
# 	fragmentSize        ;# Max frag for EAP TLS packet 500-1400
#	maxSessions         ;# Number sessions for this port
#	setupDelay          ;# Millsec between start of 1 auth to next. 0-4,294,967,295
#	establishDelay      ;# Millsec between completed/failed auth to next multiauth
#	logoffDelay         ;# Millsec delay between successive logoff msgs at teardown
#	dutTestMode         ;# 0 => Single-Host, 1 => Multi-Host, 2=> Multi Auth
#	enableSessionOnly   ;# 0 => Only session, no stream.  We can manually gen stream
#	holdTime            ;# Secs between auth and logoff 0-1,000,000
#	enableRandomHold    ;# 1-Set holdTime to random values
#	enableOnlyMulticastDestMac   ;# 1-Use multicast MAC instead of auth MAC 
#	enableAuthOnNoResponse    ;# 1-Supplicant consider itself auth if no response
#	enableStateMachineDebug   ;# 1- Generate DEBUG LOG
#	enableConfigurationDebug  ;# 1- Generate DEBUG LOG
#	enableEapolFramesDebug    ;# 1- Generate DEBUG LOG  
#	testDuration              ;# Duration of entire test
#       certificateDir            ;# Directory where certificates are located
#
#
# Output args:  None
#
#  Typical Usage:
#    nl_ixConfigDot1xPortOnly -portIdList "1" -portGroupId "1" \
#	   -authUser $uname -authPass $upass
#
##################################################################
proc nl_ixConfigDot1xPortOnly {args} {
    parse_args nl_ixConfigDot1x $args {
	portGroupId "1"
	portIdList "1"
	authPeriod "15"
	heldPeriod "10"
	startPeriod "10"
	maxStart "3"
 	fragmentSize "640"
	maxSessions  "64"
	setupDelay   "0"
	establishDelay "1000"
	logoffDelay "20"
	dutTestMode  "2"
	enableSessionOnly "0"
	holdTime "0"
	enableRandomHold "0"
	enableOnlyMulticastDestMac "1"
	enableAuthOnNoResponse "0"
	enableStateMachineDebug "1"
	enableConfigurationDebug "1"
	enableEapolFramesDebug "1"
	testDuration "3600"
        certificateDir "./certfiles"
    }
    
    ;# Generate Ixia portList from IDs
    foreach portId $portIdList {
	MapIxiaPortId $portId chassis card port
	lappend portList "$chassis $card $port"
    }
    result_debug "Establishing communication with port CPUs $portList "

    set status [dot1xSetup $portList]
    if {$status} {
	result_debug "ERROR: Could not set up ports for dot1x status $status"
	return 0
    }

    # Create a port Group
    #--------------------
    dot1xPortGroup setDefault
    dot1xPortGroup create $portGroupId
    
    # Setup generic port properties
    #------------------------------
    dot1xPort setDefault
    dot1xPort config -authPeriod        $authPeriod
    dot1xPort config -heldPeriod        $heldPeriod
    dot1xPort config -startPeriod       $startPeriod
    dot1xPort config -maxStart          $maxStart
    dot1xPort config -fragmentSize      $fragmentSize
    dot1xPort config -maxSessions       $maxSessions
    dot1xPort config -setupDelay        $setupDelay
    dot1xPort config -establishDelay    $establishDelay
    dot1xPort config -logoffDelay       $logoffDelay
    dot1xPort config -dutTestMode       $dutTestMode
    dot1xPort config -enableSessionOnly $enableSessionOnly
    dot1xPort config -holdTime          $holdTime
    dot1xPort config -enableRandomHold           $enableRandomHold
    dot1xPort config -enableOnlyMulticastDestMac $enableOnlyMulticastDestMac
    dot1xPort config -enableAuthOnNoResponse     $enableAuthOnNoResponse
    dot1xPort config -enableStateMachineDebug    $enableStateMachineDebug
    dot1xPort config -enableConfigurationDebug   $enableConfigurationDebug
    dot1xPort config -enableEapolFramesDebug     $enableEapolFramesDebug
    dot1xPort config -testDuration               $testDuration
    
    # Create configuration for each port we are interested in
    #--------------------------------------------------------
    foreach testPort $portList {
	
	result_debug "Creating dot1x configuration for the port $testPort"
	
	# Setup individual port
	#----------------------
	scan $testPort "%d %d %d" ch ca po
	dot1xPort set  $ch $ca $po
	dot1xPortGroup add $portGroupId $ch $ca $po	
    }
	
    # Cleanup the supplicant table for this port
    #-------------------------------------------
    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable delAll

    # All ports have been added to a port group. Now write the entire group
    #----------------------------------------------------------------------
    dot1xPortGroup setCommand $portGroupId writeConfig
    
    # Initialize the stat information for this group
    #-----------------------------------------------
    dot1xPortGroup setCommand $portGroupId resetStats

}




################################################################## 
# Procedure Name: nl_ixAddSupplicantToPort
#   
# Description: Once dot1xPort is configured, this procedure can be
#              used to add 1 or more supplicants to that port.
#              Each supplicant can be configured with different
#              parameters
#
# Input args:
#	portId                  ;# Port mapping ID
#	suppMac                 ;# Supplicant MAC
#	authUser                ;# Username
#	authPass                ;# Password
#	dot1xAuth               ;# dot1xAuthMD5,1  dot1xAuthTLS,0
#	dot1xUser               ;# dot1xUserNormal,0 dot1xUserFailing,1 Expect failure.
#	supHoldTime             ;# -1 use port holdTime
#	supNumNoIdResponse      ;# Number of times to suppress EAP-ID msgs (0-100)
#	supNumNoAuthResponse    ;# Number of times to suppress EAP-Auth msgs (0-100)
#	supEnableWaitIdRequest  ;# 1-Wait for DUT initiate EAP, rather than sending EAP-start
#	doWriteHw               ;# Option to write to to Ixia hw now.  Gives user
#                               ;# to do several adds then a single write.
#
# Output args:  None
#
##################################################################
proc nl_ixAddSupplicantToPort {args} {
    parse_args nl_ixAddSupplicantToPort $args {
	portId    1
	suppMac   "00 00 00 00 00 01"
	authUser  "md5_isp_1"
	authPass  "md5_isp_1"
	dot1xAuth "dot1xAuthMD5"
	dot1xUser "dot1xUserNormal"
	supHoldTime "-1"
	supNumNoIdResponse "0"
	supNumNoAuthResponse "0"
	supEnableWaitIdRequest "0"
	doWriteHw  "1"
    }

    MapIxiaPortId $portId ch ca po
    result_debug "Adding Supplicant to $ch $ca $po"

    dot1xSupplicantTable select $ch $ca $po
	
    # Add supplicant to this port
    #-----------------------------
    dot1xSupplicant setDefault
    dot1xSupplicant config -macAddr $suppMac
    dot1xSupplicant config -userType $dot1xUser
    dot1xSupplicant config -authType $dot1xAuth
    dot1xSupplicant config -userName $authUser
    dot1xSupplicant config -passWord $authPass
    dot1xSupplicant config -holdTime $supHoldTime
    dot1xSupplicant config -numNoIdResponse $supNumNoIdResponse
    dot1xSupplicant config -numNoAuthResponse $supNumNoAuthResponse
    dot1xSupplicant config -enableWaitIdRequest $supEnableWaitIdRequest
    dot1xSupplicantTable add
    result_debug "($ch:$ca:$po) Adding MAC:$suppMac u:$authUser p:$authPass authType:$dot1xAuth userType:$dot1xUser"
    result_debug "($ch:$ca:$po)     numNoIdResponse:$supNumNoIdResponse numNoAuthResponse:$supNumNoAuthResponse"
    result_debug "($ch:$ca:$po)     enableWaitIdRequest:$supEnableWaitIdRequest"
    
    if { $doWriteHw == "1" } {
	dot1xSupplicantTable write
    }

}


################################################################## 
# Procedure Name: _ixWaitForSupAuth
#   
# Description: Internal procedure that loops waiting  for a particular 
#              supplicant to authenticate.
#
# Input args: portId: Port ID of supplicants
#             mac: Specific MAC of supplicant to wait for
#             maxAuthWait: Max time to wait
#
# Output args: 0 - Failed to authenticate
#              1 - Authenticate successful
#
##################################################################
proc _ixWaitForSupAuth { portId mac maxAuthWait } {

    MapIxiaPortId $portId ch ca po

    set curDuration 0
    
    while {$curDuration < $maxAuthWait} {
	puts "Waiting for mac $mac to Auth (max:$maxAuthWait)... $curDuration"
	after 1000

	dot1xSupplicantStats get $ch $ca $po $mac
	if { [dot1xSupplicantStats cget -totalSuccess] >= 1 } {
	    break
	}
	incr curDuration 1
    }

    if {$curDuration == $maxAuthWait} {
	result_debug "===== Authentication could not be completed for $mac ====="
	return 0
    }

    nl_ixDumpSupplicantStats $portId $mac 
    return 1

}



################################################################## 
# Procedure Name: nl_ixStartSupAuth
#   
# Description: Wait for a particular supplicant to authenticate.
#              This assumes we reset counters prior to starting since 
#              we check that totalSuccess is greater than 1.
#
# Input args: portId: Port ID of supplicants
#             mac: Specific MAC of supplicant to wait for
#             maxAuthWait: Max time to wait
#
# Output args: 0 - Failed to authenticate
#              1 - Authenticate successful
#
##################################################################
proc nl_ixStartSupAuth { portId mac {maxAuthWait 10} } {

    MapIxiaPortId $portId ch ca po

    ;# Reset stats before starting.
    dot1xSupplicantStats reset $ch $ca $po $mac

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable start $mac
    result_debug "Starting sup $mac"

    if { $maxAuthWait != 0 } {
	if { [_ixWaitForSupAuth $portId $mac $maxAuthWait] == 0 } { 
	    result_debug "Authentication failed for mac $mac...test exiting."
	    return 0
	}
    } else {
	result_debug "Not waiting for authentication of mac $mac..."
    }

    return 1
}


################################################################## 
# Procedure Name: nl_ixStopSupAuth
#   
# Description: Stop a particular supplicant's authenticated session.
#
# Input args: portId: Port ID of supplicants
#             mac: Specific MAC of supplicant to wait for
#             maxAuthWait: Max time to wait
#
##################################################################
proc nl_ixStopSupAuth { portId mac {maxAuthWait 4} } {

    MapIxiaPortId $portId ch ca po

    ;# Reset stats before starting.
    dot1xSupplicantStats reset $ch $ca $po $mac

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable stop $mac
    result_debug "Stopping sup $mac"

    exSleep $maxAuthWait

    return 1
}

################################################################## 
# Procedure Name: nl_ixDelSupMac
#   
# Description: Delete a particular supplicant from supplicant table.
#
# Input args: portId: Port ID of supplicants
#             mac: Specific MAC of supplicant to wait for
#             maxAuthWait: Max time to wait
#
##################################################################
proc nl_ixDelSupMac { portId mac {maxAuthWait 4} {doWriteHw 1}} {

    MapIxiaPortId $portId ch ca po

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable del $mac
    result_debug "Deleting sup $mac"

    if { $doWriteHw == "1" } {
	dot1xSupplicantTable write
    }

    exSleep $maxAuthWait

    return 1
}

################################################################## 
# Procedure Name: nl_ixDestroyDot1xPorts
#   
# Description: Wait for a particular supplicant to authenticate.
#              This assumes we reset counters prior to starting since 
#              we check that totalSuccess is greater than 1.
#
# Input args: -portGroupId: Dot1x port group
#             -portIdList: Port IDs in group to destroy 
#
# Output args: None
#
##################################################################
proc nl_ixDestroyDot1xPorts {args} {
    parse_args nl_ixDestroyDot1x $args {
	portGroupId "1"
	portIdList "1"
    }
    
    ;# Generate Ixia portList from IDs
    foreach portId $portIdList {
	MapIxiaPortId $portId chassis card port
	lappend portList "$chassis $card $port"
    }

    result_debug "Cleaning up DOT1x $portList "

    dot1xPortGroup destroy $portGroupId
    dot1xCleanup $portList
}




################################################################## 
# Procedure Name: nl_ixCheckPortGroupStats
#   
# Description: Check the dot1x port group stats against a particular 
#              value.  Posts actual pass/fail.
#
# Input args: dot1xPortGroupId: dot1x group ID
#             stat: Which stat to compare. See below for values
#             operator: ==, >, <, etc.
#             value: Value to compare against
#
# VALID IXIA stat PARAMETER:
#   allSessionsEstablished, lastStats, 
#   eapolStartSent, eapIdResponseSent, eapolLogoffSent, eapNonIdResponseSent, 
#   eapIdRequestReceived, eapNonIdRequestReceived, eapSuccessReceived, 
#   eapFailureReceived, eapAlertReceived, eapUnExpFailure, 
#   md5Sessions, md5Success, md5FailTimeout, md5FailEap, md5MaxLatency
#   md5MinLatency, md5AvgLatency
#   tlsSessions, tlsSuccess, tlsFailTimeout, tlsFailEap, tlsMaxLatency
#   tlsMinLatency, tlsAvgLatency
#   invSessions, invSuccess, invFailTimeout, invFailEap
#
# Output args: None
#
##################################################################
proc nl_ixCheckPortGroupStats {dot1xPortGroupId stat operator value} {

    dot1xPortGroup setCommand $dot1xPortGroupId getStats
    set curStats [dot1xPortStats cget -$stat]

    report_start_test "Check Port GroupStats $stat:$curStats $operator $value"

    if {! [expr $curStats $operator $value]} {
	result_error "Stats check failed $stat..$curStats $operator $value"
    }
    result_debug "Stat:$stat:$curStats     $operator $value"
    report_end_test

}




################################################################## 
# Procedure Name: _ixWaitForMacAuth
#   
# Description: Internal procedure to wait for all MACs in a group
#              to authenticate.
#
# Input args: mac: Source mac to check for
#             maxAuthWait: Max time in sec to wait
#
# Output args: 
#
##################################################################
proc _ixWaitForMacAuth {maclist maxAuthWait {DUT "1"}} {

    set authStatus "Yes"
    set command "show netlogin"
    set parameterList ""
    foreach mac $maclist {
	lappend parameterList "$mac.*$authStatus exist"
    }
    set okOrError [CheckKeyValue "$command" $parameterList \
	    -reportResults 0 -dut $DUT -time "s: 3 i: 1 d: $maxAuthWait f: $maxAuthWait"]

    if {$okOrError == "ok"} {
	result_debug "===== Authentication completed successfully ====="
	set success 1
    } else {
	result_debug "===== Authentication could not be completed ====="
	set success 0
    }
        
    return $success
}

################################################################## 
# Procedure Name: _ixWaitForAuth
#   
# Description: Internal procedure to wait for all supplicants in a group
#              to authenticate.
#
# Input args: dot1xPortGroupId: dot1x group ID
#             maxAuthWait: Max time in sec to wait
#
# Output args: 
#
##################################################################
proc _ixWaitForAuth {dot1xPortGroupId maxAuthWait} {

    set curDuration 0
    set success 0

    while {$curDuration < $maxAuthWait} {
	puts -nonewline "Waiting(max:$maxAuthWait)... $curDuration                           \r "
	flush stdout
	after 1000
	dot1xPortGroup setCommand $dot1xPortGroupId getStats
	if {[dot1xPortStats cget -allSessionEstablished]} {
	    result_debug "===== Authentication completed successfully ====="
	    set success 1
	    break
	}
	incr curDuration 1
    }

    if {$curDuration == $maxAuthWait} {
	result_debug "===== Authentication could not be completed ====="
	set success 0
    }
    
    ;# Dump out some stats
    dot1xPortGroup setCommand $dot1xPortGroupId getStats
    set eapolStartSent [dot1xPortStats cget -eapolStartSent]
    set eapolLogoffSent [dot1xPortStats cget -eapolLogoffSent]
    set eapolSuccessReceived [dot1xPortStats cget -eapSuccessReceived]
    set eapolFailureReceived [dot1xPortStats cget -eapFailureReceived]
    set eapolAlertReceived [dot1xPortStats cget -eapAlertReceived]
    
    result_debug "eapolStartSent:       $eapolStartSent"
    result_debug "eapolLogoffSent:      $eapolLogoffSent"
    result_debug "eapolSuccessReceived: $eapolSuccessReceived"
    result_debug "eapolFailureReceived: $eapolFailureReceived"
    result_debug "eapolAlertReceived:   $eapolAlertReceived"
    
    return $success
}


################################################################## 
# Procedure Name: _ixWaitForDeauth
#   
# Description: Internal procedure to wait for all supplicants in a group
#              to become unauthenticated.
#
# Input args: dot1xPortGroupId: dot1x group ID
#             maxAuthWait: Max time in sec to wait
#
# Output args: 
#
##################################################################
proc _ixWaitForDeauth {dot1xPortGroupId maxDeauthWait} {

    set curDuration 0
    set success 0

    while {$curDuration < $maxDeauthWait} {
	puts "Waiting(max:$maxDeauthWait)... $curDuration"
	after 1000
	dot1xPortGroup setCommand $dot1xPortGroupId getStats
	if {[dot1xPortStats cget -lastStats]} {
	    result_debug "===== Deauthentication completed normally ====="
	    set success 1
	    break
	}
	incr curDuration 1
    }

    if {$curDuration == $maxDeauthWait} {
	result_debug "===== Deauthentication timed out ====="
	set success 0
    }

    return $success
}



################################################################## 
# Procedure Name: nl_ixStartAuth
#   
# Description: Start authentication for netlogin
#
# Input args: type: mac | dot1x
#             dot1xPortGroupId: dot1x group ID
#             maxAuthWait: Max time in sec to wait
#             expectFailure: Don't dump debug info if we expect auth to fail and it does
#
# Output args: 
#
##################################################################
proc nl_ixStartAuth { maclist args } {
   parse_args nl_ixStartAuth $args {
       type "mac"
       txPortId  "1"
       destMac "default"
       tag "none"
       dot1xPortGroupId "1"
       maxAuthWait  "30"
       expectFailure "no"
   }

   set rc 0
   SendACmd "clear counter"

   if {$maxAuthWait == 0} {
       result_debug "Not waiting for authentication..."
       return 1
   }
   
   result_debug "Started $type Authentications..Max Wait: $maxAuthWait secs."

    if { $type == "dot1x" } {
	dot1xPortGroup setCommand $dot1xPortGroupId resetStats
	dot1xPortGroup setCommand $dot1xPortGroupId startTest
	
	if { $maxAuthWait != 0 } {
	    if { [_ixWaitForAuth $dot1xPortGroupId $maxAuthWait] == 0 } { 
		result_debug "Authentication failed...test exiting."
		if {$expectFailure == "no"} {
		    nl_exDumpDebugInfo	
		}	
		return $rc
	    } else {
		set rc 1
	    }
	}

    } elseif { $type == "mac" } {
	;# For some reason, sometimes if Ixia port is doing something prior to SendFrame
	;# the Tx doesn't work.  This is the reason for the short sleep.

	;# Send a single L2 frame to authenticate port
	foreach mac $maclist {
	    exSleep 2
	    result_debug "Sending frame to $destMac from $mac"
	    set frameSent [SendFrame -txPortId $txPortId -destMac $destMac -sourceMac $mac \
		    -numFrames 10 -percentage 2.0 -tag $tag]
	}
	;# Wait for Radius 
	if { $maxAuthWait != 0 } {
	    if { [set rc [_ixWaitForMacAuth $maclist $maxAuthWait]] == 0 } { 
		result_debug "Authentication failed...test exiting."
		if {$expectFailure == "no"} {
		    nl_exDumpDebugInfo	
		}	
		return $rc
	    } else {
		set rc 1
	    }
	}

    } else {
	result_debug "Unsupported type:$type for ixStartAuth"
	return $rc
    }
    
    return $rc
}


################################################################## 
# Procedure Name: nl_ixStopAuth
#   
# Description: Deauthenticate a dot1x port group
#
# Input args: dot1xPortGroupId: dot1x group ID
#             maxAuthWait: Max time in sec to wait
#
# Output args: 
#
##################################################################
proc nl_ixStopAuth {args} {
   parse_args nl_ixStopAuth $args {
       type "mac"
       dot1xPortGroupId "1"
       maxAuthWait  "30" 
   }

    result_debug "Stopping Authentications..."

    if { $type == "dot1x" } {

	dot1xPortGroup setCommand $dot1xPortGroupId stopTest
	
	if {[_ixWaitForDeauth $dot1xPortGroupId $maxAuthWait] == 0} {
	    result_debug "Deauthentication timeout...test exiting."
	    return 0
	}
    }

}


################################################################## 
# Procedure Name: nl_ixDumpInterfaceInfo
#   
# Description: Debug routine to dump interface info for a port ID
#
# Input args: portId: Port ID.  No port ID dumps ALL ports info
#
# Output args: 
#
##################################################################
proc nl_ixDumpInterfaceInfo {{portId 0}} {

    global portMappingList

    if {$portId == 0} {
	;# Get ALL
	set numIxiaPorts [array size portMappingList]
	set ixiaPortId 1
    } else {
	set numIxiaPorts 1
	set ixiaPortId $portId
    }
 
    ;# Walk through each port to get interface info

    while {$numIxiaPorts} {
	
	MapIxiaPortId $ixiaPortId ch ca po

	interfaceTable select $ch $ca $po

	;# Walk through interfaceTable to see what we got!
	for {set curIf [interfaceTable getFirstInterface]} \
		{$curIf == 0 } {set curIf [interfaceTable getNextInterface]} {
	    
	    puts "($ch:$ca:$po) InterfaceMac: [interfaceEntry cget -macAddress]"
	    ;# Walk through IPv4 entries
	    for {set curIPv4 [interfaceEntry getFirstItem addressTypeIpV4]} \
		    {$curIPv4 == 0} {set curIPv4 [interfaceEntry getNextItem addresTypeIpV4] } {
		puts "     IP:[interfaceIpV4 cget -ipAddress] GW:[interfaceIpV4 cget -gatewayIpAddress]"
	    }
	}
	
	incr ixiaPortId
	incr numIxiaPorts -1
    }    
}



################################################################## 
# Procedure Name: _ixVerifySupplicantAccess
#   
# Description: Internal procedure to verify supplicant has access to 
#              network by sending L2 (ARP) traffic and IP traffic 
#              in both directions.
#              This procedure assumes a default topology similiar
#              to the show at start of file.
#
# Input args: 
#       txPortId - Transmistting port 
#       supMac   - MAC address of supplicant
#       supIp    - IP Address of supplicant
#       gwIp     - Gateway address of supplicant
#       rxPortId - Receiving port.  This is port we capture packets on.
#       rxPortIp - IP Address on receiving port to send to.  We assume 
#                  this is been setup already on the Ixia.
#       rxPortGwIp - Gateway address of interface on receive side.  Needed 
#                    to test traffic going in opposite direction.
#       portFlag - "forwarded" | "notForwarded | egress | ingress"
#       DUT      - DUT we're talking about.  Need to get MAC of DUT, so 
#                  we specify which DUT to use here.
#
# Output args: None
#
##################################################################
proc _ixVerifySupplicantAccess { txPortId supMac supIp gwIp rxPortId rxPortIp \
	rxPortGwIp {portFlag "forwarded"} {DUT "1"} {tag "none"}} {

    global DUTs_info
    global DUT1_CONNECT
    global DUT2_CONNECT
    global bcmLynx
    set numIpPacketsToSend 15
    set blockTolerance 3

    if {$DUT == "1"} {
	Login $DUT1_CONNECT
	set dutMac $DUTs_info(DUT1,sysMAC)
    } else {
	Login $DUT2_CONNECT
	set dutMac $DUTs_info(DUT2,sysMAC)
    }

    ;# We allow a tolerance when blocking.  It's okay if up to 3 packets go through
    if {$portFlag == "notForwarded"} {
	set portFlag "forwarded $blockTolerance down"
    }

    ;# This is MAC of the DUT
    set cookedDutMac [cookMacForIxia $dutMac]
    
    ;# Only check ARP if we have access
    if {$portFlag == "forwarded"} {
	result_debug "Check for ARP..."
	if {[CheckArpReply -txPortId $txPortId -sIpAddr $supIp -dIpAddr $gwIp \
		-replySendHwAddr "$cookedDutMac" -sMacAddr $supMac -percentage 0.0672 \
		-numArpFrames 2 -comment "MAC:$supMac IP:$supIp " -tag $tag] == 0} {

	    nl_exDumpDebugInfo
	}
    }
    
    ;# Seed ARP table on other port to minimize dropped packets
    ;# due to sending initial ARPs in CheckForwarding
    SendArpFrame -txPortId $rxPortId -sourceIp $rxPortIp -destIp $rxPortGwIp 

    ;# Save original value
    set originalPortFlag $portFlag
    if {$portFlag == "ingress"} {
	set portFlag "forwarded"
    } elseif {$portFlag == "egress"} {
	set portFlag "notForwarded"
    }
    result_debug "Send $numIpPacketsToSend IP Packets MAC:$supMac \
	    IP:$supIp Tag: $tag==> IP:$rxPortIp $portFlag"

    if [regexp -nocase "$bcmLynx" [GetPlatform DUT1]] {
    lappend checkPortList "$rxPortId 0"
 
    } else {
    lappend checkPortList "$rxPortId $portFlag"

    }
    if {[CheckForwarding -txPortId $txPortId -checkPortList $checkPortList \
	    -numIpFrame $numIpPacketsToSend -protocol "ip" -inSaMac $supMac \
	    -inDaMac $cookedDutMac -dIpAddr $rxPortIp -generateArpReq 0 \
	    -gIpAddr $gwIp -sIpAddr $supIp \
	    -comment "MAC:$supMac IP:$supIp ==> IP:$rxPortIp $portFlag" \
            -tag $tag] == 0} {
	
	nl_exDumpDebugInfo
    }
    unset checkPortList

    ;# Restore original value
    set portFlag $originalPortFlag

    if {$portFlag == "ingress"} {
	set portFlag "notForwarded"
    } elseif {$portFlag == "egress"} {
	set portFlag "forwarded"
    }
    result_debug "Send $numIpPacketsToSend IP Packets IP:$rxPortIp ==> \
	    MAC:$supMac IP:$supIp $portFlag"


 if [regexp -nocase "$bcmLynx" [GetPlatform DUT1]] {
    lappend checkPortList "$txPortId 0"
 
    } else {
    
    lappend checkPortList "$txPortId $portFlag"
    }    

     if {[CheckForwarding -txPortId $rxPortId -checkPortList $checkPortList \
	    -numIpFrame $numIpPacketsToSend -protocol "ip" -dIpAddr $supIp \
	    -inDaMac $cookedDutMac -generateArpReq 0 \
	    -gIpAddr $rxPortGwIp -sIpAddr $rxPortIp \
	    -comment "IP:$rxPortIp ==> MAC:$supMac IP:$supIp $portFlag" \
            ] == 0} {

	nl_exDumpDebugInfo

    }
    unset checkPortList
} 



################################################################## 
# Procedure Name: nl_ixVerifySupplicantAccess
#   
# Description: Procedure to verify supplicants have access to 
#              network by sending L2 (ARP) traffic and IP traffic 
#              in both directions.  startSupMac and startSupIp
#              is incremented and each mac/ip pair is validated
#              independently.
#              This procedure assumes a default topology similiar
#              to the show at start of file.
#
# Input args: 
#       txPortId    - Transmistting port 
#       startSupMac - MAC address of supplicant in ":" delimited format
#       startSupIp  - IP Address of supplicant
#       gwIp     - Gateway address of supplicant
#       rxPortId - Receiving port.  This is port we capture packets on.
#       rxPortIp - IP Address on receiving port to send to.  We assume 
#                  this is been setup already on the Ixia.
#       rxPortGwIp - Gateway address of interface on receive side.  Needed 
#                    to test traffic going in opposite direction.
#       numSupplicants - Number of supplicants
#       portFlag - "forwarded" | "notForwarded" | "egress" | "ingress"
#       DUT      - DUT we're talking about.  Need to get MAC of DUT, so 
#                  we specify which DUT to use here.
#
# Output args: None
#
##################################################################
proc nl_ixVerifySupplicantAccess {txPortId startSupMac startSupIp \
	gwIp rxPortId rxPortIp rxPortGwIp {numSupplicants "1"} \
	{portFlag "forwarded"} {DUT "1"} {tag "none"}} {

    set curIp $startSupIp
    set curMac [nl_stripMac $startSupMac]

    while { $numSupplicants } {
	result_debug "($numSupplicants) Verify traffic from \
		supMac:$curMac supIp:$curIp Tag:$tag <---> \ 
                target:$rxPortIp $portFlag"

	_ixVerifySupplicantAccess $txPortId $curMac  \
		$curIp $gwIp $rxPortId $rxPortIp $rxPortGwIp $portFlag $DUT $tag
	
	;# Increment IP and MAC
	set curIp [IncrIpAddr $curIp]
	set curMac [IncMacByOne $curMac ":"]

	incr numSupplicants -1
    }

}



################################################################## 
# Procedure Name: _ixStreamConfig
#   
# Description: Internal procedure to configure an Ixia stream
# 
# Input args: See IXIA doc for explanation of each!
#
# Output args: none
##################################################################
proc _ixStreamConfig { args } {
    parse_args _ixStreamConfig $args {
	chassis       1
	card          1
	port          1
	streamId      1
	numBursts     1
	numFrames     10
	preambleSize  8
	srcMac        {00 00 00 00 00 01}
	dstMac        {00 00 00 00 00 00}
	saStep        1
	saMaskValue   {00 00 00 00 00 00}
	saMaskSelect  {00 00 00 00 00 00}
	saRepeatCnt   "idle"
	numSA         16
	daStep        1
	daMaskValue   {00 00 00 00 00 00}
	daMaskSelect  {00 00 00 00 00 00}
	daRepeatCnt   "daArp"
 	numDA         16
	percentRate   100.0
	frameSize     64
	frameSizeType "sizeFixed"
	frameSizeMin  64
	frameSizeMax  1518
	frameSizeStep 1
	frameType     {08 00}
	patternType   "fixed"
	dataPattern   x00010203
	pattern       {00 01 02 03}
	dma           "advance"   ;# stopStream
	returnToId    1
	protocol          "none"
	protEthernetType  "ethernetII"
	prot802dot1qTag   "false"
	protAppName       0
	arpSrcProtAddr  {10.1.1.2}
	arpDstProtAddr  {10.1.1.1}
	arpOp           "arpRequest"
	arpSrcHwAddr    {00 00 01 02 01 01}
	arpDstHwAddr    {FF FF FF FF FF FF}
	arpSrcProtAddrMode       "arpIdle" ;# arpIncrement
	arpSrcProtAddrRepeatCnt  1 ;# 63 
	arpDestProtAddrMode      "arpIdle"
	arpDestProtAddrRepeatCnt 1
	arpSrcHwAddrMode         "arpIdle"
	arpSrcHwAddrRepeatCnt    1
	arpHwAddrMode            "arpIdle"
	arpHwAddreRepeatCnt      1
	vlanTagNo         "000"
	vlanTagCfi        "resetCFI"
	vlanTagMode       "vIdle"
	vlanTagRepeat     "1"
	vlanTagPriority   "0"	  
	ipProtocol    "tcp"
	ipSrcAddr     {10.1.1.2}
	ipSrcMask     {255.255.255.0}
	ipDstAddr     {172.16.16.2}
	ipDstMask     {255.255.255.0}
	tcpOffset     5
	tcpSrcPort    0
	tcpDstPort    0
	writeToHw       "false"
    }

    set portList [list $chassis,$card,$port]

    stream   setDefault        
    stream   config            -name                    "S_$streamId"
    stream   config            -enable                  true
    stream   config            -numBursts               $numBursts
    stream   config            -numFrames               $numFrames
    stream   config            -rateMode                usePercentRate
    stream   config            -percentPacketRate       $percentRate
    stream   config            -preambleSize            $preambleSize
    stream   config            -sa                      $srcMac
    stream   config            -saRepeatCounter         $saRepeatCnt
    stream   config            -saStep                  $saStep
    stream   config            -saMaskValue             $saMaskValue
    stream   config            -saMaskSelect            $saMaskSelect
    stream   config            -da                      $dstMac
    stream   config            -daRepeatCounter         $daRepeatCnt
    stream   config            -daStep                  $daStep
    stream   config            -daMaskValue             $daMaskValue
    stream   config            -daMaskSelect            $daMaskSelect
    stream   config            -numDA                   $numDA
    stream   config            -numSA                   $numSA
    stream   config            -framesize               $frameSize
    stream   config            -frameSizeType           $frameSizeType
    stream   config            -frameSizeMIN            $frameSizeMin
    stream   config            -frameSizeMAX            $frameSizeMax
    stream   config            -frameSizeStep           $frameSizeStep
    stream   config            -fir                     false
    stream   config            -fcs                     good
    stream   config            -patternType             $patternType
    stream   config            -dataPattern             $dataPattern
    stream   config            -pattern                 "$pattern"
    stream   config            -frameType               "$frameType"
    stream   config            -dma                     $dma
    stream   config            -returnToId               $returnToId
#    stream   config            -rxTriggerEnable         false
#    stream   config            -asyncIntEnable          true
#    stream   config            -loopCount               1
#    stream   config            -enforceMinGap           12

    protocol  setDefault        
    protocol  config     -name               $protocol
    protocol  config     -appName            $protAppName
    protocol  config     -ethernetType       $protEthernetType
    protocol  config     -enable802dot1qTag  $prot802dot1qTag
    protocol  config     -enableISLtag       false
    protocol  config     -dutStripTag        true
    protocol  config     -enableMPLS         false

    if { $prot802dot1qTag != "false"} {
	vlan config -cfi            $vlanTagCfi
	vlan config -mode           $vlanTagMode
	vlan config -repeat         $vlanTagRepeat
	vlan config -vlanID         $vlanTagNo
	vlan config -userPriority   $vlanTagPriority
	vlan set                    $chassis $card $port
    }

    if {[regexp -nocase "arp" $protAppName]} {
	
	arp  setDefault        
	arp  config  -sourceProtocolAddr             $arpSrcProtAddr ;# {10.1.1.2}
	arp  config  -destProtocolAddr               $arpDstProtAddr ;# {10.1.1.1}
	arp  config  -operation                      $arpOp ;# arpRequest
	arp  config  -sourceHardwareAddr             $arpSrcHwAddr ;# {00 00 01 02 01 01}
	arp  config  -destHardwareAddr               $arpDstHwAddr ;# {FF FF FF FF FF FF}
	arp  config  -sourceProtocolAddrMode         $arpSrcProtAddrMode       ;# arpIncrement
	arp  config  -sourceProtocolAddrRepeatCount  $arpSrcProtAddrRepeatCnt  ;# 63 
	arp  config  -destProtocolAddrMode           $arpDestProtAddrMode      ;# arpIdle
	arp  config  -destProtocolAddrRepeatCount    $arpDestProtAddrRepeatCnt ;# 1
	arp  config  -sourceHardwareAddrMode         $arpSrcHwAddrMode         ;# arpIncrement
	arp  config  -sourceHardwareAddrRepeatCount  $arpSrcHwAddrRepeatCnt    ;# 63
	arp  config  -destHardwareAddrMode           $arpHwAddrMode            ;# arpIdle
	arp  config  -destHardwareAddrRepeatCount    $arpHwAddreRepeatCnt      ;# 1
	arp  set     $chassis $card $port
    }
    
    if { ([regexp -nocase "ip" $protocol]) && \
	    (! [regexp -nocase "Arp" $protAppName]) } {
	ip setDefault        
	ip config  -precedence              routine
	ip config  -delay                   normalDelay
	ip config  -throughput              normalThruput
	ip config  -reliability             normalReliability
	ip config  -identifier              0
	ip config  -cost                    0
	ip config  -reserved                0
	ip config  -totalLength             46
	ip config  -lengthOverride          false
	ip config  -fragment                may
	ip config  -lastFragment            last
	ip config  -fragmentOffset          0
	ip config  -ttl                     64
	ip config  -ipProtocol              $ipProtocol
	ip config  -sourceIpAddr            $ipSrcAddr
	ip config  -sourceIpMask            $ipSrcMask
	ip config  -destIpAddr              $ipDstAddr
	ip config  -destIpMask              $ipDstMask
	#    ip config  -useValidChecksum        true
	#    ip config  -sourceIpAddrMode        ipIdle
	#    ip config  -sourceIpAddrRepeatCount 10
	#    ip config  -sourceClass             classA
	#    ip config  -destIpAddrMode          ipIdle
	#    ip config  -destIpAddrRepeatCount   10
	#    ip config  -destClass               classA
	#    ip config  -destMacAddr             {00 DE BB 00 00 02}
	#    ip config  -destDutIpAddr           {0.0.0.0}
	#    ip config  -options                 {}
	ip set $chassis $card $port
    }

    if {[regexp -nocase "tcp" $ipProtocol]} {
	tcp   setDefault        
	tcp   config            -offset                             $tcpOffset
	tcp   config            -sourcePort                         $tcpSrcPort
	tcp   config            -destPort                           $tcpDstPort
#	tcp   config            -sequenceNumber                     0
#	tcp   config            -acknowledgementNumber              0
#	tcp   config            -window                             0
#	tcp   config            -urgentPointer                      0
#	tcp   config            -options                            {}
#	tcp   config            -urgentPointerValid                 false
#	tcp   config            -acknowledgeValid                   false
#	tcp   config            -pushFunctionValid                  false
#	tcp   config            -resetConnection                    false
#	tcp   config            -synchronize                        false
#	tcp   config            -finished                           false
#	tcp   config            -useValidChecksum                   true
	tcp   set               $chassis $card $port
    }

    stream  set               $chassis $card $port $streamId
    
    protocolServer  config      -enableArpResponse  $::true
    protocolServer  config      -enablePingResponse $::true
    protocolServer  set $chassis $card $port

    if {$writeToHw != "false"} {
	result_debug "Writing config to $portList"
	writeConfigToHardware portList
    }

}

################################################################## 
# Procedure Name: _ixSeedFdbTable
#   
# Description: Seeds the FDB table with set of MAC addresses 
#              and a single target.  See typical topology below.
# 
# Input args: supPortId: PortId that supplicant(s) are connected to
#             startSupMac, startSupIp: Starting MAC/IP Address of supplicants
#                    We assume supplicant MAC/IP are created in increasing order
#	      gwIp: Default GW of supplicants.  Usually IP Address of DUT port to
#                   which supplicants are connected 
#             dutMac: Cooked MAC address of DUT. i.e."00 00 01 DE 98 34"
#	      numSup: Number of supplicants to seed 
# Output args: none
##################################################################
proc _ixSeedFdbTable { supPortId startSupMac startSupIp gwIp \
	dutMac {numMac "1"} } {

    result_debug "Seeding FDB table with $numMac supplicant MACs"

    MapIxiaPortId $supPortId chassis card port
    set portList [list "$chassis,$card,$port"]

    ;# ##### Seed the FDB table #####    
    set streamId       1
    set curIp          $startSupIp
    set curMac         $startSupMac
    ;# create 1 stream to send out ARP_Requests for ALL supplicants
    _ixStreamConfig -chassis $chassis -card $card -port $port -streamId $streamId \
	    -numBursts 1 -numFrames $numMac \
	    -srcMac $startSupMac -saRepeatCnt "increment" -numSA $numMac \
	    -daRepeatCnt "idle" -dstMac {FF FF FF FF FF FF} \
	    -percentRate 50.0 -frameSize 64 -dma "stopStream" -protocol "ipV4" -protAppName "Arp" \
	    -protEthernetType "ethernetII" \
	    -arpSrcProtAddr  $startSupIp  -arpDstProtAddr $gwIp \
	    -arpOp "arpRequest" -arpSrcHwAddr $startSupMac \
	    -arpDstHwAddr  {FF FF FF FF FF FF} \
	    -arpSrcProtAddrMode "arpIncrement" -arpSrcProtAddrRepeatCnt $numMac \
	    -arpSrcHwAddrMode  "arpIncrement"  -arpSrcHwAddrRepeatCnt   $numMac \
	    -writeToHw "true"	
    
    result_debug "Transmitting on $portList"
    ixStartTransmit portList
    sleep 2
    result_debug "Checking if Tx done..."
    if {[ixCheckTransmitDone portList]} {
	result_debug "Error in transmitting"
    }   
}



################################################################## 
# Procedure Name: _ixCreateMultiSupplicantStreams
#   
# Description: Internal procedure to create IP data streams for
#              multiple supplicants.  Multiple streams are
#              created, and all written once to Ixia at the
#              end.  This speeds up tests that require 64
#              supplicants.
#
#              Traffic flow is usually based on topology indicated
#              at start of file.  Supplicants send to single 
#              unprotected target.  Target sends traffic back to
#              supplicant.
#
# Input args: 
#      supPortId:     Supplicant port Id 
#      startSupMac:   Starting MAC address
#      startSupIp:    Starting IP Address
#      gwIp:          GW IP of the supplicants
#      unprotPortId:  Target port Id 
#      unprotPortIp   Target IP
#      unprotPortGwIp Target GW
#      dutMac:        MAC of DUT
#      numSup:        Number of supplicants
#      numFrames:     Number of frames to send
#      txDirection:   Direction to send traffic
#
# Output args: none
##################################################################
proc _ixCreateMultiSupplicantStreams { supPortId startSupMac startSupIp \
	gwIp unprotPortId unprotPortIp unprotPortGwIp dutMac {numSup "1"} \
	{numFrames 1} {txDirection "out"} }  {

    if { $txDirection == "out" } {
	MapIxiaPortId $supPortId chassis card port
    } else {
	MapIxiaPortId $unprotPortId chassis card port
	set unprotMacList [nl_ixGetPortIdMacs $unprotPortId]
	set unprotMac [cookMacForIxia [lindex $unprotMacList 0]]
	result_debug "unprotMac: $unprotMac"
    }

    ;# ##### Create the Streams #####
    set streamId       1
    set dma            "advance"
    set writeToHw      "false"
    set curIp          $startSupIp
    set curMac         $startSupMac
    set numSupplicants $numSup
    while { $numSupplicants } {

	;# Configure last stream to stop and also make sure to write to
	if {$numSupplicants == 1} {
	    set dma  "stopStream"
	    set writeToHw  "true"
	}
	if { $txDirection == "out" } {

	    result_debug "($numSupplicants) Setting up stream for \
		    supMac:$curMac supIp:$curIp ---> target:$unprotPortIp"

	    _ixStreamConfig -chassis $chassis -card $card -port $port -streamId $streamId \
		    -numBursts 1 -numFrames $numFrames -srcMac $curMac -dstMac $dutMac \
		    -daRepeatCnt "idle" -percentRate 50.0 \
		    -frameSize 64 -dma $dma -protocol "ipV4" \
		    -protEthernetType "ethernetII" -ipProtocol "tcp" \
		    -ipSrcAddr $curIp -ipSrcMask {255.255.255.0} \
		    -ipDstAddr $unprotPortIp -ipDstMask {255.255.255.0} \
		    -writeToHw $writeToHw
	} else {

	    result_debug "($numSupplicants) Setting up stream for \
		    target:$unprotPortIp --> supMac:$curMac supIp:$curIp"

	    _ixStreamConfig -chassis $chassis -card $card -port $port -streamId $streamId \
		    -numBursts 1 -numFrames $numFrames -srcMac $unprotMac -dstMac $dutMac \
		    -daRepeatCnt "idle" -percentRate 50.0 \
		    -frameSize 64 -dma $dma -protocol "ipV4" \
		    -protEthernetType "ethernetII" -ipProtocol "tcp" \
		    -ipSrcAddr $unprotPortIp  -ipSrcMask {255.255.255.0} \
		    -ipDstAddr $curIp -ipDstMask {255.255.255.0} \
		    -writeToHw $writeToHw
	}

	;# Increment IP and MAC
	set curIp [IncrIpAddr $curIp]
	set curMac [IncMacByOne $curMac ":"]

	incr numSupplicants -1
	incr streamId
    }
    result_debug "ALL STREAMS CONFIGURED..."
    
}

################################################################## 
# Procedure Name: _ixVerifyMultiSupplicantAccess
#   
# Description: Internal procedure to verify traffic for multi
#              supplicants.  Proc assumes streams and DUT are
#              already configured.  This procedure starts and captures
#              traffic and confirms uni-directional traffic is
#              sent correctly.
# Input args: 
#      supPortId:     Supplicant port Id 
#      startSupIp:    Starting IP Address
#      unprotPortId:  Target port Id 
#      numSup:        Number of supplicants
#      numFramesThreshold:    Number of frames requ'd to receive for success
#      txDirection:   Direction to send traffic
#
# Output args: none
##################################################################
proc  _ixVerifyMultiSupplicantAccess { supPortId unprotPortId numSup startSupIp \
	numFramesThreshold {txDirection "out"} } {
    
    report_start_test "Verify $numSup Supplicant Access $txDirection"

    ;# ##### Send and Capture the traffic #####
    StopPortsCapture [list $supPortId $unprotPortId]
    sleep 2
    
    if {$txDirection == "out"} {
	set txPortId $supPortId
	set rxPortId $unprotPortId
    } else {
	set txPortId $unprotPortId
	set rxPortId $supPortId
    }

    ;# Start capture
    StartPortsCapture [list $rxPortId]
    sleep 1

    ;# Start streams
    MapIxiaPortId $txPortId chassis card port
    set portList [list "$chassis,$card,$port"]
    ixStartTransmit portList

    if {[ixCheckTransmitDone portList]} {
	result_debug "Error in transmitting"
	report_end_test
	return
    }
    result_debug "DONE TRANSMITTING ********************************"

    StopPortsCapture [list $rxPortId]
    sleep 2

    ;# ##### Parse the received data  #####
    ;# Parse Rx Port Capture Buffer to verify we received packets. 
    set numSupplicants $numSup
    set curIp $startSupIp

    ;# ASSUME CAPTURE BUFFER IS IN ORDER OF supIp ADDRESSES!
    set rawPortDataList [GetCapturedFrames $rxPortId]

    while { $numSupplicants } {

	set numFramesMatched 0
	foreach frame $rawPortDataList {

	    if {$txDirection == "out"} {
		set curIpRx [GetSourceIPAddress $frame]
	    } else {
		set curIpRx [GetDestIPAddress $frame]
	    }

	    if {$curIpRx == $curIp} {
		incr numFramesMatched
	    }
	    if {$numFramesMatched == $numFramesThreshold} {
		result_debug "Found $numFramesMatched packets from $curIp"
		break
	    }
	}

	if {$numFramesMatched != $numFramesThreshold} {
	    result_error "Found only $numFramesMatched packets from $curIp...test failed"
	    report_end_test
	    return
	}

	;# Increment IP and MAC
	set curIp [IncrIpAddr $curIp]

	incr numSupplicants -1
    }
    
    result_ok "Access Okay for $numSup Supplicants"
    report_end_test
}


################################################################## 
# Procedure Name: nl_ixVerifyMultiSupplicantAccess
#   
# Description: Procedure to verify traffic for multi-supplicants.  
#              Seeds FDB table for both ends, creates streams
#              sends and verifies traffic flow.  Repeats for
#              opposite direction.
#              Assumes topology similiar to the one shown above.
# Input args: 
#      supPortId:       Supplicant Port Mapping ID
#      startSupMac:     Supplicant starting MAC
#      startSupIp:      Supplicant starting IP
#      gwIp:            GW IP of supplicants
#      unprotPortId:    Unprotected target port ID
#      unprotMac:       Unprotected target MAC
#      unprotPortIp:    Unprotected target IP
#      unprotPortGwIp:  Unprotected target port GW 
#      dutMac:          DUT MAC
#      numSup:          Number of supplicants to verify
#      portFlag:        "forwarded" | "notForwarded"
#
# Output args: none
##################################################################
proc nl_ixVerifyMultiSupplicantAccess { supPortId startSupMac startSupIp \
	gwIp unprotPortId unprotMac unprotPortIp unprotPortGwIp dutMac \
	{numSup "1"} {portFlag "forwarded"} } {

    set numFrames           10   ;# Send 10
    set numFramesThreshold  5    ;# As long as other end receives 5, we're okay for this test.
    
    ;# Cook MAC
    set startSupMac [cookMacForIxia $startSupMac]
    set unprotMac   [cookMacForIxia $unprotMac]
    set dutMac      [cookMacForIxia $dutMac]


    ;# Seed supplicant end
    _ixSeedFdbTable $supPortId $startSupMac $startSupIp $gwIp \
	    $dutMac $numSup

    exSleep 2

    ;# Seed target end
    _ixSeedFdbTable $unprotPortId $unprotMac $unprotPortIp $unprotPortGwIp \
	    $dutMac 1

    ;# Debug to check FDB is poplulated
    ;#    SendACmd "show fdb po [MapDUTPortId 1]"

    _ixCreateMultiSupplicantStreams $supPortId $startSupMac $startSupIp $gwIp \
	    $unprotPortId $unprotPortIp $unprotPortGwIp \
	    $dutMac $numSup $numFrames "out"

    _ixVerifyMultiSupplicantAccess $supPortId $unprotPortId $numSup $startSupIp \
	    $numFramesThreshold "out"

    _ixCreateMultiSupplicantStreams $supPortId $startSupMac $startSupIp $gwIp \
	    $unprotPortId $unprotPortIp $unprotPortGwIp \
	    $dutMac $numSup $numFrames "in"

    _ixVerifyMultiSupplicantAccess $supPortId $unprotPortId $numSup $startSupIp \
	    $numFramesThreshold "in"

}




################################################################## 
# Procedure Name: nl_ixSendIpTraffic
#   
# Description: Procedure to send IP Traffic to another port.
#              Each MAC (when more than 1) initiates traffic 
#              destined to target rxPortIp.  No checking is done.
#
# Input args: 
#      txPortId:    Supplicant Port Mapping ID
#      startSupMac: Supplicant starting MAC
#      startSupIp:  Supplicant starting IP
#      gwIp:        GW IP of supplicants
#      rxPortId:    Unprotected target port ID
#      rxPortIp:    Unprotected target IP
#      rxPortGwIp:  Unprotected target port GW 
#      numSupplicants:     Number of supplicants
#      numPacketsToSend:   Number of packets to transmit
#      DUT:         1 | 2
#
# Output args: none
##################################################################
proc nl_ixSendIpTraffic { txPortId startSupMac startSupIp gwIp rxPortId \
	rxPortIp rxPortGwIp {numSupplicants 1} {numPacketsToSend 10} \
	{DUT "1"}} {

    global DUTs_info
    global DUT1_CONNECT
    global DUT2_CONNECT

    if {$DUT == "1"} {
	Login $DUT1_CONNECT
	set dutMac $DUTs_info(DUT1,sysMAC)
    } else {
	Login $DUT2_CONNECT
	set dutMac $DUTs_info(DUT2,sysMAC)
    }

    ;# This is MAC of the DUT
    set cookedDutMac [cookMacForIxia $dutMac]

    set curIp $startSupIp
    set curMac [nl_stripMac $startSupMac]

    while { $numSupplicants } {
	;# This should generate entry in table.
	SendArpFrame -txPortId $txPortId -sourceMac $curMac -sourceIp $curIp \
		-destIp $gwIp -numFrames 2 
	

	;# Send some IP traffic
	SendIpFrame -txPortId $txPortId -sourceIp $curIp \
		-destMac $cookedDutMac -gatewayIp $gwIp \
		-destIp $rxPortIp -numFrames $numPacketsToSend

	;# Increment IP and MAC
	if {$curIp != ""} {
	    set curIp [IncrIpAddr $curIp]
	}
	if {$curMac != ""} {
	    set curMac [IncMacByOne $curMac ":"]
	}


	incr numSupplicants -1

    }
}


################################################################## 
# Procedure Name: nl_ixStartEapolFlood
#   
# Description: Procedure to create an L2 stream of a particular EAPOL 
#              packet type.  Then start transmitting at that rate.
#              Used for EAPOL flooding tests
#
# Input args: 
#        txPortId: Supplicant Port Mapping ID 
#        type:     "start" | "response-identity" | "logoff"  
#        dstMac:   dstMac to send to...usually DUT 
#        rate:     % rate to send traffic.
#
# Output args: none
#
##################################################################
proc nl_ixStartEapolFlood {txPortId type dstMac {rate 100.0}} {

    set eapolType {88 8E}
    set srcMac {00 00 01 AB CD EF}


    if {$type == "start"} {

	set pattern {01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}

    } elseif { $type == "response-identity" } {

	set pattern {01 00 00 0C 02 03 00 0C 01 64 6F 74 31 78 31 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}


    } elseif { $type == "logoff" } {
	
	set pattern {01 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    } else {

	result_debug "Unsupported EAPOL type $type" 
	return 0
    }

    MapIxiaPortId $txPortId chassis card port
    set portList [list "$chassis,$card,$port"]

    set streamId       1
    set dma            "contPacket"
    set srcMac         {00 00 01 BE EF BA}

    puts "EAPOL stream type $type $chassis:$card:$port"

    _ixStreamConfig -chassis $chassis -card $card -port $port -streamId $streamId \
	    -srcMac $srcMac -dstMac $dstMac \
	    -daRepeatCnt "idle" -percentRate "$rate" \
	    -pattern $pattern -patternType "nonRepeat" -dataPattern "userpattern" \
	    -frameSize 64 -frameType $eapolType -dma $dma -protocol "mac" \
	    -protEthernetType "ethernetII"  -writeToHw "true"

    ixStartTransmit portList

    return 1

}


################################################################## 
# Procedure Name: nl_ixStopTx
#   
# Description: Procedure to stop transmitting on a Ixia port
#
# Input args: 
#        txPortId: Port Mapping ID 
#
# Output args: none
#
##################################################################
proc nl_ixStopTx {txPortId} {

    MapIxiaPortId $txPortId chassis card port
    set portList [list "$chassis,$card,$port"]

    ixStopTransmit portList

}

################################################################## 
# Procedure Name: nl_ixStopEapolFlood
#   
# Description: Procedure to stop transmitting on an Ixia port
#
# Input args: 
#        txPortId: Port Mapping ID 
#
# Output args: none
#
##################################################################
proc nl_ixStopEapolFlood {txPortId} {

    nl_ixStopTx $txPortId

}



################################################################## 
# Procedure Name: nl_ixDumpSupplicantStats
#   
# Description: Dump supplicant statistics to STDOUT
#
# Input args: 
#        portId: Port Mapping ID 
#        mac:    Supplicant mac to dump
#
# Output args: none
#
##################################################################
proc nl_ixDumpSupplicantStats { portId mac } {

    MapIxiaPortId $portId ch ca po

    dot1xSupplicantStats get $ch $ca $po $mac

    set totalSuccess [dot1xSupplicantStats cget -totalSuccess]
    set totalSessions [dot1xSupplicantStats cget -totalSessions]
    set avgLatency [dot1xSupplicantStats cget -avgLatency]
    set minLatency [dot1xSupplicantStats cget -minLatency]
    set totalFailEap [dot1xSupplicantStats cget -totalFailEap]
    set totalFailTimeout [dot1xSupplicantStats cget -totalFailTimeout]
    
    result_debug "Stats for Supplicant $mac"
    result_debug "  totalSuccess:     $totalSuccess"
    result_debug "  totalSessions:    $totalSessions"
    result_debug "  avgLatency:       $avgLatency"
    result_debug "  minLatency:       $minLatency"
    result_debug "  totalFailEap:     $totalFailEap"
    result_debug "  totalFailTimeout: $totalFailTimeout"
    
}


################################################################## 
# Procedure Name: nl_ixCheckPing
#  
# Description: Check that we can ping from supplicant to target. Reports
#              pass of fail.
#
# Input args: dstIp 
#             srcIp 
#             gwIp 
#             txPortId 
#             status 
#             srcMac 
#             dstMac
#
# Output args: cooked MAC with no : seperators
#
##################################################################
proc nl_ixCheckPing {dstIp srcIp gwIp txPortId status srcMac dstMac} {

    _ixSeedFdbTable $txPortId $srcMac $srcIp $gwIp $dstMac 1
    check_ping $dstIp $srcIp $txPortId $status "NULL" $srcMac $dstMac
}


################################################################## 
# Procedure Name: nl_ixSendPing
#  
# Description: Proc that sends a PING frame from Ixia.  Does NOT report
#              success or failure.  
#              Sent to start EAP exchange from DUT.
#
# Input args:  dstIp 
#              srcIp 
#              gwIp 
#              txPortId 
#              srcMac 
#              dstMac
#
# Output args: none
#
##################################################################
proc nl_ixSendPing {dstIp srcIp gwIp txPortId srcMac dstMac} {

    result_debug "Seeding fdb table"
    _ixSeedFdbTable $txPortId $srcMac $srcIp $gwIp $dstMac 1
    
    set pPattern  "feedbeef"
    set frameSize 64

    result_debug "Sending ICMP frame"
    set frameSent [SendIpFrame -txPortId $txPortId -protocol "icmp" \
                  -dataPattern $pPattern -frameSize $frameSize \
                  -sourceMac $srcMac -destMac $dstMac -sourceIp $srcIp -destIp $dstIp \
                  -type 8 -code 0 -id 1234 -sequence 5678 ]

   result_debug "(802.1x) Frame (icmp) sent on portId $txPortId:"
   result_debug "$frameSent"

}

#
# ############################## EXTREME SWITCH FUNCTIONS ###########################
# 

################################################################## 
# Procedure Name: nl_exConfigStandardVlan
#   
# Description: Standard 2 port vlan configuration for dot1x tests
# 
# Output args: NULL
##################################################################
proc nl_exConfigStandardVlan {protectedPort unprotectedPort \
	protectedIP unprotectedIP \
	{protectedVlanName "vlan_1"} {unprotectedVlanName "vlan_2"}} {

    SendACmd    "create vlan $protectedVlanName"
    SendACmd    "conf $protectedVlanName add port $protectedPort"
    SendACmd    "conf $protectedVlanName ipaddress $protectedIP/24"
    
    ;# vlan_2 contains the normal port which we send to and from.
    SendACmd    "create vlan $unprotectedVlanName"
    SendACmd    "conf $unprotectedVlanName add port $unprotectedPort"
    SendACmd    "conf $unprotectedVlanName ipaddress $unprotectedIP/24"
    
    SendACmd    "enable ipforwarding"
    
}

proc nl_exUnconfigStandardVlan {{protectedVlanName "vlan_1"} \
	{unprotectedVlanName "vlan_2"}} {

    SendACmd    "delete $protectedVlanName"
    SendACmd    "delete $unprotectedVlanName"
    SendACmd    "disable ipforwarding"


}

proc nl_exConfigDhcpServer { {dhcpVlan "vlan_1"} \
	{startIpRange "10.1.1.2"} \
	{endIpRange "10.1.1.254"} \
	{gateway "10.1.1.1"} \
	{leaseTimer "1200"} \
	{dns "10.0.0.1"} \
	{wins "10.0.0.85"} }	{

    SendACmd "configure $dhcpVlan dhcp-address-range $startIpRange - $endIpRange"
    SendACmd "configure $dhcpVlan dhcp-lease-timer $leaseTimer"
    SendACmd "configure $dhcpVlan dhcp-options default-gateway $gateway"
    SendACmd "configure $dhcpVlan dhcp-options dns-server $dns"
    SendACmd "configure $dhcpVlan dhcp-options wins-server $wins"
}

proc nl_exUnconfigDhcpServer { {dhcpVlan "vlan_1"} } {
    
    SendACmd "unconfig $dhcpVlan dhcp-address-range"
    SendACmd "unconfig $dhcpVlan dhcp-options"
}

proc nl_exEnableDhcpOnPort { port vlan } {
    SendACmd "enable dhcp port $port vlan $vlan"
}

proc nl_exDisableDhcpOnPort { port vlan } {
    SendACmd "disable dhcp port $port vlan $vlan"
}

################################################################## 
# Procedure Name: nl_exConfigRadius
#   
# Description: Configure and enable radius server
# 
# Sample Usage:
#  nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret
#
# Output args: NULL
##################################################################
proc nl_exConfigRadius {serverIP serverPort clientIP {sharedSecret "extreme"} \
	{which "primary"} } {

    ;# NOTE: shared secret is required before enabling.

    SendACmd    "disable radius"

    set vr [GetVrString 1]
    #set vr "VR-mgmt"

    SendACmd "config radius $which server $serverIP $serverPort \
	    client-ip $clientIP vr $vr"
    
    SendACmd    "config radius $which shared-secret $sharedSecret"
    
    SendACmd    "enable radius"

    SendACmd "disable radius mgmt-access"
}

proc nl_exUnconfigRadius {} {

    SendACmd "unconfig radius"
    SendACmd "disable radius"

}

################################################################## 
# Procedure Name: nl_exEnableDebugLogFilter
#   
# Description: Turn on debug logs.
# 
# Output args: NULL
##################################################################
proc nl_exEnableDebugLogFilter {} {

    SendACmd "configure log filter \"DefaultFilter\" del event all"
    SendACmd "configure log filter \"DefaultFilter\" add events nl severity debug-data"
    SendACmd "configure log filter \"DefaultFilter\" add events aaa severity debug-data"
    SendACmd "enable log debug"
    SendACmd "cl log"
}

################################################################## 
# Procedure Name: nl_exDisableDebugLogFilter
#   
# Description: Turn off debug logs.
# 
# Output args: NULL
##################################################################
proc nl_exDisableDebugLogFilter {} {

    SebdACnd "disable log debug"
    SendACmd "unconfigure log filter \"DefaultFilter\""

}

################################################################## 
# Procedure Name: nl_exDumpDebugInfo
#   
# Description: Dump all debug info
# 
# Output args: NULL
##################################################################
proc nl_exDumpDebugInfo { {vlan ""} } {

    result_debug "================ START DEBUG DUMP ==============="
    SendACmd "show config vlan"
    SendACmd "show config fdb"
    SendACmd "show config netlogin"
    SendACmd "show netlogin"
    SendACmd "show vlan $vlan"
    SendACmd "show radius"
    SendACmd "show fdb"
    SendACmd "show iparp"

    EnableDebugMode


    if {[CompareRelease [GetVersion "DUT1"] "12.1.0.47"]<=0} {

    SendACmd "jerry show vlan vpif"
    SendACmd "jerry netlogin show dot1x-clients"
    SendACmd "jerry netlogin show vr"
    SendACmd "jerry netlogin show pif"
    SendACmd "jerry netlogin show vpif clients details"
    SendACmd "jerry netlogin show mac-cache"
    } else {
    SendACmd "debug vlan show vpif"
    SendACmd "debug netlogin show dot1x-clients"
    SendACmd "debug netlogin show vr"
    SendACmd "debug netlogin show pif"
    SendACmd "debug netlogin show vpif clients details"
    SendACmd "debug netlogin show mac-cache"
    }
    
    SendACmd "show log"

    DisableDebugMode
    result_debug "================ END DEBUG DUMP ==============="
}

################################################################## 
# Procedure Name: nl_exConfigNetlogin
#   
# Description: Configure and enable netlogin
# 
# Sample Usage:
#  nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret
#
# Output args: NULL
##################################################################
proc nl_exConfigNetlogin {{vlan "defNetloginVlan"} {type "mac"}}  {

    SendACmd    "create vlan $vlan"
    SendACmd    "config netlogin vlan $vlan"
    SendACmd    "enable netlogin $type"    
}

proc nl_exUnconfigNetlogin { {vlan "defNetloginVlan"} {type "mac"} }  {

    SendACmd "disable netlogin $type"
    SendACmd "unconfig netlogin vlan"
    SendACmd "delete $vlan"

}

################################################################## 
# Procedure Name: nl_exEnableNetlogin
#   
# Description: Enable/Disable netlogin
# 
# Sample Usage:
#  nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret
#
# Output args: NULL
##################################################################
proc nl_exEnableNetlogin {{type "mac"}}  {

    SendACmd    "enable netlogin $type"    
}

proc nl_exDisableNetlogin { {type "mac"} }  {

    SendACmd "disable netlogin $type"
}


################################################################## 
# Procedure Name: nl_exEnableNetloginPort
#   
# Description: Enable netlogin on a port.  We wrap it because of we've seen
#              lots of command truncation after executing this command.  To 
#              deal with this we added a delay after executing.
# 
# Input args:  port:  Port to activate
#              type: dot1x/mac/web-based
#              delay: Seconds to wait before returning
#
# Output args: NULL
#
# Typical Usage:
#  nl_exEnableNetloginPort [MaptDUTPortId 1] "dot1x" 5
##################################################################
proc nl_exEnableNetloginPort {port {type "mac"} {delay 1}} {
    
    SendACmd "enable netlogin port $port $type"
    exSleep $delay

}

################################################################## 
# Procedure Name: nl_exDisableNetloginPort
#   
# Description: Disable netlogin on a port.  We wrap it because of we've seen
#              lots of command truncation after executing this command.  To 
#              deal with this we added a delay after executing.
# 
# Input args:  port:  Port to deactivate
#              type: /mac/web/dot1x
#              delay: Seconds to wait before returning
#
# Output args: NULL
#
# Typical Usage:
#  nl_exDisableNetloginPort [MaptDUTPortId 1] "ispVlan" 5
##################################################################
proc nl_exDisableNetloginPort {port {type "mac"} {delay 1}} {
    
    SendACmd    "disable netlogin port $port $type"
    exSleep $delay
}


################################################################## 
# Procedure Name: nl_exAddMacList 
#   
# Description: Add entries to mac list
# 
# Input args:  mac:  mac | "default"
#              mask: bitmask              
#              encrypted: true | false
#              passwd: "string"
#
# Output args: NULL
#
# Typical Usage:
#  nl_exAddMacList 
##################################################################
proc nl_exAddMacList {{mac "default"} {maskbits ""} {encrypted "0"} {passwd ""}} {
    
    result_debug "mac:$mac  maskbits:$maskbits encrypted:$encrypted  pwd:$passwd"
    if {$encrypted != 0} {
	set encrypt "encrypt"
    } else {
	set encrypt ""
    }

    if {$maskbits == ""} {
	SendACmd "configure netlogin add mac-list $mac $encrypt $passwd"
    } else {
	SendACmd "configure netlogin add mac-list $mac $maskbits $encrypt $passwd"
    }
}


################################################################## 
# Procedure Name: nl_exDelMacList 
#   
# Description: Del entries to mac list
# 
# Input args:  mac:  mac | "default"
#              mask: bitmask              
#
# Output args: NULL
#
# Typical Usage:
#  nl_exDelMacList 
##################################################################
proc nl_exDelMacList {{mac "default"} {mask ""}} {
        ;# Only supported Default for now...
    SendACmd "configure netlogin del mac-list $mac $mask"
} 


proc nl_exAddMacListSet { maclistSet } {

    result_debug "nl_exAddMacListSet: There are [llength $maclistSet] entries to add"

    foreach macentry $maclistSet {

	set mac [lindex $macentry 0]
	set maskbits [lindex $macentry 1]
	set encrypted [lindex $macentry 2]
	set passwd [lindex $macentry 3]

	nl_exAddMacList $mac $maskbits $encrypted $passwd
    }

}


proc nl_exDelMacListSet { maclistSet } {

    result_debug "nl_exDelMacListSet: There are [llength $maclistSet] entries to delete"

    foreach macentry $maclistSet {

	set mac [lindex $macentry 0]
	set maskbits [lindex $macentry 1]

	nl_exDelMacList $mac $maskbits
    }

}

proc nl_exRestartPort { port {delay 2} } {

    SendACmd "disable port $port"
    exSleep $delay
    SendACmd "enable port $port"
    exSleep $delay
}

################################################################## 
# Procedure Name: nl_exVerifyMacList 
#   
# Description: Verifies entries in the mac list
# 
# Input args:  mac:  macPasswordList
#
# Output args: NULL
#
# Partial show netlogin output for MAC List. NOTE: yaqu is encrypted form for "test"
#
# MAC Address/Mask      Password (encrypted)
# --------------------  --------------------------
# Default               <not configured>
# Default               yaqu
# 00:DE:AD:BE:EF:01/48  <not configured>
# 00:DE:AD:BE:EF:01/48  yaqu
# 00:DE:AD:00:00:00/24  <not configured>
# 00:DE:AD:00:00:00/24  yaqu
# 
# ------------------------------------------------
#
proc nl_exVerifyMacList { {macPasswordList ""} {mode ""} } {
    
    
    CheckKeyValue "show netlogin $mode" $macPasswordList

}


################################################################## 
# Procedure Name: nl_exVerifyNetloginAuthMode
#   
# Description: Verify global netlogin authentication mode
#
# Input args:  mode:  mac | 802 | web
#              state: disabled | enabled
#
# Output args: NULL
#
# Typical Usage:
#  nl_exVerifyNetloginAuthMode "mac" "disabled"
##################################################################
proc nl_exVerifyNetloginAuthMode { {mode "mac"} {state "enabled"} } {
    
    set state [string toupper $state]

    lappend parameterList "{NetLogIn Auth.*\ *:.*.*$mode.*\ $state\(;|\n|\ )}"
    CheckKeyValue "show netlogin" $parameterList
    unset parameterList
    
    
}

################################################################## 
# Procedure Name: nl_exVerifyMacList 
#   
# Description: Verify netlogin mac list 
#
# Input args:  port:  Port to verify
#              status: enabled/disabled
#              type: dot1x/mac/web
#
# Output args: NULL
#
# Typical Usage:
#  lappend mList {"Default\ *\<not configured" exist}
#  nl_exVerifyMacList $mList
##################################################################
proc nl_exVerifyMacList { {macList ""} {mode ""} } {
    
    CheckKeyValue "show netlogin $mode" $macList \
	    -comment "Verify Netlogin MAC list"
    
}

################################################################## 
# Procedure Name: nl_exVerifyNetloginOnPort
#   
# Description: Verify netlogin on a port. 
#
# Input args:  port:  Port to verify
#              status: enabled/disabled

#
# Output args: NULL
#
# Typical Usage:
#  nl_exVerifyNetloginOnPort [MaptDUTPortId 1] "ispVlan" 5
##################################################################
proc nl_exVerifyNetloginOnPort { port status type {typeStatus "enabled"}} {
    
    # show port 2:7 info detail
    #
    # NetLogIn:    Enabled 
    # NetLogIn mode:    802.1X, Mac based, Web login
    
    set parameterList ""

    if [regexp -nocase "enable" $status] {
	lappend parameterList "{NetLogIn:.*Enabled} exist"
    } elseif [regexp -nocase $status "disable"] {
	lappend parameterList "{NetLogIn:.*Disabled} exist"
    }
 

    if [regexp -nocase "enable" $typeStatus ] {
	set tStatus "exist"
    } else {
	set tStatus "notExist"
    }
    
    if {$status == "enabled"} {
	if [regexp -nocase "dot1x" $type] {
	    lappend parameterList "{NetLogin.*mode:.*802.1x} $tStatus"
	}
	
	if [regexp -nocase "web" $type] {
	    lappend parameterList "{NetLogin.*mode:.*Web} $tStatus"
	}
	
	if [regexp -nocase "mac" $type] {
	    lappend parameterList "{NetLogin.*mode:.*Mac} $tStatus"
	}
	
	CheckKeyValue "show port $port info detail" $parameterList
	unset parameterList
    }
}

################################################################## 
# Procedure Name: nl_exGetNetloginVal
#   
# Description: Retrieve the value for a particular MAC Address.
# 
# Input args:  mac:   Mac address to look for
#              param: Parameter to retrieve
#
# Output args: paramter or NULL
#
# VALID param VALUES: IP address, Auth, Type, ReAuth-Timer User
#  i.e.
#  Port: 21,   Vlan: vlan_1,  State: Enabled
#  MAC                IP address      Auth   Type      ReAuth-Timer User    
#  00:00:01:02:01:01  0.0.0.0         No     802.1x    0            Unknown 
#
# Typical Usage:
#  set reauth [nl_exGetNetloginVal "00:00:01:02:01:01" ReAuth-Timer]
##################################################################
proc nl_exGetNetloginVal { port vlan supMac param } {

   global tmpPath
   set tmp "Tmp"
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile "$tmp/tmp_Dot1X$pid"

    set _mac NULL
    set _ip NULL 
    set _auth NULL
    set _type NULL
    set _reauth NULL
    set _user NULL

    ;# Execute show netlogin and put output into a file
    set fd_in [open $tempFile "w"]
    SendACmd "show netlogin" NULL $fd_in

    close $fd_in

    ;# Open for reading
    set fd_in [open $tempFile "r"]
    
    set portVlanMatchLine  ""
    set macMatchLine       ""
    ;# Find correct port/vlan and MAC lines 
    while {[gets $fd_in line] != -1} {

	;# Look for Port/Vlan Match.
	if {[regexp -nocase -indices -- Port:.*$port.*Vlan:.*$vlan $line matchedRange] == 1} {
	    set portVlanMatchLine $line
	    result_debug "FOUND Port:$port Vlan:$vlan on line:$line"

	    ;# Now look for MAC Match
	    while {[gets $fd_in line] != -1} {
		
		if {[regexp -nocase "/-/-/-/-/-/-" $line] == 1} {
		    ;# Found end of port section delimiter...MAC not found in the section.
		    result_debug "Hit delimiter without finding MAC"
		    break;
		}
		
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    result_debug "FOUND MAC:$supMac on line:$line"
		    set macMatchLine $line
		    break
		}
	    }
	    break;
	}
    }
    close $fd_in
    file delete $tempFile
    
    
    if {$portVlanMatchLine == ""} {
	result_debug "Port:$port Vlan:$vlan NOT FOUND"
	return NULL
    }

    if { [string length $macMatchLine] > 0 } {
	regexp {(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)}  \
		$macMatchLine \
		ignore _mac _ip _auth _type _reauth _user
	result_debug "mac: $_mac"
	result_debug "ip: $_ip"
	result_debug "auth: $_auth"
	result_debug "type: $_type"
	result_debug "reauth: $_reauth"
	result_debug "user: $_user"
    }

    ;# Default _reauth to 0 if not found or not an int
    if {! [string is integer -strict $_reauth] } {
	set _reauth 0
    }
    switch -exact -- $param \
	    "mac"    {return $_mac} \
	    "ip"     {return $_ip} \
	    "auth"   {return $_auth} \
	    "type"   {return $_type} \
	    "reauth" {return $_reauth} \
	    "user"   {return $_user} \
	    default  {return NULL} \
}


################################################################## 
# Procedure Name: nl_exVerifyPortAuth
#   
# Description: Verify that a port is authenticated/unauthenticated
# 
# Input args:  port: DUT port
#              vlan: DUT vlan
#              authStatus: "Auth" | "Unauth | "notExist""
#
# Output args: none
#
##################################################################
proc nl_exVerifyPortAuth {port vlan authStatus} {    

    set parameterList [list]
 
    if {$authStatus == "notExist"} {
	if {$vlan != ""} {
	    lappend parameterList "{Port:.* $port.*Vlan:.*$vlan.* State:} notExist"
	    set returnCode [CheckKeyValue "show netlogin" $parameterList  \
		    -comment "Verifying Port:$port Vlan:$vlan doesn't exist"]
	} else {
	    ;# Not exist at all on ANY vlan
	    lappend parameterList "{Port:.* $port.*Vlan:} notExist"
	    set returnCode [CheckKeyValue "show netlogin" $parameterList  \
		    -comment "Checking if Port:$port doesn't exist"]	    
	}
    } else {
	lappend parameterList "{Port:.* $port.*Vlan:.*$vlan.* State: $authStatus} exist"
	set returnCode [CheckKeyValue "show netlogin" $parameterList  \
		-comment "Checking if Port:$port Vlan:$vlan is $authStatus"]
    }
    return $returnCode

}

################################################################## 
# Procedure Name: nl_exVerifyMacAuth
#   
# Description: Verify that a particular MAC is authenticated/unauthenticated
# 
# Input args:  port: DUT port
#              vlan: DUT vlan
#              mac:  MAC address of supplicant
#              authStatus: "Auth" | "Unauth" | "none"
#                 *authStatus of "none" means MAC is NOT listed at all
#
# Output args: none
#
##################################################################
proc nl_exVerifyMacAuth { port vlan mac authStatus } { 

    set parameterList [list]
    
    if {$authStatus == "none"} {
	lappend parameterList "$mac.* notExist"
	set returnCode [CheckKeyValue "show netlogin" $parameterList \
		-comment "Checking $mac is NOT present"]
    } else {
	lappend parameterList "$mac.*$authStatus exist"
	set returnCode [CheckKeyValue "show netlogin" $parameterList \
		-comment "Checking $mac IS present"]
    }

    return $returnCode
}

################################################################## 
# Procedure Name: _exCheckMatch
#   
# Description: Verify that a port is authenticated/unauthenticated
# 
# Input args:  actual:
#              expected:
#                 *If expected is "", we're NOT interested in it, so just return 1.
#              matchType: "greater" | "less" | "equal" | "ge" | "le" | "string
#              nocase: "true" | "false" Case sensitive
#
# Output args: 1-match 0-no match
#
##################################################################
proc _exCheckMatch { actual expected {matchType "string"} {nocase "true"} } {
    
    set nc ""

    if {$nocase == "true"} {
	set nc "-nocase"
    }
	
    if [string length $expected] {
	if {$matchType == "string"} {
	    if [regexp $nc $expected $actual] {
		result_debug "string match of $actual vs. $expected OK"
		return 1
	    } else {
		result_debug "string match of $actual vs. $expected FAIL"
		return 0
	    }
	    
	} elseif {$matchType == "greater"} {
	    if {$actual > $expected} {
		result_debug "greater match of $actual > $expected OK"
		return 1
	    }
	    result_debug "greater match of $actual > $expected FAIL"
	} elseif {$matchType == "less"} {
	    if {$actual < $expected} {
		return 1
	    }
	    result_debug "less match of $actual < $expected FAIL"
	} elseif {$matchType == "equal"} {
	    if {$actual == $expected} {
		result_debug "equal match of $actual ==  $expected OK"
		return 1
	    }
	    result_debug "equal match of $actual ==  $expected FAIL"
	} elseif {$matchType == "ge"} {
	    if {$actual >= $expected} {
		result_debug "greater or equal match of $actual >= $expected OK"
		return 1
	    }
	    result_debug "greater or equal match of $actual >= $expected FAIL"
	} elseif {$matchType == "le"} {
	    if {$actual <= $expected} {
		result_debug "less or equal match of $actual <= $expected OK"
		return 1
	    }
	    result_debug "less or equal match of $actual <= $expected FAIL"
	}

    } else {
	result_debug "NOT Interested in $expected vs $actual"
	;# We're not interested in this parameter, so just return 1.
	return 1
    }
    
    return 0
}



################################################################## 
# Procedure Name: _exMacMatch
#   
# Description: Find a matching MAC in the line looking for supMac,supIp,
#              authVal, authType, user, and reauthTimer values
# 
# Input args:  macMatchLine: Line to do comparison against
#              supMac: MAC of sup.
#              supIp: IP Addr of sup.  Only checked for WEB BASED!
#              authVal: "No" | "Yes"
#              authType: "802.1x" | "Http"
#              reauthTimer: "0" | "-1" | <value>
#                 -1 : ignore
#                  0 : Looking for timer == 0
#               <val>: Looking for GREATER <val> 
#              user: Username used to login with.
#
# Output args: 1-match 0-no match
#
# Expected output of show netlogin. 
#
# * Summit48i:94 # show netlogin 
# Port: 21,   Vlan: vlan_1,  State: Authenticated
# MAC                IP address      Auth   Type      ReAuth-Timer User    
# 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown 
# 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5
# ------------------------------------------------
#
##################################################################
proc _exMacMatch {macMatchLine supMac supIp authVal authServer authType reauthTimer user} {

    result_debug "Examining macMatchLine $macMatchLine"

    set _supMac ""
    set _supIp "" 
    set _authVal "" 
    set _authServer "" 
    set _authType "" 
    set _reauthTimer "" 
    set _user ""
    
    ;# MAC - IP - Auth - Type - ReAuth - User
    if {[CompareRelease [GetVersion "DUT1"] "11.7.0.11"]>=0} {
        scan $macMatchLine {%s %s %s %s %s %s %s} _supMac _supIp _authVal _authServer _authType _reauthTimer _user
    } else {
        scan $macMatchLine {%s %s %s %s %s %s} _supMac _supIp _authVal _authType _reauthTimer _user
    }
#    ;# Hack for empty IP Address.  Check if _supIp field picks up Yes/No from _authVal field
#   if {($_supIp == "Yes") || ($_supIp == "No")} {
#	scan $macMatchLine {%s %s %s %s %s} _supMac _authVal _authType _reauthTimer _user
#	set _supIp ""
#   }
    if {[CompareRelease [GetVersion "DUT1"] "11.7.0.11"]>=0} {
       result_debug "EXPECTED: $supMac $supIp $authVal $authServer $authType $reauthTimer $user"	
       result_debug "ACTUAL    $_supMac $_supIp $_authVal $_authServer $_authType $_reauthTimer $_user"
    } else {
       result_debug "EXPECTED: $supMac $supIp $authVal $authType $reauthTimer $user"	
       result_debug "ACTUAL    $_supMac $_supIp $_authVal $_authType $_reauthTimer $_user"
    }
    
    ;# IP Address is only valid for WEB Based.  Make sure we don't check it if
    ;# we expect auth type of 802.1x
    if [regexp -nocase "802.1x" $authType] {
	set supIp ""
    }
    
    set macMatch 1
    set macMatch [expr $macMatch & [_exCheckMatch $_supIp $supIp]]
    set macMatch [expr $macMatch & [_exCheckMatch $_authVal $authVal]]
    if {[CompareRelease [GetVersion "DUT1"] "11.7.0.11"]>=0} {
       set macMatch [expr $macMatch & [_exCheckMatch $_authServer $authServer]]
    }
    set macMatch [expr $macMatch & [_exCheckMatch $_authType $authType]]
    set macMatch [expr $macMatch & [_exCheckMatch $_user $user "string" "false"]]

    ;# DON'T CHECK FOR NOW
    if {0} {
	if {$reauthTimer == "0"} {
	    set macMatch [expr $macMatch & [_exCheckMatch $_reauthTimer $reauthTimer "equal"]]
	} elseif {$reauthTimer == "-1"} {
	    set macMatch 1
	} else {
	    set macMatch [expr $macMatch & [_exCheckMatch $_reauthTimer $reauthTimer "greater"]]
	}
    }


    return $macMatch
}

################################################################## 
# Procedure Name: _exVerifyShowNetlogin
#   
# Description: Internal procedure that verifies show netlogin params.  Must pass
#              tempfile which contains output of sh netlogin.  This proc
#              just does the checking
# 
# Input args: 
#       port:   DUT port
#	vlan:   DUT vlan
#	portState: "Auth" | "Unauth"
#	supMac: supplicant MAC
#	supIp:  supplicant IP
#	authVal: "Yes" | "No"
#	authType: "802.1x" | "Http"
#       reauthTimer: "0" | "-1" | <value>
#          -1 : ignore
#           0 : Looking for timer == 0
#        <val>: Looking for GREATER <val> 
#	user: username logged in as
#	tempFile: File containing "show netlogin" output
#
# Output args: 1-match 0-no match
#
# Expected output of show netlogin. 
#
# * Summit48i:94 # show netlogin 
# Port: 21,   Vlan: vlan_1,  State: Authenticated
# MAC                IP address      Auth   Type      ReAuth-Timer User    
# 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown 
# 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5
# ------------------------------------------------
#
# NOTE: Did NOT use CheckKeyValue because it couldn't handle multi layer output of 
#       Port, then MAC list
##################################################################
proc _exVerifyShowNetlogin {args} {
    parse_args _exVerifyShowNetlogin $args {
	port        ""
	vlan        ""
	portState   ""
	supMac      ""
	supIp       ""
	authVal     ""
	authType    ""
	authServer  ""
	reauthTimer ""
	user        ""
	tempFile    ""
    }

    ;# Open for reading
    set fd_in [open $tempFile "r"]
    
    set portVlanMatchLine  ""
    set macMatchLine       ""
    ;# Find correct port/vlan and MAC lines 
    while {[gets $fd_in line] != -1} {
	;# Look for Port/Vlan Match.
	if {[regexp -nocase -indices -- Port:.*$port.*Vlan:.*$vlan $line matchedRange] == 1} {
	    set portVlanMatchLine $line
	    result_debug "FOUND Port:$port Vlan:$vlan on line:$line"
	    
	    if {[string length $supMac] == 0} {
		;# Only looking for port/vlan state
		result_debug "No MAC given.  Only needed port/vlan state."
		break
	    }
	    
	    ;# Now look for MAC Match
	    while {[gets $fd_in line] != -1} {
		
		result_debug "Looking for a MAC Match...$line"
		if {[regexp -nocase "/-/-/-/-/-/-" $line] == 1} {
		    ;# Found end of port section delimiter...MAC not found in the section.
		    result_debug "Hit delimiter without finding MAC"
		    break;
		}
		    
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    result_debug "FOUND MAC:$supMac on line:$line"
		    set macMatchLine $line
		    break
		}
	    }
	    break;
	}
    }
    close $fd_in
    
    
    if {$portVlanMatchLine == ""} {
	result_debug "Port:$port Vlan:$vlan NOT FOUND"
	return 0
    }

    set portVlanMatch 0

    ;# Apply required key info matches
    if { [string length $portVlanMatchLine] > 0 } {
	if {$portState != ""} {
	    set portVlanMatch [regexp -nocase "\ $portState" $portVlanMatchLine]
	    if {$portVlanMatch} {
		result_debug "portState $portState OK"
	    } else {
		result_debug "string match of $portState vs $portVlanMatchLine FAILED"
	    }

	} else {
	    set portVlanMatch 1
	    result_debug "Ignoring portState $portState portVlanMatch: $portVlanMatch"
	}
    }
    
    ;# We don't care about supplicant MAC entry
    if {[string length $supMac] == 0} {
	result_debug "SupMac $supMac was not given.  Returning portVlanMatch: $portVlanMatch"
	return $portVlanMatch
    }
    

    set macMatch 0

    if { [string length $macMatchLine] > 0 } {
	result_debug "Matching supMac $supMac with $macMatchLine"
        set macMatch [_exMacMatch $macMatchLine $supMac $supIp $authVal \
               $authServer $authType $reauthTimer $user]
    } else {
	result_debug "$supMac not found"
    }

    result_debug "RETURNING port: $portVlanMatch  mac: $macMatch"

    return [expr $portVlanMatch & $macMatch]
    
}



################################################################## 
# Procedure Name: nl_exVerifyShowNetlogin
#   
# Description: Verifies "show netlogin" parameters for 1 or more 
#              supplicants.  Writes output to a temp file for which
#              is parsed by an internal proc.  Temp file is deleted
#              before exiting.
# 
# Input args: 
#       port:   DUT port
#	vlan:   DUT vlan
#	portState: "Auth" | "Unauth"
#	supMac: supplicant MAC
#	supIp:  supplicant IP
#	authVal: "Yes" | "No"
#	authType: "802.1x" | "Http"
#       reauthTimer: "0" | "-1" | <value>
#          -1 : ignore
#           0 : Looking for timer == 0
#        <val>: Looking for GREATER <val> 
#	user: username logged in as
#	numSupplicants: 1 or more
#
# Output args: none
#
# Expected output of show netlogin. 
#
# * Summit48i:94 # show netlogin 
# Port: 21,   Vlan: vlan_1,  State: Authenticated
# MAC                IP address      Auth   Type      ReAuth-Timer User    
# 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown 
# 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5
# ------------------------------------------------
#
# NOTE: Did NOT use CheckKeyValue because it couldn't handle multi layer output of 
#       Port, then MAC list
##################################################################
proc nl_exVerifyShowNetlogin {args} {
    parse_args nl_exVerifyShowNetlogin $args {
	port        ""
	vlan        ""
	portState   ""
	supMac ""
	supIp  ""
	authVal     ""
	authType    ""
	authServer  ""
	reauthTimer ""
	user        ""
	numSupplicants "1"
    }

    set curIp $supIp
    set curMac $supMac
    set numSup $numSupplicants

    report_start_test "Verify show netlogin for $numSup supplicant(s) $portState"

   global tmpPath
   set tmp "Tmp"
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile "$tmp/tmp_netlogin$pid"

    ;# Execute show netlogin and put output into a file
    set fd_in [open $tempFile "w"]
    SendACmd "show netlogin" NULL $fd_in

    close $fd_in
    set numFail 0
    while { $numSup } {
	result_debug "($numSup) Verify show netlogin supMac:$curMac supIp:$curIp"
    
	if {! [_exVerifyShowNetlogin -port $port \
		-vlan $vlan -portState $portState -supMac $curMac \
		-supIp $curIp -authVal $authVal -authServer $authServer \
                -authType $authType -reauthTimer $reauthTimer -user $user \
                -tempFile $tempFile]} {
	    result_error "Verification of show netlogin parameters failed."
	    incr numFail
	}
	;# Increment IP and MAC
	if {$curIp != ""} {
	    set curIp [IncrIpAddr $curIp]
	}
	if {$curMac != ""} {
	    set curMac [IncMacByOne $curMac ":"]
	}
	incr numSup -1
    }
    if {$numFail > 0} {
	result_error "$numFail of $numSupplicants supplicants failed to Authenticate"
    }
    report_end_test

    if {$numFail == 0} {
	file delete $tempFile
    } else {
	result_debug "FAILURES! Preserving $tempFile for review"
	result_debug "********** EXPECTED FILE CONTENTS ***********"
	SendACmd "show netlogin"
    }
    return $numFail
}



################################################################## 
# Procedure Name: _exVerifyShowNetloginPorts
#   
# Description: Internal procedure that checks "show netlogin ports <x> <vlan>" 
#              parameters for an individual port/vlan combination
# 
# Input args: 
#       port:   DUT port
#	vlan:   DUT vlan
#	auth:   mac-based | 802.1x | web-based
#	portState: "Enabled" | "Disabled"
#	supIp:  supplicant IP
#	authVal: "Yes" | "No"
#	authType: "802.1x" | "Http"
#       reauthTimer: "0" | "-1" | <value>
#          -1 : ignore
#           0 : Looking for timer == 0
#        <val>: Looking for GREATER <val> 
#	user: username logged in as
#       showMode: port | vlan | port_vlan
#              show netlogin port <portNum>
#              show netlogin vlan <vlanName>
#              show netlogin port <portNum> vlan <vlanName>
#
# Output args: none
#
# * BD-10808.321 # show netlogin ports 2:11
# Port           : 21        
# Vlan           : vlan_1
# Authentication : mac-based
# Port State     : Enabled
#
# MAC                IP address      Auth   Type      ReAuth-Timer User    
# ------------------------------------------------------------------
# 00:00:01:02:01:01  0.0.0.0         No     802.1x    2            Unknown         
#
##################################################################
proc _exVerifyShowNetloginPorts {args} {
    parse_args _exVerifyShowNetloginPorts $args {
	port        ""
	vlan        ""
	auth        ""
	portState   ""
	supMac      ""
	supIp       ""
	authVal     ""
	authType    ""
        authServer  ""
	reauthTimer ""
	user        ""
	showMode    "port_vlan"
    }

    ;# Not enough parameters
    if {$port == "" && $vlan == ""} {
	result_debug "_exVerifyShowNetloginPorts{} Not enough parameters"
	return 0
    }

   global tmpPath
   set tmp "Tmp"
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile "$tmp/tmp_Dot1X$pid"

    ;# Execute show netlogin po and put output into a file
    set fd_in [open $tempFile "w"]
   if {$showMode == "port"} {
       SendACmd "show netlogin port $port" NULL $fd_in
   } elseif {$showMode == "vlan"} {
       SendACmd "show netlogin vlan $vlan" NULL $fd_in
   } else {
       SendACmd "show netlogin port $port vlan $vlan" NULL $fd_in
   }
   close $fd_in

   ;# Open for reading
   set fd_in [open $tempFile "r"]
    
   set portMatchLine  ""
   set vlanMatchLine  ""
   set authMatchLine  ""
   set portStateMatchLine ""
   set macMatchLine       ""
   ;# Find correct port/vlan and MAC lines 
    while {[gets $fd_in line] != -1} {

	;# Look for Port/Vlan Match.
	if {[regexp -nocase -indices -- Port\ *:\ *$port.* $line matchedRange] == 1} {

	    set portMatchLine $line

	    ;# Get next line for Vlan
            while {[gets $fd_in line] != -1} {
		set vlanMatchLine $line
		if {[regexp -nocase -indices -- Vlan\ *:\ *$vlan.* $line matchedRange] != 1} {
		    ;# No port/vlan match...get next line
		    set vlanMatchLine ""
		    continue
		}
               break;
	    }

	    result_debug "FOUND Port:$port Vlan:$vlan\n$portMatchLine\n$vlanMatchLine"
	    
	    ;# Get Auth ... We assume it's on next line vlan
	    if {[gets $fd_in line] != -1} {
		set authMatchLine $line
	    }

	    ;# Get Port State... We assume it's on next line following Auth
	    if {[gets $fd_in line] != -1} {
		set portStateMatchLine $line
	    }    
	    
	    if {[string length $supMac] == 0} {
		;# Only looking for port/vlan/auth/portState
		break
	    }

	    ;# Now look for MAC Match
	    while {[gets $fd_in line] != -1} {
		
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    result_debug "FOUND MAC:$supMac on line:$line"
		    set macMatchLine $line
		    break
		}
	    }
	    if {$macMatchLine == ""} { result_debug "MAC:$supMac NOT FOUND"}
	    break;
	}
    }

    close $fd_in
    file delete $tempFile
    
    if {$portMatchLine == ""} {
	result_debug "Port:$port NOT FOUND"
	return 0
    }

    set portVlanMatch 1

    ;# Apply required key info matches
    if {$portState != ""} {
	set portMatch [regexp -nocase "Port State\ *:\ *$portState" $portStateMatchLine]
	result_debug "Looking at portState $portState portVlanMatch: $portVlanMatch"
	result_debug "$portVlanMatch  $portMatch"
	set portVlanMatch [expr $portVlanMatch & $portMatch]
	result_debug "After & operator $portVlanMatch"
    }
    

    if {$auth != ""} {
	set authMatch [regexp -nocase "Authentication\ *:\ *$auth" $authMatchLine]
	result_debug "Looking at AuthMode:$auth authMatch: $authMatch"
	result_debug "$portVlanMatch  $authMatch"
	set portVlanMatch [expr $portVlanMatch & $authMatch]
	result_debug "After & operator $portVlanMatch"
    }
           
    ;# We don't care about supplicant MAC entry
    if {[string length $supMac] == 0} {
	result_debug "SupMac $supMac was not given.  Returning portVlanMatch: $portVlanMatch"
	return $portVlanMatch
    }
    

    set macMatch 0
    if { [string length $macMatchLine] > 0 } {

	   set macMatch [_exMacMatch $macMatchLine $supMac $supIp $authVal \
                $authServer $authType $reauthTimer $user]
    }

    result_debug "RETURNING port: $portVlanMatch  mac: $macMatch"
    return [expr $portVlanMatch & $macMatch]
}



################################################################## 
# Procedure Name: nl_exVerifyShowNetloginPorts
#   
# Description: Proc that checks "show netlogin ports <x> <vlan>" 
#              parameters for 1 or more supplicants.  We, of course,
#              assume all supplicants have the same values when 
#              checking multiple supplicants.
# 
# Input args: 
#       port:   DUT port
#	vlan:   DUT vlan
#       auth:    mac-based | dot1x | web-based
#	portState: "Disabled" | "Enabled"
#	supMac: supplicant MAC
#	supIp:  supplicant IP
#	authVal: "Yes" | "No"
#	authType: "802.1x" | "Http"
#       reauthTimer: "0" | "-1" | <value>
#          -1 : ignore
#           0 : Looking for timer == 0
#        <val>: Looking for GREATER <val> 
#	user: username logged in as
#       numSupplicants: Number of supplicants to check.
#       showMode: port | vlan | port_vlan
#              show netlogin port <portNum>
#              show netlogin vlan <vlanName>
#              show netlogin port <portNum> vlan <vlanName>
#
# Output args: none
#
# Expected output of show netlogin ports 
#
# * BD-10808.321 # show netlogin ports 2:11
# Port           : 21        
# Vlan           : vlan_1
# Authentication : mac-based
# Port State     : Enabled
#
# MAC                IP address      Auth   Type      ReAuth-Timer User    
# ------------------------------------------------------------------
# 00:00:01:02:01:01  0.0.0.0         No     802.1x    2            Unknown         
#
##################################################################
proc nl_exVerifyShowNetloginPorts {args} {
    parse_args nl_exVerifyShowNetloginPorts $args {
	port        ""
	vlan        ""
	auth        ""
	portState   ""
	supMac      ""
	supIp       ""
	authVal     ""
	authType    ""
	authServer  ""
	reauthTimer ""
	user        ""
	numSupplicants "1"
	showMode    "port_vlan"
    }

    set rc 1
    set curIp $supIp
    set curMac $supMac

    report_start_test "Verify show netlogin ports for $numSupplicants supplicant(s) $portState"

    while { $numSupplicants } {
	result_debug "($numSupplicants) Verify show netlogin ports supMac:$curMac supIp:$curIp"
	
	if {$authType == "mac" } {
	    ;# username is same as MAC without the ":"
	    set user [nl_stripMac $curMac ""] 
	    result_debug "Setting user to $user"
	}

	if {! [_exVerifyShowNetloginPorts -port $port \
		-vlan $vlan -portState $portState -auth $auth -supMac $curMac \
		-supIp $curIp -authVal $authVal -authType $authType \
                -authServer $authServer -reauthTimer $reauthTimer -user $user \
                -showMode $showMode]} {
	    result_error "Verification of show netlogin ports parameters failed."
	    set rc 0
	}
	;# Increment IP and MAC
	if {$curIp != ""} {
	    set curIp [IncrIpAddr $curIp]
	}
	if {$curMac != ""} {
	    set curMac [IncMacByOne $curMac ":"]
	}

	incr numSupplicants -1
    }

    report_end_test

    return $rc
}

    


################################################################## 
# Procedure Name: nl_exVerifyShowSession
#   
# Description: Proc that checks "show session"
#              This actually just wraps CheckKeyValue so parameters
#              are checked based on min regexp.  For example, loginTime
#              can be entered as "Dec" or "Thu Dec 16" to yield a
#              good match.
# 
# Input args: 
#	id:        Login id. 0-n
#	loginTime: Date/Time of login
#	user:      Username of login
#	type:      "console" | "netlogin" | "radius"
#	auth:      "local" | "radius"
#	cliAuth:   "enabled" | "disabled"
#	location:  "serial" | <ip>
#
# Output args: none
#
# Expected output of show session
#
# * Summit48i:12 # show session
#    # Login Time                 User     Type     Auth     CLI Auth Location
# ==============================================================================
#      0 Wed Dec 15 12:23:20 1999 admin    console  local    disabled serial
#      4 Thu Dec 16 16:20:27 1999 ixia1md5 netlogin radius   disabled 0.0.0.0
#      5 Thu Dec 16 16:20:28 1999 ixia1md5 netlogin radius   disabled 0.0.0.0
#      6 Thu Dec 16 16:20:29 1999 ixia1md5 netlogin radius   disabled 0.0.0.0
#      7 Thu Dec 16 16:20:30 1999 ixia1md5 netlogin radius   disabled 0.0.0.0
#      8 Thu Dec 16 16:20:32 1999 ixia1md5 netlogin radius   disabled 0.0.0.0
# * 1028 Thu Dec 16 16:20:56 1999 admin    telnet   radius   disabled 10.212.9.4
#
##################################################################
proc nl_exVerifyShowSession {args} {
    parse_args nl_exVerifyShowSession $args {
	id        ""
	loginTime ""
	user      ""
	type      ""
	auth      ""
	cliAuth   ""
	location  ""
    }
    report_start_test "Verify show session"

    lappend parameterList "$id.*$loginTime.*$user.*$type.*$auth.*cliAuth.*$location"
    set rc [CheckKeyValue "show session" $parameterList \
	    -comment "Verify Show Session Params"]

    report_end_test
    if {$rc == "ok"} {
	return 1
    } else {
	return 0
    }
}


################################################################## 
# Procedure Name: _reportVerifyProtocolResult
#   
# Description: Internal procedure that merely prints error or ok on
#              whether desired traffic was received.
# 
# Input args: 
#      traffic:    "exist" | "notExist"
#      matchCnt:   Number of frames found that match
#      portId:     Logging purposes only
#      typeWanted: Logging purposes only
#
# Output args: none
#
#
##################################################################
proc _reportVerifyProtocolResult { traffic matchCnt portId typeWanted } {
    
    if {$traffic == "exist"} {
	if {$matchCnt <= 0} {
	    result_error "PortId:$portId: Wanted $typeWanted but received $matchCnt"
	    return ERROR
	}
    } elseif {$traffic == "notExist"} {
	if {$matchCnt > 0} {
	    result_error "PortId:$portId: DID NOT want $typeWanted but received $matchCnt"
	    return ERROR
	}
    } else {
	result_debug "PortId:$portId: Unknown state traffic $traffic specified"
	return ERROR
    }

    result_ok "SUCCESS: PortId:$portId: Wanted $traffic. $matchCnt \
	    $typeWanted received as expected"
    return OK

}

################################################################## 
# Procedure Name: _verifyEDP
#   
# Description:  Verify the presence of EDP Traffic.  We enable EDP
#               on a DUT then wait to see traffic on a ports(s) by
#               capturing traffic on Ixia.
#
# 
# Input args: portIdList: Port IDs of ports to examine traffic on
#             edpTraffic:  "exist" | "notExist"
#             command:  "enable" | "disable" protocol on DUT
#
# Output args: none
#
# Decode EDP Packet
# EDP Packet is SNAP Encapsulated Frame.  EDP Header should start after
# SNAP header at location 0x0016 bytes from start of frame.
# EDP Header is followed by 1+ TLV blocks
#
# EDP Header (14 octets)
# ----------
#  1 Version
#  1 reserved
#  2 checksum
#  2 sequence#
#  8 device id (00 00 [mac address])
#
# TLV (Type - Length - Value) 
# ---
#  1 Marker (0x99)
#  1 Type 
#      0 NULL - End Signal
#      1 Display - (MIBII Display String)
#      2 Info - (Basic system info)
#      5 VLAN Info 
#      8 ESRP
#  2 Length
#  n DATA
#
# INFO TLV
# --------
#   2  originating slot
#   2  originating port
#   2  Virtual Chassis ID (If connected to virtual chassis)
#   6  RESERVED
#   4  SW Version
#   16 Virtual Chassis ID Connections
#
# VLAN TLV
# --------
#   1  Flags (bit 8 - 1 means this vlan has IP interface) 
#   3  RESERVED
#   2  VLAN ID (0 if untagged)
#   2  RESERVED
#   4  VLAN IP Addr
#   n  VLAN Name
#
##################################################################
proc _verifyEDP {portIdList {edpTraffic "exist"} {command "enable"} } {

    ;# Start port capture
    StartPortsCapture $portIdList

    sleep 2
    
    ;# Enable protocol
    foreach portId $portIdList {
	SendACmd "$command edp ports [MapDUTPortId $portId]"
    }


    ;# Wait 65 seconds for an EDP Packet (Should arrive every minute)
    result_debug "Sleeping 125 seconds"
    #exSleep 65
    exSleep 125

    ;# Stop Capture
    StopPortsCapture $portIdList

    foreach portId $portIdList {
	report_start_test "Verify PortId:$portId EDP $command EDP Traffic $edpTraffic"
	;# Parse output for packets
	set frameList [GetCapturedFrames $portId]
	set matchCnt 0
	foreach frame $frameList {
	    ;# Look for Device ID MAC followed by TLV Marker.	
	    if {[GetMessageType $frame] == "EDP"} {
		incr matchCnt
	    }
	}
	
	_reportVerifyProtocolResult $edpTraffic $matchCnt $portId "EDP Packets"
	report_end_test
    }
}



################################################################## 
# Procedure Name: _verifySTP
#   
# Description:  Verify the presence of STP Traffic.  We enable STP
#               on a DUT then wait to see traffic on a ports(s) by
#               capturing traffic on Ixia.
#
# 
# Input args: portIdList: Port IDs of ports to examine traffic on
#             vlanList: List of vlans to enable STP on.
#             stpTraffic:  "exist" | "notExist"
#             command:  "enable" | "disable" protocol on DUT
#
# Output args: none
#
# Called from nl_VerifyProtocol
#
##################################################################
proc _verifySTP {portIdList vlanList {stpTraffic "exist"} {command "enable"} } {
    
    
    set portIndex 0

    foreach myVlan $vlanList {
	
	;# Add vlan to default vlan domain s0
	SendACmd "config stpd s0 add vlan $myVlan port all"
    
	;# Start port capture
	StartPortsCapture $portIdList
	
	;# Enable/Disable STP
	SendACmd "$command stpd s0"
	
	;# Wait for some BPDUs to get sent
	result_debug "Waiting 5 seconds for some BPDUs to get sent"
	exSleep 5
	
	;# Stop Capture
	StopPortsCapture $portIdList
	
	;# Parse Buffer
	set portId [lindex $portIdList $portIndex]
	if {$portId == ""} {
	    set portId 1
	}
	#	foreach portId $portIdList {
	    report_start_test "Verify PortId:$portId STP $command BPDUs $stpTraffic"
	    ;# Parse output for packets
	    set frameList [GetCapturedFrames $portId]
	    set matchCnt 0
	    foreach frame $frameList {
		if { [regexp -nocase "BPDU" [GetMessageType $frame]] } {
		    incr matchCnt
		}
	    }
	    
	    _reportVerifyProtocolResult $stpTraffic $matchCnt $portId "STP BPDUs"
	    report_end_test
	    #	}
	    incr portIndex

	;# Clean up
	SendACmd "config stpd s0 delete vlan $myVlan port all"
	SendACmd "unconfig stpd"
    }
}



################################################################## 
# Procedure Name: _verifyRIP
#   
# Description:  Verify the presence of RIP Traffic.  We enable RIP
#               on a DUT then wait to see traffic on a ports(s) by
#               capturing traffic on Ixia.
#
# 
# Input args: portIdList: Port IDs of ports to examine traffic on
#             ripTraffic:  "exist" | "notExist"
#             command:  "enable" | "disable" protocol on DUT
#
# Output args: none
#
# Called from nl_VerifyProtocol
#
##################################################################
proc _verifyRIP {portIdList {ripTraffic "exist"} {command "enable"} } {


    SendACmd "enable ipforwarding"      
    SendACmd "config rip add vlan all"
    SendACmd "config rip updatetime 10"

    ;# Start port capture
    StartPortsCapture $portIdList

    ;# Enable/Disable RIP
    SendACmd "$command rip"      

    ;# Wait for some RIP packets to get sent
    result_debug "Waiting 13 seconds for some RIP packets to get sent"
    exSleep 13

    ;# Stop Capture
    StopPortsCapture $portIdList
    
    ;# Parse Buffer
    foreach portId $portIdList {
	report_start_test "Verify PortId:$portId RIP $command RIP Packets $ripTraffic"
	;# Parse output for packets
	set frameList [GetCapturedFrames $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase "RIP" [GetMessageType $frame]] } {
		incr matchCnt
	    }
	}
	
	_reportVerifyProtocolResult $ripTraffic $matchCnt $portId "RIP Packets"
	report_end_test
    }
    
    ;# Clean up
    SendACmd "config rip delete vlan all"
    SendACmd "disable rip"

}

################################################################## 
# Procedure Name: _verifyOSPF
#   
# Description:  Verify the presence of OSPF Traffic.  We enable OSPF
#               on a DUT then wait to see traffic on a ports(s) by
#               capturing traffic on Ixia.
#
# 
# Input args: portIdList: Port IDs of ports to examine traffic on
#             ospfTraffic:  "exist" | "notExist"
#             command:  "enable" | "disable" protocol on DUT
#
# Output args: none
#
# Called from nl_VerifyProtocol
#
##################################################################
proc _verifyOSPF {portIdList {ospfTraffic "exist"} {command "enable"} } {

    SendACmd "create ospf area 0.0.0.5"
    SendACmd "enable ipforwarding"      
    
#    SendACmd "config ospf add vlan all area 0.0.0.5"

    set rtValue [CheckCmdLegal "config ospf add vlan all area 0.0.0.5" NULL "CheckCmdLegal" 0]

    if { $rtValue == "legal"} {
    ;# Start port capture
    StartPortsCapture $portIdList

    ;# Enable/Disable OSPF
    SendACmd "$command ospf"      

    ;# Wait for some OSPF packets to get sent
    result_debug "Waiting 5 seconds for some OSPF packets to get sent"
    exSleep 5

    ;# Stop Capture
    StopPortsCapture $portIdList
    
    ;# Parse Buffer
    foreach portId $portIdList {
	report_start_test "Verify PortId:$portId OSPF $command OSPF Packets $ospfTraffic"
	;# Parse output for packets
	set frameList [GetCapturedFrames $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase "OSPF" [GetMessageType $frame]] } {
		incr matchCnt
	    }
	}
	
	_reportVerifyProtocolResult $ospfTraffic $matchCnt $portId "OSPF Packets"
	report_end_test
    }
} else {
    result_debug "This platform does not support OSPF"
}
    
    ;# Clean up
    SendACmd "unconfig ospf"
    SendACmd "disable ospf"
}

################################################################## 
# Procedure Name: _verifyIGMP
#   
# Description:  Verify the presence of IGMP Traffic.  We enable IGMP
#               on a DUT then wait to see traffic on a ports(s) by
#               capturing traffic on Ixia.
#
# 
# Input args: portIdList: Port IDs of ports to examine traffic on
#             igmpTraffic:  "exist" | "notExist"
#             command:  "enable" | "disable" protocol on DUT
#
# Output args: none
#
# Called from nl_VerifyProtocol
##################################################################
proc _verifyIGMP {portIdList {igmpTraffic "exist"} {command "enable"} } {

    ;# Start port capture
    StartPortsCapture $portIdList

    ;# Enable/Disable IGMP
    SendACmd "disable igmp"
    SendACmd "config igmp 1 1 1"  ;# Shorten interval so we don't wait long for
    SendACmd "$command igmp"      ;# a packet to arrive

    ;# Wait for some IGMP Packets to get sent
    result_debug "Waiting 30 seconds for some IGMP packets to get sent"
    exSleep 30

    ;# Stop Capture
    StopPortsCapture $portIdList
    
    ;# Parse Buffer
    foreach portId $portIdList {
	report_start_test "Verify PortId:$portId IGMP $command IGMP Packets $igmpTraffic"
	;# Parse output for packets
	set frameList [GetCapturedFrames $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase "IGMP" [GetMessageType $frame]] } {
		incr matchCnt
	    }
	}
	
	_reportVerifyProtocolResult $igmpTraffic $matchCnt $portId "IGMP Packets"
	report_end_test
    }


    ;# Clean up IGMP is enabled by default
    SendACmd "unconfig igmp"
    SendACmd "enable igmp"
}


################################################################## 
# Procedure Name: nl_VerifyProtocol
#   
# Description: Verify that a particular protocol is blocked or unblocked
# 
# Input args: 
#    portIdList:   Port IDs to check traffic on
#    command:      "enable" | "disable"
#    protocol:     "edp" | "rip" | "ospf" | "stp" | "igmp"
#    traffic:      "exist" | "notExist"
#    optionalList: Currently used by "stp" for list of vlans
#
# Output args: none
#
# Typical Usage:
#    Login $DUT1_CONNECT
#    nl_VerifyProtocol [list 1 2] "enable" "edp" "exist"
#    nl_VerifyProtocol [list 1 2] "disable" "edp" "notExist"
#
##################################################################
proc nl_VerifyProtocol { portIdList command protocol traffic {optionalList [list]} } {
    
    switch -- $protocol \
      "edp" {
        _verifyEDP $portIdList $traffic $command
    } "rip" { 
	_verifyRIP $portIdList $traffic $command
    } "ospf" {
        _verifyOSPF $portIdList $traffic $command
    } "stp" {
	_verifySTP $portIdList $optionalList $traffic $command
    } "igmp" {
	_verifyIGMP $portIdList $traffic $command
    } default {
	result_error "Unsupported protocol $protocol"
    }
}


################################################################## 
# Procedure Name: nl_ixCheckDHCPBroadcastBlocked
#   
# Description: Verify that DHCP broadcasts don't go out protected port
#
# Input args: 
#    protectedPortId: Port which should NOT receive broadcasts
#    dhcpPortId:      Informational only. Used for message. 
#    srcMac:          Source MAC of DHCP request.  Usually supplicant.     
#    dhcpServer:      DHCP Server to send request to. Usually DUT 
#    reqIP:           IP Address being requested.  This really doesn't matter.
#
# Output args: none
#
# Typical Usage:
#   nl_CheckDHCPBroadcastBlocked $protectedPortId $dhcpPortId \
#	  $supMacCampus "10.1.1.1" "10.1.1.3" 
#
##################################################################
proc nl_ixCheckDHCPBroadcastBlocked { protectedPortId dhcpPortId \
	srcMac dhcpServer reqIP} {

    set broadcastMac "FF FF FF FF FF FF"

    StartPortsCapture [list $protectedPortId]
    set rawframe [SendDHCPRequest $srcMac 2 $dhcpServer $reqIP 0]

    StopPortsCapture [list $protectedPortId]
    
    report_start_test "Check DHCP Broadcast from port:[MapDUTPortId $dhcpPortId] does \
	    not reach protected port:[MapDUTPortId $protectedPortId]"

    set rawPortDataList [GetCapturedFrames 1]
    set fCnt 0
    foreach frame $rawPortDataList {
	;# Check if we received any broadcast traffic.
	set targetMac [GetTargetMacAddress $frame]
	if {$targetMac == $broadcastMac} {
	    incr fCnt
	    result_debug "Protected port [MapDUTPortId $protectedPortId] received illegal broadcast $frame"
	}
    }

    if {$fCnt == 0} {
	result_ok "DHCP Broadcasts blocked on protected port [MapDUTPortId $protectedPortId]"
    } else {
	result_error "Protected port [MapDUTPortId $protectedPortId] received $fCnt broadcast packets"
    }
    report_end_test
}

################################################################## 
# Procedure Name: nl_CheckARPBroadcastBlocked
#   
# Description: Ping from DUT out unprotected port.  Verify that ARP 
#              Broadcast is sent out unprotected port and NOT protected 
#              port.   
#              We assume protected and unprotected ports ARE 
#              ON THE SAME VLAN!  
# Input args: 
#     protectedPortId    Port ID of netlogin port.
#     unprotectedPortId: Port ID of non-netlogin port.
#     destIp:            IP Address in ARP.  We use this to clear
#                        the entry to make sure we get a new ARP.
#
# Output args: none
#
# Typical Usage:
#     Login $DUT1_CONNECT
#     nl_CheckARPBroadcast $protectedPortId $pingPortId "10.1.1.100"
#
##################################################################
proc nl_CheckARPBroadcastBlocked { protectedPortId unprotectedPortId destIp } {
    
    set portIdList [list $protectedPortId $unprotectedPortId]
    
    ;# Delete destIp entry from ARP table to make sure we generate ARP.
    SendACmd "clear iparp $destIp"

    report_start_test "Sending ping from DUT to $destIp to generate ARP"

    StartPortsCapture $portIdList

    SendACmd "ping $destIp"

    StopPortsCapture $portIdList
    
    set rawPortDataProtected [GetCapturedFrames $protectedPortId]
    set rawPortDataUnprotected [GetCapturedFrames $unprotectedPortId]
    
    result_debug "******************** PROTECTED PORT DATA ************************"
    set protectedStatus   0
    set unprotectedStatus 0
    foreach frame $rawPortDataProtected {
	
	set msgType [GetMessageType $frame]
	result_debug "($msgType) Raw: $frame"
	if [regexp "ARP_REQUEST" $msgType ] {
	    set protectedStatus 1
	}

    }

    result_debug "******************** UNPROTECTED PORT DATA ************************"
    foreach frame $rawPortDataUnprotected {
	
	set msgType [GetMessageType $frame]
	result_debug "($msgType) Raw: $frame"
	if [regexp "ARP_REQUEST" $msgType] {
	    set unprotectedStatus 1  
	}

    }
    if {$protectedStatus} {
	result_error "Broadcast ARP_REQUEST seen on Protected"
    } else {
	result_ok "No ARP_REQUEST seen on Protected($protectedStatus)"
    }

    if {$unprotectedStatus} {
	result_ok "Broadcast ARP_REQUEST seen on Unprotected Port"
    } else {
	result_error "No ARP_REQUEST seen on Unprotected Port($unprotectedStatus)"
    }

    report_end_test
}


################################################################## 
# Procedure Name: nl_VerifyDHCPBootPRelay
#   
# Description: Verify we can reach external DHCP server.  We send DHCP 
#              request from supplicant on txPortId with MAC srcMac
#              to external DHCP server after authenticating.
#
# NOTE: We only check that packet is forwarded by looking at 
#       BootPRelay Stats.  We don't actually check for response.
#       That's left for a future exercise.  This actually only
#       an interim check.  Ideally, Ixia IxAuth should support
#       DHCP, to really validate.  Until then, this is good enough
#  
# Input args: 
#     txPortId: Port to transmit out of
#     srcMac:   Source address of supplicant MAC.
#
# Output args: none
#
# Typical Usage:
#    Login $DUT1_CONNECT
#    .....802.1x Authenticated $cookedSupMac.....     
#    nl_VerifyDHCPBootPRelay 1 $cookedSupMac
#
##################################################################
proc nl_VerifyDHCPBootPRelay { txPortId srcMac } {

    SendACmd "clear counters"

    set frame [SendDhcpFrame -txPortId $txPortId -destMac "FF FF FF FF FF FF" \
	    -sourceMac $srcMac -sourceIp "0.0.0.0" \
	    -destIp "255.255.255.255" -opCode "dhcpBootRequest" \
	    -optionCodeList [list dhcpMessageType dhcpDiscover] \
	    -clientHwAddr $srcMac];     	
    
    result_debug "(802.1x) DHCP Discover frame: $frame"
    
    ;# Verify bootprelay stats increasing with show ipstats
    ;# DHCP/BOOTP relay statistics:
    ;#        Received to server: 0   Received to client: 0
    ;#        Requests relayed: 0     Responses relayed: 0
    ;#        DHCP Discover:  0       DHCP Offer:     0
    ;#        DHCP Request:   0       DHCP Decline:   0
    ;#        DHCP Ack:       0       DHCP NAck:      0
    ;#        DHCP Release:   0       DHCP Inform:    0

    set parameterList [list]
    lappend parameterList "{Received to server: 1} exist";
    lappend parameterList "{Requests relayed: 1} exist";  
    CheckKeyValue "show bootprelay" $parameterList -comment "DHCP relay stats";
    unset parameterList;
}


################################################################## 
# Procedure Name: nl_VerifySupplicantPackets
#   
# Description: 
#     rawPortData: Raw frames data
#     srcMac:      Source MAC that we're looking for
#     dstMac       Dest MAC that we're looking for
#     packetExpr:  Type of packet to look for. This should match msgTypes returned
#                  from MessageDecoding.tcl.  If MessageDecoding.tcl does not support
#                  a particular packet type, this procedure will not work.
#                  Use alternation "|" symbol (i.e. "stringA|stringB") to match multiple strings
#     rx:          "yes" | "no"   yes-we should receive, no-we should NOT receive any
# 
# Input args: 
#
# Output args: none
#
# Typical Usage:
#    nl_VerifySupplicantPackets $rawPortData $cookedDutMac $cookedSupMac "EAP.*REQ"
#    nl_VerifySupplicantPackets $rawPortData $cookedDutMac $cookedSupMac "EAP.*FAIL"
#    nl_VerifySupplicantPackets $rawPortData $srcMac $dstMac "EAP.*REQUEST_IDENTITY|EAP.*SUCC"
#
##################################################################
proc nl_VerifySupplicantPackets { rawPortData srcMac dstMac packetExpr {rx "yes"} } {

    report_start_test "Verify we receive correct packets"

    set statusCnt 0

    foreach frame $rawPortData {
	set msgType [GetMessageType $frame]
	set frameDstMac [GetDestMacAddress $frame]
	set frameSrcMac [GetSourceMacAddress $frame]

	result_debug "FRAME TYPE: $msgType src:$frameSrcMac dst:$frameDstMac"
	result_debug "LOOKING FOR src:$srcMac dst:$dstMac"
	
	;# Verify supplicant received Success/Fail Frame.
	if {[regexp -nocase "$packetExpr" $msgType]} {
	    result_debug "---> Got $packetExpr Packet <---"
	    if { ($srcMac == $frameSrcMac) && ($dstMac == $frameDstMac) } {
		incr statusCnt 
	    }
	}
    }
    
    if { ($statusCnt == 0) && ($rx == "no") } {
	result_ok "Supplicant received $statusCnt messages as expected ($packetExpr)"
    } elseif { ($statusCnt == 0) && ($rx == "yes") } {
	result_error "Supplicant received NO messages, but expected to. ($packetExpr)"
    } elseif { ($statusCnt > 0) && ($rx == "no") } {
	result_error "Supplicant received $statusCnt messages, but expected NONE. ($packetExpr)"
    } elseif { ($statusCnt > 0) && ($rx == "yes") } {
	result_ok "Supplicant received $statusCnt message as expected ($packetExpr)"
    }

    report_end_test

}

################################################################## 
# Procedure Name: nl_VerifySupplicantEAPPackets
#   
# Description: Looks at raw frame data from capture and verifies that 
#              supplicant received the EAP REQUEST_IDENTITY and SUCCESS 
#              packets.
# 
# Input args: 
#     rawPortData: Raw port data from a packet capture 
#     srcMac:      Src MAC to search for
#     dstMac:      Dst MAC to search for
#     status:      "SUCCESS" | "FAIL"
#
# Output args: none
#
# Typical Usage:
#       nl_VerifySupplicantEAPPackets $rawPortData $cookedDutMac $cookedSupMac
#
##################################################################
proc nl_VerifySupplicantEAPPackets { rawPortData srcMac dstMac {status "SUCCESS"}} {


    nl_VerifySupplicantPackets $rawPortData $srcMac $dstMac \
	    "EAP.*REQUEST_IDENTITY|EAP.*$status"

    return


    report_start_test "Verify we receive correct EAP packets"

    set eapRiCnt 0
    set eapStatusCnt 0

    foreach frame $rawPortData {
	set msgType [GetMessageType $frame]
	set frameDstMac [GetDestMacAddress $frame]
	set frameSrcMac [GetSourceMacAddress $frame]

	result_debug "FRAME TYPE: $msgType src:$frameSrcMac dst:$frameDstMac"
	result_debug "LOOKING FOR src:$srcMac dst:$dstMac"
	
	;# Verify supplicant received EAP-Request-Identity Frame
	if {[regexp -nocase "EAP.*REQUEST_IDENTITY" $msgType]} {
	    if { ($srcMac == $frameSrcMac) && ($dstMac == $frameDstMac) } {
		incr eapRiCnt 
	    }
	}

	;# Verify supplicant received EAP Success/Fail Frame.
	if {[regexp -nocase "EAP.*$status" $msgType]} {
	    if { ($srcMac == $frameSrcMac) && ($dstMac == $frameDstMac) } {
		incr eapStatusCnt 
	    }
	}
    }
    
    if { ($eapRiCnt == 0) || ($eapStatusCnt == 0) } {
	if {$eapRiCnt == 0} {
	    result_error "No EAP Request Identity Packet received"
	}
	if {$eapStatusCnt == 0} {
	    result_error "No EAP $status Packet received"
	}
    } else {
	result_ok "Supplicant received correct EAP messages"
    }

    report_end_test
}



################################################################## 
# Procedure Name: nl_VerifyTaggedPackets
#   
# Description: Verify whether we find any tagged frames in a raw
#              frame capture.
#
# Input args: 
#     rawFrameData:   Ixia packet capture frames
#     tag:            Tag number. No tag means we should NOT receive any
#     comment:        Normal comment to output to test
#
# Output args: none
#
# Typical Usage:
#    nl_VerifyTaggedPackets $rawData_1 "" "Dot1x port [MapDUTPortId 1]"    ;# No tag
#    nl_VerifyTaggedPackets $rawData_2 "$tag"  "Tagged port [MapDUTPortId 2]"  
#
##################################################################
proc nl_VerifyTaggedPackets { rawFrameData {tag ""} {comment ""}} {

    if {$tag == ""} {
	report_start_test "Verify packets are NOT tagged ($comment)"

	;# Stop as soon as we find a tagged packet
	set curTag -1
	foreach frame $rawFrameData {
	    set curTag [GetTagId $frame]
	    if { $curTag > -1 } {
		result_error "Expected no tagged packets. Got packet $frame with VLAN ID $curTag"
		break;
	    }
	}
	if { $curTag == -1 } {
	    result_ok "No tagged packets found"
	}
	
    } else {
	report_start_test "Verify packets are tagged. VLAN ID $tag ($comment)"

	;# Check that NO PACKETS are tagged
	foreach frame $rawFrameData {
	    set curTag [GetTagId $frame]
	    if {$curTag == $tag} {
		result_ok "Got a matching tagged packet with id $tag"
		break;
	    }
	}
	if { $curTag != $tag } {
	    result_error "No tagged packets found.  Expected packets with VLAN ID $tag"
	}
    }

    report_end_test
}

################################################################## 
# Procedure Name: nl_stripMac
#  
# Description: Proc that strips MAC of ":" seperators
#
# Input args:  mac: MAC address with ":" to strip
#
# Output args: cooked MAC with no : seperators
#
##################################################################
proc nl_stripMac { mac {newDelimiter " "}} {

    set cookedMac ""
    regsub -all ":" $mac $newDelimiter cookedMac

    return $cookedMac
}

################################################################## 
# Procedure Name: nl_delimitMac
#  
# Description: Proc that replaces MAC " " with ":" seperators
#
# Input args:  mac: MAC address
#
# Output args: uncooked MAC with : seperators
#
##################################################################
proc nl_delimitMac { mac } {

    set uncookedMac ""
    regsub -all " " $mac ":" uncookedMac

    return $uncookedMac
}

################################################################## 
# Procedure Name: nl_getMacForIP 
#  
# Description: Retrieves MAC for a given IP from a list returned
#              by nl_ixCreatePortIfs.  Format is {port ip mac}
#
# Input args:  ip, macList, cooked
#
# Output args: MAC with : seperators, unless cooked != 0
#
##################################################################
proc nl_getMacForIP { ip macList {cooked 0}} {

    set mac ""

    result_debug "nl_getMacForIP{} macList: $macList"


    foreach entry $macList {
	;# entry: <port> <IP> <{MAC}>
	result_debug "entry: $entry"
	
	set ipAddr [lindex $entry 1]

	if {$ipAddr == $ip} {
	    set mac [lindex $entry 2]
	    break
	}
    }

    if {$cooked} {
	return $mac   ;# Space delimited MAC
    } else {
	return [nl_delimitMac $mac]    ;# : delimited MAC
    }
}


################################################################## 
# Procedure Name: nl_SkipTestBasedOnPlatform 
#  
# Description: Skip a test because not supported for a platform
#
# Input args:  platformList as defined in..
#                 DUTs_info(DUT1,platform) "Summit200-24"
#              DUT
#
# Output args: 1 skip - 0 don't skip
#
##################################################################
proc nl_SkipTestBasedOnPlatform { platformList {DUTName "DUT1"}} {

    set platform [GetPlatform $DUTName]

    result_debug "nl_SkipTestBasedOnPlatform $platform  list:$platformList"
    foreach platformToSkip $platformList {
	result_debug "$platformToSkip"
	if [regexp -nocase $platformToSkip $platform] {
	    result_debug "nl_SkipTestBasedOnPlatform $platform  $platformToSkip returning 1"
	    
	    return 1
	}
    }
    return 0
}


################################################################## 
# Procedure Name: nl_CheckTaskCrash
#  
# Description: Check logs for a task crash.  You must know the name
#              of the task.
#
# We look for a log entry similiar to ...
# 04/02/2004 21:45.58 <CRIT:SYST> Task tDot1xTask (a783d331) failed
#
# Input args:  taskName  vxWorks Task Name
#
# Output args: ok    - no crash
#              error - found task failure
#
##################################################################
proc nl_CheckTaskCrash { taskName {DUTName "DUT1"} {exitOnFailure 1}} {
    
    global DUT1_CONNECT
    global DUT2_CONNECT
    global DUT3_CONNECT
    global DUT4_CONNECT
    global DUT5_CONNECT

    Login [set [set DUTName]_CONNECT]

    set paramList [list]

    lappend paramList "{Task $taskName .* failed} notExist"
    set returnVal [CheckKeyValue "show log" $paramList]
    
    if {([regexp -nocase "error" $returnVal]) && ($exitOnFailure)} {
	error "ERROR: Task $taskName crashed...script terminating"	
    } else {
	return $returnVal
    }
}


proc nl_CheckDot1xTaskCrash {} {
    
    nl_CheckTaskCrash "tDot1xTask"
}

################################################################## 
# Procedure Name: nl_CreateLocalUser
#  
# Description: Creates a Netlogin local user.
#
# Input args:  login - Login Name
#              passward - Password
#              vlan     - vlan information for the user
#              tag - Whether the port will be tagged port
#
# Output args: None
#
##################################################################
proc nl_CreateLocalUser {login {passwd ""} {vlan ""} {tag ""}} {
    
   if {$vlan == ""} {
      send "create netlogin local-user $login\r"
   } else {
      send "create netlogin local-user $login vlan-vsa $tag $vlan\r"
   }
   expect {
     "password: " {
         if {$passwd == ""} {
            send "\r"
            expect {
               "Reenter password: " {
                send "\r"
                result_debug "password is $passwd"
               }
            }
         } else {
            send "$passwd\r"
            expect {
               "Reenter password:" {
                send "$passwd\r"
                result_debug "password is $passwd"
               }
            }
         }
      }
   }
  exSleep 2
}

################################################################## 
# Procedure Name: nl_DeleteLocalUser
#  
# Description: Deletes a Netlogin local user.
#
# Input args:  login - Login Name
#
# Output args: None
#
##################################################################
proc nl_DeleteLocalUser {login} {
   SendACmd "delete netlogin local-user $login"
}

proc nl_ChangeLocalUser {login {passwd ""} {vlan ""} {tag ""}} {
    
   #send "configure netlogin local-user $login\r"
   if {$vlan == ""} {
      send "configure netlogin local-user $login\r"
   } else {
      send "configure netlogin local-user $login vlan-vsa $tag $vlan\r"
   }
   expect {
     "password: " {
         if {$passwd == ""} {
            send "\r"
            expect {
               "Reenter password: " {
                send "\r"
               }
            }
         } else {
            send "$passwd\r"
            expect {
               "Reenter password:" {
                send "$passwd\r"
               }
            }
         }
      }
   }
}

################################################################## 
# Procedure Name: nl_VerifyDuplicateLocalUser
#  
# Description: Verifies the login password vlan and tag information
#
# Input args:  login - Login Name
#              passward - Password
#              vlan     - vlan information for the user
#              tag - Whether the port will be tagged port
#
# Output args: None
#
##################################################################
proc nl_VerifyDuplicateLocalUser {login {passwd ""} {vlan ""} {tag ""} \
              {comment "Verifying Error message is returned when duplicate \
                        local-user is configured"}} {
    
   report_start_test "$comment"

   set retVal 0
   if {$vlan == ""} {
      send "create netlogin local-user $login\r"
   } else {
      send "create netlogin local-user $login vlan-vsa $tag $vlan\r"
   }
   expect {
     "password: " {
         if {$passwd == ""} {
            send "\r"
            expect {
               "Reenter password: " {
                send "\r"
               }
            }
         } else {
            send "$passwd\r"
            expect {
               "Reenter password:" {
                   send "$passwd\r"
                   expect {
                     "Error: User already exists" {
                        set retVal "ok"
                        result_ok "Error returned as User already exists"
                     }
                     timeout {
                        set retVal "error"
                        result_error "No Error returned but Error expected"
                     }
                   }
               }
            }
         }
      }
   }

   if {($retVal != "ok") && ($retVal != "error")} {
      result_error "Command did not execute properly"
   }

   report_end_test

   return $retVal
}

########################################################################
# Procedure Name: nl_VerifyChangeLocalUser
#  
# Description: Verifies the change of password for a Netlogin local user
#
# Input args:  user  - Login Name
#              var1  - String containing login and password information 
#                      before the password is changed.
#              var2  - String containing login and password information 
#                      after the password is changed.
#              status - The passwords are expected to be equal or unequal
#              commnet - Comment
#
# Output args: None
#
########################################################################
proc nl_VerifyChangeLocalUser {user var1 var2 {status "equal"} \
        {comment "Verifying the change of password for the user $user"}} {

   report_start_test "$comment"

   regexp "(.*$user)( .*)( .*)( .*not.*configured)" $var1 res0 res1 res2 

   regexp "(.*$user)( .*)( .*)( .*not.*configured)" $var2 res4 res5 res6

   if {[string tolower $status] == "equal"} {
      if {$res2 == $res6} {
         result_ok "Password is same as expected"
      } else {
         result_error "Password is different but expected to be same"
      }
   } else {
      if {$res2 == $res6} {
         result_error "Password is same but expected to be different"
      } else {
         result_ok "Password is different as expected"
      }
   }
   report_end_test
}

########################################################################
# Procedure Name: nl_VerifyNetLoginPort
#  
# Description: Verifies the Netlogin port information for various attributes
#
# Input args:  user        - Login Name
#              port        - Port for which netlogin attributes are verified
#              portState   - Netlogin state expected
#              vlan        - Vlan in which the port is expected
#              mac         - Mac Address whose autnetication information
#                            is verified
#              user        - User for which authentication is done
#              authType    - Autentication type. mac-based
#              authStatus  - Verification of authentication status for the
#                            specified Mac address. Yes/No
#              guestVlan   - Guest Vlan status. Enabled/Disabled
#              ipAddr      - IP address of the Mac client which is authenticated
#              macLine     - Line number in which the Mac address autnetication
#                            information is expected.
#              commnet     - Comment
#
# Output args: None
#
########################################################################
proc nl_VerifyNetLoginPort { args } {
    parse_args nl_VerifyNetLoginPort $args {
       port           ""
       portState      "Enabled"
       vlan           ""
       mac            ""
       user           ""
       authType       "mac-based"
       authStatus     "yes"
       guestVlan      "Disabled"
       ipAddr         "0.0.0.0"
       macLine        "1"
       comment        "nl_VerifyNetLoginPort"
    }

set ver [GetVersion DUT1]
set ver_val [CompareRelease $ver 11.6.0.0]
set mat_val [regexp -nocase .*fuji.* $ver]

if {($ver_val == 1) || ($mat_val == 1)} {
   set baseLine 1
} else {
   set baseLine 0
}

set version [GetVersion DUT1 majmin]

if {$version < "12.0"} {
    set portLine [expr $baseLine+1]
} else {
    set portLine [expr $baseLine+2]
}


set mList ""
lappend mList "{.*Port.* $port} {.*Vlan.* $vlan} inLine exist $portLine"
lappend mList "{.*Vlan.* $vlan} {.*Authentication.*$authType} inLine exist 1"
lappend mList "{.*Vlan.* $vlan} {.*Port State.*$portState} inLine exist 2"
if {$version < "12.1" || [regexp -nocase $authStatus "yes"]} { 
   lappend mList "{.*Vlan.* $vlan} exist"
   lappend mList "{.*$mac .*$ipAddr.* $authStatus.* MAC .* $user} exist"
}
if {[CheckKeyValue "show netlogin port $port" $mList -comment $comment] != "ok"} {
  nl_exDumpDebugInfo
}
}

proc nl_resetIxiaPort { {port "1"}} {

    global portMappingList
    globalSetDefault
    global phyMode

    set TxRxPortList {}
    set portId [lindex $port 0]
    MapIxiaPortId $portId chid c p	 
    result_debug "Setting portId $portId to factory defaults..."
    port setFactoryDefaults $chid $c $p
    if {[info exists phyMode]} {
        if {[llength $phyMode]==1} {
            if {[regexp -nocase "fiber" $phyMode]} {
                port setPhyMode $::portPhyModeFiber $chid $c $p
                puts "Seeting Fiber mode  $chid $c $p"
            }
            if {[regexp -nocase "fibernoauto" $phyMode]} {
                port config -autonegotiate false
                port set $chid $c $p
            }
        } else {
            if {$portId != 9} {
                foreach phyPortInfo $phyMode {
                    set phyPortId [lindex $phyPortInfo 0]
                    set phyPortMode [lindex $phyPortInfo 1]
                    if {$phyPortId == $portId} {
                        if {[regexp -nocase "fiber" $phyPortMode]} {
                            port setPhyMode $::portPhyModeFiber $chid $c $p
                            if {[regexp -nocase "fibernoauto" $phyPortMode]} {
                                result_debug "Setting $c $p to Fiber mode with auto negotiaton off"
                                port config -autonegotiate false
                                port set $chid $c $p
                            } else {
                                result_debug "Setting $c $p to Fiber mode"
                            }
                        } else {
                            port setPhyMode $::portPhyModeCopper $chid $c $p
                        }
                    }
                }
            }
        }
    }
    StopPortsTransmit $portId  ;# setFactoryDefaults dont stop the xmit.
    if {[ixPortClearOwnership $chid $c $p force]!=0} {
        result_error "Can not clear ixia port ownership:$chid $c $p"
    }
    port config -MacAddress [GetPortIdMac $portId]
    port set $chid $c $p
    port write $chid $c $p

    #   ixiaGenMap $numIxiaCd $startCardNum "standard" "2Way" $chid

    # Make sure link is up
    if [ixInitLinks one2oneArray $TxRxPortList] {
        #      cleanUp 
        return 1
    }
}
########################################################################
# Procedure Name: nl_waitForReauth
#
# Description: Verifies whether a auth request is sent to the Radius server
#
# Input args: time = Initial time to wait before starting the check
#
# Output args: None
#
########################################################################
proc  nl_waitForReauth {time} {
global DUT1_CONNECT

set version [GetVersion DUT1 majmin]
puts "The version is $version"
  SendACmd "show netlogin"
  SendACmd "clear counters"
  set radList [list]
  if { $version >= 16.1 } {
     lappend radList "{Primary Netlogin Radius server} {Access Requests.*1} inLine exists 8"
     CheckKeyValue "show radius" $radList \
         -comment "Verify reauth is initiated" -time "s: $time  i: 2 d: 20 f: 20"
      return 1

  } else {
     lappend radList "{Primary Netlogin Radius server} {Access Requests.*1} inLine exists 6"
     CheckKeyValue "show radius" $radList \
         -comment "Verify reauth is initiated" -time "s: $time  i: 2 d: 20 f: 20"
      return 1
  }

}
##################################################################
# Procedure Name: nl_exCheckAuthFail
#
# Description: Configuring NL authentication failure VLAN
#
# Input args:  
#
# Output args: None
#
# Typical Usage:
#
##################################################################
proc nl_exConfigAuthFail {args } {
 parse_args nl_exConfigAuthFail $args {
    port           ""
    vlan           ""
    ipAddr         "0.0.0.0"
    vlanExist      0
    comment        "nl_exConfigAuthFail"
 }
 if { !$vlanExist } {
  SendACmd "create vlan $vlan"
  if { $ipAddr != "0.0.0.0" } {
    SendACmd "config vlan $vlan ipaddress $ipAddr/24"
    SendACmd "enable ipforwarding"
  }
 }
 SendACmd "config netlogin authentication failure vlan $vlan \
           ports $port "
 SendACmd "enable netlogin authentication failure vlan ports $port" 

}

##################################################################
# Procedure Name: nl_exDeleteAuthFail
#
# Description: Unconfiguring the Authentication Failure VLAN config
#
# Input args: None
#
# Output args: None
#
# Typical Usage:
#
##################################################################
proc nl_exDeleteAuthFail { } {

 SendACmd "disable netlogin authentication failure vlan ports all"
 SendACmd "unconfigure netlogin authentication failure vlan"

}
##################################################################
# Procedure Name: nl_exCheckPortStatus
#
# Description: To check the Netlogin status for a specific port
#
# Input args: 
#          vlan     VLAN name 
#          status   Values - "exist" or "notExist" 
#          auth     Authenticated or unauthenticated: Vlaues "a" or "u" 
#          tag      Vlan Tag 
#          port     Port 
#
# Output args: None
#
# Typical Usage:
#
##################################################################
proc nl_exCheckPortStatus {args} {
    parse_args nl_exCheckPortStatus $args {
          vlan     ""
          status   "exist"
          auth     ""
          tag      ""
          port     ""
     }

   set checkPortList [list]
   if { $auth == "" } { 
     if {$tag == "" } {
        lappend checkPortList "{\\*$port.*} $status"
     } else {
        lappend checkPortList "{$tag:.*\\*$port.*} $status"
     }
   } else { 
     lappend checkPortList "{$tag:.*\\*$port.*$auth} $status"
   } 
   set result [CheckKeyValue "show vlan $vlan" $checkPortList \
               -comment "Verify port $port $status in $vlan" \
               -time "s: 0  i: 1 d: 5 f: 5"]
   unset checkPortList
   return $result
} 
##################################################################
# Procedure Name: nl_exCheckFDBStatus
#
# Description: To Check for a supplicant MAC in the FDB table with 
#              right flags 
#
# Input args: mac - MAC address of the Supplicant
#             port - Netlogin Port 
#             status - exist/notExist 
#
# Output args: None
#
# Typical Usage:
#
##################################################################
proc nl_exCheckFDBStatus {mac port {status {exist}} {tag {untag}}} {

  set fdbMacList [list]
  puts "YESS"
  if { $tag == "tag" } {
   lappend fdbMacList "{$mac.*npm} $status"
  } else {
   lappend fdbMacList "{$mac.*n.*m} $status"
  }
  set result [CheckKeyValue "show fdb port $port" $fdbMacList \
              -comment "Verify FDB Table for the Client MAC $status"]
  return $result

}

##################################################################
# Procedure Name: nl_exConfigServiceUnavail 
#
# Description: To configure the Authentication Service Unavailable
#              VLAN
#
# Input args: Port   - Netlogin Port 
#             vlan   - Service Unavailable VLAN  
#             ipAddr - IP Address for the Service Unavailable VLAN 
#             vlanExist - Flag toggle Service Unavailable VLAN create      
#             comment - Comments
#
# Output args: None
#
# Typical Usage:
#
##################################################################
proc nl_exConfigServiceUnavail {args } {
 parse_args nl_exConfigAuthFail $args {
    port           ""
    vlan           ""
    ipAddr         "0.0.0.0"
    vlanExist      0
    comment        "nl_exConfigServiceUnavail"
 }
 if { !$vlanExist } {
  SendACmd "create vlan $vlan"
  if { $ipAddr != "0.0.0.0" } {
    SendACmd "config vlan $vlan ipaddress $ipAddr/24"
    SendACmd "enable ipforwarding"
  }
 }
 SendACmd "config netlogin authentication service-unavailable vlan $vlan \
           ports $port "
 SendACmd "enable netlogin authentication service-unavailable vlan ports $port"

}


##################################################################
# Procedure Name: nl_exDeleteServiceUnavail 
#
# Description: To disable the Authentication Service Unavailable 
#              VLAN  
#
# Input args: None
#
# Output args: None
#
# Typical Usage:
#
##################################################################

proc nl_exDeleteServiceUnavail { } {

 SendACmd "disable netlogin authentication service-unavailable vlan ports all"
 SendACmd "unconfigure netlogin authentication service-unavailable vlan"

}

##################################################################
# Procedure Name: nl_exClearNetlogin 
#
# Description: This will the wrapper procedure to provide multiple
#              ways to clear the Netlogin port state 
#
# Input args: port - Netlogin port 
#             type - method used to clear the netlogin state
#                  1 -> "clear netlogin state port <>"      
#
# Output args: None
#
# Typical Usage:
#
##################################################################

proc nl_exClearNetlogin { port {type "1"}} { 

 switch $type {
  "1" { SendACmd "clear netlogin state port $port"}
 }
}


##################################################################
# Procedure Name: nl_SetupRadius 
#
# Description: Configured the Radius Server for the Netlogin TestCases 
#
# Input args: None 
#
# Output args: None
#
# Typical Usage:
#
##################################################################

proc nl_SetupRadius { } {

global DUT1_IP
global Netloginv2RadiusServer
global sharedSecret

set priRadiusServer    $Netloginv2RadiusServer
set priRadiusPort      1645
set clientIP           $DUT1_IP

nl_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret
}


################################################################## 
# Procedure Name: Mac_CreateRadiusUser
#  
# Description: _CreateRadiusUser - Creates user name in 
#              the necessary tables if user is not. If no username is 
#              given then dafault user name md5_isp_$DUT1_IP 
#
# Input args: username 
#
# Output args: error = unsuccess set; ok - successful set
#
##################################################################
proc Mac_CreateRadiusUser {args} {
    global DUT1_IP
    global radius_handler
    global radVersion

    parse_args Mac_CreateRadiusUser $args {
        username  ""
        password ""
        authType "Local"
   }

   if {$username == ""} {
       set username "unknown_$DUT1_IP"
}

if { $radVersion == 0 } {
    #for radius version < 3.0
    set PasswdStr "Password"
} else {
    set PasswdStr "Cleartext-Password"
}

set present [mysqlsel $radius_handler "select *  from radusergroup where username = '$username'"]


if {$present == 0} {
	mysqlexec $radius_handler "INSERT into radusergroup (username, groupname) VALUES ('$username', 'sup')"

		mysqlexec $radius_handler "INSERT into radcheck (username,attribute,value,op) VALUES ('$username',\
		'$PasswdStr', '$password',':=')"

		if {$radVersion == 0} {
			mysqlexec $radius_handler "INSERT into radcheck (username,attribute,value,op) VALUES ('$username',\
				'Auth-Type', '$authType',':=')"
		}
	set value [dot1x_GetUserAttribute $username "$PasswdStr"]


	if {$value != $password} {
			return "error"
		}

	if {$radVersion == 0} {
		set value [dot1x_GetUserAttribute $username "Auth-Type"]
		if {$value != $authType} {
				return "error"
		}
	}
} else {
	return "duplicate"
}

return "ok"

}

################################################################## 
# Procedure Name: Policy_Check
#  
# Description: Policy_Check - Verify the Platform Support Policy or 
#               Not
# Return 1 for True , Else return False
#
##################################################################
proc Policy_Check { {DUT_No "1"}  } {

global Policy_Platform
global DUTs_info
set policy_flag 0

set version [GetVersion DUT$DUT_No majmin]
if { $version >= 21.1 } {
	set policy_flag 1
} else {
	set platform [GetPlatform DUT$DUT_No]
	set plat $platform
	if { $plat == "Stack" } {
		set blade $DUTs_info(DUT$DUT_No,sysType)
		puts "The blade that is used : $blade"
		if  {[regexp -nocase "$Policy_Platform" $blade] && $version >= 16.1} {
			set policy_flag 1
		}
	} elseif {[regexp -nocase "$Policy_Platform" $plat] && $version >= 16.1} {
		set policy_flag 1
	}
}

return $policy_flag
}
################################################################
#  Procedure Name: RadiusProcessCheck
#
#  Description:
#    This procedure verify radius process is running in specified
#    Radius server
#
#  Input Variables:
#    RadiusServer - Name of the radius server
#
#  Optional Args:
#    None
#
#  Output Variables:
#     None
#
#  Return Variables:
#    -1 - on failure
#    Process ID - on success
#
#  Possible Usage:
#    RadiusProcessCheck RadiusServer
###############################################################
proc RadiusProcessCheck { RadiusServer } {

set radiusPID [radiusUtilGetPID radiusd $RadiusServer]
   if { $radiusPID != -1 } {
      result_debug "/usr/sbin/radiusd is running with pid $radiusPID"
      result_debug "radiusd($radiusPID) is running"
	  return 1
   } else {
      # radiusd is not running
      result_debug "radiusd is not running"
	  return 0
   }  
}

################################################################
#  Procedure Name: radiusUtilGetPID
#
#  Description:
#    This procedure returns the process identifier of a specific
#    process. If the process is not running, it returns -1 as 
#    process id.
#
#  Input Variables:
#    pName - Name of the process
#    RadServer - Radius server to check
#  Optional Args:
#    None
#
#  Output Variables:
#     None
#
#  Return Variables:
#    -1 - on failure
#    Process ID - on success
#
#  Possible Usage:
#    radiusUtilGetPID radiusd RadServer
###############################################################
proc radiusUtilGetPID { pName RadServer } {

   login_linux $RadServer "autotest" "autotest" ;
   set output [ linuxSendACmd "\/bin\/ps -e |grep \"$pName\"" ]
   linuxSendACmd "exit\r"
   if {[info exists output]} {
      foreach item [split $output "\n"] {
         if { [regexp $pName $item] && ![regexp "grep" $item] } {
            return [lindex $item 0]
         }
      }
  }
  # Process id not found 
  return -1
}
################################################################## 
# Procedure Name: nlweb_login
#   
# Description: create python script for client login
# 
# Sample Usage:
#  nlweb_login $testNo $user $pass 
#
# Output args: NULL
##################################################################
proc nlweb_login {testNo user pass {dut "2"} {auth "http"}} {

	DHCP_check
	
	global verflag
	global verflag1
    set filesToUpload ""
	set filesToDownload ""
	set version [GetVersion DUT$dut majmin]
	set DUT1_version [GetVersion DUT1 whole]
	
	lappend filesToUpload "Tmp/$testNo"
	lappend filesToDownload "$testNo"
	set fd [open "Tmp/$testNo" "w"]
	if {$version>=30.1} {
	puts $fd "import os"
	puts $fd "os.environ\[\'EXOS_VR_ID\'\]=\'2\'"
	if {$auth == "https"} {
	puts $fd "os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'"
	}
	} else {
	puts $fd "f = open('/proc/self/ns_id', 'w')"
	puts $fd "f.write('2\\n')"
	puts $fd "f.close()"
	}
	puts $fd "import urllib2, base64"
	if {$verflag != 0} {
	# the check is add for 21.1 and 16.2 release
	if {$DUT1_version>="22.5.0.34"} {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com/login\?url\=20.1.1.1\")"
	} else {
	puts $fd "request1 = urllib2.Request(\"$auth://20.1.1.1/\")"
	}
	puts $fd "try: "
	puts $fd "    result1 = urllib2.urlopen(request1)"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	}
	puts $fd "request = urllib2.Request(\"$auth://20.1.1.1/hello\")"
	puts $fd "request2 = urllib2.Request(\"$auth://20.1.1.1/login\")"
	puts $fd "basestr = base64.encodestring('%s:%s' % (\"$user\", \"$pass\")).replace('\\n',' ')"
	puts $fd "request.add_header(\"Authorization\", \"Basic %s\" % basestr)"
	puts $fd "try: "
	puts $fd "    result2 = urllib2.urlopen(request2)"
	puts $fd "    print(result2.read())"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	puts $fd "try: "
	puts $fd "    result = urllib2.urlopen(request)"
	puts $fd "    print(result.read())"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	close $fd
	
	CheckTftpPutMulti "$filesToUpload"
	
	if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
	result_debug "Skipped: Python Files Did Not Download Correctly"
	report_start_test "Skipped: Python Files Did Not Download Correctly"
	report_end_test 
	
	}
}
################################################################## 
# Procedure Name: DHCP_check
#   
# Description: To show the client acquired the DHCP IP
# 
# Sample Usage:
#  DHCP_check 
#
# Output args: NULL
##################################################################

proc DHCP_check { } {

global DUT2_CONNECT

Login   $DUT2_CONNECT

SendACmd "show dhcp-client state"

}
################################################################## 
# Procedure Name: nlweb_login1
# 
# Description: python script creation for login
#
# Input args: none
# Output args: none
# Typical usage:
#             nlweb_login1 $testNo $user $pass
#
##################################################################
proc nlweb_login1 {testNo user pass {dut "2"} {auth "http"} {retry "1"}} {
	
	DHCP_check
	
    set filesToUpload ""
	set filesToDownload ""
	global verflag
	set version [GetVersion DUT$dut majmin]
	set DUT1_version [GetVersion DUT1 whole]
	
	lappend filesToUpload "Tmp/$testNo"
	lappend filesToDownload "$testNo"
	set fd [open "Tmp/$testNo" "w"]
	if {$version>=30.1} {
	puts $fd "import os"
	puts $fd "os.environ\[\'EXOS_VR_ID\'\]=\'2\'"
	if {$auth == "https"} {
	puts $fd "os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'"
	}
	} else {
	puts $fd "f = open('/proc/self/ns_id', 'w')"
	puts $fd "f.write('2\\n')"
	puts $fd "f.close()"
	}
	puts $fd "import urllib2, base64 "
	puts $fd "import urllib, time "
	if {$verflag != 0} {
	puts $fd "import ctypes"
	puts $fd "libc = ctypes.cdll.LoadLibrary('libc.so.6') "
	puts $fd "res_init = libc.__res_init "
	puts $fd "res_init() "
	if {$DUT1_version>="22.5.0.34"} {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com/login\?url\=20.1.1.1\")"
	} else {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com\") "
	}
	for {set i 0} {$i < $retry} {incr i} {
    puts $fd "request3 = urllib2.Request(\"$auth://network-access.com/login\") "
	}
	puts $fd "request = urllib2.Request(\"$auth://network-access.com/hello\") "
	puts $fd "try: "
	puts $fd "    print \"\\nThe Start page is as follows:--------------------\\n\" "
	puts $fd "    result1 = urllib2.urlopen(request1) "
	puts $fd "    print(result1.read()) "
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	} else {
	if {$DUT1_version>="22.5.0.34"} {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com/login\?url\=20.1.1.1\")"
	} else {
	puts $fd "request1 = urllib2.Request(\"$auth://20.1.1.1/\")"
	}
	for {set i 0} {$i < $retry} {incr i} {
    puts $fd "request3 = urllib2.Request(\"$auth://20.1.1.1/login\") "
	}
	puts $fd "request = urllib2.Request(\"$auth://20.1.1.1/hello\") "
	}
#	puts $fd "values = {'extremenetloginuser' : '$user', "
#	puts $fd "          'extremenetloginpassword' : '$pass', "
	puts $fd "          } "
	puts $fd " "
	puts $fd "data = urllib.urlencode(values) "
	puts $fd "try: "
	puts $fd "    print \"\\nThe Login page is as follows:--------------------\\n\" "
	puts $fd "    result3 = urllib2.urlopen(request3) "
	puts $fd "    print(result3.read()) "
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	puts $fd "	 "
	puts $fd "try: "
	puts $fd "    print \"\\nThe Login Success Page is as follows---------------\\n\" "
	puts $fd "    result = urllib2.urlopen(request, data) "
	puts $fd "    print(result.read()) "
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	puts $fd " "
	puts $fd " "
	close $fd
	
	CheckTftpPutMulti "$filesToUpload"
	
	if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
	result_debug "Skipped: Python Files Did Not Download Correctly"
	report_start_test "Skipped: Python Files Did Not Download Correctly"
	report_end_test
	}
}
################################################################## 
# Procedure Name: nlweb_logout
# 
# Description: python script creation for logout
#
# Input args: none
# Output args: none
# Typical usage:
#             nlweb_logout 
#
##################################################################
proc nlweb_logout {testNo user pass {dut "2"} {auth "http"}} {
	
    set filesToUpload ""
	set filesToDownload ""
	set version [GetVersion DUT$dut majmin]
	
	lappend filesToUpload "Tmp/$testNo$user"
	lappend filesToDownload "$testNo$user"
	set fd [open "Tmp/$testNo$user" "w"]
	if {$version>=30.1} {
	puts $fd "import os"
	puts $fd "os.environ\[\'EXOS_VR_ID\'\]=\'2\'"
	if {$auth == "https"} {
	puts $fd "os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'"
	}
	} else {
	puts $fd "f = open('/proc/self/ns_id', 'w')"
	puts $fd "f.write('2\\n')"
	puts $fd "f.close()"
	}
	puts $fd "import urllib2, base64"
	puts $fd "request2 = urllib2.Request(\"$auth://192.168.1.1/goodbye\") "
	puts $fd "basestr = base64.encodestring('%s:%s' % (\"$user\", \"$pass\")).replace('\\n',' ')"
	puts $fd "request2.add_header(\"Authorization\", \"Basic %s\" % basestr)"
	puts $fd " "
	puts $fd "try: "
	puts $fd "    print \"\\nThe Logout Success Page is as follows---------------\\n\" "
	puts $fd "    result2 = urllib2.urlopen(request2) "
	puts $fd "    print(result2.read()) "
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	puts $fd " "
	close $fd
	
	CheckTftpPutMulti "$filesToUpload"
	
	if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
	result_debug "Skipped: Python Files Did Not Download Correctly"
	report_start_test "Skipped: Python Files Did Not Download Correctly"
	report_end_test
	}
}
################################################################## 
# Procedure Name: nlweb_login3
#   
# Description: create python script for clinet login
# 
# Sample Usage:
#  nlweb_login3 $testNo $user $pass 
#
# Output args: NULL
##################################################################
proc nlweb_login3 {testNo user pass {dut "2"} {auth "http"} {browser "Firefox"}} {
	
	DHCP_check
	
	global verflag
    set filesToUpload ""
	set filesToDownload ""
	set agent [browser_agent $browser]
	set version [GetVersion DUT$dut majmin]
	set DUT1_version [GetVersion DUT1 whole]
	#puts "agent:>>>>>>>>>>>>>>>>>>>>$agent>>>>>>>>>>>>>>>>> "
	lappend filesToUpload "Tmp/$testNo"
	lappend filesToDownload "$testNo"
	set fd [open "Tmp/$testNo" "w"]
	if {$version>=30.1} {
	puts $fd "import os"
	puts $fd "os.environ\[\'EXOS_VR_ID\'\]=\'2\'"
	if {$auth == "https"} {
	puts $fd "os.environ\[\'PYTHONHTTPSVERIFY\']=\'0\'"
	}
	} else {
	puts $fd "f = open('/proc/self/ns_id', 'w')"
	puts $fd "f.write('2\\n')"
	puts $fd "f.close()"
	}
	puts $fd "import urllib2, base64"
	if {$verflag != 0} {
	# the check is add for 21.1 and 16.2 release
	if {$DUT1_version>="22.5.0.34"} {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com/login\?url\=20.1.1.1\")"
	} else {
	puts $fd "request1 = urllib2.Request(\"$auth://20.1.1.1/\")"
	}
	puts $fd "try: "
	puts $fd "    result1 = urllib2.urlopen(request1)"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	}
	puts $fd "request = urllib2.Request(\"$auth://20.1.1.1/hello\")"
	puts $fd "request2 = urllib2.Request(\"$auth://20.1.1.1/login\")"
	puts $fd "basestr = base64.encodestring('%s:%s' % (\"$user\", \"$pass\")).replace('\\n',' ')"
	puts $fd "request.add_header(\"Authorization\", \"Basic %s\" % basestr)"
	puts $fd "request.add_header(\"User-Agent\" , \"$agent\")"
	puts $fd "try: "
	puts $fd "    result2 = urllib2.urlopen(request2)"
	puts $fd "    print(result2.read())"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	puts $fd "try: "
	puts $fd "    result = urllib2.urlopen(request)"
	puts $fd "    print(result.read())"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	close $fd
	
	CheckTftpPutMulti "$filesToUpload"
	
	if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
	result_debug "Skipped: Python Files Did Not Download Correctly"
	report_start_test "Skipped: Python Files Did Not Download Correctly"
	report_end_test
	}
}
#
################################################################## 
# Procedure Name: browser_agent
#   
# Description: set user agent fot different browser
# 
# Sample Usage:
#  browser_agent $browser_name 
#
# Output args: NULL
##################################################################
proc browser_agent { broswer } {
	set agent ""
	if {$broswer == "Firefox"} {
		set agent "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko"
	} elseif {$broswer == "Chrome"} {
		set agent "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36"
	} elseif {$broswer == "Opera"} {
		set agent "Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14"
	} elseif {$broswer == "Safari"} {
		set agent "Mozilla/5.0 (Windows; U; Windows NT 6.1; tr-TR) AppleWebKit/533.20.25 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27"
	} elseif {$broswer == "InternetExplorer"} {
		set agent "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko"
	} elseif {$broswer == "Apple"} {
		set agent "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A"
	}
	return $agent
}
################################################################## 
# Procedure Name: nlweb_login
#   
# Description: create python script for clinet login
# 
# Sample Usage:
#  nlweb_login $testNo $user $pass 
#
# Output args: NULL
##################################################################
proc nlweb_login_URL {testNo user pass {dut "2"} {auth "http"}} {
	
	DHCP_check
	
	global verflag
	global verflag1
    set filesToUpload ""
	set filesToDownload ""
	set version [GetVersion DUT$dut majmin]
	set DUT1_version [GetVersion DUT1 whole]
	
	lappend filesToUpload "Tmp/$testNo"
	lappend filesToDownload "$testNo"
	set fd [open "Tmp/$testNo" "w"]
	if {$version>=30.1} {
	puts $fd "import os"
	puts $fd "os.environ\[\'EXOS_VR_ID\'\]=\'2\'"
	} else {
	puts $fd "f = open('/proc/self/ns_id', 'w')"
	puts $fd "f.write('2\\n')"
	puts $fd "f.close()"
	}
	puts $fd "import urllib2, base64"
	if {$verflag != 0} {
	# the check is add for 21.1 and 16.2 release
	if {$DUT1_version>="22.5.0.34"} {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com/login\?url\=20.1.1.1\")"
	} else {
	puts $fd "request1 = urllib2.Request(\"$auth://network-access.com/\")"
	}
	puts $fd "try: "
	puts $fd "    result1 = urllib2.urlopen(request1)"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	}
	puts $fd "request = urllib2.Request(\"$auth://network-access.com/hello\")"
	puts $fd "request2 = urllib2.Request(\"$auth://network-access.com/login\")"
	puts $fd "basestr = base64.encodestring('%s:%s' % (\"$user\", \"$pass\")).replace('\\n',' ')"
	puts $fd "request.add_header(\"Authorization\", \"Basic %s\" % basestr)"
	puts $fd "try: "
	puts $fd "    result2 = urllib2.urlopen(request2)"
	puts $fd "    print(result2.read())"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	puts $fd "try: "
	puts $fd "    result = urllib2.urlopen(request)"
	puts $fd "    print(result.read())"
	puts $fd "except urllib2.HTTPError, e: "
	puts $fd "    print e "
	puts $fd "except urllib2.URLError, e: "
	puts $fd "    print e.args "
	close $fd
	
	CheckTftpPutMulti "$filesToUpload"
	
	if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
	result_debug "Skipped: Python Files Did Not Download Correctly"
	report_start_test "Skipped: Python Files Did Not Download Correctly"
	report_end_test
	}
}
###########################################################################
## Procedure Name: Dot1x_Client
##
## Description: Creates a Python script to simulate Dot1x Client from EXOS
##
## Sample Usage:
##  Dot1x_Client $testNo 
##
##  Output args: NULL
##
##  Usage of Python script: 
#    
##  1.load script <script_name> <username> <password> <interface_name>
#
##  2.load script <script_name> <username> <password> <interface_name> \
#                             <operation name: logout\reauth> <time interval>    
#############################################################################

proc Dot1x_Client {testNo {dut "2"}} {

    set filesToUpload ""
    set filesToDownload ""
    lappend filesToUpload "Tmp/$testNo"
    lappend filesToDownload "$testNo"
    set fd [open "Tmp/$testNo" "w"]
    puts $fd "######################################################################################################## "
	puts $fd "######################################################################################################## "
	puts $fd "# "
	puts $fd "#                                        DOT1X Client Program "
	puts $fd "# "
	puts $fd "# -----------------------------------------Pre Requirements -------------------------------------------- "
	puts $fd "# "
	puts $fd "#            **Generate the name of the Interface with vlan_name\[5\]_{snmpvalue in hex} "
	puts $fd "#            **Ensure the Vlan is created prior and an active port is added "
	puts $fd "#            **Assign IP to the vlan and enable ip forwarding - Though we are dealing with L2 packets "
	puts $fd "#            **the CPU will LIFT the packet only for a L3 interface hence assign an IP to the Vlan "
	puts $fd "#            ****** The CPU lifts the L2 packets when DHCP is enabled in the interface -Update 20 Jan "
	puts $fd "######################################################################################################## "
	puts $fd " "
	puts $fd "#!/usr/bin/python "
	puts $fd " "
	puts $fd "from socket import * "
	puts $fd "from struct import * "
	puts $fd "from md5 import * "
	puts $fd "from sys import * "
	puts $fd "import time "
	puts $fd " "
	puts $fd "### Argument Settings "
	puts $fd " "
	puts $fd "try: "
	puts $fd "    Username = argv\[1\] "
	puts $fd "    Password = argv\[2\] "
	puts $fd "    interface = argv\[3\] "
	puts $fd "except: "
	puts $fd "    print \"The Username or Password or Interface is not specified correctly: exiting !!!\" "
	puts $fd "    print \"Usage: python <script_name> <username> <password> <interface_name>\" "
	puts $fd "    exit() "
	puts $fd "logoff = 0 "
   puts $fd "reauth = 0 "
	puts $fd "if len(argv) > 4: "
	puts $fd "    try: "
	puts $fd "        operation = argv\[4\] "
	puts $fd "        timer = argv\[5\] "
	puts $fd "        if operation == \"logout\": "
	puts $fd "            print \"Dot1x process start with logout operation at interval:\",timer "
	puts $fd "### LOGOFF Scenario "
	puts $fd "            logontime = timer "
	puts $fd "            logoff = 1 "
	puts $fd "        elif operation == \"reauth\": "
	puts $fd "            print \"Dot1x process start with reauthentication operation at interval:\",timer "
	puts $fd "### Re Authentication "
	puts $fd "            reauth = 1 "
	puts $fd "            reauth_time = timer "
	puts $fd "        else: "
	puts $fd "            print \"Invalid Operation Exiting\" "
	puts $fd "            print \"Usage: load script <script_name> <username> <password> <interface_name> <operation name: logout\\reauth> <time interval>\" "
	puts $fd "            exit() "
	puts $fd "    except: "
	puts $fd "        print \"Wrong Usage: Arguments <Operation> and <Timer> are not specified correctly !!!\" "
	puts $fd "        print \"Usage: load script <script_name> <username> <password> <interface_name> <operation name: logout\\reauth> <time interval>\" "
	puts $fd "        exit() "
	puts $fd "         "
	puts $fd "else: "
	puts $fd "    print \"Proceeding with Dot1x authtication with no special operation like logout or reauth\" "
	puts $fd "               "
	puts $fd " "
	puts $fd "###  Authentication parameters "
	puts $fd " "
	puts $fd "USER = Username "
	puts $fd "PASS = Password "
	puts $fd "DEV = interface "
	puts $fd " "
	puts $fd "### Constants "
	puts $fd " "
	puts $fd "ETHERTYPE_PAE = 0x888e "
	puts $fd "PAE_GROUP_ADDR = \"\\x01\\x80\\xc2\\x00\\x00\\x03\" "
	puts $fd "ETH_P_ALL=0x0003 "
	puts $fd " "
	puts $fd "EAPOL_VERSION = 1 "
	puts $fd "EAPOL_EAPPACKET = 0 "
	puts $fd "EAPOL_START = 1 "
	puts $fd "EAPOL_LOGOFF = 2 "
	puts $fd "EAPOL_KEY = 3 "
	puts $fd "EAPOL_ASF = 4 "
	puts $fd " "
	puts $fd "EAP_REQUEST = 1 "
	puts $fd "EAP_RESPONSE = 2 "
	puts $fd "EAP_SUCCESS = 3 "
	puts $fd "EAP_FAILURE = 4 "
	puts $fd " "
	puts $fd "EAP_TYPE_ID = 1 "
	puts $fd "EAP_TYPE_MD5 = 4 "
	puts $fd "EAP_TYPE_TLS = 4 "
	puts $fd " "
	puts $fd "count1 = 0 "
   puts $fd "count2 = 0 "
   puts $fd "count3 = 0 "
   puts $fd " "
   puts $fd "EXTREME_SO_VRID = 37 "
	puts $fd " "
	puts $fd "### Packet builders "
	puts $fd " "
	puts $fd "def EAPOL(type, payload=\"\"): "
	puts $fd "    return pack(\"!BBH\", EAPOL_VERSION, type, len(payload))+payload "
	puts $fd " "
	puts $fd "def EAP(code, id, type=0, data=\"\"): "
	puts $fd "    if code in \[EAP_SUCCESS, EAP_FAILURE\]: "
	puts $fd "        return pack(\"!BBH\", code, id, 4) "
	puts $fd " "
	puts $fd "    else: "
	puts $fd "        return pack(\"!BBHB\", code, id, 5+len(data), type)+data "
	puts $fd " "
	puts $fd "def ethernet_header(src, dst, type): "
	puts $fd "    return dst+src+pack(\"!H\",type) "
	puts $fd " "
	puts $fd " "
	puts $fd "### Main program "
	puts $fd " "
	puts $fd "### L2 RAW Socket Creation and EXOS tweak to work in VR-DEFAULT "
	puts $fd " "
	puts $fd "s=socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) "
	puts $fd "s.setsockopt(SOL_SOCKET, EXTREME_SO_VRID, 2) "
	puts $fd " "
	puts $fd "### Interface binding to listen to the socket"
	puts $fd "s.settimeout(60)"
	puts $fd "s.bind((DEV, 0)) "
	puts $fd " "
	puts $fd "### Sending EAPOL Start Packet "
	puts $fd " "
	puts $fd "mymac=s.getsockname()\[4\] "
	puts $fd "llhead=ethernet_header(mymac, PAE_GROUP_ADDR, ETHERTYPE_PAE) "
	puts $fd " "
	puts $fd "print \"--> Sent EAPOL Start\" "
	puts $fd "s.send(llhead+EAPOL(EAPOL_START)) "
	puts $fd " "
	puts $fd "### EAP Transaction Start based on the EAP TYPE "
	puts $fd " "
	puts $fd "try:"
	puts $fd "    while 1:  "
	puts $fd "        p = s.recv(1600) "
	puts $fd "        ether1, ether2 = unpack(\"!BB\",p\[16:18\]) "
	puts $fd "        ether = str(hex(ether1)) + str(hex(ether2))\[2:\] "
	puts $fd "        print \"The Ethertype is \", ether "
	puts $fd "        if ether == hex(ETHERTYPE_PAE): "
	puts $fd "            print \"<-- Got 802.1x Packet with Ethertype\",ether "
	puts $fd "            p = p\[18:\] "
	puts $fd "            vers,type,eapollen  = unpack(\"!BBH\",p\[:4\]) "
	puts $fd "            if type == EAPOL_EAPPACKET: "
	puts $fd "                    code, id, eaplen = unpack(\"!BBH\", p\[4:8\]) "
	puts $fd "### EAP SUCCESS TYPE "
	puts $fd "                    if code == EAP_SUCCESS: "
	puts $fd "                          print \"<-- Got EAP Success\" "
	puts $fd "                          count1 = 0 "
   puts $fd "                          count2 = 0 "
   puts $fd "                          if logoff == 1: "
	puts $fd "                              time.sleep(float(logontime))"
	puts $fd "                              s.send(llhead+EAPOL(EAPOL_LOGOFF)) "
   puts $fd "                              print \"--> Operation: Logout --> Sent EAP Logout after delay\""  
   puts $fd "                              break"     
   puts $fd "                          elif reauth == 1: "    
   puts $fd "                              print \"Operation: Reauthentication <-- Listening until Reauth expires\""
   puts $fd "                              time.sleep(float(reauth_time)) "           
   puts $fd "                              print \"--> Reauthentication started -- Waiting for Reauth Packet\""
   puts $fd "                              reauth = 0"
   puts $fd "                          else: "
	puts $fd "                              break "
	puts $fd "### EAP FAILURE TYPE "
	puts $fd "                    elif code == EAP_FAILURE:"
	puts $fd "                          print \"<-- Got EAP Failure\" "
   puts $fd "                          count1 = 0 "
   puts $fd "                          count2 = 0 "
	puts $fd "                          break "
	puts $fd "                    elif code == EAP_RESPONSE:  "
	puts $fd "                          print \"?? Got EAP Response\" "
	puts $fd "### EAP IDENTITY REQUEST "
	puts $fd "                    elif code == EAP_REQUEST:"
	puts $fd "                          reqtype = unpack(\"!B\", p\[8:9\])\[0\] "
	puts $fd "                          reqdata = p\[9:4+eaplen\]  "
	puts $fd "                          if reqtype == EAP_TYPE_ID: "
	puts $fd "                                print \"<--Got EAP Request for identity\"  "
   puts $fd "                                count1 = count1 + 1 "
   puts $fd "                                if count1 < 2: "      
	puts $fd "                                    s.send(llhead+ "
	puts $fd "                                       EAPOL(EAPOL_EAPPACKET, "
	puts $fd "                                              EAP(EAP_RESPONSE, "
	puts $fd "                                                            id,  "
	puts $fd "                                                       reqtype,  "
	puts $fd "                                                          USER))) "
	puts $fd "                                    print \"--> Sent EAP response with identity = \[%s\]\" % USER "
   puts $fd "                                else: "
   puts $fd "                                    print \"<-- Duplicate Packet Received - EAP Identity Request\""  
	puts $fd "                          elif reqtype == EAP_TYPE_MD5: "
	puts $fd "### EAP MD5 Challenge and Response Handling "
	puts $fd "                              print \"<-- Got EAP Request for MD5 challenge\" "
   puts $fd "                              count2 = count2 + 1 "
   puts $fd "                              if count2 < 2: "
	puts $fd "                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]"
	puts $fd "                                resp=md5(challenge).digest() "
	puts $fd "                                resp=chr(len(resp))+resp "
	puts $fd "                                s.send(llhead+   "
	puts $fd "                                       EAPOL(EAPOL_EAPPACKET,"
	puts $fd "                                       EAP(EAP_RESPONSE, "
	puts $fd "                                                     id,"
	puts $fd "                                                reqtype,"
	puts $fd "                                              resp+USER)))"
	puts $fd "                                print \"--> Send EAP response with MD5 challenge\" "
   puts $fd "                              else: "
   puts $fd "                                print \"<-- Duplicate Packet Received - EAP MD5 Challenge Request\" "
	puts $fd "                          elif reqtype == EAP_TYPE_TLS: "
	puts $fd "### EAP TLS - Under Research "
	puts $fd "                                print \"Got EAP Request for TLS Handshake\" "
	puts $fd "                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]  "
	puts $fd "                                resp=md5(challenge).digest() "
	puts $fd "                                resp=chr(len(resp))+resp "
	puts $fd "                                s.send(llhead+   "
	puts $fd "                                       EAPOL(EAPOL_EAPPACKET,   "
	puts $fd "                                       EAP(EAP_RESPONSE,    "
	puts $fd "                                                     id,   "
	puts $fd "                                                reqtype,   "
	puts $fd "                                              resp+USER))) "
	puts $fd "                                print \"--> Send EAP response with TLS Handshake\" "
	puts $fd "                          else: "
	puts $fd "                                print \"?? Got unknown Request type (%i)\" % reqtype"
	puts $fd "                    else: "
	puts $fd "                          print \"?? Got unknown EAP code (%i)\" % code"
	puts $fd "            else: "
	puts $fd "                print \"Got EAPOL type %i\" % type "
	puts $fd "        else: "
	puts $fd "            print \"------> Neglecting - Got Packet with Different Ethertype\",ether "
   puts $fd "            count3 = count3 + 1"
   puts $fd "            if count3 > 20:"
   puts $fd "                break"         
	puts $fd "except KeyboardInterrupt:"
	puts $fd "    print \"Interrupted by user\""
	puts $fd "except timeout: "
	puts $fd "    print \"!!!  Exiting due to timeout - No response received\""
    close $fd
    CheckTftpPut "$filesToUpload"
    if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
    result_debug "Skipped: Dot1x Client Python File Did Not Download Correctly"
   }
}

##################### REAUTHENTICATION Scenario

proc Dot1x_Reauth_Client {testNo {dut "2"}} {

    set filesToUpload ""
    set filesToDownload ""
    lappend filesToUpload "Tmp/$testNo"
    lappend filesToDownload "$testNo"
    set fd [open "Tmp/$testNo" "w"]
    puts $fd "######################################################################################################## "
	puts $fd "######################################################################################################## "
	puts $fd "# "
	puts $fd "#                                        DOT1X Client Program "
	puts $fd "# "
	puts $fd "# -----------------------------------------Pre Requirements -------------------------------------------- "
	puts $fd "# "
	puts $fd "#            **Generate the name of the Interface with vlan_name\[5\]_{snmpvalue in hex} "
	puts $fd "#            **Ensure the Vlan is created prior and an active port is added "
	puts $fd "#            **Assign IP to the vlan and enable ip forwarding - Though we are dealing with L2 packets "
	puts $fd "#            **the CPU will LIFT the packet only for a L3 interface hence assign an IP to the Vlan "
	puts $fd "#            ****** The CPU lifts the L2 packets when DHCP is enabled in the interface -Update 20 Jan "
	puts $fd "######################################################################################################## "
	puts $fd " "
	puts $fd "#!/usr/bin/python "
	puts $fd " "
	puts $fd "from socket import * "
	puts $fd "from struct import * "
	puts $fd "from md5 import * "
	puts $fd "from sys import * "
	puts $fd "import time "
	puts $fd " "
	puts $fd "### Argument Settings "
	puts $fd " "
	puts $fd "try: "
	puts $fd "    Username = argv\[1\] "
	puts $fd "    Password = argv\[2\] "
	puts $fd "    interface = argv\[3\] "
	puts $fd "except: "
	puts $fd "    print \"The Username or Password or Interface is not specified correctly: exiting !!!\" "
	puts $fd "    print \"Usage: python <script_name> <username> <password> <interface_name>\" "
	puts $fd "    exit() "
	puts $fd "logoff = 0 "
   puts $fd "reauth = 0 "
	puts $fd "if len(argv) > 4: "
	puts $fd "    try: "
	puts $fd "        operation = argv\[4\] "
	puts $fd "        timer = argv\[5\] "
	puts $fd "        if operation == \"logout\": "
	puts $fd "            print \"Dot1x process start with logout operation at interval:\",timer "
	puts $fd "### LOGOFF Scenario "
	puts $fd "            logontime = timer "
	puts $fd "            logoff = 1 "
	puts $fd "        elif operation == \"reauth\": "
	puts $fd "            print \"Dot1x process start with reauthentication operation at interval:\",timer "
	puts $fd "### Re Authentication "
	puts $fd "            reauth = 1 "
	puts $fd "            reauth_time = timer "
	puts $fd "        else: "
	puts $fd "            print \"Invalid Operation Exiting\" "
	puts $fd "            print \"Usage: load script <script_name> <username> <password> <interface_name> <operation name: logout\\reauth> <time interval>\" "
	puts $fd "            exit() "
	puts $fd "    except: "
	puts $fd "        print \"Wrong Usage: Arguments <Operation> and <Timer> are not specified correctly !!!\" "
	puts $fd "        print \"Usage: load script <script_name> <username> <password> <interface_name> <operation name: logout\\reauth> <time interval>\" "
	puts $fd "        exit() "
	puts $fd "         "
	puts $fd "else: "
	puts $fd "    print \"Proceeding with Dot1x authtication with no special operation like logout or reauth\" "
	puts $fd "               "
	puts $fd " "
	puts $fd "###  Authentication parameters "
	puts $fd " "
	puts $fd "USER = Username "
	puts $fd "PASS = Password "
	puts $fd "DEV = interface "
	puts $fd " "
	puts $fd "### Constants "
	puts $fd " "
	puts $fd "ETHERTYPE_PAE = 0x888e "
	puts $fd "PAE_GROUP_ADDR = \"\\x01\\x80\\xc2\\x00\\x00\\x03\" "
	puts $fd "ETH_P_ALL=0x0003 "
	puts $fd " "
	puts $fd "EAPOL_VERSION = 1 "
	puts $fd "EAPOL_EAPPACKET = 0 "
	puts $fd "EAPOL_START = 1 "
	puts $fd "EAPOL_LOGOFF = 2 "
	puts $fd "EAPOL_KEY = 3 "
	puts $fd "EAPOL_ASF = 4 "
	puts $fd " "
	puts $fd "EAP_REQUEST = 1 "
	puts $fd "EAP_RESPONSE = 2 "
	puts $fd "EAP_SUCCESS = 3 "
	puts $fd "EAP_FAILURE = 4 "
	puts $fd " "
	puts $fd "EAP_TYPE_ID = 1 "
	puts $fd "EAP_TYPE_MD5 = 4 "
	puts $fd "EAP_TYPE_TLS = 4 "
	puts $fd " "
	puts $fd "count1 = 0 "
   puts $fd "count2 = 0 "
   puts $fd "count3 = 0 "
   puts $fd " "
   puts $fd "EXTREME_SO_VRID = 37 "
	puts $fd " "
	puts $fd "### Packet builders "
	puts $fd " "
	puts $fd "def EAPOL(type, payload=\"\"): "
	puts $fd "    return pack(\"!BBH\", EAPOL_VERSION, type, len(payload))+payload "
	puts $fd " "
	puts $fd "def EAP(code, id, type=0, data=\"\"): "
	puts $fd "    if code in \[EAP_SUCCESS, EAP_FAILURE\]: "
	puts $fd "        return pack(\"!BBH\", code, id, 4) "
	puts $fd " "
	puts $fd "    else: "
	puts $fd "        return pack(\"!BBHB\", code, id, 5+len(data), type)+data "
	puts $fd " "
	puts $fd "def ethernet_header(src, dst, type): "
	puts $fd "    return dst+src+pack(\"!H\",type) "
	puts $fd " "
	puts $fd " "
	puts $fd "### Main program "
	puts $fd " "
	puts $fd "### L2 RAW Socket Creation and EXOS tweak to work in VR-DEFAULT "
	puts $fd " "
	puts $fd "s=socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL)) "
	puts $fd "s.setsockopt(SOL_SOCKET, EXTREME_SO_VRID, 2) "
	puts $fd " "
	puts $fd "### Interface binding to listen to the socket"
	puts $fd "s.settimeout(60)"
	puts $fd "s.bind((DEV, 0)) "
	puts $fd " "
	puts $fd "### Sending EAPOL Start Packet "
	puts $fd " "
	puts $fd "mymac=s.getsockname()\[4\] "
	puts $fd "llhead=ethernet_header(mymac, PAE_GROUP_ADDR, ETHERTYPE_PAE) "
	puts $fd " "
	puts $fd "print \"--> Not Sending EAPOL Start for Reauthention Scenario !!\" "
	puts $fd " "
	puts $fd "### EAP Transaction Start based on the EAP TYPE "
	puts $fd " "
	puts $fd "try:"
	puts $fd "    while 1:  "
	puts $fd "        p = s.recv(1600) "
	puts $fd "        ether1, ether2 = unpack(\"!BB\",p\[16:18\]) "
	puts $fd "        ether = str(hex(ether1)) + str(hex(ether2))\[2:\] "
	puts $fd "        print \"The Ethertype is \", ether "
	puts $fd "        if ether == hex(ETHERTYPE_PAE): "
	puts $fd "            print \"<-- Got 802.1x Packet with Ethertype\",ether "
	puts $fd "            p = p\[18:\] "
	puts $fd "            vers,type,eapollen  = unpack(\"!BBH\",p\[:4\]) "
	puts $fd "            if type == EAPOL_EAPPACKET: "
	puts $fd "                    code, id, eaplen = unpack(\"!BBH\", p\[4:8\]) "
	puts $fd "### EAP SUCCESS TYPE "
	puts $fd "                    if code == EAP_SUCCESS: "
	puts $fd "                          print \"<-- Got EAP Success\" "
	puts $fd "                          count1 = 0 "
   puts $fd "                          count2 = 0 "
   puts $fd "                          if logoff == 1: "
	puts $fd "                              time.sleep(float(logontime))"
	puts $fd "                              s.send(llhead+EAPOL(EAPOL_LOGOFF)) "
   puts $fd "                              print \"--> Operation: Logout --> Sent EAP Logout after delay\""  
   puts $fd "                              break"     
   puts $fd "                          elif reauth == 1: "    
   puts $fd "                              print \"Operation: Reauthentication <-- Listening until Reauth expires\""
   puts $fd "                              time.sleep(float(reauth_time)) "           
   puts $fd "                              print \"--> Reauthentication started -- Waiting for Reauth Packet\""
   puts $fd "                              reauth = 0"
   puts $fd "                          else: "
	puts $fd "                              break "
	puts $fd "### EAP FAILURE TYPE "
	puts $fd "                    elif code == EAP_FAILURE:"
	puts $fd "                          print \"<-- Got EAP Failure\" "
   puts $fd "                          count1 = 0 "
   puts $fd "                          count2 = 0 "
	puts $fd "                          break "
	puts $fd "                    elif code == EAP_RESPONSE:  "
	puts $fd "                          print \"?? Got EAP Response\" "
	puts $fd "### EAP IDENTITY REQUEST "
	puts $fd "                    elif code == EAP_REQUEST:"
	puts $fd "                          reqtype = unpack(\"!B\", p\[8:9\])\[0\] "
	puts $fd "                          reqdata = p\[9:4+eaplen\]  "
	puts $fd "                          if reqtype == EAP_TYPE_ID: "
	puts $fd "                                print \"<--Got EAP Request for identity\"  "
   puts $fd "                                count1 = count1 + 1 "
   puts $fd "                                if count1 < 2: "      
	puts $fd "                                    s.send(llhead+ "
	puts $fd "                                       EAPOL(EAPOL_EAPPACKET, "
	puts $fd "                                              EAP(EAP_RESPONSE, "
	puts $fd "                                                            id,  "
	puts $fd "                                                       reqtype,  "
	puts $fd "                                                          USER))) "
	puts $fd "                                    print \"--> Sent EAP response with identity = \[%s\]\" % USER "
   puts $fd "                                else: "
   puts $fd "                                    print \"<-- Duplicate Packet Received - EAP Identity Request\""  
	puts $fd "                          elif reqtype == EAP_TYPE_MD5: "
	puts $fd "### EAP MD5 Challenge and Response Handling "
	puts $fd "                              print \"<-- Got EAP Request for MD5 challenge\" "
   puts $fd "                              count2 = count2 + 1 "
   puts $fd "                              if count2 < 2: "
	puts $fd "                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]"
	puts $fd "                                resp=md5(challenge).digest() "
	puts $fd "                                resp=chr(len(resp))+resp "
	puts $fd "                                s.send(llhead+   "
	puts $fd "                                       EAPOL(EAPOL_EAPPACKET,"
	puts $fd "                                       EAP(EAP_RESPONSE, "
	puts $fd "                                                     id,"
	puts $fd "                                                reqtype,"
	puts $fd "                                              resp+USER)))"
	puts $fd "                                print \"--> Send EAP response with MD5 challenge\" "
   puts $fd "                              else: "
   puts $fd "                                print \"<-- Duplicate Packet Received - EAP MD5 Challenge Request\" "
	puts $fd "                          elif reqtype == EAP_TYPE_TLS: "
	puts $fd "### EAP TLS - Under Research "
	puts $fd "                                print \"Got EAP Request for TLS Handshake\" "
	puts $fd "                                challenge=p\[5:6\]+PASS+reqdata\[1:17\]  "
	puts $fd "                                resp=md5(challenge).digest() "
	puts $fd "                                resp=chr(len(resp))+resp "
	puts $fd "                                s.send(llhead+   "
	puts $fd "                                       EAPOL(EAPOL_EAPPACKET,   "
	puts $fd "                                       EAP(EAP_RESPONSE,    "
	puts $fd "                                                     id,   "
	puts $fd "                                                reqtype,   "
	puts $fd "                                              resp+USER))) "
	puts $fd "                                print \"--> Send EAP response with TLS Handshake\" "
	puts $fd "                          else: "
	puts $fd "                                print \"?? Got unknown Request type (%i)\" % reqtype"
	puts $fd "                    else: "
	puts $fd "                          print \"?? Got unknown EAP code (%i)\" % code"
	puts $fd "            else: "
	puts $fd "                print \"Got EAPOL type %i\" % type "
	puts $fd "        else: "
	puts $fd "            print \"------> Neglecting - Got Packet with Different Ethertype\",ether "
   puts $fd "            count3 = count3 + 1"
   puts $fd "            if count3 > 20:"
   puts $fd "                break"         
	puts $fd "except KeyboardInterrupt:"
	puts $fd "    print \"Interrupted by user\""
	puts $fd "except timeout: "
	puts $fd "    print \"!!!  Exiting due to timeout - No response received\""
    close $fd
    CheckTftpPut "$filesToUpload"
    if {[CheckTftpGetMulti $dut "$filesToDownload" py ] == "illegal"} {
    result_debug "Skipped: Dot1x Client Python File Did Not Download Correctly"
   }
}

###########################################################################
### Procedure Name: Interface
###
### Description: Retrieves the Interface name for the resp Vlan created
###
### Sample Usage:
###  Interface <Vlan Name>
###
###  Output : returns the Interface name for the respective Vlan
###
###  Usage of Python script: Interface v1
##
##############################################################################

proc Interface { Vlan } {

set parameterList ""
lappend parameterList "{vlanNameInkernel:} 1"
set interface [GetKeyValue "debug vlan show vlan $Vlan" $parameterList]
return $interface
unset parameterList
}
