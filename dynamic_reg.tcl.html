<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>dynamic_reg.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#dynamic_reg.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>dynamic_reg.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="dynamic_reg.tcl-annot.html">annotations</a> | <a href="dynamic_reg.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<strong><a name="::::egrep_unique_1">proc <a href="dynamic_reg.tcl-annot.html#::::egrep_unique">::::egrep_unique</a></a></strong> {args} {
    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> egrep_unique $args {
       f         &#34;&#34;
       find      &#34;&#34;
       t         &#34;&#34;
       targetDir &#34;&#34;
       ext      &#34;tcl&#34;
       option   &#34;&#34;
    }

    if {$f != &#34;&#34;} {
        set find $f
    }
    if {$t != &#34;&#34;} {
        set targetDir $t
    }
    set fList &#34;&#34;
    foreach match [glob  -nocomplain  ${targetDir}/*.$ext]  {
        if {![catch {exec egrep $option $find $match} matchPhrase] &amp;&amp; [lsearch $fList $matchPhrase] &lt; 0} {
            lappend fList $matchPhrase
        }
    }
    return $fList
}
<strong><a name="::::egrep_files_25">proc <a href="dynamic_reg.tcl-annot.html#::::egrep_files">::::egrep_files</a></a></strong> {args} {
    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> egrep_files $args {
       f         &#34;&#34;
       find      &#34;&#34;
       t         &#34;&#34;
       targetDir &#34;&#34;
       ext      &#34;tcl&#34;
    }

    if {$f != &#34;&#34;} {
        set find $f
    }
    if {$t != &#34;&#34;} {
        set targetDir $t
    }
    set fList &#34;&#34;
    foreach match [glob  -nocomplain  ${targetDir}/*.$ext]  {
        if {![catch {exec egrep -l &#34;$find&#34; $match} matchPhrase]} {
            lappend fList $matchPhrase
        }
    }
    return $fList
}
<strong><a name="::::egrep_files_count_48">proc <a href="dynamic_reg.tcl-annot.html#::::egrep_files_count">::::egrep_files_count</a></a></strong> {args} {
    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> egrep_files_count $args {
       f         &#34;&#34;
       find      &#34;&#34;
       t         &#34;&#34;
       targetDir &#34;&#34;
       ext      &#34;tcl&#34;
    }

    if {$f != &#34;&#34;} {
        set find $f
    }
    if {$t != &#34;&#34;} {
        set targetDir $t
    }
    set fList &#34;&#34;
    foreach match [glob  -nocomplain  ${targetDir}/*.$ext]  {
        <span class="comment-line">#puts &#34;Sending exec egrep -c \&#34;$find\&#34; $match&#34;</span>
        if {![catch {exec egrep -c &#34;$find&#34; $match} matchPhrase]} {
            set fParts [split $match /]
            set theFile [lindex $fParts [expr [llength $fParts] - 1]]
            lappend fList &#34;$theFile:$matchPhrase&#34;
        }
    }
    return $fList
}
<strong><a name="::::get_5node_cfgfiles_74">proc <a href="dynamic_reg.tcl-annot.html#::::get_5node_cfgfiles">::::get_5node_cfgfiles</a></a></strong> {path} {
    return [<a name="::egrep_files(1)"><a href="./dynamic_reg.tcl.html#::egrep_files_25">::egrep_files</a></a> -f DUT3|DUT4|DUT5 -t $path -ext cfg]
}
<strong><a name="::::get_5node_scripts_77">proc <a href="dynamic_reg.tcl-annot.html#::::get_5node_scripts">::::get_5node_scripts</a></a></strong> {path} {
    return [<a name="::egrep_files(2)"><a href="./dynamic_reg.tcl.html#::egrep_files_25">::egrep_files</a></a> -f &#34;Login.*DUT3|DUT4|DUT5&#34; -t $path -ext tcl]
}

<strong><a name="::::get_node_scripts_81">proc <a href="dynamic_reg.tcl-annot.html#::::get_node_scripts">::::get_node_scripts</a></a></strong> {path} {
    return [<a name="::egrep_files(3)"><a href="./dynamic_reg.tcl.html#::egrep_files_25">::egrep_files</a></a> -f DUT1|DUT2 -t $path -ext tcl]
}
<strong><a name="::::is_5node_cfg_84">proc <a href="dynamic_reg.tcl-annot.html#::::is_5node_cfg">::::is_5node_cfg</a></a></strong> {path} {
    if {![catch {exec egrep -l DUT3|DUT4|DUT5 $path} matchPhrase]} {
        return $matchPhrase
    } else {
        return 0
    }
}
<strong><a name="::::is_5node_script_91">proc <a href="dynamic_reg.tcl-annot.html#::::is_5node_script">::::is_5node_script</a></a></strong> {path} {
    if {![catch {exec egrep -l &#34;Login.*DUT3|DUT4|DUT5&#34; $path} matchPhrase]} {
        if {[regexp -nocase &#34;\[0-9a-zA-Z]&#34; $matchPhrase]} {
            return 1
        } else {
            return 0
        }
    } else {
        return 0
    }
}
<strong><a name="::::is_2node_script_102">proc <a href="dynamic_reg.tcl-annot.html#::::is_2node_script">::::is_2node_script</a></a></strong> {path} {
    if {![catch {exec egrep -l &#34;Login.*DUT2&#34; $path} matchPhrase]} {
        if {[regexp -nocase &#34;\[0-9a-zA-Z]&#34; $matchPhrase]} {
            return 1
        } else {
            return 0
        }
    } else {
        return 0
    }
}

<strong><a name="::::is_10node_script_114">proc <a href="dynamic_reg.tcl-annot.html#::::is_10node_script">::::is_10node_script</a></a></strong> {path} {
    if {![catch {exec egrep -l DUT6 $path} matchPhrase]} {
        return $matchPhrase
    } else {
        return 0
    }
}
<strong><a name="::::get_proc_files_121">proc <a href="dynamic_reg.tcl-annot.html#::::get_proc_files">::::get_proc_files</a></a></strong> {path} {
    set oFileList &#34;&#34;
    set pFileList [<a name="::egrep_files_count(1)"><a href="./dynamic_reg.tcl.html#::egrep_files_count_48">::egrep_files_count</a></a> -f &#34;^proc|^ +proc&#34; -t $path -ext tcl]
    foreach pf $pFileList {
        set pCount [lindex [split $pf :] 1]
        if {$pCount &gt; 1} {
            lappend oFileList &#34;[lindex [split $pf :] 0]&#34;
        }
    }
    return $oFileList
}
<strong><a name="::::get_area_132">proc <a href="dynamic_reg.tcl-annot.html#::::get_area">::::get_area</a></a></strong> {in} {
    switch -nocase -regexp $in {
        &#34;bench&#34; {
            return Benchmarktest
        }
        &#34;cli&#34;  {
            return CLItest
        }
        &#34;diag&#34; {
            return DiagnosticsTest
        }
        &#34;epi&#34;  {
            return EPICenter-test
        }
        &#34;func&#34; {
            return Functionaltest
        }
        &#34;scrip&#34; {
            return ixScriptMate
        }
        &#34;perf&#34; {
            return PerformanceTest
        }
        &#34;scal&#34; {
            return Scalabilitytest
        }
        &#34;snmp&#34; {
            return SnmpFunctionaltest
        }
        &#34;stress&#34; {
            return Stresstest
        }
        &#34;syst&#34; {
            return SystemTest
        }
        &#34;xml&#34; {
            return XML_API
        }
        default {
            return 0
        }
    }
}
<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line">#  proc VerifyTopologyMatchDir</span>
<span class="comment-line">#  </span>
<span class="comment-line">#  NODECOUNT is set in main.tcl</span>
<span class="comment-line">#</span>
<span class="comment-line">#  args:  in - args  -module   -mod_dir</span>
<span class="comment-line">#         out - 1 if they case is supported on the bed</span>
<span class="comment-line">#               0 if the case is not supportted on the bed</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#  typical usage:  </span>
<span class="comment-line">#</span>
<span class="comment-line">#   if ![VerifyTopologyMatch -testcase $cTest -module $Module  -mod_dir $testDir] </span>
<span class="comment-line">#         # this test case does not match the test bed</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
<strong><a name="::::VerifyTopologyMatchDir_190">proc <a href="dynamic_reg.tcl-annot.html#::::VerifyTopologyMatchDir">::::VerifyTopologyMatchDir</a></a></strong> {args} {
    global MAIN curAutoRoot nodeByFeature

    <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> VerifyTopologyMatchDir $args {
       module    &#34;null&#34;
       mod_dir   &#34;null&#34;
    }

    if {[info exists nodeByFeature($module)]} {
        puts &#34;Use topology from database&#34;
        if {$nodeByFeature($module) == 5} {
            set tc5node 1; set tc2node 0; set tc1node 0;
        }
        if {$nodeByFeature($module) == 2} {
            set tc5node 0; set tc2node 1; set tc1node 0;
        }
        if {$nodeByFeature($module) == 1} {
            set tc5node 0; set tc2node 0; set tc1node 1;
        }
    } else {
        set tc5node 1
        set tc2node 1
        set tc1node 1
        <span class="comment-line">#Check to see if the case is a 5 node case</span>
        set dirfull ${curAutoRoot}[string trim $mod_dir &#34;.&#34;]/[string trim $module &#34;.&#34;]
        set rtrScripts [<a name="::get_5node_scripts(1)"><a href="./dynamic_reg.tcl.html#::get_5node_scripts_77">::get_5node_scripts</a></a> $dirfull];<span class="comment-line"># Check for DUT3|DUT4|DUT5 in files</span>
        set c 0
        foreach s $rtrScripts {
            set f [file tail $s]
            if {[regexp &#34;\[0-9]+\.\[0-9]+.*\.tcl|T.*\.tcl&#34; $f]} {
                incr c
            }
        }
        puts &#34;check NODECOUNT $dirfull $rtrScripts&#34;
        if {$c &gt; 1} {
            set tc5node 1; set tc1node 0; set tc2node 0;
        } else {
            <span class="comment-line"># undetermined.. just no DUT3,4 or 5 in a numbered tcl file</span>
            set tc1node 1; set tc2node 1; set tc5node 0;
        }
    }
    switch $MAIN(NODECOUNT) {
        1 {
            if {!$tc1node} {
                puts &#34;\n@@@@ $mod_dir $module is not supported on a 1 Node Test Bed @@@@&#34;
                return 0
            } else {
                return 1
            }
        }
        2 {
            if {!$tc2node} {
                puts &#34;\n@@@@ $mod_dir $module is not supported on a 2 Node Test Bed @@@@&#34;
                return 0
            } else {
                return 1
            }
        }
        5 {
            if {!$tc5node} {
                puts &#34;\n@@@@ $mod_dir $module is not supported on a 5 Node Test Bed @@@@&#34;
                return 0
            } else {
                return 1
            }
        }
        default {return 1;}
    }
    return 1;
}


<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line">#  proc VerifyTopologyMatch</span>
<span class="comment-line">#  </span>
<span class="comment-line">#  NODECOUNT is set in main.tcl</span>
<span class="comment-line">#</span>
<span class="comment-line">#  args:  in - args   -testcase  -module   -mod_dir</span>
<span class="comment-line">#         out - 1 if they case is supported on the bed</span>
<span class="comment-line">#               0 if the case is not supportted on the bed</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#  typical usage:  </span>
<span class="comment-line">#</span>
<span class="comment-line">#   if ![VerifyTopologyMatch -testcase $cTest -module $Module  -mod_dir $testDir] </span>
<span class="comment-line">#         # this test case does not match the test bed</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
<strong><a name="::::VerifyTopologyMatch_277">proc <a href="dynamic_reg.tcl-annot.html#::::VerifyTopologyMatch">::::VerifyTopologyMatch</a></a></strong> {args} {
    global MAIN curAutoRoot

    <a name="::parse_args(5)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> VerifyTopologyMatch $args {
       testcase  &#34;null&#34;
       module    &#34;null&#34;
       mod_dir   &#34;null&#34;
    }

    set tc2node 0
    set tc5node 0
    <span class="comment-line">#Check to see if the case is a 5 node case</span>
    set tcfull ${curAutoRoot}[string trim $mod_dir &#34;.&#34;]/[string trim $module &#34;.&#34;]/${testcase}.tcl
    puts &#34;check NODECOUNT $tcfull&#34;
    if {[<a name="::is_5node_script(1)"><a href="./dynamic_reg.tcl.html#::is_5node_script_91">::is_5node_script</a></a> $tcfull] != 0} {
        set tc5node 1
    } elseif {[<a name="::is_2node_script(1)"><a href="./dynamic_reg.tcl.html#::is_2node_script_102">::is_2node_script</a></a> $tcfull] != 0} {
        set tc2node 1
    } else {
        puts &#34;\nDebug - ODD no test bed node count match found&#34;
    }

    switch $MAIN(NODECOUNT) {
        1 {
            if {$tc5node || $tc2node} {
                puts &#34;\n@@@@ Test Case $testcase is not supported on a 1 Node Test Bed @@@@&#34;
                return 0
            } else {
                return 1
            }
        }
        2 {
            if {$tc5node} {
                puts &#34;\n@@@@ Test Case $testcase is not supported on a 2 Node Test Bed @@@@&#34;
                return 0
            } else {
                return 1
            }
        }
        5 {
            if {$tc2node} {
                puts &#34;\n@@@@ Test Case $testcase is not supported on a 1 Node Test Bed @@@@&#34;
                return 0
            } else {
                return 1
            }
        }
        default {return 1;}
    }
    return 1;
}

<strong><a name="::::make_dyn_tests_329">proc <a href="dynamic_reg.tcl-annot.html#::::make_dyn_tests">::::make_dyn_tests</a></a></strong> {module cfg} {
    set retMod ${module}_2node
    set tpt 2
    puts &#34;Mod $module cfg $cfg&#34;
    set dbug 1
    set ctString &#34;set tests_to_run_quick(all) \{\n \
@@TESTS@@\n
\}\n \
set tests_to_run_pass(all) \{\n \
\}\n \
set tests_to_run_all(all) \{\n \
\}\n \
set tests_to_run_debug(all) \{\n \
\}\n \
set tests_to_run(null) \{\n \
   cleanup\n \
\}\n&#34;
    <span class="comment-line">#Check cfg path</span>
    set cList [split $cfg /]
    if {[lindex $cList 0] == &#34;cfg&#34;} {
        set cPath $cfg
    } else {
        set cPath &#34;cfg/$cfg&#34;
    }
    if {![file isfile $cPath]} {
        puts &#34;Error!! Can not find the cfg file $cPath&#34;
        return -1
    } else {
        if {$dbug} {puts &#34;$cPath EXISTS\nCheck to see if this is a 5node cfg&#34;;}
        set fList &#34;&#34;
        if {[<a name="::is_5node_script(2)"><a href="./dynamic_reg.tcl.html#::is_5node_script_91">::is_5node_script</a></a> $cPath] != 0} {
            puts &#34;This is a 5 node cfg file&#34;
            set retMod ${module}_5node
            set tbt 5
        } else {
            puts &#34;This is a 2 node cfg file&#34;
            set retMod ${module}_2node
            set tbt 2
        }
        if {[file isfile ../Dynamic/Tmp/${module}.lst]} {
            puts &#34;Open ${module}.lst&#34;
            set fd_in [open &#34;../Dynamic/Tmp/${module}.lst&#34; &#34;r&#34;]
            while {[gets $fd_in line] != -1} {
                if {$dbug} {puts &#34;----- Line=|$line|&#34;;}
                set lPieces [split $line /]
                set area [<a name="::get_area(1)"><a href="./dynamic_reg.tcl.html#::get_area_132">::get_area</a></a> [lindex $lPieces 0]]
                set feat [lindex $lPieces 1]
                if {[lsearch $fList $feat] &lt; 0} {
                    lappend fList $feat
                    set usedIEList($feat) &#34;&#34;
                    set nodeFiles($feat) &#34;&#34;
                    set nodeSmallFiles($feat) &#34;&#34;
                    set tFiles($feat) &#34;&#34;
                    set fCtList($feat) &#34;&#34;
                    set pLibs($feat) &#34;&#34;
                    set fArea($feat) &#34;$area&#34;
                    <span class="comment-line">#puts &#34;SET AREA fArea($feat)  $fArea($feat)&#34;</span>
                }
                set tc [lindex $lPieces 2]
                set cleanTc [string trimright $tc &#34;.tcl&#34;]
                set fPath &#34;../${area}/${feat}/&#34;
                if {$tbt == 5} {
                    set oList [<a name="::get_5node_scripts(2)"><a href="./dynamic_reg.tcl.html#::get_5node_scripts_77">::get_5node_scripts</a></a> $fPath]
                } else {
                    set aList [<a name="::get_node_scripts(1)"><a href="./dynamic_reg.tcl.html#::get_node_scripts_81">::get_node_scripts</a></a> $fPath]
                    set bList [<a name="::get_5node_scripts(3)"><a href="./dynamic_reg.tcl.html#::get_5node_scripts_77">::get_5node_scripts</a></a> $fPath]
                    if {[llength $aList] &gt; 0 &amp;&amp; [llength $bList] &lt; 2} {
                        set oList $aList
                    } else {
                        set oList &#34;&#34;
                    }
                }
                if {[llength $oList] &gt; 0} {
                    set fCtList($feat) [GetCompleteTestsLists \
                        -sourcefile &#34;${fPath}completetests.lst&#34; \
                        -platform   &#34;x480-24x&#34; \
                        -lst        &#34;dev&#34; \
                        -pId        &#34;null&#34; \
                        -test       &#34;null&#34; \
                        -inVersion  &#34;30.1.1.1&#34; \
                        -inHwList   &#34;null&#34; \
                        -debugFile  &#34;0&#34; \
                        -debugSkip  &#34;0&#34; \
                        -debugSkipCom  &#34;0&#34; \
                        -debugOut   &#34;0&#34; \
                        -debugCom   &#34;0&#34; \
                        -debug      &#34;0&#34;]
                    if {$dbug} {puts &#34;$cleanTc At [lsearch $fCtList($feat) $cleanTc]&#34;;}
                    <span class="comment-line">#puts &#34;$fCtList($feat)&#34;</span>
                    set iEList [lsearch -all -regexp $fCtList($feat) {init|end}]
                    if {$dbug} {puts &#34;Init/End [lsearch -all -regexp $fCtList($feat) {init|end}]&#34;;}
                }
                if {[llength $oList] &gt; 0 &amp;&amp; [file isfile ${fPath}/$tc]} {
                    <span class="comment-line">#Add any possible lib files to the nodeFiles(feature) arrays</span>
                    if {[llength $pLibs($feat)] == 0} {
                        set pp [<a name="::get_proc_files(1)"><a href="./dynamic_reg.tcl.html#::get_proc_files_121">::get_proc_files</a></a> ${fPath}]
                        if {[llength $pp] &gt; 0} {
                            foreach p $pp {
                                if {$dbug} {puts &#34;Found proc file $p&#34;;}
                                lappend pLibs($feat) $p
                            }
                        } else {
                            lappend pLibs($feat) nope
                        }
                    }
                    if {$dbug} {puts &#34;Appending node ${fPath}/$tc&#34;;}
                    lappend nodeFiles($feat) ${fPath}/$tc
                    lappend nodeSmallFiles($feat) $tc
                    lappend tFiles($feat) $cleanTc
                }
            }
            close $fd_in
        } else {
            puts &#34;Can't find the lst file ${module}.lst&#34;
            return -1  
        }
        if {[llength $fList] &gt; 0} {
            set allTC &#34;&#34;
            puts &#34;We have some features $fList&#34;
            if [catch {file mkdir ../Dynamic/$retMod} reason] {
                puts &#34;Could not create ../Dynamic/$retMod&#34;
            } else {
                foreach f $fList {
                    if {$dbug} {puts &#34;Check $f for files - count = [llength $nodeFiles($f)]&#34;;}
                    if {[llength $nodeFiles($f)] &gt; 0} {
                        foreach s $nodeFiles($f) {
                            <span class="comment-line"># Move the script specified in the input file</span>
                            if {[catch {exec cp $s ../Dynamic/$retMod} reason]} {
                                puts &#34;Could not copy $s to ../Dynamic/$retMod&#34;
                            }
                            set fParts [split $s /]
                            set fs [lindex $fParts [expr [llength $fParts] - 1]]
                            set cleanFs [string trimright $fs &#34;.tcl&#34;]
                            <span class="comment-line"># Rename files with feature prepended to support same script name in diff features.</span>
                            if {[catch {exec mv ../Dynamic/$retMod/$fs ../Dynamic/$retMod/${f}_$fs} reason]} {
                                puts &#34;Could not mv ../Dynamic/$retMod/$fs to ../Dynamic/$retMod/${f}_$fs&#34;
                            }
                            <span class="comment-line"># Open the test case for replacing proc name with feature prepended</span>
                            set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;r&#34;]
                            set fContent [read $fd_t]
                            close $fd_t
                            <span class="comment-line"># Remove the original script so we can write the version with the new proc name</span>
                            if {[catch {exec rm -f ../Dynamic/$retMod/${f}_$fs} reason]} {
                                puts &#34;Could not delete ../Dynamic/$retMod/${f}_$fs&#34;
                            }
                            <span class="comment-line"># Open the script to write after replacements</span>
                            set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;w&#34;]
                            if {$dbug} {puts &#34;regsub \&#34;proc $cleanFs\&#34; fContent ${f}_$cleanFs&#34;;}
                            regsub &#34;proc $cleanFs&#34; $fContent &#34;proc ${f}_$cleanFs&#34; fContent
                            regsub &#34;testNo $cleanFs&#34; $fContent &#34;testNo ${f}_$cleanFs&#34; fContent
                            puts $fd_t $fContent
                            close $fd_t
                        }
                        set move($f) &#34;&#34;
                        set j 0
                        <span class="comment-line">#Walk the completetests to look for init and end files</span>
                        foreach ctf $fCtList($f) {
                            if {[regexp init $ctf]} {
                                set iList [split $ctf .]
                                set iPos [lsearch $fCtList($f) $ctf]
                                set initNum [lindex $iList 0]
                                set iEnd [lsearch $fCtList($f) ${initNum}.end]
                                if {$iEnd &lt; 0} {
                                    set iEnd 500
                                }
                                set top [llength $tFiles($f)]
                                set mc 0
                                foreach myCase $tFiles($f) {
                                    if {$dbug} {puts &#34;Look for $myCase - ipos $iPos iend $iEnd&#34;;}
                                    if {[lsearch $fCtList($f) $myCase] &gt; $iPos &amp;&amp; \
                                        [lsearch $fCtList($f) $myCase] &lt; $iEnd &amp;&amp; \
                                        [lsearch $allTC ${f}_$ctf] &lt; 0} {
                                        if {$dbug} {puts &#34;CT add ${f}_$ctf and ${f}_$myCase - fArea($f) $fArea($f)&#34;;}
                                        if {[catch {exec cp ../$fArea($f)/${f}/${ctf}.tcl ../Dynamic/$retMod/${f}_${ctf}.tcl} reason]} {
                                            puts &#34;Could not copy ../$fArea($f)/${f}/${ctf}.tcl to ../Dynamic/$retMod/${f}_${ctf}.tcl&#34;
                                        }
                                        <span class="comment-line"># Change the init proc name - prepend feature</span>
                                        set fs ${ctf}.tcl
                                        set cleanFs $ctf
                                        <span class="comment-line"># Rename files with feature prepended to support same script name in diff features.</span>
                                        <span class="comment-line"># Open the test case for replacing proc name with feature prepended</span>
                                        set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;r&#34;]
                                        set fContent [read $fd_t]
                                        close $fd_t
                                        <span class="comment-line"># Remove the original script so we can write the version with the new proc name</span>
                                        if {[catch {exec rm -f ../Dynamic/$retMod/${f}_$fs} reason]} {
                                            puts &#34;Could not delete ../Dynamic/$retMod/${f}_$fs&#34;
                                        }
                                        <span class="comment-line"># Open the script to write after replacements</span>
                                        set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;w&#34;]
                                        if {$dbug} {puts &#34;regsub \&#34;proc $cleanFs\&#34; fContent ${f}_$cleanFs&#34;;}
                                        regsub &#34;proc $cleanFs&#34; $fContent &#34;proc ${f}_$cleanFs&#34; fContent
                                        regsub &#34;testNo $cleanFs&#34; $fContent &#34;testNo ${f}_$cleanFs&#34; fContent
                                        puts $fd_t $fContent
                                        close $fd_t
                                        <span class="comment-line"># Add test cases to the new completetest.lst with x.init before it</span>
                                        lappend allTC ${f}_$ctf
                                        lappend allTC ${f}_$myCase
                                        if {$mc == [expr $top - 1] &amp;&amp; $iEnd != 500} {
                                            if {$dbug} {puts &#34;CT add ${f}_${initNum}.end&#34;;}
                                            if {[catch {exec cp ../$fArea($f)/${f}/${initNum}.end.tcl ../Dynamic/$retMod/${f}_${initNum}.end.tcl} reason]} {
                                                puts &#34;Could not copy ../$fArea($f)/${f}/${initNum}.end.tcl to ../Dynamic/$retMod/${f}_${initNum}.end.tcl&#34;
                                            }
                                            <span class="comment-line"># Change the end proc name - prepend feature</span>
                                            set fs ${initNum}.end.tcl
                                            set cleanFs ${initNum}.end
                                            <span class="comment-line"># Rename files with feature prepended to support same script name in diff features.</span>
                                            <span class="comment-line"># Open the test case for replacing proc name with feature prepended</span>
                                            set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;r&#34;]
                                            set fContent [read $fd_t]
                                            close $fd_t
                                            <span class="comment-line"># Remove the original script so we can write the version with the new proc name</span>
                                            if {[catch {exec rm -f ../Dynamic/$retMod/${f}_$fs} reason]} {
                                                puts &#34;Could not delete ../Dynamic/$retMod/${f}_$fs&#34;
                                            }
                                            <span class="comment-line"># Open the script to write after replacements</span>
                                            set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;w&#34;]
                                            if {$dbug} {puts &#34;regsub \&#34;proc $cleanFs\&#34; fContent ${f}_$cleanFs&#34;;}
                                            regsub &#34;proc $cleanFs&#34; $fContent &#34;proc ${f}_$cleanFs&#34; fContent
                                            regsub &#34;testNo $cleanFs&#34; $fContent &#34;testNo ${f}_$cleanFs&#34; fContent
                                            puts $fd_t $fContent
                                            close $fd_t
                                            <span class="comment-line"># add the end file to the new completelist</span>
                                            lappend allTC ${f}_${initNum}.end
                                        }
                                    } elseif {[lsearch $fCtList($f) $myCase] &gt; $iPos &amp;&amp; \
                                        [lsearch $fCtList($f) $myCase] &lt; $iEnd &amp;&amp; \
                                        [lsearch $allTC ${f}_$ctf] &gt;= 0 &amp;&amp; \
                                        [lsearch $allTC ${f}_$myCase] &lt; 0} {
                                        if {$dbug} {puts &#34;CT add ${f}_$myCase&#34;;}
                                        lappend allTC ${f}_$myCase
                                        if {$mc == [expr $top - 1] &amp;&amp; $iEnd != 500} {
                                            if {$dbug} {puts &#34;CT add ${f}_${initNum}.end&#34;;}
                                            if {[catch {exec cp ../$fArea($f)/${f}/${initNum}.end.tcl ../Dynamic/$retMod/${f}_${initNum}.end.tcl} reason]} {
                                                puts &#34;Could not copy ../$fArea($f)/${f}/${initNum}.end.tcl to ../Dynamic/$retMod/${f}_${initNum}.end.tcl&#34;
                                            }
                                            <span class="comment-line"># Change the end proc name - prepend feature</span>
                                            set fs ${initNum}.end.tcl
                                            set cleanFs ${initNum}.end
                                            <span class="comment-line"># Rename files with feature prepended to support same script name in diff features.</span>
                                            <span class="comment-line"># Open the test case for replacing proc name with feature prepended</span>
                                            set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;r&#34;]
                                            set fContent [read $fd_t]
                                            close $fd_t
                                            <span class="comment-line"># Remove the original script so we can write the version with the new proc name</span>
                                            if {[catch {exec rm -f ../Dynamic/$retMod/${f}_$fs} reason]} {
                                                puts &#34;Could not delete ../Dynamic/$retMod/${f}_$fs&#34;
                                            }
                                            <span class="comment-line"># Open the script to write after replacements</span>
                                            set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;w&#34;]
                                            if {$dbug} {puts &#34;regsub \&#34;proc $cleanFs\&#34; fContent ${f}_$cleanFs&#34;;}
                                            regsub &#34;proc $cleanFs&#34; $fContent &#34;proc ${f}_$cleanFs&#34; fContent
                                            regsub &#34;testNo $cleanFs&#34; $fContent &#34;testNo ${f}_$cleanFs&#34; fContent
                                            puts $fd_t $fContent
                                            close $fd_t
                                            <span class="comment-line"># add the end file to the new completelist</span>
                                            lappend allTC ${f}_${initNum}.end
                                        }
                                    } elseif {$mc == $top &amp;&amp; $iEnd != 500} {
                                        if {$dbug} {puts &#34;CT add ${f}_${initNum}.end&#34;;}
                                        if {[catch {exec cp ../$fArea($f)/${f}/${initNum}.end.tcl ../Dynamic/$retMod/${f}_${initNum}.end.tcl} reason]} {
                                            puts &#34;Could not copy ../$fArea($f)/${f}/${initNum}.end.tcl to ../Dynamic/$retMod/${f}_${initNum}.end.tcl&#34;
                                        }
                                        <span class="comment-line"># Change the end proc name - prepend feature</span>
                                        set fs ${initNum}.end.tcl
                                        set cleanFs ${initNum}.end
                                        <span class="comment-line"># Rename files with feature prepended to support same script name in diff features.</span>
                                        <span class="comment-line"># Open the test case for replacing proc name with feature prepended</span>
                                        set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;r&#34;]
                                        set fContent [read $fd_t]
                                        close $fd_t
                                        <span class="comment-line"># Remove the original script so we can write the version with the new proc name</span>
                                        if {[catch {exec rm -f ../Dynamic/$retMod/${f}_$fs} reason]} {
                                            puts &#34;Could not delete ../Dynamic/$retMod/${f}_$fs&#34;
                                        }
                                        <span class="comment-line"># Open the script to write after replacements</span>
                                        set fd_t [open &#34;../Dynamic/$retMod/${f}_$fs&#34; &#34;w&#34;]
                                        if {$dbug} {puts &#34;regsub \&#34;proc $cleanFs\&#34; fContent ${f}_$cleanFs&#34;;}
                                        regsub &#34;proc $cleanFs&#34; $fContent &#34;proc ${f}_$cleanFs&#34; fContent
                                        regsub &#34;testNo $cleanFs&#34; $fContent &#34;testNo ${f}_$cleanFs&#34; fContent
                                        puts $fd_t $fContent
                                        close $fd_t
                                        <span class="comment-line"># add the end file to the new completelist </span>
                                        lappend allTC ${f}_${initNum}.end
                                    }
                                    incr mc
                                }
                            } elseif {[lsearch $allTC ${f}_$ctf] &gt;= 0 || [lsearch $tFiles($f) $ctf] &lt; 0} {
                                if {$dbug} {puts &#34;Hit cont first [lsearch $allTC $ctf] sec [lsearch $tFiles($f) $ctf] files $tFiles($f)&#34;;}
                                continue
                            } else {
                                if {$dbug} {puts &#34;CT add else ${f}_$ctf&#34;;}
                                lappend allTC ${f}_$ctf
                            }
                        }
                        <span class="comment-line">#lappend allTC [join $tFiles($f) \n]</span>
                        <span class="comment-line"># Copy any possible proc files to the dynamic module directory</span>
                        foreach pf $pLibs($f) {
                            <span class="comment-line"># Move the possible lib file</span>
                            if {[lsearch $tFiles($f) $pf] &lt; 0} {
                                if {$dbug} {puts &#34;MOVING possible lib $pf&#34;;}
                                if {[catch {exec cp ../$fArea($f)/${f}/$pf ../Dynamic/$retMod/$pf} reason]} {
                                    puts &#34;Could not copy ../$fArea($f)/${f}/$pf to ../Dynamic/$retMod/$pf&#34;
                                }
                            }
                        }
                    }
                }
                set fd_ct [open &#34;../Dynamic/$retMod/completetests.lst&#34; &#34;w&#34;]
                set theTests [join $allTC &#34;\n&#34;]
                regsub {@@TESTS@@} $ctString $theTests ctString
                puts $fd_ct $ctString
                close $fd_ct                
            }
        } else {
            puts &#34;No files found&#34;
            return -1
        } 
        return $retMod
    }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
