<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>semaphore.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#semaphore.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>semaphore.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="semaphore.tcl-annot.html">annotations</a> | <a href="semaphore.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#  ListToJSON </span>
<span class="comment-line">#################################################################</span>
<strong><a name="::::listToJson_5">proc <a href="semaphore.tcl-annot.html#::::listToJson">::::listToJson</a></a></strong> {args} {
    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> listToJson $args {
        mlist &#34;&#34;
        elem &#34;Test&#34;
    }

    <span class="comment-line">#set in &#34;\{\&#34;uuid\&#34;:\&#34;$myUuid\&#34;,\&#34;config\&#34;:\&#34;$L1CFG\&#34;,\&#34;portlist\&#34;:\[$pstr\],\</span>
    <span class="comment-line">#    \&#34;ipaddress\&#34;:\&#34;$myServerIp\&#34;,\&#34;port\&#34;:\&#34;$mySock\&#34;\}&#34;</span>

    set j &#34;\{\&#34;$elem\&#34;: \{&#34;
    foreach {a v} $mlist {
        set j [append j &#34;\&#34;$a\&#34;:\&#34;$v\&#34;,&#34;];
    }
    set j [string trimright $j &#34;,&#34;]
    set j [append j &#34;\}\}&#34;]
    return $j

}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># A library procedure to enhance writing json formated strings</span>
<span class="comment-line">#</span>
<span class="comment-line"># dict create key1 value1 ke2 value2 .........</span>
<span class="comment-line"># Example:</span>
<span class="comment-line"># set d [dict create blue [list 1 2] ocean water]</span>
<span class="comment-line"># set jsonOut [tcl2json $d]</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::tcl2json_34">proc <a href="semaphore.tcl-annot.html#::::tcl2json">::::tcl2json</a></a></strong> value {
    <span class="comment-line"># Guess the type of the value; deep *UNSUPPORTED* magic!</span>
    <span class="comment-line">#regexp {^value is a (.*?) with a refcount} \</span>
    <span class="comment-line">#	[::tcl::unsupported::representation $value] -&gt; type</span>
    set type dict

    switch $type {
	string {
	    return [json::write string $value]
	}
	dict {
	    return [json::write object {*}[
		dict map {k v} $value {<a name="::tcl2json(1)"><a href="./semaphore.tcl.html#::tcl2json_34">::tcl2json</a></a> $v}]]
	}
	list {
	    return [json::write array {*}[lmap v $value {<a name="::tcl2json(2)"><a href="./semaphore.tcl.html#::tcl2json_34">::tcl2json</a></a> $v}]]
	}
	int - double {
	    return [expr {$value}]
	}
	booleanString {
	    return [expr {$value ? &#34;true&#34; : &#34;false&#34;}]
	}
	default {
	    <span class="comment-line"># Some other type; do some guessing...</span>
	    if {$value eq &#34;null&#34;} {
		<span class="comment-line"># Tcl has *no* null value at all; empty strings are semantically</span>
		<span class="comment-line"># different and absent variables aren't values. So cheat!</span>
		return $value
	    } elseif {[string is integer -strict $value]} {
		return [expr {$value}]
	    } elseif {[string is double -strict $value]} {
		return [expr {$value}]
	    } elseif {[string is boolean -strict $value]} {
		return [expr {$value ? &#34;true&#34; : &#34;false&#34;}]
	    }
	    return [json::write string $value]
	}
    }
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># proc _RequestSemaphore</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_RequestSemaphore_81">proc <a href="semaphore.tcl-annot.html#::::_RequestSemaphore">::::_RequestSemaphore</a></a></strong> {args} {
    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> SendFrame $args {
        user &#34;1&#34;
        regServerIp &#34;0&#34;
        cfg &#34;&#34;
        socket &#34;&#34;
        uuid &#34;&#34;
        db &#34;&#34;
        dbIp &#34;&#34;
        harness &#34;&#34;
    }
    set in &#34;\{\&#34;uuid\&#34;:\&#34;$myUuid\&#34;,\&#34;config\&#34;:\&#34;$L1CFG\&#34;,\&#34;portlist\&#34;:\[$pstr\],\&#34;ipaddress\&#34;:\&#34;$myServerIp\&#34;,\&#34;port\&#34;:\&#34;$mySock\&#34;\}&#34;

    puts &#34;json = $in&#34;
    set resWaiting 1
    while {$resWaiting} {
        set token [::http::geturl &#34;http://10.68.69.31/api/topologies&#34; -type &#34;application/json&#34; \
                     -method &#34;POST&#34; -query $in]
        set code [::http::code $token]
        set data [::http::data $token]

        puts &#34;code $code&#34;
        puts &#34;data $data&#34;

        set parsed [json::json2dict $data]
        puts $parsed
        foreach {key val} $parsed {
            set retArray($key) $val
        }
        if {$retArray(status) == &#34;success&#34;} {
            set resWaiting 0
            foreach ixiaList $retArray(ixia_port_list) {
                set pId [lindex $ixiaList 0]
                set ixiaIp [lindex $ixiaList 1]
                set iCh [lindex $ixiaList 2]
                set iSlot [lindex $ixiaList 3]
                set iPort [lindex $ixiaList 4]
                puts &#34;portId $pId Ixia $ixiaIp info $iCh $iSlot $iPort&#34;
                set ixiaPortMappingArray($pId) &#34;$iCh $iSlot $iPort&#34;
                set l1Configured($pId) 1
                IxiaOnePortInit $pId
            }
        } else {
            puts &#34;\nWait 60 seconds for free Ixia Ports&#34;
            after 60000
        }
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># proc OpenTPBControlPort:</span>
<span class="comment-line">#    Open a communication socket for TPB to receive cases and</span>
<span class="comment-line">#    send results.</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::OpenTPBControlPort_135">proc <a href="semaphore.tcl-annot.html#::::OpenTPBControlPort">::::OpenTPBControlPort</a></a></strong> {args} {

    package require json::write
    package require json
    global env

    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> OpenTPBControlPort $args {
        <a name="::port(1)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> &#34;null&#34;
    }
    if {$port == &#34;null&#34;} {
        set mySock [expr 10000 + [expr {int(rand()*50000)}]]
    } else {
        set mySock $port
    } 
    if {[catch {socket -server on_connect $mySock} why]} {
        puts &#34;\n@@@@\n@@@@\nFailed to open Socket server on socket $mySock\n@@@@\n@@@@\n&#34;
        return 0
    }  ;<span class="comment-line"># Create a server socket</span>
    puts &#34;@@@\n@@@\nTPB Control Socket = TCP Port $mySock\n@@@\n@@@&#34;;
    return 1;

}
<span class="comment-line"># Change the port to meet requirements.  Read it for example from the</span>
<span class="comment-line"># commandline or a configuration file</span>

<span class="comment-line"># socket -server on_connect 12345</span>

<span class="comment-line"># Procedure called whenever a new connection is made by a client.</span>
<strong><a name="::::on_connect_163">proc <a href="semaphore.tcl-annot.html#::::on_connect">::::on_connect</a></a></strong> {newsock clientAddress clientPort} {
    global initsend mySock

    if [info exists initsend] {
        set initsend &#34;$initsend&#34;
    } else {
        set initsend &#34;You are $clientAddress on port $clientPort. Socket is $newsock&#34;
    }
    set mySock $newsock
    <span class="comment-line"># This is the place to add checks disallowing connections based</span>
    <span class="comment-line"># upon the hostname/ipaddress of the peer.</span>
    <span class="comment-line">#puts &#34;CLIENT CONNECTED&#34;</span>
    fconfigure $newsock -blocking 0 -buffering line
    puts $newsock &#34;$initsend&#34;
    fileevent  $newsock readable [list handleInput $newsock]
}

<span class="comment-line"># Procedure called whenever input arrives on a connection.</span>
<strong><a name="::::handleInput_181">proc <a href="semaphore.tcl-annot.html#::::handleInput">::::handleInput</a></a></strong> {f} {
    global getmyjson getexec freepause ineed youneed
    <span class="comment-line"># Delete the handler if the input was exhausted.</span>
    if {[eof $f]} {
        puts &#34;Monitoring Client Closed.&#34;; 
        fileevent $f readable {}
        close     $f
        return
    }

    <span class="comment-line"># Read and handle the incoming information. Here we just log it to</span>
    <span class="comment-line"># stdout.</span>
    set srvin [string trim [read $f]];
    puts $f &#34;Rx main.tcl: $srvin&#34;
    set initIn &#34;$srvin&#34;

    <span class="comment-line">#regsub -all {\{} $srvin &#34;&#34; srvin</span>
    <span class="comment-line"># Control Returning the socket and variable svrin to the parent proc</span>
    if {[regexp -nocase -all &#34;tpbsubmit&#34; &#34;$srvin&#34;]} {
        set ineed &#34;$f=$initIn&#34;;
        set getmyjson [ clock second ];
    } elseif {[regexp -nocase &#34;.*exec.*&#34; $srvin]} {
        set getexec [ clock second ];
    } elseif {[regexp -nocase &#34;.*freepause.*&#34; $srvin]} {
        set freepause [ clock second ];
    } else {
        puts $f &#34;Input: $srvin&#34;
        puts $f &#34;Input does not match the current handler&#34;
    }
}
<strong><a name="::::handleOutput_211">proc <a href="semaphore.tcl-annot.html#::::handleOutput">::::handleOutput</a></a></strong> {f msg} {
global useSocket
    if [catch {puts $f $msg} why] {
        puts &#34;Socket or Client is not available&#34;
    } else {
        flush $f
    }
}

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
