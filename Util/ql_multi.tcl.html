<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>ql_multi.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#ql_multi.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>ql_multi.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="ql_multi.tcl-annot.html">annotations</a> | <a href="ql_multi.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

<span class="comment-line">############################### MAIN #################################</span>
source /auto/automation/Util/runReg.cfg
source /auto/automation/Lib/mysqlLib.tcl
global curAutoRoot
global DUTs_info


source ../Lib/mainLib.tcl
package require Tclx

load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]

set curLocation [pwd]
set curDirList [split [string trim [string trim $curLocation &#34;..&#34;] &#34;/&#34;] &#34;/&#34;]
set v 0;
set pathList &#34;&#34;
set curAutoRoot &#34;&#34;
set skipCC 0
foreach cd $curDirList {
    if {$cd == &#34;main&#34; || $cd == &#34;Lib&#34; || $cd == &#34;Util&#34;} {
        for {set x 0} {$x&lt;$v} {incr x} {
            lappend pathList [lindex $curDirList $x]
        }
        set curAutoRoot &#34;/[join $pathList &#34;/&#34;]&#34;
    } else {
        incr v;
    }
}
puts &#34;CURRENT PATH: $curAutoRoot&#34;
set cDir [file tail [pwd]]
set LIB_PATH &#34;./../Lib&#34;
lappend auto_path $LIB_PATH
puts &#34;DEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;

<a name="::gen_index(1)"><a href="./summarize.tcl.html#::gen_index_76">::gen_index</a></a> &#34;./../Lib&#34;
<span class="comment-line">#source the local lib until it gets moved to lib</span>
source ./regtoolsLib.tcl

<strong><a name="::print_usage_41">proc <a href="ql_multi.tcl-annot.html#::print_usage">::print_usage</a></a></strong><a name="::print_usage"></a> {} {
    puts &#34;\r&#34;
    puts {Usage: multi_CC.tcl}
    puts &#34;\r&#34;
}

<span class="comment-line"># checking command parameters</span>
set incfgs &#34;&#34;
if {$argc==1} {
    puts &#34;We got $argv&#34;
    set incfgs $argv
}

catch {exec clear &gt;@ stdout} ww
<span class="comment-line">## ----------------------------------------------------------------</span>
<span class="comment-line">##   Main </span>
<span class="comment-line">## ----------------------------------------------------------------</span>
fconfigure stdin -blocking 1
set chInts &#34;1 2&#34;
if {[regexp -nocase &#34;rdureg|salemreg&#34; $HOST]} {
    set choice &#34;1&#34;
    set ch(1) &#34;RDUREG/SALEMREG&#34;
    set ch(2) &#34;RDU Automation&#34;
    set chStr(1) &#34;swdev&#34;
    set chStr(2) &#34;Production&#34;
} elseif {[regexp -nocase &#34;autoregrdu&#34; $HOST]} {
    set choice &#34;1&#34;
    set ch(1) &#34;RDU Automation&#34;
    set ch(2) &#34;RDUREG/SALEMREG&#34;
    set chStr(1) &#34;Production&#34;
    set chStr(2) &#34;swdev&#34;
} else {
    set choice &#34;1&#34;
    set ch(1) &#34;RDUREG/SALEMREG&#34;
    set ch(2) &#34;RDU Automation&#34;
    set chStr(1) &#34;swdev&#34;
    set chStr(2) &#34;Production&#34;
}
while {1} {
    puts &#34;\n\n&#34;;
    puts &#34;Harness to run:&#34;
    foreach x $chInts {
        puts &#34;$x = $ch($x)&#34;
    }
    puts -nonewline &#34;What harness are you running in &lt;cr&gt;=default \[$choice\]: &#34;;
    flush stdout;
    gets stdin userChoice;
    if {$userChoice==&#34;&#34;} {
       set userChoice $choice
    }
    if {[lsearch $chInts $userChoice] &gt;=0} {
       puts &#34;You are running on: $ch($userChoice)&#34;;
       set server $chStr($userChoice);
       break;
    } else {
       puts &#34;Error: You must choose either \[join $chInts ' or ']&#34;;
       continue;
    }
}
if {$server == &#34;swdev&#34;} {
    set cfgList [<a name="::getlocked(1)"><a href="./regtoolsLib.tcl.html#::getlocked_469">::getlocked</a></a>]
    set cfgList [concat $cfgList [<a name="::getUserLocks(1)"><a href="./regtoolsLib.tcl.html#::getUserLocks_484">::getUserLocks</a></a>]]
    <span class="comment-line">#puts &#34;Locked List $lockedList&#34;</span>
    <span class="comment-line">#puts &#34;Locked List $lockedList&#34;</span>
    set cfgList [<a name="::swsharedbeds(1)"><a href="./regtoolsLib.tcl.html#::swsharedbeds_300">::swsharedbeds</a></a> $cfgList]
    <span class="comment-line">#puts &#34;$server Locked List $cfgList&#34;</span>
    set cfgList [<a name="::NumberedMenu(1)"><a href="./regtoolsLib.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Available Test Beds&#34; \
                -question1 &#34;Select test beds to run check connections on&#34; \
                -choices $cfgList \
                -menuWidth        75 \
                -keyWidth         3 \
                -headerPadChar    &#34;=&#34; \
                -chAppendList     &#34;null&#34; \
                -chPrependList    &#34;null&#34; \
                -barChar          &#34;-&#34; \
                -clearXterm       &#34;yes&#34; \
                -clearXtermInfo   &#34;&#34; ]

} else {
    while {1} {
        puts &#34;&#34;;
        set choice &#34;21.1&#34;
        puts -nonewline &#34;Enter a release \[$choice\]: &#34;;
        flush stdout;
        gets stdin userChoice;
        if {$userChoice == &#34;&#34;} {
            set userChoice $choice
        }
        if {[regexp -nocase &#34;^\[0-9]{2,2}\.\[0-9]{1,1}$&#34; $userChoice]} {
            set rel $userChoice
            set cfgList [<a name="::get_test_beds(1)"><a href="./regtoolsLib.tcl.html#::get_test_beds_499">::get_test_beds</a></a> $userChoice];
            <span class="comment-line">#puts &#34;\nMAIN cfglist $cfgList&#34;;</span>
            break;
        } else {
            puts &#34;Error: Your choice must be in the format 21.1&#34;;
            continue;
        }
    }
    while {1} {
        puts &#34;&#34;;
        set choice &#34;No&#34;
        puts &#34;&#34;
        puts &#34;HIT ENTER TO SKIP&#34;
        puts -nonewline &#34;Regex filter on cfg and owner.  Enter the string '440_G|450_G|620|mix'\[$choice\]: &#34;;
        flush stdout;
        gets stdin userChoice;
        if {$userChoice==&#34;&#34;} {
            set autoUserBeds &#34;&#34;
            set userChoice $choice
        }
        if {[regexp -nocase &#34;^n|^no&#34; $userChoice]} {
            <span class="comment-line">#puts &#34;return nothing&#34;</span>
            break;
        } else {
            set newCList [<a name="::get_filtered_test_beds(1)"><a href="./regtoolsLib.tcl.html#::get_filtered_test_beds_563">::get_filtered_test_beds</a></a> $cfgList $userChoice]
            if {[llength $newCList] &lt;= 0} {
                puts &#34;No match.  Using the entire release based cfg file list&#34;
                break;
            } else {
                set cfgList $newCList;
                break;
            }
        }
    }

    set mainL [<a name="::maintestbeds(1)"><a href="./regtoolsLib.tcl.html#::maintestbeds_278">::maintestbeds</a></a>];
    set ccL [<a name="::cctestbeds(1)"><a href="./regtoolsLib.tcl.html#::cctestbeds_380">::cctestbeds</a></a>];
    set qlL [<a name="::qltestbeds(1)"><a href="./regtoolsLib.tcl.html#::qltestbeds_402">::qltestbeds</a></a>];
    set vtL [<a name="::vttestbeds(1)"><a href="./regtoolsLib.tcl.html#::vttestbeds_424">::vttestbeds</a></a>];
    set lcL [<a name="::lctestbeds(1)"><a href="./regtoolsLib.tcl.html#::lctestbeds_446">::lctestbeds</a></a>];
    set cfgLen [llength $cfgList];
    set newCfgList &#34;&#34;
    for {set x 0} {$x&lt;$cfgLen} {incr x} {
        if {[lsearch $mainL [lindex $cfgList $x]] &gt;=0} {
            puts &#34;Cfg [lindex $cfgList $x] is running main.tcl&#34;;
            continue;
        }
        if {[lsearch $ccL [lindex $cfgList $x]] &gt;=0} {
            puts &#34;Cfg [lindex $cfgList $x] is running checkConnections.tcl&#34;;
            continue;
        }
        if {[lsearch $qlL [lindex $cfgList $x]] &gt;=0} {
            puts &#34;Cfg [lindex $cfgList $x] is running QLoadImage.tcl&#34;;
            continue;
        }
        if {[lsearch $vtL [lindex $cfgList $x]] &gt;=0} {
            puts &#34;Cfg [lindex $cfgList $x] is running verifyTestBed.tcl&#34;;
            continue;
        }
        if {[lsearch $lcL [lindex $cfgList $x]] &gt;=0} {
            puts &#34;Cfg [lindex $cfgList $x] is sitting a loadConsoles&#34;;
            continue;
        }
        if {[llength $incfgs] &gt; 0} {
            if {[lsearch $incfgs [lindex $cfgList $x]] &lt; 0} {
                puts &#34;Using Args Cfg [lindex $cfgList $x] is not passed in&#34;;
                continue;
            }
        }
        lappend newCfgList [lindex $cfgList $x]
    }
    set cfgList $newCfgList

    set cfgList [<a name="::NumberedMenu(2)"><a href="./regtoolsLib.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Available Test Beds&#34; \
                -question1 &#34;Select a $rel test bed&#34; \
                -choices $cfgList \
                -menuWidth        100 \
                -keyWidth         5 \
                -headerPadChar    &#34;=&#34; \
                -chAppendList     &#34;null&#34; \
                -chPrependList    &#34;null&#34; \
                -barChar          &#34;-&#34; \
                -clearXterm       &#34;yes&#34; \
                -clearXtermInfo   &#34;&#34; ]

}

set pl &#34;&#34;
set pil &#34;&#34;
set partition &#34;&#34;
set useSame 0
foreach cfg $cfgList {
    while {1} {
        set choice y
        puts -nonewline &#34;Would you like to download code on $cfg (y/n)\[$choice\]: &#34;;
        flush stdout;
        gets stdin userChoice;
        if {$userChoice==&#34;&#34;} {
           set userChoice $choice
           puts &#34;choice $choice&#34;
        }
        if {[regexp -nocase &#34;y&#34; $userChoice] || [regexp -nocase &#34;n&#34; $userChoice]} {
            if {[regexp -nocase &#34;y&#34; $userChoice]} {
                set go 1
            } else {
                set go 0
            }
           puts &#34;&#34;
           break;
        } else {
           puts &#34;Error: Config selection must be either y or n&#34;
           continue
        }
    }
    if {!$go} {
        continue;
    }
    if {$useSame} {
        puts &#34;Using the same. Values = QLoadImage.tcl -cfg $cfg -pl \&#34;pl\&#34; -pil \&#34;$pil\&#34; -partition \&#34;$partition\&#34;&#34;
    } else {
        while {1} {
            set choice sec
            puts -nonewline &#34;Which parition (sec/pri)\[$choice\]: &#34;;
            flush stdout;
            gets stdin userChoice;
            if {$userChoice==&#34;&#34;} {
               set userChoice $choice
               puts &#34;choice $choice&#34;
            }
            if {[regexp -nocase &#34;sec&#34; $userChoice] || [regexp -nocase &#34;pri&#34; $userChoice]} {
                set partition $userChoice
                break;
                puts &#34;&#34;
            } else {
                puts &#34;Error: Config selection must be either pri or sec&#34;
                continue
            }
        }
        set tCount 0
        set pl &#34;&#34;
        while {1} {
            set choice x460
            set legalList &#34;x460 x480 x430 Aspen Everest x870 NWI Olympic Mariner Pioneer&#34;
            set choice [lindex $legalList $tCount]
            puts &#34;Legal Values: $legalList&#34;
            puts -nonewline &#34;Type to download (x460=All summitX) \[$choice\]: &#34;;
            flush stdout;
            gets stdin userChoice;
            if {$userChoice==&#34;&#34;} {
               set userChoice $choice
            }
            if {[lsearch $legalList $userChoice] &lt; 0} {
                puts &#34;Error: Must be one of $legalList&#34;
                continue
            } elseif {[lsearch $pl $userChoice] &gt;= 0} {
                puts &#34;Error: $userChoice is already in the list \[$pl]. Try again&#34;
                continue
            } else {
                lappend pl $userChoice
                unset userChoice
                set choice no
                puts &#34;Current -platformList \&#34;$pl\&#34;&#34;
                puts -nonewline &#34;Would you like to download another platform type? (Yes/No)\[no\]: &#34;;
                flush stdout;
                gets stdin userChoice;
                if {$userChoice==&#34;&#34;} {
                   set userChoice $choice
                }
                if {[regexp -nocase &#34;y&#34; $userChoice] || [regexp -nocase &#34;n&#34; $userChoice]} {
                    if {[regexp -nocase &#34;y&#34; $userChoice]} {
                        incr tCount
                        continue
                    } else {
                        break
                    }
                   puts &#34;&#34;
                } else {
                   puts &#34;Error: Yes or No, y or n ... I am bailing&#34;
                   exit
                }
            }
        }
        foreach p $pl {
            while {1} {
                puts -nonewline &#34;Enter the $p image full path: &#34;;
                flush stdout;
                gets stdin userChoice;
                if {$userChoice==&#34;&#34;} {
                    puts &#34;Error: No value entered!&#34;
                    continue;
                }
                if {![regexp -nocase &#34;^\/&#34; $userChoice]} {
                    puts &#34;   Error: File $userChoice \
                                      should start from /&#34;
                    continue;
                } else {
                    if {![file isfile $userChoice]} {
                        puts &#34;   Error: $p File $userChoice is invalid file&#34;
                        continue
                    } else {
                        lappend pil $userChoice
                        break
                    }
                }
            }
        }

    }
    while {1} {
        set choice y
        puts &#34;\nQLoadImage.tcl -cfg $cfg -pl \&#34;$pl\&#34; -pil \&#34;$pil\&#34; -p $partition&#34;
        puts &#34;If any of this is wrong. Ctrl+C and start over!&#34;
        puts -nonewline &#34;Is it okay to execute the download (y/n)\[$choice\]: &#34;;
        flush stdout;
        gets stdin userChoice;
        if {$userChoice==&#34;&#34;} {
           set userChoice $choice
        }
        if {[regexp -nocase &#34;y&#34; $userChoice] || [regexp -nocase &#34;n&#34; $userChoice]} {
           set go 1
           break;
        } else {
           puts &#34;Error: Config selection must be either y or n&#34;
           continue
        }
    }
    while {1} {
        set choice y
        puts -nonewline &#34;Use the same values for all cfgs \
                   (A good idea if all plaform images are in place) (y/n)\[$choice\]: &#34;;
        flush stdout;
        gets stdin userChoice;
        if {$userChoice==&#34;&#34;} {
           set userChoice $choice
        }
        if {[regexp -nocase &#34;y&#34; $userChoice] || [regexp -nocase &#34;n&#34; $userChoice]} {
            if {[regexp -nocase &#34;y&#34; $userChoice]} {
                set useSame 1
            } else {
                set useSame 0
            }
           puts &#34;&#34;
           break;
        } else {
           puts &#34;Error: Config selection must be either y or n&#34;
           continue
        }
    }
    if {!$go} {
        continue;
    }
    cd ../main
    if {$cfg != &#34;null&#34;} {
        if {![regexp -nocase &#34;^cfg&#34; $cfg] } {
            puts &#34;matched start with cfg&#34;
            set cfgFile [format %s/%s cfg $cfg]
            set cfgFile [string trim $cfgFile];
        } else {
            puts &#34;matched catch all&#34;
            set cfgFile $cfg
        }
    }
    puts &#34;Using config file: ($cfgFile) [pwd]&#34;

    if {[file exists $cfgFile] == 0} {
        puts &#34;Cannot find config file: $cfgFile\n&#34;
        puts stderr &#34;Cannot find config file: $cfgFile&#34;
        return
    }

    puts &#34;************** ABOUT TO source $cfgFile *****************&#34;
    catch {source $cfgFile } reason
    if {$server == &#34;swdev&#34;} {
        <strong><a name="::result_debug_404">proc <a href="ql_multi.tcl-annot.html#::result_debug">::result_debug</a></a></strong><a name="::result_debug"></a> {cmd} {puts &#34;$cmd&#34;;}
        <strong><a name="::result_ok_405">proc <a href="ql_multi.tcl-annot.html#::result_ok">::result_ok</a></a></strong><a name="::result_ok"></a> {cmd} {puts &#34;$cmd&#34;;}
        <strong><a name="::result_error_406">proc <a href="ql_multi.tcl-annot.html#::result_error">::result_error</a></a></strong><a name="::result_error"></a> {cmd} {puts &#34;$cmd&#34;;}
        <strong><a name="::result_warning_407">proc <a href="ql_multi.tcl-annot.html#::result_warning">::result_warning</a></a></strong><a name="::result_warning"></a> {cmd} {puts &#34;$cmd&#34;;}
        set numDUT 1
        while { [info exists DUT${numDUT}_CONNECT] } {
            puts &#34;***** DUT${numDUT}_CONNECT***** &#34;
            puts &#34;***** numDUT=$numDUT ***** &#34;
            PowerOffDUT $numDUT &#34;on&#34;
            incr numDUT 1
        }
        incr numDUT -1
    }
    set mydir [pwd]
    <span class="comment-line">#puts &#34;launching QLoadImage for cfg $cfgFile in xterm&#34;</span>
    <span class="comment-line">#puts &#34;/Util/bash_ql $cfgFile $cfgFile \&#34;$pl\&#34; \&#34;$pil\&#34; $partition&#34;</span>
    puts &#34;$cfg&#34;
    if {[catch {exec /usr/bin/xterm -e \
             &#34;../Util/bash_ql $cfgFile $partition \&#34;$pl\&#34; \&#34;$pil\&#34; $cfgFile&#34; &amp;} reason]} {
         puts &#34;OOOPPPSSSSS&#34;
    }
    if {$useSame==0} {
        set pl &#34;&#34;;
        set pil &#34;&#34;;
        set partition &#34;&#34;;
    }
    after 2000
    puts &#34;\n\n&#34;
    cd $mydir
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:00.</cite>
</div>

</body>
</html>
