<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>regtoolsLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#regtoolsLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>regtoolsLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="regtoolsLib.tcl-annot.html">annotations</a> | <a href="regtoolsLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#</span>
<strong><a name="::NumberedMenu_2">proc <a href="regtoolsLib.tcl-annot.html#::NumberedMenu">::NumberedMenu</a></a></strong><a name="::NumberedMenu"></a> {args} {
    parse_args NumberedMenu $args {
        head             &#34;This is a Menu&#34;
        question1        &#34;What&#34;
        choices          &#34;This That TheOther&#34;
        chAppendList     &#34;null&#34;
        chPrependList    &#34;null&#34;
        menuWidth        100
        keyWidth         5
        headerPadChar    &#34;-&#34;
        barChar          &#34;-&#34;
        clearXterm       &#34;yes&#34;
        clearXtermInfo   &#34;&#34;
        all              &#34;no&#34;
        simple           &#34;no&#34;
    }

    if {$chAppendList != &#34;null&#34;} {
        set choices [concat $choices $chAppendList]
    }
    if {$chPrependList != &#34;null&#34;} {
        set choices [concat $chPrependList $choices]
    }
    if {[llength $choices] &lt; 1} {
        puts &#34;No elements passed into menu&#34;
        exit
    } else {
        <span class="comment-line">#puts &#34;Choices $choices&#34;</span>
    }
    set nWidth $keyWidth; <span class="comment-line"># width of number column</span>
    set longest 0; <span class="comment-line"># init longest value in</span>
    set i 0
    foreach cc $choices {
        set ln [string length $cc]
        if {$ln &gt; $longest} {
            set longest $ln; <span class="comment-line"># return the longest string length pased in</span>
        }
        incr i
    }
    set choiceCount $i
    set valWidth [expr $longest + 4]; <span class="comment-line"># leave some white space 3 spaces</span>
    set numValWidth [expr $nWidth + $valWidth];<span class="comment-line"># entire col width</span>
    set colCount [expr int(floor($menuWidth / $numValWidth))]; <span class="comment-line"># columns in menu 100 chars/ longest val</span>
    set choiceLen [llength $choices]
    if {$choiceLen &gt; $colCount} {
        set numRows [expr int(ceil($choiceLen/$colCount))];<span class="comment-line"># elements in array div by num rows</span>
    } else {
        set numRows 1
    }
    <span class="comment-line"># Create a bar the width of the menu</span>
    set bl 0
    set bar &#34;&#34;
    while {$bl &lt;= $menuWidth} {
        append bar &#34;$barChar&#34;
        incr bl
    }
    <span class="comment-line"># ------------------------------------------------</span>
    <span class="comment-line">#        make header</span>
    <span class="comment-line"># ------------------------------------------------</span>
    <span class="comment-line"># Header will look like -----  $head  -----</span>
    set headWidth [expr $menuWidth - 4]; <span class="comment-line"># leave for with spaces</span>
    set slen [string length $head];<span class="comment-line"># Length of the header passed in</span>
    set pad [expr $headWidth - $slen];<span class="comment-line"># buffer is line length of 90 - 4 spaces - header</span>
    set pad [expr int(floor($pad / 2))];<span class="comment-line"># div buffer by 2 to left and right side</span>

    set h 0 ;<span class="comment-line"># counter for pad string</span>
    set padStr &#34;&#34;
    while {$h&lt;=$pad} {
        append padStr $headerPadChar;<span class="comment-line"># create the pad string</span>
        incr h ;<span class="comment-line"># pad length</span>
    }
    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">#  Create the menu</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>

    <span class="comment-line"># init the menu counters</span>
    set lastSelection &#34;&#34;
    set listOut &#34;&#34;
    set listIn $choices
    <span class="comment-line"># make the menu</span>
    while {1} {
        <span class="comment-line"># print the header</span>
        puts &#34;\n\n&#34;
        <span class="comment-line"># ------------------------------------------------</span>
        <span class="comment-line"># Previous app important info to display</span>
        <span class="comment-line">#   this menu may clear stdout.  If you want</span>
        <span class="comment-line">#   to add important info to display at the top</span>
        <span class="comment-line">#   after stdout is cleared. Pass it in as a list</span>
        <span class="comment-line">#   $clearXtermInfo &#34;&#34;</span>
        if {[llength $clearXtermInfo] &gt; 0} {
            puts &#34;$bar&#34;
            foreach preI $clearXtermInfo {
                if {[llength $preI] == 2} {
                    set pic 0
                    foreach kv $preI {
                        set pikv($pic) $kv
                        incr pic
                    }
                    puts &#34;[format &#34;%-20s %-20s&#34; ${pikv(0)}: ${pikv(1)}]&#34;
                } else {
                    puts &#34;$preI&#34;
                }
            }
        }
        puts &#34;${padStr}  ${head}  $padStr&#34;

        set r 0;
        set x 0;
        while {$x &lt;= $choiceLen} {
            <span class="comment-line"># build the format colCount   nWidth valWidth</span>
            set ls &#34;&#34;
            for {set ccc 0} {$ccc&lt;$colCount} {incr ccc} {
                <span class="comment-line"># Loop formats the </span>
                if {[string trim [lindex $listIn $x]] != &#34;&#34;} {
                    set pDigit [expr $x+1]; <span class="comment-line"># print digit is 1 higher than key</span>
                    lappend ls [format &#34;%-${nWidth}s %-${valWidth}s&#34; ${pDigit}: [lindex $listIn $x]]
                } else {
                    set blk &#34;&#34;
                    lappend ls [format &#34;%-${nWidth}s %-${valWidth}s&#34; $blk $blk]
                }
                incr x
            }
            puts &#34;[join $ls &#34;&#34;]&#34;
        }

        if {[llength $listOut] &gt; 0} {
            set selLen [llength $listOut]
            puts &#34;\n\nYour Current Selections:&#34;
            set xx 0;
            set blk &#34; &#34;

            while {$xx &lt;= $selLen} {
                <span class="comment-line"># build the format colCount   nWidth valWidth</span>
                set ls &#34;&#34;
                for {set ccc 0} {$ccc&lt;$colCount} {incr ccc} {
                    <span class="comment-line"># Loop formats the </span>
                    if {[string trim [lindex $listOut $xx]] != &#34;&#34;} {
                        lappend ls [format &#34;%-${valWidth}s %-${nWidth}s&#34; [lindex $listOut $xx] $blk]
                    } else {
                        set blk &#34; &#34;
                        lappend ls [format &#34;%-${valWidth}s %-${nWidth}s&#34; $blk $blk]
                    }
                    incr xx
                }
                puts &#34;[join $ls &#34;&#34;]&#34;
            }
        }
        <span class="comment-line"># reset selection to array index</span>
        puts &#34; &#34;
        if {$simple == &#34;yes&#34;} {
            puts -nonewline &#34;$question1 : Default = 1: [lindex $listIn 0] :&#34;;
        } else {
            puts -nonewline &#34;$question1 : (a)ll, (u)ndo, (f)inished &lt;CR&gt;Default = 1: [lindex $listIn 0] :&#34;;
        }
        flush stdout;
        gets stdin userChoice;
        if {$userChoice==&#34;&#34;} {
            set userChoice 1
        }
        <span class="comment-line"># Simple, what's next, menu case</span>
        if {$simple == &#34;yes&#34;} {
            set inIndex [expr $userChoice - 1]
            return [lindex $listIn $inIndex]
        }
        <span class="comment-line"># ---------- Complex, build array menu -------------</span>
        if {[regexp -nocase &#34;^a&#34; $userChoice]} {
            set listOut $listIn
            break
        }
        if {[regexp -nocase &#34;^f&#34; $userChoice]} {
            break
        }
        if {[regexp -nocase &#34;^u&#34; $userChoice]} {
            if {$lastSelection == &#34;&#34;} {
                puts &#34;You can only undo the last selection&#34;
                after 3000
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                continue
            }
            lappend listIn $lastSelection
            set listOut [ldelete $listOut &#34;$lastSelection&#34;];
            set choiceLen [llength $listIn]
            if {$clearXterm == &#34;yes&#34;} {
                catch {exec clear &gt;@ stdout} ww
            }
            set lastSelection &#34;&#34;
            continue;
        }
        if {[regexp -nocase &#34;\[a-zA-Z]&#34; $userChoice]} {
            puts &#34;Must be a number&#34;;
            after 2000;
            if {$clearXterm == &#34;yes&#34;} {
                catch {exec clear &gt;@ stdout} ww
            }
            continue;
        }
        set userChoice [expr $userChoice - 1];<span class="comment-line"># reset to list key value</span>
        if {$userChoice &gt;= 0 &amp;&amp; $userChoice &lt; $x} {
            <span class="comment-line">#puts -nonewline &#34;You selected: [lindex $listIn $userChoice].\</span>
            <span class="comment-line">#                     &lt;R|Retry&gt;  &lt;S|Select 1&gt; and Contiue &lt;F|Finished&gt; &lt;A|Add&gt;\[A]:&#34;;</span>

            <span class="comment-line">#flush stdout;</span>
            <span class="comment-line">#gets stdin whatNext;</span>
            set whatNext a
            if {$whatNext == &#34;&#34;} {
                set whatNext &#34;a&#34;
            }
            if {[regexp -nocase &#34;^a&#34; $whatNext]} {
                lappend listOut [lindex $listIn $userChoice]
                set lastSelection &#34;[lindex $listIn $userChoice]&#34;
                set listIn [ldelete $listIn &#34;[lindex $listIn $userChoice]&#34;];
                set choiceLen [llength $listIn]
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                continue;
            } elseif {[regexp -nocase &#34;^r&#34; $whatNext]} {
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                continue;

            } elseif {[regexp -nocase &#34;^f&#34; $userChoice]} {
                set listOut $listIn
                break
            } elseif {[regexp -nocase &#34;^s&#34; $whatNext]} {
                if {[llength $listOut] &lt;= 0} {
                    set listOut &#34;[lindex $listIn $userChoice]&#34;
                }
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                break;
            } else {
                puts &#34;You did not enter a legal value. A to Add, R to Retry, S for select and continue&#34;
                after 2000
                continue;
            }
        } else {
            puts &#34;Error: You must select a number 1 through [expr $x - 1]\n&#34;;
            continue;
        }

    }
    puts &#34;\nRETURN:\n[join $listOut &#34;\n&#34;]\n&#34;
    return $listOut;
}

<span class="comment-line">#</span>
<strong><a name="::runningBeds_253">proc <a href="regtoolsLib.tcl-annot.html#::runningBeds">::runningBeds</a></a></strong><a name="::runningBeds"></a> {} {
   global DEVREG
   set psOut [catch {exec ps -eafwww | egrep -e &#34; -cfg &#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set unlockTestbeds &#34;&#34;
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         if {[lsearch $unlockTestbeds $fileTail]==-1} {
            lappend unlockTestbeds $fileTail
         }
      }
      return $unlockTestbeds
   } else {
      return &#34;&#34;
   }
}
<strong><a name="::maintestbeds_278">proc <a href="regtoolsLib.tcl-annot.html#::maintestbeds">::maintestbeds</a></a></strong><a name="::maintestbeds"></a> {} {
   global DEVREG
   set runningCfgs &#34;&#34;
   set psOut [catch {exec ps -eafwww | egrep -e &#34;main\.tcl.*\.cfg&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set loadingtestbeds &#34;&#34;
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         lappend runningCfgs $fileTail
      }
      return $runningCfgs
   }
}
<strong><a name="::swsharedbeds_300">proc <a href="regtoolsLib.tcl-annot.html#::swsharedbeds">::swsharedbeds</a></a></strong><a name="::swsharedbeds"></a> {incfgs} {
    global DEVREG

    set mainL [<a name="::maintestbeds(1)"><a href="./regtoolsLib.tcl.html#::maintestbeds_278">::maintestbeds</a></a>];
    set ccL [<a name="::cctestbeds(1)"><a href="./regtoolsLib.tcl.html#::cctestbeds_380">::cctestbeds</a></a>];
    set qlL [<a name="::qltestbeds(1)"><a href="./regtoolsLib.tcl.html#::qltestbeds_402">::qltestbeds</a></a>];
    set vtL [<a name="::vttestbeds(1)"><a href="./regtoolsLib.tcl.html#::vttestbeds_424">::vttestbeds</a></a>];
    set lcL [<a name="::lctestbeds(1)"><a href="./regtoolsLib.tcl.html#::lctestbeds_446">::lctestbeds</a></a>];

    set inUseList [concat $mainL $ccL $qlL $vtL $lcL]   

    <span class="comment-line">#puts &#34;\nmainL $mainL\n&#34;</span>
    <span class="comment-line">#puts &#34;\nccL $ccL&#34;</span>
    <span class="comment-line">#puts &#34;\nqlL $qlL&#34;</span>
    <span class="comment-line">#puts &#34;\nvtL $vtL&#34;</span>
    <span class="comment-line">#puts &#34;\nlcL $lcL&#34;</span>
    <span class="comment-line">#puts &#34;\ninuse: $inUseList \n&#34;</span>
    set runningCfgs &#34;&#34;
    set sharedCfgs &#34;&#34;
    set preLines &#34;&#34;
    set psOut [catch {exec ps -eafwww | egrep -e &#34;regSer.*share&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
    if {$psOut==0} {
        set loadingtestbeds &#34;&#34;
        set fd_tmp [FileOpen Tmp/ps[pid] r]
        set psLines &#34;&#34;
        while {[gets $fd_tmp psLine]!=-1} {
            lappend psLines $psLine
        }
        close $fd_tmp
        file delete Tmp/ps[pid]
        foreach iCfg $incfgs {
            foreach psLine $psLines {
                set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
                set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
                set fileTail [file tail $cfgFileName]
                set cCfg $fileTail
                set shIndex [lsearch $psLine &#34;-partnerList&#34;]
                set shCfg [lindex $psLine [expr $shIndex+1]]
                set fileTail [file tail $shCfg]
                set sCfg $fileTail
                if {$iCfg == $cCfg &amp;&amp; [lsearch $runningCfgs $iCfg] &lt; 0 &amp;&amp; \
                    [lsearch $runningCfgs $sCfg] &lt; 0} {
                    <span class="comment-line">#puts &#34;Shared $iCfg sCfg $sCfg&#34;</span>
                    if {[lsearch $inUseList $iCfg] &gt;= 0 || [lsearch $inUseList $sCfg] &gt;= 0} {
                        puts &#34;Skip $iCfg - Share $sCfg is probably running&#34;
                        lappend sharedCfgs $sCfg
                        continue
                    } else {
                        lappend runningCfgs $iCfg
                        lappend sharedCfgs $sCfg
                    }
                } else {
                    if {$iCfg == $cCfg &amp;&amp; [lsearch $runningCfgs $sCfg] &gt;= 0} {
                        puts &#34;Skip $iCfg shared $sCfg is added already&#34;
                    }
                    continue
                }
            }
        }
        foreach iCfg $incfgs {
            if {[lsearch $inUseList $iCfg] &gt;= 0} {
                continue
            }
            if {[lsearch $runningCfgs $iCfg] &lt; 0 &amp;&amp; [lsearch $sharedCfgs $iCfg] &lt; 0} {
                <span class="comment-line">#puts &#34;Add nonShared $iCfg&#34;</span>
                lappend runningCfgs $iCfg
            }
        }
        return $runningCfgs
    } else {
        foreach iCfg $incfgs {
            if {[lsearch $inUseList $iCfg] &gt;= 0} {
                continue
            } else {
                lappend runningCfgs $iCfg
            }
        }
        return $runningCfgs
    }
}
<strong><a name="::cctestbeds_380">proc <a href="regtoolsLib.tcl-annot.html#::cctestbeds">::cctestbeds</a></a></strong><a name="::cctestbeds"></a> {} {
   global DEVREG
   set runningCfgs &#34;&#34;
   set psOut [catch {exec ps -eafwww | egrep -e &#34;checkConn.*\.cfg&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set loadingtestbeds &#34;&#34;
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         lappend runningCfgs $fileTail
      }
      return $runningCfgs
   }
}
<strong><a name="::qltestbeds_402">proc <a href="regtoolsLib.tcl-annot.html#::qltestbeds">::qltestbeds</a></a></strong><a name="::qltestbeds"></a> {} {
   global DEVREG
   set runningCfgs &#34;&#34;
   set psOut [catch {exec ps -eafwww | egrep -e &#34;QLoad.*\.cfg&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set loadingtestbeds &#34;&#34;
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         lappend runningCfgs $fileTail
      }
      return $runningCfgs
   }
}
<strong><a name="::vttestbeds_424">proc <a href="regtoolsLib.tcl-annot.html#::vttestbeds">::vttestbeds</a></a></strong><a name="::vttestbeds"></a> {} {
   global DEVREG
   set runningCfgs &#34;&#34;
   set psOut [catch {exec ps -eafwww | egrep -e &#34;verifyTest.*\.cfg&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set loadingtestbeds &#34;&#34;
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;-cfg&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         lappend runningCfgs $fileTail
      }
      return $runningCfgs
   }
}
<strong><a name="::lctestbeds_446">proc <a href="regtoolsLib.tcl-annot.html#::lctestbeds">::lctestbeds</a></a></strong><a name="::lctestbeds"></a> {} {
   global DEVREG
   set runningCfgs &#34;&#34;
   set psOut [catch {exec ps -eafwww | egrep -e &#34;bash_lc.*\cfg&#34; | grep -v grep &gt;&amp; Tmp/ps[pid]} psLines]
   if {$psOut==0} {
      set lctestbeds &#34;&#34;
      set fd_tmp [FileOpen Tmp/ps[pid] r]
      set psLines &#34;&#34;
      while {[gets $fd_tmp psLine]!=-1} {
         lappend psLines $psLine
      }
      close $fd_tmp
      file delete Tmp/ps[pid]
      foreach psLine $psLines {
         set cfgIndex [lsearch $psLine &#34;../Util/bash_lc&#34;]
         set cfgFileName [lindex $psLine [expr $cfgIndex+1]]
         set fileTail [file tail $cfgFileName]
         set bob [regexp {(.*\.cfg).*} $fileTail everything lccfg ]
         lappend runningCfgs $lccfg
      }
      return $runningCfgs
   }
}
<strong><a name="::getlocked_469">proc <a href="regtoolsLib.tcl-annot.html#::getlocked">::getlocked</a></a></strong><a name="::getlocked"></a> {} {
    global DEVREG

    if {[set fd_in [FileOpen $DEVREG(server,lockFile) r]]==-1} {
        return $fd_in
    }
    set lList &#34;&#34;
    while {[gets $fd_in line]!=-1} {
        set line [string trimleft $line &#34;!&#34;]
        lappend lList $line
    }
    funlock $fd_in
    close $fd_in
    return $lList
}
<strong><a name="::getUserLocks_484">proc <a href="regtoolsLib.tcl-annot.html#::getUserLocks">::getUserLocks</a></a></strong><a name="::getUserLocks"></a> {} {
    global DEVREG
    set pList &#34;&#34;
    set queues [glob -nocomplain -- $DEVREG(server,imagesRunningDir)/*]
    ;<span class="comment-line"># Look for any qId that is actively using queued platform</span>
    foreach qIdPath $queues {
        set catchVal [catch {exec egrep -e &#34;lockFile:&#34; $qIdPath/info} userInfo]
        if {! $catchVal} {
            regexp {lockFile:\ *([A-Za-z0-9_\-]+\.cfg)\ *$} $userInfo ignore cCfg
            lappend pList $cCfg
        }
    }
    return &#34;$pList&#34;
}

<strong><a name="::get_test_beds_499">proc <a href="regtoolsLib.tcl-annot.html#::get_test_beds">::get_test_beds</a></a></strong><a name="::get_test_beds"></a> {release {skipShared &#34;Yes&#34;}} {
    global DEVREG

    catch {mysqlconnect -host 10.69.6.211 -user regression_user -password extreme \
                        -db autoweb_db_7} mysql_handler

    set shareCfgFiles [mysqlsel $mysql_handler \
        &#34;SELECT platform_id,platform_share_list,platform_cfg_file_name \
        FROM platform_table WHERE start_release &lt;= '$release' \
        AND end_release &gt;= '$release'  AND status = 'Active' AND location = 'RTP' \
        ORDER By number_nodes ASC&#34; -list]

    set shareskiplist &#34;&#34;
    foreach share $shareCfgFiles {
        set myPlatId [string trim [lindex $share 0]]
        set platShareList [string trim [lindex $share 1]]
        set platcfg [string trim [lindex $share 2]]
        if {$platShareList != &#34;&#34;} {
            if {[lsearch $shareskiplist $platShareList] &lt; 0 &amp;&amp; \
                   [lsearch $shareskiplist $platcfg] &lt; 0} {
                lappend shareskiplist $platcfg
            }
            set platIdShare($myPlatId) $platShareList
            set platIdByShareName($platShareList) $myPlatId;
        }
    }
    <span class="comment-line"># Go through all test beds in the release passed in.</span>
    set allCfgFiles [mysqlsel $mysql_handler &#34;SELECT platform_id,platform_cfg_file_name \
                FROM platform_table WHERE start_release &lt;= '$release' AND \
                status = 'Active' AND location = 'RTP' \
                AND end_release &gt;= '$release' ORDER By number_nodes ASC&#34; -list]

    set pShareList &#34;&#34;
    foreach cfg $allCfgFiles {
        set pId  [lindex $cfg 0]
        set pCfg [lindex $cfg 1]
        if {[lsearch $shareskiplist $pCfg] &gt;= 0 &amp;&amp; $skipShared == &#34;Yes&#34;} {
            puts &#34;Skip share $cfg&#34;
            continue;
        }
        set cfgShareArray($pId) &#34;&#34;
        if {[info exists platIdShare($pId)]} {
            set myS $platIdShare($pId);
            set mySId $platIdByShareName($myS)
            set cfgShareArray($pId) $mySId
        }
        <span class="comment-line"># Check to see which configs have a pause set to no which equals running fine</span>
        set statusPId [mysqlsel $mysql_handler &#34;SELECT platform_id \
            FROM current_run_table WHERE (reserved = 'no' || reserved = 'paused' ) \
            AND (platform_id = '$pId' OR platform_id = '$cfgShareArray($pId)')&#34; -flatlist]
        if {0 &amp;&amp; [info exists statusPId] &amp;&amp; $statusPId &gt; 0} {
            if {$cfgNameShareArray($pId) != &#34;NULL&#34;} {
                <span class="comment-line">#puts &#34;$pCfg OR $cfgNameShareArray($pId) is Running&#34;;</span>
            } else {
                <span class="comment-line">#puts &#34;$pCfg is Running&#34;;</span>
            }
        } else {
            <span class="comment-line">#puts &#34;Found $pCfg&#34;</span>
            lappend cfgList $pCfg
        }
        unset statusPId
    }
    return $cfgList
}
<strong><a name="::get_filtered_test_beds_563">proc <a href="regtoolsLib.tcl-annot.html#::get_filtered_test_beds">::get_filtered_test_beds</a></a></strong><a name="::get_filtered_test_beds"></a> {cfgList {filter &#34;null&#34;}} {

    if {$filter == &#34;null&#34;} {
        return $cfglist;
    }

    catch {mysqlconnect -host 10.69.6.211 -user regression_user -password extreme \
                        -db autoweb_db_7} mysql_handler

    <span class="comment-line"># Go through all test beds in the release passed in.</span>
    set allCfgFiles [mysqlsel $mysql_handler &#34;SELECT platform_id,platform_cfg_file_name,\
                platform_owner FROM platform_table WHERE \
                status = 'Active' AND location = 'RTP' ORDER By number_nodes ASC&#34; -list]

    set myCfgs &#34;&#34;
    set mc 0
    foreach cfg $allCfgFiles {
        set pId    [lindex $cfg 0]
        set pCfg   [lindex $cfg 1]
        set pOwner [lindex $cfg 2]

        if {[regexp -nocase &#34;$filter&#34; $pCfg] || [regexp -nocase &#34;$filter&#34; &#34;$pOwner&#34;]} {
            if {[lsearch $cfgList $pCfg] &gt;=0} {
                lappend myCfgs $pCfg;
                incr mc;
            }
        }
    }
    if {$mc &gt; 0} {
        return $myCfgs;
    } else {
        return $cfgList;
        puts &#34;\nThe filter did not match any test beds. All test beds will be used.\n&#34;;
    }

}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:00.</cite>
</div>

</body>
</html>
