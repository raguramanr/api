<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>regServer.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#regServer.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>regServer.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="regServer.tcl-annot.html">annotations</a> | <a href="regServer.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

global MAIN IMAGEFAMILYPLATFORMS IMAGEFAMILYSYSTYPES
source ../Lib/parse_args.tcl
source ../Lib/mainLib.tcl
source ../Lib/login.tcl
source ../Lib/SendSwCmd.tcl
source ../Lib/mysqlLib.tcl
source ../Lib/robot.tcl
source ../Autoweb/cgi-bin/cgiScripts/modulesToBeSummarized.cfg
source ./runReg.cfg
source ./iTest.cfg
source ../main/runReg.cfg
source ../main/cfg/robot.cfg
source ../main/cfg/common.cfg
<span class="comment-line"># Logic to enable auto re-sourcing of important files if they are changed.</span>
set mainRunregTime [file mtime ../main/runReg.cfg]
set runregTime [file mtime runReg.cfg]
set tgen ixia

if {$tcl_platform(platform) == &#34;windows&#34;} {
    load &#34;expect52.dll&#34;
} else {
    load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
}
set MAIN(SWDEVXTERM) &#34;&#34;
<strong><a name="::::print_usage_27">proc <a href="regServer.tcl-annot.html#::::print_usage">::::print_usage</a></a></strong> {} {
   global DEVREG
   global platformsSupported
   global regressionTypes
   puts &#34;\r&#34;
   puts {Usage: regServer.tcl -platformType &lt;type&gt; -regressionType &lt;regType&gt; -cfg &lt;config file&gt; [-partnerList &lt;partner cfgs&gt;] [-shareId &lt;integer&gt;] [-help]}
   puts &#34;   &lt;platformType&gt;: $DEVREG(server,platformsSupported)&#34;
   puts &#34;   &lt;regressionType&gt;: $DEVREG(server,regressionTypes)&#34;
   puts &#34;   &lt;partnerList&gt;:  A list of other test beds that share this same hardware&#34;
   puts &#34;   &lt;shareId&gt;:  An integer common to all test beds in a shared queue&#34;
   puts {   &lt;cfg&gt;: Path of the config file name (e.g. short/ptgm4x6.2.2b4.cfg)} 
   puts {   \[help\]: Prints the help screen of this program)} 
   puts &#34;\r&#34;
}

<span class="comment-line"># ------   Local Variables   -------</span>
set userBreakInput &#34;&#34;

<a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> regServer $argv {
      cfg &#34;null&#34;
      platformType &#34;null&#34;
      regressionType &#34;null&#34;
      partnerList &#34;null&#34;
      shareId &#34;null&#34;
      multiple &#34;null&#34;
      harness  &#34;all&#34;
      help &#34;null&#34;
}

<span class="comment-line"># Check if &#34;-help&#34; asked, print_usage in that case</span>
if {$help!=&#34;null&#34;} {
   <a name="::::print_usage(1)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
   return 1
}
if {[regexp -nocase &#34;robot&#34; $harness]} {
    set harn robot
    set MAIN(harness) &#34;robot&#34;
    set DEVREG(server,harness) &#34;robot&#34;
    set MAIN(cfg) $cfg
    puts &#34;sourcing the robot\n$MAIN(cfg)&#34;
    set runRegPlatformCode [<a name="::get_robot_yaml_info(1)"><a href="./robot.tcl.html#::get_robot_yaml_info_313">::get_robot_yaml_info</a></a>]
    set cfg $DEVREG(server,robotTestPath)/$DEVREG(server,CFG_PATH)/$MAIN(cfg)
    puts &#34;  big cfg $cfg&#34;
} else {
    set harn $harness
    set MAIN(harness) $harn
}
<span class="comment-line"># checking command parameters</span>
if {$argc&lt;6} {
    puts &#34;\n\nNot enough parameters&#34;
    <a name="::::print_usage(2)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
    puts stderr &#34;\n\nNot enough parameters&#34;
    return
}
<span class="comment-line"># verify the directory structure is in place</span>
<a name="::VerifyRegserverFileSystem(1)"><a href="./queueLib.tcl.html#::VerifyRegserverFileSystem_4162">::VerifyRegserverFileSystem</a></a>
if {[<a name="::VerifyPlatformType(1)"><a href="./queueLib.tcl.html#::VerifyPlatformType_36">::VerifyPlatformType</a></a> $platformType]==-1} {
    puts &#34;\n\nError: Invalid platformType $platformType&#34;
    <a name="::::print_usage(3)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
    return -1
}
if {![file exists $cfg]} {
    puts &#34;\n\nError: file $cfg does not exist&#34;
    <a name="::::print_usage(4)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
    return -1
}
append MAIN(SWDEVXTERM) &#34;$platformType &#34;
if {$multiple != &#34;null&#34;} {
    append MAIN(SWDEVXTERM) &#34;LB &#34;
}
if {$partnerList != &#34;null&#34;} {
    <span class="comment-line"># ---------------------------------------------------------------</span>
    <span class="comment-line"># This section defines the sharing method.  Each test bed is</span>
    <span class="comment-line"># assigned a list of unique minutes. (1 3 5 7 9 ....59)</span>
    <span class="comment-line"># (0 2 4 6 .... 58).  The test bed is only allowed to check</span>
    <span class="comment-line"># for a module to run during their specified window.</span>
    <span class="comment-line"># ---------------------------------------------------------------</span>
    set cleanPartnerList &#34;&#34;;<span class="comment-line"># remove the paths so just file name list</span>
    set myPartnerList &#34;&#34;;<span class="comment-line"># a list of my partner clean cfg files</span>
    lappend cleanPartnerList [file tail $cfg];<span class="comment-line">#</span>
    set p 1;
    foreach pcfg $partnerList {
        if {![file exists $pcfg]} {
           puts &#34;Error: partner cfg file $pcfg does not exist&#34;
           <a name="::::print_usage(5)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
           return -1
        }
        lappend cleanPartnerList [file tail $pcfg]
        lappend myPartnerList [file tail $pcfg]
        append MAIN(SWDEVXTERM) &#34;Share [file tail $pcfg] &#34;
        incr p
    }
    set numPartners [expr [llength $partnerList] +1]
    set oCfgList [lsort $cleanPartnerList]
    set minVals 0
    for {set u 0} {$u&lt;60} {incr u} {
        foreach partCfg $oCfgList {
            if {$minVals == 60} {
                break;
            }
            lappend minuteList($partCfg) $minVals
            incr minVals
        }
    }
    <span class="comment-line">#puts &#34;!!!!!\n!!!!!\n!!!!!\nSorted: $oCfgList\nMinutes: $myMin\nDate: $date\n!!!!!\n!!!!!\n!!!!!&#34;</span>
}
if {![file isdirectory Report]} {
    file mkdir Report
}
if {![file isdirectory Result]} {
    file mkdir Result
}
if {![file isdirectory Tmp]} {
    file mkdir Tmp
}
if {![file isdirectory /tmp/Tmp]} {
    file mkdir /tmp/Tmp
}
    if {![file isdirectory Log]} {
    file mkdir Log
}
set skipMysqlAutomate 0
set harn all
set cfgFileTail [file tail $cfg]
set MAIN(skipMysqlAutomate) 0
set MAIN(tmpSpawnIds)       &#34;&#34;;<span class="comment-line"># powercycler spawnids that should be closed on each loop if still open</span>
set MAIN(cfg) $cfgFileTail
set MAIN(feature_directory) &#34;Waiting&#34;
set mainRet &#34;&#34;
<span class="comment-line"># ----------------------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># ----------------------------------------------------------------------------------------</span>
set MAIN(TrackInit) [<a name="::OpenTrackingPort(1)"><a href="./resource_track.tcl.html#::OpenTrackingPort_7">::OpenTrackingPort</a></a> -cfg &#34;$MAIN(cfg)&#34; -script_name &#34;regServer&#34; -type &#34;daemon&#34;]

<span class="comment-line"># ------------- Source the TCL cfg file ----------------</span>
if {$harness != &#34;robot&#34;} {
    source ../main/cfg/$cfgFileTail
}
set fd_res [<a name="::open_result_file(1)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;$cfgFileTail&#34;]
result_h1 &#34;Starting regServer $cfgFileTail&#34;

<span class="comment-line"># -----------------------------------------------------------------------------------------</span>
<span class="comment-line"># mysql server cfg for posting</span>
<span class="comment-line"># -----------------------------------------------------------------------------------------</span>
<span class="comment-line">#source ../Lib/mysqlLib.tcl</span>
if {[info exists DEVREG(mysql,UseDb)] &amp;&amp; $DEVREG(mysql,UseDb)} {
    global mysql_handler
    <span class="comment-line"># connect to local sync database -- queuries are stored on the sync database while updating</span>
    <span class="comment-line">#                                   the central db.  If central is successful that sync query</span>
    <span class="comment-line">#                                   is deleted.  Else it is saved and purged once link is back</span>
    <span class="comment-line">#                                   up.</span>
    puts &#34;-----\nConnecting to SYNC database $DEVREG(mysql,localdb) at $DEVREG(mysql,localbackup)\n-----&#34;
    set localstatus [<a name="::conn_to_db(1)"><a href="./mysqlLib.tcl.html#::conn_to_db_8">::conn_to_db</a></a> $DEVREG(mysql,localbackup) $DEVREG(mysql,localdb)]
    set DEVREG(mysql,localhandler) $mysql_handler
    puts &#34;-----\nDatabase $DEVREG(mysql,localdb) at $DEVREG(mysql,localbackup) - \
                status $localstatus handler $DEVREG(mysql,localhandler)\n-----&#34;
    catch {mysqlclose $DEVREG(mysql,localhandler)} myreason

    puts &#34;-----\nConnecting to CENTRAL database $DEVREG(mysql,centraldb) at $DEVREG(mysql,centralserver)\n-----&#34;
    set centralstatus [<a name="::conn_to_db(2)"><a href="./mysqlLib.tcl.html#::conn_to_db_8">::conn_to_db</a></a> $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb)]
    set DEVREG(mysql,centralhandler) $mysql_handler
    puts &#34;-----\nDatabase $DEVREG(mysql,centraldb) at $DEVREG(mysql,centralserver) - \
                status $centralstatus handler $DEVREG(mysql,centralhandler)\n-----&#34;
    catch {mysqlclose $DEVREG(mysql,centralhandler)} myreason

}
<span class="comment-line"># --------------------------------------------------------------------------</span>
<span class="comment-line"># Get platformcode from main/runReg.cfg - get_platform_code </span>
<span class="comment-line">#                           uses a global so args are dummy</span>
<span class="comment-line">#   NOTE: source ../main/runReg.cfg from above set global regplatform</span>
<span class="comment-line">#         global set for cfg</span>
<span class="comment-line">#         global set for cfgFileTail </span>
<span class="comment-line">#   The platform will be returned.</span>
<span class="comment-line"># --------------------------------------------------------------------------</span>
if {$DEVREG(server,harness) == &#34;robot&#34;} {
    set runRegPlatformCode [<a name="::get_robot_yaml_info(2)"><a href="./robot.tcl.html#::get_robot_yaml_info_313">::get_robot_yaml_info</a></a>]
} else {
    set runRegPlatformCode [<a name="::get_platform_code(1)"><a href="./mysqlLib.tcl.html#::get_platform_code_1748">::get_platform_code</a></a> functional FROM_regServer FROM_regServer FROM_regServer]
}
set MAIN(runRegPlatform) $runRegPlatformCode
<span class="comment-line"># Check for lockfile entry for myself i.e. $cfg</span>
<span class="comment-line"># Check for high priority queue image</span>
<span class="comment-line"># check if my setup is requested to run a module i.e. bd-10808/pc</span>
<span class="comment-line"># if yes, take a module and run the standard/routing regression on it.</span>
<span class="comment-line"># else go into loop again</span>
set MAIN(queueId)    -1
set MAIN(oldQueueId) -1
set MAIN(oldResD)    -1
set MAIN(resD)        1
set MAIN(updRetValue) 1
set MAIN(pollTime)    5000
set updRetValue 1
set alreadyOnConsole 0
set DEVREG(active,con1pid) 0
set DEVREG(active,ALOCK) 0
set DEVREG(active,USERLOCK) 0
set DEVREG(active,SHARERUNNNG) 0
set DEVREG(active,STILLWAITING) 0
set pollTime 5000
set poweredOff 1
<a name="::UpdateTrackDB(1)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; -teefile &#34;&#34; -testcase &#34;&#34;
while {1} {
    set MAIN(feature_directory) &#34;Waiting&#34;
    <a name="::SetTerminalTitle(1)"><a href="./queueLib.tcl.html#::SetTerminalTitle_5146">::SetTerminalTitle</a></a>


    <span class="comment-line"># Put logic in place to re-source important files if they change</span>


    if {[file mtime ../main/runReg.cfg] != $mainRunregTime} {
        puts &#34;!!!!!\n!!!!!\nSourcing ../main/runReg.cfg because it changed\n!!!!!\n!!!!!&#34;
        set tmpLS $DEVREG(mysql,localstatus)
        set tmpLH $DEVREG(mysql,localhandler)
        set tmpCS $DEVREG(mysql,centralstatus)
        set tmpCH $DEVREG(mysql,centralhandler)
        set rc [catch {source ../main/runReg.cfg} res]
        if {$rc} {puts &#34;Error sourcing runReg.cfg $res&#34;;}
        set mainRunregTime [file mtime ../main/runReg.cfg]
        set DEVREG(mysql,localstatus)    $tmpLS
        set DEVREG(mysql,localhandler)   $tmpLH
        set DEVREG(mysql,centralstatus)  $tmpCS
        set DEVREG(mysql,centralhandler) $tmpCH
    }
    if {[file mtime runReg.cfg] != $runregTime} {
        puts &#34;!!!!!\n!!!!!\nSourcing runReg.cfg because it changed\n!!!!!\n!!!!!&#34;
        set tmpLS $DEVREG(mysql,localstatus)
        set tmpLH $DEVREG(mysql,localhandler)
        set tmpCS $DEVREG(mysql,centralstatus)
        set tmpCH $DEVREG(mysql,centralhandler)
        set rc [catch {source ./runReg.cfg} res]
        if {$rc} {puts &#34;Error sourcing runReg.cfg $res&#34;;}
        set runregTime [file mtime runReg.cfg]
        set DEVREG(mysql,localstatus)    $tmpLS
        set DEVREG(mysql,localhandler)   $tmpLH
        set DEVREG(mysql,centralstatus)  $tmpCS
        set DEVREG(mysql,centralhandler) $tmpCH
    }

    flush $fd_res
    <span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># First check to see if I am ADMIN locked for maintenance</span>
    <span class="comment-line"># ----------------------------------------------------------------</span>
    if {[<a name="::locked(1)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $cfgFileTail]==1} {
        set alreadyOnConsole 0
        if {[<a name="::autolocked(1)"><a href="./queueLib.tcl.html#::autolocked_178">::autolocked</a></a> $cfgFileTail]==1} {
            if {$DEVREG(active,ALOCK) == 0} {
                <a name="::UpdateTrackDB(2)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: AutoLock&#34; -status &#34;red&#34; -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
                incr DEVREG(active,ALOCK)
            }
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            <span class="comment-line"># If the test bed gets autolocked, we must assume that it is possible a new</span>
            <span class="comment-line">#    image was loaded on the box.</span>
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            puts &#34;------\nDue to AUTOLOCK, software status is unknown -- user software download will repeat\n------&#34;;
            set MAIN(oldQueueId) &#34;&#34;
            puts &#34;$cfgFileTail: HAS BEEN AUTOLOCKED!&#34;
        } else {
            if {$DEVREG(active,ALOCK) == 0} {
                <a name="::UpdateTrackDB(3)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: AdminLock&#34; -status &#34;royalblue&#34; -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
                incr DEVREG(active,ALOCK)
            }
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            <span class="comment-line"># If the test bed gets admin locked, we must assume that it is possible a new</span>
            <span class="comment-line">#    image was loaded on the box.</span>
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            puts &#34;------\nDue to Admin LOCK, software status is unknown -- user software download will repeat\n------&#34;;
            set MAIN(oldQueueId) &#34;&#34;
            puts &#34;$cfgFileTail: Currently locked&#34;
        }
        flush stdout
        <span class="comment-line"># -----------------------------------------------------------------</span>
        <span class="comment-line">#  Update a file with a current time stamp</span>
        <span class="comment-line"># -----------------------------------------------------------------</span>
        <a name="::UpdateIdle(1)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
        after $pollTime
        continue
    }
    if {$DEVREG(active,ALOCK)&gt;0} {
        <a name="::UpdateTrackDB(4)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
        set DEVREG(active,ALOCK) 0
    }
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    <span class="comment-line"># Check to see if this platform is shared AND if the partner is running</span>
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    if {$partnerList != &#34;null&#34;} {
        set myMin [string trimleft [clock format [clock seconds] -format &#34;%M&#34;] 0]
<span class="comment-line">#        set partnerStat [partnerInUse $partnerList]</span>
         set partnerStat 0
        <span class="comment-line"># -----------------------------------------------------------------</span>
        <span class="comment-line"># Alter code to not lock consoles for shared test beds</span>
        <span class="comment-line"># -----------------------------------------------------------------</span>
        if {[lsearch -exact  $minuteList($cfgFileTail) $myMin]== -1 } {
            puts &#34;$cfgFileTail is waiting for polling window.&#34;
            flush stdout
            <span class="comment-line"># ----------------------------------------------------------------</span>
            <span class="comment-line">#  Update a file with a current time stamp</span>
            <span class="comment-line"># ----------------------------------------------------------------</span>
            <a name="::UpdateIdle(2)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            after $pollTime
            continue;
            <span class="comment-line">#$partnerStat &gt;= 0</span>
        } elseif {![<a name="::acquire_lock(1)"><a href="./autolock.tcl.html#::acquire_lock_109">::acquire_lock</a></a> $shareId]} {
            puts &#34;$cfgFileTail could not lock. A shared queue is running&#34;
            if {$DEVREG(active,SHARERUNNNG) == 0} {
                <a name="::UpdateTrackDB(5)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: ShareRunning $myPartnerList&#34; -status &#34;green&#34; \
                    -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
                incr DEVREG(active,SHARERUNNNG)
            }
            set MAIN(oldQueueId) &#34;&#34;
            flush stdout
            <span class="comment-line"># ----------------------------------------------------------------</span>
            <span class="comment-line">#  Update a file with a current time stamp</span>
            <span class="comment-line"># ----------------------------------------------------------------</span>
            <a name="::UpdateIdle(3)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            after $pollTime
            continue;
        } elseif {0 || [lsearch -exact  $minuteList($cfgFileTail) $myMin]== -1 } {
            puts &#34;$cfgFileTail is waiting for polling window.&#34;
            flush stdout
            <span class="comment-line"># ----------------------------------------------------------------</span>
            <span class="comment-line">#  Update a file with a current time stamp</span>
            <span class="comment-line"># ----------------------------------------------------------------</span>
            <a name="::UpdateIdle(4)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            after $pollTime
            continue;
        } else {
            <span class="comment-line"># ----------------------------------------------------------------</span>
            foreach mycfg $partnerList {
                set mycfgTail [file tail $mycfg]
                puts &#34;Not running $mycfgTail&#34;
                flush stdout
            }
            if {$DEVREG(active,SHARERUNNNG)&gt;0} {
                <a name="::UpdateTrackDB(6)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
                set DEVREG(active,SHARERUNNNG) 0
            }
        }
    }
    <span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># Add code to keep multiple same type beds from servicing queue</span>
    <span class="comment-line">#    at the same time</span>
    <span class="comment-line"># ----------------------------------------------------------------</span>
    if {$partnerList == &#34;null&#34; &amp;&amp; $multiple != &#34;null&#34;} {
        set pollTime 3000
        set currSecond [clock format [clock seconds] -format &#34;%S&#34;]
        if {[regexp -nocase {.*ight.*\.cfg|.*[3-4]\.cfg} $cfgFileTail] &amp;&amp; \
                  ($currSecond &lt; 40)} {
            puts &#34;$cfgFileTail - window = 40&lt;-&gt;59 : $currSecond&#34;
            <a name="::UpdateIdle(5)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            after $pollTime
            continue;
        } elseif {[regexp -nocase {.*[2]\.cfg} $cfgFileTail] &amp;&amp; $currSecond &gt; 20} {
            puts &#34;$cfgFileTail - window = 1&lt;-&gt;20 : $currSecond&#34;
            <a name="::UpdateIdle(6)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            after $pollTime
            continue;
        } elseif {[regexp -nocase {[a-z_\-]\.cfg|.*1\.cfg} $cfgFileTail] &amp;&amp; \
                  ($currSecond &lt; 21 || $currSecond &gt; 40) &amp;&amp; \
                 ![regexp -nocase {.*ight.*\.cfg} $cfgFileTail]} {
            puts &#34;$cfgFileTail - window = 21&lt;-&gt;40 : $currSecond&#34;
            <a name="::UpdateIdle(7)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            after $pollTime
            continue;
        }
    }
    <span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># Init the rerun variable to 0 - set to 1 after mysqlMain (rerun)</span>
    <span class="comment-line"># ----------------------------------------------------------------</span>
    set DEVREG(active,inrerun) 0
    <span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># Get the module from a queueid</span>
    <span class="comment-line"># uInput is an out array arg</span>
    <span class="comment-line"># ----------------------------------------------------------------</span>
    array unset uInput 
    <a name="::UpdateTimedLockFile(1)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;unlock&#34; ;<span class="comment-line"># if from prev run's server</span>
    <span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># This is a critical check:</span>
    <span class="comment-line">#     - go through the priority file to get a list of queueIds</span>
    <span class="comment-line">#     - go through all queueIds and open the info files to pop.</span>
    <span class="comment-line">#         the uInput array.</span>
    <span class="comment-line">#     - check the uInput array to see if any of the info files</span>
    <span class="comment-line">#         are supposed to run on this platform type</span>
    <span class="comment-line">#     - If yes set the proper Mod to running in the info file</span>
    <span class="comment-line"># ----------------------------------------------------------------</span>
    global platformList
    set platformList $platformType
    set MAIN(queueId) [<a name="::GetAModule(1)"><a href="./queueLib.tcl.html#::GetAModule_709">::GetAModule</a></a> $regressionType $platformType uInput $cfgFileTail]
    set DEVREG(active,queueId) $MAIN(queueId)
    <span class="comment-line">#result_debug &#34;MAIN(queueId) $MAIN(queueId), uInput [parray uInput]&#34;</span>
    <span class="comment-line"># Update the imagesQueued and imagesRunning dir with changes</span>
    if {$MAIN(queueId)&gt;0} {
        <a name="::SetTerminalTitle(2)"><a href="./queueLib.tcl.html#::SetTerminalTitle_5146">::SetTerminalTitle</a></a> -add $MAIN(queueId)
        set hitSustainingRerun 0
        <span class="comment-line"># -------------------------------------------------------------------------------</span>
        <span class="comment-line"># Update the info file with the with the test bed being run and the status</span>
        <span class="comment-line"># -------------------------------------------------------------------------------</span>
    	if {[set updRetValue [<a name="::UpdateImagesRunning(1)"><a href="./queueLib.tcl.html#::UpdateImagesRunning_999">::UpdateImagesRunning</a></a> $MAIN(queueId) [array get uInput] $cfgFileTail]]==-1} {
            <span class="comment-line">#exit -1</span>
            <a name="::WriteToQueueDebug(1)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateImagesRunning $MAIN(queueId)&#34; &#34;Returned a -1 - Don't exit like before&#34;;  
            puts &#34;UpdateImagesRunning $MAIN(queueId) returned a -1&#34;
        }
        <span class="comment-line"># If there are jobs to do then the test bed will be powered up</span>
        if {$poweredOff != 0} {
            for {set i 1} {$i &lt;= 10} {incr i} {
                <a name="::PowerOffDUT(1)"><a href="./poweroutlet.tcl.html#::PowerOffDUT_983">::PowerOffDUT</a></a> $i &#34;on&#34;
            }
            set poweredOff 0
        }
        <span class="comment-line"># -------------------------------------------------------------------------------</span>
        <span class="comment-line"># Initialize any variables that may be missing in jobs submitted prior to a new</span>
        <span class="comment-line">#    code design change</span>
        <span class="comment-line"># -------------------------------------------------------------------------------</span>
        if {![info exists uInput(sustaining:)]} { set uInput(sustaining:) 0;}
        if {![info exists uInput(xmod:)]} { set uInput(xmod:) &#34;NULL&#34;;}
        if {![info exists uInput(faillock:)]} { set uInput(faillock:) &#34;no&#34;;}
        if {![info exists uInput(jenkins_url:)]} { set uInput(jenkins_url:) &#34;NULL&#34;;}
        if {![info exists uInput(harness:)]} { set uInput(harness:) &#34;all&#34;;}
        if {![info exists uInput(mode:)]} { set uInput(mode:) &#34;auto&#34;;}
        
        set comment &#34;&#34; 
        if {[regexp -nocase &#34;manager&#34; $uInput(userid:)]} {
            set comment &#34;no_analyzer&#34;
        }
        set alreadyOnConsole 0
        set count 0
        <span class="comment-line"># Set the runningIndex, which keys the modules, types and lsts lists</span>
        foreach runStatus $uInput(runStatus:) {
            if {$runStatus == &#34;runningOn$cfgFileTail&#34;} {
                set runningIndex $count  ;<span class="comment-line"># There should be only one &#34;runningOn&#34; per call to UpdateImagesRunning</span>
                break
            }
            incr count
        }
        puts &#34;$cfgFileTail: QueueId Running: $MAIN(queueId) [lindex $uInput(moduleNames:) $runningIndex]&#34;
        <span class="comment-line">#set featureSubType [_getMysqlAutomateSubType $platformType [lindex $uInput(moduleNames:) $runningIndex]]</span>
        if {[info exists uInput(lockFile:)] &amp;&amp; ![info exists uInput(platformToRunOn:)]} {
            <span class="comment-line">### Keep on waiting until $uInput(runStatus:) is changed to done</span>
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            <span class="comment-line"># If the test bed gets admin locked, we must assume that it is possible a new</span>
            <span class="comment-line">#    image was loaded on the box.</span>
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            puts &#34;\n------ SHOULD BE A USER LOCK FOR $uInput(userid:) -------\nAny previous user software \
                download will repeat after unlocking\nIf this is NOT a user lock scenerio contact Sqaauto&#34;;
            set MAIN(oldQueueId) &#34;&#34;
            if {$DEVREG(active,USERLOCK) == 0} {
                <a name="::UpdateTrackDB(7)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: UserLock - $uInput(userid:)&#34; -status &#34;royalblue&#34; \
                    -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;$MAIN(queueId)&#34;
                
                incr DEVREG(active,USERLOCK)
            }
            while {[regexp -nocase &#34;runningon&#34; $uInput(runStatus:)]} {
                puts &#34;$cfgFileTail: locked for QueueId $MAIN(queueId), userId $uInput(userid:)&#34; 
                <span class="comment-line"># Check if the runinngStatus Changed</span>
                if {[set retCode [<a name="::ReadQueueInfoIntoArray(1)"><a href="./queueLib.tcl.html#::ReadQueueInfoIntoArray_2721">::ReadQueueInfoIntoArray</a></a> $DEVREG(server,imagesRunningDir)/$MAIN(queueId)/info uInput]]==-1} {
                    puts &#34;ReadQueueInfoIntoArray $DEVREG(server,imagesRunningDir)/$MAIN(queueId)/info RETURNED a minus 1&#34;
                    <a name="::WriteToQueueDebug(2)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;ReadQueueInfoIntoArray FAILED&#34; &#34;Returned a -1 - Don't exit like before&#34;;
                    <span class="comment-line">#exit $retCode</span>
                } else {
                    after $pollTime
                }
            }
            if {$DEVREG(active,USERLOCK)&gt;0} {
                <a name="::UpdateTrackDB(8)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
                set DEVREG(active,USERLOCK) 0
            }
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            <span class="comment-line"># Initialize any variables that may be missing in jobs submitted prior to a new</span>
            <span class="comment-line">#    code design change - uInput is redefine above.</span>
            <span class="comment-line"># -------------------------------------------------------------------------------</span>
            if {![info exists uInput(sustaining:)]} { set uInput(sustaining:) 0;}
            if {![info exists uInput(xmod:)]} { set uInput(xmod:) &#34;NULL&#34;;}
            if {![info exists uInput(faillock:)]} { set uInput(faillock:) &#34;no&#34;;}

            if {[set targetDir [<a name="::MoveReportToQueueFinished(1)"><a href="./queueLib.tcl.html#::MoveReportToQueueFinished_1634">::MoveReportToQueueFinished</a></a> $MAIN(queueId) [array get uInput] $runningIndex Unknown]]==-1} {
                set targetDir &#34;Report dir not generated&#34;
            }
            if {![regexp -nocase &#34;manager&#34; $uInput(userid:)]} {
                set str &#34;&#34;
                set str [append str [<a name="::PrintUserQueue(1)"><a href="./queueLib.tcl.html#::PrintUserQueue_2538">::PrintUserQueue</a></a> [array get uInput] $MAIN(queueId)]]
                puts &#34;Now sending mail for unlock&#34;
                if {[regexp -nocase &#34;\@&#34; $uInput(userid:)]} {
                    set toBeSent &#34;$uInput(userid:).extremenetworks.com&#34;
                } else {
                    set toBeSent &#34;$uInput(userid:)@extremenetworks.com&#34;
                }
                if {![regexp -nocase &#34;manager&#34; $toBeSent]} {
                   exec /bin/mail -s &#34;Queueid:$MAIN(queueId)\($platformType\) ***unlocked*** testbed $uInput(lockFile:)&#34; \
                    &#34;$toBeSent&#34; -- -r &#34;Sqaautosupport@extremenetworks.com&#34; &lt;&lt; &#34;$str&#34; &amp;
                }
            }
        } else {
            <span class="comment-line"># ---  Real run starting ---</span>
            set platToRunOn [string tolower $uInput(platformToRunOn:)]
            <a name="::LogRegStart(1)"><a href="./queueLib.tcl.html#::LogRegStart_2232">::LogRegStart</a></a> $MAIN(queueId) $runningIndex $cfgFileTail [array get uInput]  ;<span class="comment-line"># log the regression start to regstart.log</span>
            <a name="::CreateQueueDebug(1)"><a href="./queueLib.tcl.html#::CreateQueueDebug_1605">::CreateQueueDebug</a></a> $MAIN(queueId) $runningIndex $cfgFileTail
            if {$DEVREG(server,harness) == &#34;robot&#34;} {
                <span class="comment-line"># ----------------  R O B O T    S E C T I O N  ------------------</span>
                if {$DEVREG(mysql,UseDb)} {
                    set MAIN(reg_id) [<a name="::getRegIdFromQId(1)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $MAIN(queueId)]
                }
                <span class="comment-line"># ---  Information gathered from the cfg/robot.cfg files about this yaml file ---</span>
                <span class="comment-line"># DEVREG(server,CFG_PATH) </span>
                <span class="comment-line"># DEVREG(server,CFG_AREA)</span>
                <span class="comment-line"># DEVREG(server,CFG_TYPE)</span>
                <span class="comment-line"># ----------------------------------------------------------------------------------------</span>
                <span class="comment-line"># Create the mount report directory</span>
                set modName [lindex $uInput(moduleNames:) $runningIndex]
                <a name="::UpdateTrackDB(9)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Start Regression on $modName&#34; -status &#34;green&#34; \
                             -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;$MAIN(queueId)&#34;
                set MAIN(module) $modName
                if {[info exists uInput(moduleTypes:)]} {
                    set modType [lindex $uInput(moduleTypes:) $runningIndex]
                    <a name="::WriteToQueueDebug(3)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Define modType&#34; &#34;!!!!!!!!\n!!!!!!!!\n \
                              EXISTS uInput(moduleTypes:)\nSET to $modType\n!!!!!!!!\n!!!!!!!! &#34;
                } else {
                    set modType robotunit
                    <a name="::WriteToQueueDebug(4)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Define modType&#34; &#34;!!!!!!!!\n!!!!!!!!\n \
                              DOES NOT EXIST uInput(moduleTypes:)\nSET to $modType\n!!!!!!!!\n!!!!!!!! &#34;
                }
                set MAIN(robotRepDir) [<a name="::_createRobotReportDir(1)"><a href="./robot.tcl.html#::_createRobotReportDir_273">::_createRobotReportDir</a></a> $MAIN(queueId) $MAIN(module)]
                <span class="comment-line">#if {[regexp -nocase &#34;unit&#34; $modType]} {</span>
                <span class="comment-line">#    append suite &#34; -s $modName $DEVREG(server,robotTestPath)/Unit/NetworkElements/$modName&#34;</span>
                <span class="comment-line">#} else {</span>
                <span class="comment-line">#    append suite &#34; -s $modName $DEVREG(server,robotTestPath)/Unit/NetworkElements/$modName&#34;</span>
                <span class="comment-line">#}</span>
                <span class="comment-line">#set pybotCmd $DEVREG(server,pybotPath)</span>
                if {[info exists MAIN(oldQueueId)] &amp;&amp; $MAIN(oldQueueId) != $MAIN(queueId)} {
                    puts &#34;Robot Download Enabled&#34;
                    <a name="::_copyRobotImagesToTftp(1)"><a href="./robot.tcl.html#::_copyRobotImagesToTftp_356">::_copyRobotImagesToTftp</a></a> [array get uInput] -qId $MAIN(queueId)
                    <span class="comment-line"># --- check if the i386 image / DUT2+ image is included</span>
                    set lptr [string tolower $uInput(platformToRunOn:)]
                    if {(![info exists $uInput(i386Image:)] || $uInput(i386Image:) == &#34;&#34; || \
                         [regexp -nocase &#34;null&#34; $uInput(i386Image:)]) &amp;&amp; \
                         [info exists DEVREG(platImageType,$lptr)] } {
                            catch {exec /usr/bin/pybot -L trace --listener $DEVREG(server,robotResultMnt)/$DEVREG(server,robotListener) \
                               -v TestBedVariable:$DEVREG(server,CFG_PATH)/$MAIN(cfg) \
                               -v QUEUEID:$MAIN(queueId) -v MODULE:$modName -v TFTPSERVER:10.69.5.248 \
                               -v FAMILY:$DEVREG(platImageType,$lptr) \
                               -d $MAIN(robotRepDir) -s $modName $DEVREG(server,robotTestPath)/Unit/NetworkElements/$modName  &gt;@stdout | \
                               busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRet
                    }
                } else {
                    puts &#34;Skipping Robot Download b/c Already downloaded&#34;
                    catch {exec /usr/bin/pybot -L trace --listener $DEVREG(server,robotResultMnt)/$DEVREG(server,robotListener) \
                       -v TestBedVariable:$DEVREG(server,CFG_PATH)/$MAIN(cfg) \
                       -v QUEUEID:$MAIN(queueId) -v MODULE:$modName \
                       -d $MAIN(robotRepDir) -s $modName $DEVREG(server,robotTestPath)/Unit/NetworkElements/$modName  &gt;@stdout | \
                       busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRet
                }
                set MAIN(resultList) [<a name="::getRunRegTestModuleStatus(1)"><a href="./mysqlLib.tcl.html#::getRunRegTestModuleStatus_4038">::getRunRegTestModuleStatus</a></a> $MAIN(reg_id) $MAIN(module)]
                if {1 || [regexp -nocase &#34;pass&#34; $mainRet]} {
                    puts &#34;PYBOT RETURNED: $mainRet&#34;
                    set DEVREG(active,failcount) 0
                    <a name="::WriteToQueueDebug(5)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Robot TestCompleted&#34; \
                         &#34;UpdateRobotImagesDone $MAIN(queueId) $runningIndex [lindex $MAIN(resultList) 0]&#34;;
                    catch {<a name="::UpdateRobotImagesDone(1)"><a href="./robot.tcl.html#::UpdateRobotImagesDone_404">::UpdateRobotImagesDone</a></a> $MAIN(queueId) $runningIndex [lindex $MAIN(resultList) 0]} why
                    <span class="comment-line">#set emailRet [EmailReportFilesMail $MAIN(queueId) $runningIndex $cfgFileTail robot PASS -mainReturnInfo $mainRet]</span>
                }
                set MAIN(oldQueueId) $MAIN(queueId)
                if {$partnerList != &#34;null&#34;} {
                    <span class="comment-line"># Release the lock on the shared queue.</span>
                    <a name="::release_lock(1)"><a href="./autolock.tcl.html#::release_lock_141">::release_lock</a></a> $shareId
                    <a name="::verify_release_lock(1)"><a href="./autolock.tcl.html#::verify_release_lock_166">::verify_release_lock</a></a> $shareId
                    after 5000
                }
                flush stdout
                if {$uInput(sustaining:) &amp;&amp; $hitSustainingRerun} {
                    <span class="comment-line">#Set the old queueid to garbage so that the next module will download code</span>
                    set MAIN(oldQueueId) 123
                }
                <a name="::UpdateTrackDB(10)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; \
                             -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
                continue;<span class="comment-line"># Go check the imagesQueued/GetModule</span>
            }


            <a name="::WriteToQueueDebug(6)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Regserver Pre Download&#34; &#34;LogRegStart: $MAIN(queueId) $runningIndex $cfgFileTail&#34;;
            <a name="::WriteToQueueDebug(7)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Flags A&#34; &#34;oldQueueId = $MAIN(oldQueueId) MAIN(queueId) \
                     $MAIN(queueId) oldRedD regexp [regexp -nocase &#34;^0&#34; $MAIN(oldResD)]&#34;;
            set modName        [lindex $uInput(moduleNames:) $runningIndex]
            if {[info exists uInput(moduleTypes:)]} {
                set modType [lindex $uInput(moduleTypes:) $runningIndex]
                <a name="::WriteToQueueDebug(8)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Define modType&#34; &#34;!!!!!!!!\n!!!!!!!!\n \
                          EXISTS uInput(moduleTypes:)\nSET to $modType\n!!!!!!!!\n!!!!!!!! &#34;
            } else {
                set modType functional
                <a name="::WriteToQueueDebug(9)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Define modType&#34; &#34;!!!!!!!!\n!!!!!!!!\n \
                          DOES NOT EXIST uInput(moduleTypes:)\nSET to $modType\n!!!!!!!!\n!!!!!!!! &#34;
            }
            if {$DEVREG(mysql,UseDb)} {
                set MAIN(reg_id) [<a name="::getRegIdFromQId(2)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $MAIN(queueId)]
            } 
            set myRegPath      [<a name="::GetModuleFullType(1)"><a href="./queueLib.tcl.html#::GetModuleFullType_4251">::GetModuleFullType</a></a> $modType directory] ;<span class="comment-line"># -regPath $myRegPath - Functionaltest | XML_API etc.</span>
            set myRegPathSmall [<a name="::GetModuleFullType(2)"><a href="./queueLib.tcl.html#::GetModuleFullType_4251">::GetModuleFullType</a></a> $modType runreg] ;<span class="comment-line">#  - functional | ixscriptmate | scalability | snmp etc.</span>
            set featureSubType [<a name="::_getMysqlAutomateSubType(1)"><a href="./queueLib.tcl.html#::_getMysqlAutomateSubType_3969">::_getMysqlAutomateSubType</a></a> $platformType [lindex $uInput(moduleNames:) $runningIndex] $modType];<span class="comment-line"># ipRoute1 | standard</span>
            <span class="comment-line"># -----------------------------------------------------------------------------------------</span>
            <span class="comment-line"># Get platformcode from main/runReg.cfg - LYNX_FUNC_IPR,1 | LYNX_SNMP_IPR,1 etc</span>
            <span class="comment-line">#   NOTE: Now that we know what module and what modType (funct|snmp etc) we can set the correct</span>
            <span class="comment-line">#         regserver(PLATFORMNAME)</span>
            <span class="comment-line">#         This is important because mysqlMain uses runRegPlatform to decide what to rerun</span>
            <span class="comment-line"># -----------------------------------------------------------------------------------------</span>
    <span class="comment-line">##   #     set MAIN(runRegPlatform) [get_platform_code $myRegPathSmall $featureSubType NULL NULL]</span>
            <span class="comment-line"># ------------------------------------------------------------------------------</span>
            <span class="comment-line">#  Case in which a differenct automation release path ie fuji,trunk2</span>
            <span class="comment-line">#    - set the main directory path for this modules run.</span>
            <span class="comment-line">#    - NOTE: all paths to main above can use the env base path b/c</span>
            <span class="comment-line">#        loadcode does not need to run from the alt repository.</span>
            <span class="comment-line"># ------------------------------------------------------------------------------</span>
            if {[info exists uInput(relInfo:)] &amp;&amp; $uInput(relInfo:) != &#34;&#34; \
                  &amp;&amp; [regexp -- $uInput(relInfo:) $DEVREG(server,relInfoList)]} {
                set mainPath &#34;$DEVREG(relInfoPath,$uInput(relInfo:))/../main&#34;
                 <a name="::WriteToQueueDebug(10)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;relInfo Check&#34; &#34;Found reInfo: $uInput(relInfo:) Path: $mainPath&#34;;
            } else {
                if {[info exists uInput(relInfo:)]} {
                    <a name="::WriteToQueueDebug(11)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;relInfo Check&#34; &#34;W H Y   D I D   T H I S   M I S S :\
                    \n$DEVREG(server,relInfoList) \nCHECK $uInput(relInfo:) \
                    [regexp -- $DEVREG(server,relInfoList) $uInput(relInfo:)]&#34;
                }
                <a name="::WriteToQueueDebug(12)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;relInfo Check&#34; &#34;Hit a normal run&#34;;
                set mainPath &#34;${env(BASE_PATH)}/../main&#34; ;<span class="comment-line">#  this leaves us at /auto/</span>
            }
            puts &#34;\n ==================================================\n\
            Regression executed from path: $mainPath\n\
            ==================================================\n&#34;;
            <a name="::WriteToQueueDebug(13)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Running&#34; &#34;mainPath $mainPath and mainPath val $mainPath&#34;;
            <span class="comment-line"># --------------------------------------------------------------------</span>
            <span class="comment-line">#  Make Sure There is a Valid Image to Run ::</span>
            <span class="comment-line">#  If the platform to run is set '$uInput(platformToRunOn:)', and the</span>
            <span class="comment-line">#  image '$uInput(${platformNameLower}Image:)' is set to NULL and </span>
            <span class="comment-line">#  the dut2+ images $uInput($RestOfDUTType($uInput(platformToRunOn:))Image:)</span>
            <span class="comment-line"># are set to NULL then skip download</span>
            <span class="comment-line"># --------------------------------------------------------------------</span>
            set hitAllNull 0
            <span class="comment-line"># --------------------------------------------------------------------</span>
            <span class="comment-line"># Check for platfromToRunOn. When found, check the related</span>
            <span class="comment-line">#   images (${platformNameVar}Image:, $RestOfDUTType($uInput(platformToRunOn:))Image:,</span>
            <span class="comment-line">#   or RestOfIPRDUTType($uInput(platformToRunOn:)lower)Image:) to </span>
            <span class="comment-line">#   see if LoadImage should be skipped or downloaded.</span>
            <span class="comment-line"># --------------------------------------------------------------------</span>
            if {[info exists uInput(platformToRunOn:)]} {
                set targetPlatform $uInput(platformToRunOn:)
                set targetPlatformLower [string tolower $targetPlatform]
                <span class="comment-line"># ----- Determine DUT2+ image type ... rtr or std</span>
                if {$featureSubType == &#34;cit2node&#34;} {
                    set restDutLower [string tolower $citDut2ImageType($targetPlatform)]
                    if {[info exists uInput(${restDutLower}Image:)]} {
                        set dut2Plat $RestOfDUTType($targetPlatform)
                        set dut2Image $uInput(${restDutLower}Image:)
                    }
                } elseif {$featureSubType == &#34;standard&#34; } {
                    set restDutLower [string tolower $RestOfDUTType($targetPlatform)]
                    if {[info exists uInput(${restDutLower}Image:)]} {
                        set dut2Plat $RestOfDUTType($targetPlatform)
                        set dut2Image $uInput(${restDutLower}Image:)
                    }
                } else {
                    set restDutLower [string tolower $RestOfIPRDUTType($targetPlatform)]
                    if {[info exists uInput(${restDutLower}Image:)]} {
                        set dut2Plat $RestOfIPRDUTType($targetPlatform)
                        set dut2Image $uInput(${restDutLower}Image:)
                    }
                }
                <span class="comment-line"># --------------------------------------------------------</span>
                <span class="comment-line"># Check the 2 images for NULL</span>
                <span class="comment-line"># --------------------------------------------------------</span>
                if {[info exists uInput(${targetPlatformLower}Image:)] &amp;&amp; \
                    $uInput(${targetPlatformLower}Image:)==&#34;NULL&#34; &amp;&amp; \
                    $dut2Image==&#34;NULL&#34;} {
                        set hitAllNull 1; <span class="comment-line"># Hit null</span>
                }
                <span class="comment-line"># --------------------------------------------------------</span>
                <span class="comment-line"># COMMONIMAGE is a catch all safety in runReg.cfg</span>
                <span class="comment-line">#    if a specific value is passed in for the device</span>
                <span class="comment-line">#    do not take the common image.</span>
                <span class="comment-line">#    COMMONIMAGE = platform type image I am going to download</span>
                <span class="comment-line"># --------------------------------------------------------</span>
                <span class="comment-line"># !!!! Note this caused issues with Stacks</span>
                if {[info exists uInput(${targetPlatformLower}Image:)] &amp;&amp; \
                    $uInput(${targetPlatformLower}Image:)!=&#34;NULL&#34;} {
                    <span class="comment-line">#set COMMONIMAGE($targetPlatform) $targetPlatform</span>
                }
                if {$dut2Image!=&#34;NULL&#34;} {
                    <span class="comment-line">#set COMMONIMAGE($dut2Plat) $dut2Plat; # DL type of myself</span>
                }
            }
            <a name="::WriteToQueueDebug(14)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Flags B&#34; &#34;oldQueueId = $MAIN(oldQueueId) MAIN(queueId) \
                        $MAIN(queueId) oldRedD regexp [regexp -nocase &#34;^0&#34; $MAIN(oldResD)]&#34;;
            set MAIN(DownloadState) 0
            if {$hitAllNull} {
                set MAIN(DownloadState) 1
                <span class="comment-line"># Hit null so skip download</span>
                set MAIN(resD) 0
                set MAIN(oldQueueId) $MAIN(queueId)
                set MAIN(oldResD) $MAIN(resD)
                <a name="::WriteToQueueDebug(15)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Regserver Download&#34; &#34;All Images Are NULL&#34;;
            } else {
                if {$MAIN(oldQueueId)!=$MAIN(queueId) || [regexp -nocase &#34;^0&#34; $MAIN(oldResD)]!=1} {  ;<span class="comment-line"># only download first time for a given queue</span>
                    <span class="comment-line"># --------------------------------------------------------------------</span>
                    <span class="comment-line">#  If the platform to run  $uInput(platformToRunOn:) and the</span>
                    <span class="comment-line">#  image $uInput(${targetPlatformLower}Image:) is set to skip </span>
                    <span class="comment-line">#  then skip download</span>
                    <span class="comment-line"># --------------------------------------------------------------------</span>
                    set MAIN(DownloadState) 1
                    set hitSkip 0
                    if {[info exists uInput(${targetPlatformLower}Image:)] &amp;&amp; \
                        $uInput(${targetPlatformLower}Image:) == &#34;skip&#34; } {
                        <span class="comment-line"># ---------------------------------------------------------------</span>
                        <span class="comment-line"># Hit skip so do not download - enforce the check above.</span>
                        <span class="comment-line"># ---------------------------------------------------------------</span>
                        <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skipping download image!&#34;
                        <a name="::WriteToQueueDebug(16)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Regserver Download&#34; &#34;Skipping download image! uInput(Platform) set to skip&#34;;
                        set MAIN(resD) 0
                    } else {
                        <span class="comment-line"># Start the download process</span>
                        <a name="::WriteToQueueDebug(17)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Regserver Download&#34; &#34;Normal Download Start&#34;;
                        <span class="comment-line"># ----------------------------------------------------------------------</span>
                        <span class="comment-line">#  Get the platformToRunOn and use it to get/link to the DUT1 image</span>
                        <span class="comment-line">#     path as well as the DUT2+ paths.</span>
                        <span class="comment-line"># ----------------------------------------------------------------------</span>
                        set plats &#34;&#34;
                        set platImagePaths &#34;&#34;
                        <span class="comment-line"># --- targetPlatformLower set above</span>
                        if {[info exists uInput(${targetPlatformLower}Image:)] &amp;&amp; \
                            $uInput(${targetPlatformLower}Image:)!=&#34;NULL&#34; &amp;&amp; \
                            $uInput(${targetPlatformLower}Image:)!=&#34;skip&#34; } {
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            <span class="comment-line"># Set the image name to the oldest common name</span>
                            <span class="comment-line">#   Sonoma -&gt; Aspen</span>
                            <span class="comment-line">#   Melange-&gt; Aspen</span>
                            <span class="comment-line">#   Torino -&gt; Olympic</span>
                            <span class="comment-line">#</span>
                            <span class="comment-line"># COMMONIMAGE($targetPlatform) is initialized in runReg.cfg</span>
                            <span class="comment-line"># -----------------------------------------------------------</span>
                        
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            <span class="comment-line"># Set image info for DUT1</span>
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            set commonImageA $COMMONIMAGE($targetPlatform); <span class="comment-line"># $COMMONIMAGE(Sonoma)-&gt;Aspen</span>
                            set commonImageALower [string tolower $commonImageA]
                            set uInput(${commonImageALower}Image:) $uInput(${targetPlatformLower}Image:)
                            lappend plats &#34;$commonImageA&#34;; <span class="comment-line"># List of platforms &#34;Aspen&#34;</span>
                            lappend platImagePaths &#34;$uInput(${commonImageALower}Image:)&#34;; <span class="comment-line"># List of full image paths</span>
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            <span class="comment-line"># Set image info for DUT2</span>
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            set commonImageB $COMMONIMAGE($dut2Plat); <span class="comment-line"># $COMMONIMAGE(Sonoma)-&gt;Aspen</span>
                            set commonImageBLower [string tolower $commonImageB]
                            set uInput(${commonImageBLower}Image:) $dut2Image
                            if {[string tolower [file tail $uInput(${commonImageBLower}Image:)]] != &#34;null&#34;} {
                                puts &#34;NULL not hit: [string tolower [file tail $uInput(${commonImageBLower}Image:)]]&#34;
                                lappend plats &#34;$commonImageB&#34;; <span class="comment-line"># List of platforms &#34;Aspen Cougar&#34;</span>
                                lappend platImagePaths &#34;$uInput(${commonImageBLower}Image:)&#34;; <span class="comment-line"># List of full image paths</span>
                            }
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            <span class="comment-line"># Add the no diags X480 image if the flag is set for this test bed in runReg.cfg</span>
                            <span class="comment-line"># -----------------------------------------------------------</span>
                            if {[info exists X480EXISTS($targetPlatform,$regressionType)] &amp;&amp; \
                                   $X480EXISTS($targetPlatform,$regressionType) &amp;&amp; \
                                   [info exists uInput(x480Image:)] &amp;&amp; [string tolower $uInput(x480Image:)] != &#34;null&#34;} {
                                puts &#34;NULL not hit on X480: [string tolower [file tail $uInput(x480Image:)]]&#34;
                                lappend plats &#34;x480&#34;; <span class="comment-line"># Add x480 no diags</span>
                                lappend platImagePaths &#34;$uInput(x480Image:)&#34;; <span class="comment-line"># Add x480 no diags image path</span>
                            }
                        }
                    
                        <a name="::UpdateTrackDB(11)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Downloading&#34; -status &#34;green&#34; \
                                     -teefile &#34;/tmp/Tmp/$MAIN(queueId)[pid]&#34; -testcase &#34;&#34; -qid &#34;$MAIN(queueId)&#34;
                        <a name="::GetLocalImageDir(1)"><a href="./queueLib.tcl.html#::GetLocalImageDir_3031">::GetLocalImageDir</a></a> -id $MAIN(queueId) -platformList $plats -platformImageList $platImagePaths
                        <span class="comment-line">#GetLocalImageDir $MAIN(queueId) $uInput(i386Image:) $uInput(marinerImage:) $uInput(aspenImage:) \</span>
                        <span class="comment-line">#     $uInput(aspennapaImage:) $uInput(cougarImage:) $uInput(olympicImage:) $uInput(jaguarImage:) \</span>
                        <span class="comment-line">#     $uInput(pantherImage:) $uInput(voyagerImage:) i386Image marinerImage aspenImage aspennapaImage \</span>
                        <span class="comment-line">#     cougarImage olympicImage jaguarImage pantherImage voyagerImage </span>
                        <span class="comment-line"># ----------------------------------------------------------------------</span>
                        <span class="comment-line"># Re-create the image path lists from variables set in GetLocalImageDir</span>
                        <span class="comment-line"># ----------------------------------------------------------------------</span>
                        set platImagePaths &#34;&#34;
                        foreach myPlat $plats {
                           lappend platImagePaths $DEVREG(imageDir,$myPlat)
                        }
                        set mydir [pwd]
                        cd $mainPath
                        <a name="::WriteToQueueDebug(18)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;QLoadImage call&#34; &#34;QLoadImage.tcl -cfg $DEVREG(server,CFG_PATH)/$cfg \
                               -platformList $plats -qId $MAIN(queueId) -platformImageList $platImagePaths \
                               -xmod $uInput(xmod:)&#34;;
                        puts &#34;QLoadImage.tcl -cfg $DEVREG(server,CFG_PATH)/$cfg \
                               -platformList $plats -qId $MAIN(queueId) -platformImageList $platImagePaths \
                               -xmod $uInput(xmod:)&#34;;
                        catch {exec ./QLoadImage.tcl -cfg $DEVREG(server,CFG_PATH)/$cfg -platformList $plats -qId $MAIN(queueId) \
                                    -platformImageList $platImagePaths \
                                    -xmod $uInput(xmod:) &gt;@stdout | busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} MAIN(resD)
                        cd $mydir
                        <a name="::WriteToQueueDebug(19)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;AfterQLoadImage call&#34; &#34;Result = $MAIN(resD)&#34;;
                        if {[catch {exec cp /tmp/Tmp/$MAIN(queueId)[pid] /tmp/Tmp/DL_$MAIN(queueId)} reason]} {
                            puts &#34;Error: Cannot cp /tmp/Tmp/$MAIN(queueId)[pid] to /tmp/Tmp/DL_$MAIN(queueId) ...$reason&#34;;
                            <span class="comment-line">#return -1</span>
                        }
                    }
                    set MAIN(oldQueueId) $MAIN(queueId)
                    set MAIN(oldResD) $MAIN(resD)
                    <a name="::WriteToQueueDebug(20)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;End of Download choices&#34; &#34;oldResD $MAIN(oldResD) oldQueueId $MAIN(oldQueueId)&#34;;
                    if {($MAIN(resD)==0)||([regexp -nocase &#34;^0&#34; $MAIN(resD)]==1&amp;&amp;[regexp -nocase &#34;write error&#34; $MAIN(resD)])} {
                        <span class="comment-line"># Download image successful, move the report dir to avoid conflict with failed ones</span>
                        <span class="comment-line"># Since we do not want to compute the info file here but only move the</span>
                        <span class="comment-line"># download report dir</span>
                        set DEVREG(active,failcount) 0
                        <a name="::WriteToQueueDebug(21)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download image successful&#34; &#34;Call MoveReportToQueueFinished&#34;;
                        <span class="comment-line"># -------------------------------------------------------------------------------</span>
                        <span class="comment-line"># Start semaphore application which runs for 15 mins by default.  This allows</span>
                        <span class="comment-line">#   other processes to check to see whether this queue is running a regression.</span>
                        <span class="comment-line">#   In this case it helps avoid a race condition in the event of multiple test</span>
                        <span class="comment-line">#   beds sharing a queue.</span>
                        <span class="comment-line"># -------------------------------------------------------------------------------</span>
                        <span class="comment-line">#set cmd1 &#34;exec tclsh dyingSemaphore.tcl -cfg $cfgFileTail -qId $MAIN(queueId) -time 180 &amp;&#34;</span>
                        <span class="comment-line">#set outpid1 [catch &#34;$cmd1&#34; reason1]</span>
                        <span class="comment-line">#if {$outpid1} {</span>
                        <span class="comment-line">#    result_debug &#34;failed to spawn semaphore application: $reason1\n&#34;</span>
                        <span class="comment-line">#}</span>
                        <span class="comment-line">#puts &#34;Started Semaphore Application 2 with pid $reason1&#34;</span>
                        <span class="comment-line">#flush stdout</span>
                        file delete /tmp/Tmp/$MAIN(queueId)[pid]
                        if {[set targetDir [<a name="::MoveReportToQueueFinished(2)"><a href="./queueLib.tcl.html#::MoveReportToQueueFinished_1634">::MoveReportToQueueFinished</a></a> $MAIN(queueId) [array get uInput] $runningIndex DownloadPassed]]==-1} {
                            set targetDir &#34;Report dir not generate&#34;
                        }
                        puts &#34;!!!!\nTarget Dir\n$targetDir\n!!!!!&#34;
                        if {$uInput([set platToRunOn]Image:)!=&#34;skip&#34;} {
                            if {!$skipMysqlAutomate} {
                                <a name="::WriteToQueueDebug(22)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download image successful&#34; &#34;mysqlAutomate: -platform $MAIN(runRegPlatform) -regId $MAIN(queueId) \
                                    -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex]  -qId $MAIN(queueId) \
                                    -regType $myRegPathSmall -regSubType $featureSubType&#34;;
                                catch {exec $mainPath/../main/mysqlAutomate.tcl -regId $MAIN(queueId) -platform $MAIN(runRegPlatform) \
                                    -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex]  -qId $MAIN(queueId) \
                                    -regType $myRegPathSmall -regSubType $featureSubType -callLocation \
                                    &#34;regServer: MAIN(resD)=0 download successful $cfg&#34;&gt;@stdout} automateRet
                            }
                        }
                    }
                }
            }
            <a name="::UpdateIdle(8)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
            <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MAIN(resD) |$MAIN(resD)|, oldQueueId $MAIN(oldQueueId), MAIN(queueId) $MAIN(queueId)&#34;
            <a name="::WriteToQueueDebug(23)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Flags C&#34; &#34;oldQueueId = $MAIN(oldQueueId) MAIN(queueId) \
                        $MAIN(queueId) oldRedD regexp [regexp -nocase &#34;^0&#34; $MAIN(oldResD)]&#34;;
            flush stdout
            if {($MAIN(resD)==0)||([regexp -nocase &#34;^0&#34; $MAIN(resD)]==1&amp;&amp;[regexp -nocase &#34;write error&#34; $MAIN(resD)])} {
                <span class="comment-line">#  Download Successful</span>
                <span class="comment-line">#  UpdateImagesDone $MAIN(queueId) $runningIndex DownloadPassed targetDir</span>
                set mainRet &#34;testCompleted&#34;
                set modName [lindex $uInput(moduleNames:) $runningIndex]
                set MAIN(module) $modName
                if {![info exists uInput(tcList$MAIN(module):)]} { set uInput(tcList$MAIN(module):) &#34;all&#34;;}
                if {[info exists uInput(moduleTypes:)]} {
                    set modType [lindex $uInput(moduleTypes:) $runningIndex]
                } else {
                    set modType functional
                }
                set myRegPath [<a name="::GetModuleFullType(3)"><a href="./queueLib.tcl.html#::GetModuleFullType_4251">::GetModuleFullType</a></a> $modType dir] ;<span class="comment-line"># -regPath $myRegPath</span>
    
                if {[regexp -nocase cfg [lindex $uInput(moduleLists:) $runningIndex]]} {
                   set lst $uInput($modName,tstList:)
                   if {[info exists uInput(relInfo:)]} {
                      set releaseInfo $uInput(relInfo:)
                   } else {
                      set releaseInfo &#34;current&#34;
                   }
                   if {$releaseInfo==&#34;&#34;} {
                      set releaseInfo &#34;current&#34;
                   }
                   set Path Path
    
                   if {$releaseInfo==&#34;current&#34;} {
                      if {[catch {exec mv $DEVREG(server,imagesQueuedDir)/$MAIN(queueId)/$lst \
                             $mainPath/../${myRegPath}/$modName/$MAIN(queueId)} reason]} {
                         <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;This regresson is using 'cfg' to run a list, but the lst file is not present&#34;
                         puts &#34;Error: Cannot move $DEVREG(server,imagesQueuedDir)/$MAIN(queueId)/$modName ...$reason&#34;;
                         set lst null
                      }
                   } else {
                      if {[catch {exec mv $DEVREG(server,imagesQueuedDir)/$MAIN(queueId)/$lst \
                              $mainPath/../${myRegPath}/$modName/$MAIN(queueId)} reason]} {
                         <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;This regresson is using 'cfg' to run a list, but the lst file is not present&#34;
                         puts &#34;Error: ...$reason&#34;;
                         set lst null
                      }
                   }
                   if {$lst == &#34;null&#34;} {
                       set lst [lindex $uInput(moduleLists:) $runningIndex]
                   } else {
                       set lst $MAIN(queueId)
                   }
                } else {
                   set lst [lindex $uInput(moduleLists:) $runningIndex]
                }
                <span class="comment-line"># Debug file mv</span>
                if {[info exists uInput($modName,debugChoice:)]} {
                   if {$uInput($modName,debugChoice:)==&#34;Yes&#34;} {
                      set dbgFile $uInput($modName,dbgFile:)
                      if {[catch {exec mv $DEVREG(server,imagesQueuedDir)/$MAIN(queueId)/$dbgFile \
                            $mainPath/../${myRegPath}/$modName/$MAIN(queueId).dbg} reason]} {
                          puts &#34;Error: Cannot move $DEVREG(server,imagesQueuedDir)/$MAIN(queueId)/$modName Debug File ...$reason&#34;;
                          set dbg 0
                      } else {
                          set dbg $MAIN(queueId).dbg
                      }
                   } else {           
                      set dbg 0
                   }
                } else {
                   set dbg 0
                }
    
                if {$modName==&#34;epm&#34;} {
                    set platformtorunon [string tolower $uInput(platformToRunOn:)]Image:
                    set uInput($modName,value:) &#34;$uInput($platformtorunon)&#34;
                }
    
                <span class="comment-line">### efence code</span>
                global mysqlIP my_db
                set host $mysqlIP
                set db $my_db
                global host mysql_handler
                
                
                <span class="comment-line"># find the efence processes for this feature</span>
                <span class="comment-line"># do not activate efence for stackables</span>
                if {[info exists uInput(efence:)]} {
                    set efence $uInput(efence:)
                } else {
                    set efence &#34;&#34;
                }
                set testModule $modName
                set cfg $cfg
                
                set efenceProcessList &#34;no&#34;
                if {[llength $efence] &gt; 0} {
                    if {[string compare [lindex $efence 0] &#34;enable&#34;]==0} {
                        <a name="::conn_to_db(3)"><a href="./mysqlLib.tcl.html#::conn_to_db_8">::conn_to_db</a></a> $host $db
                        set efenceProcessList [<a name="::getEfenceProcessList(1)"><a href="./mysqlLib.tcl.html#::getEfenceProcessList_2251">::getEfenceProcessList</a></a> -module $testModule -cfg $cfg]
                    }
                }
                if {$uInput(platformToRunOn:) == &#34;i386&#34; || $uInput(platformToRunOn:) == &#34;exosvm&#34;} {
                    set tgen ixvm
                }
                <span class="comment-line">#--------------------  Add Robot -----------------------</span>
                if {$MAIN(harness) == &#34;robot&#34;} {
                    puts &#34;Should I be here for robot&#34;
                } else {
                    <a name="::UpdateTrackDB(12)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Running $modName&#34; -status &#34;green&#34; \
                                 -teefile &#34;/tmp/Tmp/$MAIN(queueId)[pid]&#34; -testcase &#34;&#34; -qid &#34;$MAIN(queueId)&#34;
                    set tcLst $uInput(tcList$MAIN(module):);<span class="comment-line"># This is set to 'all' above if not set in info file</span>
                    set am $uInput(mode:);<span class="comment-line"># mode is set to auto above is not in the info file.</span>
                    if {!$MAIN(DownloadState) &amp;&amp; $uInput(mode:) == &#34;dev&#34;} {
                        set am &#34;dev&#34;
                    } else {
                        set am &#34;auto&#34;
                    }
                    if {[info exists uInput($modName,value:)]} {
                       <span class="comment-line"># --------------------------------------------------</span>
                       <span class="comment-line"># ---  Exec main.tcl if there is a moduleArg --</span>
                       <span class="comment-line"># --------------------------------------------------</span>
                       set moduleArg $uInput($modName,value:)
                       if {[info exists uInput(relInfo:)]  &amp;&amp; $uInput(relInfo:) != &#34;&#34; \
                           &amp;&amp; [regexp -- $uInput(relInfo:) $DEVREG(server,relInfoList)]} {
                          <span class="comment-line"># --------------------------------------------------</span>
                          <span class="comment-line">#  Run main in a parallel dir</span>
                          <span class="comment-line"># --------------------------------------------------</span>
                          set mydir [pwd]
                          cd $mainPath
                          <a name="::WriteToQueueDebug(24)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;modNave,value exists&#34; &#34;main.tcl -mode $am -lst $lst -tcList $tcLst \
                            -debugLevel $dbg -module $modName -qId $MAIN(queueId) -TrafficGen $tgen -harness $MAIN(harness) \
                            -cfg $DEVREG(server,CFG_PATH)/$cfg -moduleArg $moduleArg -regPath $myRegPath&#34;
                          catch {exec ./main.tcl -mode $am -lst $lst -debugLevel $dbg -module $modName -qId $MAIN(queueId) -harness $MAIN(harness) \
                            -cfg $DEVREG(server,CFG_PATH)/$cfg -moduleArg $moduleArg -regPath $myRegPath -TrafficGen $tgen -tcList $tcLst \
                            &gt;@stdout | busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRet
                          cd $mydir
                       } else {
                          set mydir [pwd]
                          <span class="comment-line"># --------------------------------------------------</span>
                          <span class="comment-line"># Run normal main with moduleArg</span>
                          <span class="comment-line"># --------------------------------------------------</span>
                          cd $mainPath
                          <a name="::WriteToQueueDebug(25)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Normal main with moduleArg&#34; &#34;main.tcl -mode $am -lst $lst -tcList $tcLst \
                             -debugLevel $dbg -module $modName -qId $MAIN(queueId) -TrafficGen $tgen -harness $MAIN(harness) \
                            -cfg $DEVREG(server,CFG_PATH)/$cfg -moduleArg $moduleArg -efence $efenceProcessList&#34;
                          catch {exec ./main.tcl -mode $am -lst $lst -debugLevel $dbg -module $modName -qId $MAIN(queueId) \
                            -cfg $DEVREG(server,CFG_PATH)/$cfg -moduleArg $moduleArg -harness $MAIN(harness) -tcList $tcLst \
                            -TrafficGen $tgen -efence $efenceProcessList &gt;@stdout | \
                            busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRet
                          cd $mydir
                       }
                    } else {
                       <span class="comment-line"># NORMAL RUN</span>
                       if {[info exists uInput(relInfo:)]  &amp;&amp; $uInput(relInfo:) != &#34;&#34; \
                           &amp;&amp; [regexp -- $uInput(relInfo:) $DEVREG(server,relInfoList)]} {
                          <span class="comment-line"># --------------------------------------------------</span>
                          <span class="comment-line"># --- Exec main.tcl in a parallel directory ---</span>
                          <span class="comment-line"># --------------------------------------------------</span>
                          set mydir [pwd]
                          cd $mainPath
                          <a name="::WriteToQueueDebug(26)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;relInfo Exec Main&#34; &#34;main.tcl -mode $am -lst $lst -tcList $tcLst \
                             -debugLevel $dbg -module $modName -qId $MAIN(queueId) -TrafficGen $tgen -harness $MAIN(harness) \
                             -cfg $DEVREG(server,CFG_PATH)/$cfg -regPath $myRegPath&#34;
                          catch {exec ./main.tcl -mode $am -lst $lst -debugLevel $dbg -module $modName -qId $MAIN(queueId) -tcList $tcLst \
                             -cfg $DEVREG(server,CFG_PATH)/$cfg -regPath $myRegPath -TrafficGen $tgen -harness $MAIN(harness) \
                             &gt;@stdout | busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRet
                          cd $mydir
                       } else {
                          <span class="comment-line"># --------------------------------------------------</span>
                          <span class="comment-line"># --- Normal exec main.tcl ---</span>
                          <span class="comment-line"># --------------------------------------------------</span>
                          set mydir [pwd]
                          cd $mainPath
                          <a name="::WriteToQueueDebug(27)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Normal Exec Main&#34; &#34;main.tcl -mode $am -lst $lst -tcList $tcLst \
                             -debugLevel $dbg -module $modName -qId $MAIN(queueId) -TrafficGen $tgen -harness $MAIN(harness) \
                             -cfg $DEVREG(server,CFG_PATH)/$cfg -regPath $myRegPath -efence $efenceProcessList&#34;
                          catch {exec ./main.tcl -mode $am -lst $lst -debugLevel $dbg -module $modName -qId $MAIN(queueId) \
                             -cfg $DEVREG(server,CFG_PATH)/$cfg -regPath $myRegPath -harness $MAIN(harness) -tcList $tcLst \
                             -TrafficGen $tgen -efence $efenceProcessList \
                             &gt;@stdout | busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRet
                          <a name="::WriteToQueueDebug(28)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Normal Exec Main END&#34; &#34;Made it past normal main.tcl&#34;
                          cd $mydir
                       }
                    }
                    <span class="comment-line">#; tee in above call potentially may give write error if</span>
                    <span class="comment-line">#  kill is called in running server. It has been seen earlier</span>
                    <span class="comment-line"># causing following switch to follow default (instead of killed)</span>
                    <span class="comment-line"># construct sending the whole trace to user.</span>
                    after 1000
                    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the $MAIN(queueId) $modName mainRet |$mainRet|&#34;
                    switch -regexp -- $mainRet {
                       &#34;^testCompleted&#34; -
                       &#34;^testSkipped&#34; {
                          <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;inside testCompleted&#34;
                          set DEVREG(active,failcount) 0
                          <a name="::WriteToQueueDebug(29)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;TestCompleted Or Skipped&#34; \
                             &#34;UpdateImagesDone $MAIN(queueId) $runningIndex PASSedOn$cfgFileTail targetDir&#34;;
                          catch {<a name="::UpdateImagesDone(1)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex PASSedOn$cfgFileTail targetDir} why
                          set emailRet [<a name="::EmailReportFilesMail(1)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir PASS -mainReturnInfo $mainRet]
        
                          <span class="comment-line"># Check here if some tests failed, if failed some tests, rerun the failed tests separately</span>
                          <span class="comment-line"># Rerun involves, calling standalone shell script, reporting it to web,</span>
                          <span class="comment-line"># Moving the report to imagesFinished area</span>
                          if {$uInput(faillock:) == &#34;yes&#34; &amp;&amp; [regexp -nocase &#34;fail&#34; $emailRet]} {
                              <span class="comment-line"># --- set rerun to 0 so the harness does not run again and we break out</span>
                              set uInput(rerun:) 0
                              <span class="comment-line">#  Create the userlock queue file $cfg</span>
                              set lInput(faillock:)     &#34;yes&#34;
                              set lInput(priority:)     1
                              set lInput(moduleNames:)  &#34;none&#34;
                              set lInput(efence:)       &#34;no&#34;
                              set lInput(moduleTypes:)  &#34;none&#34;
                              set lInput(relInfo:)      &#34;&#34;
                              set lInput(userid:)       &#34;$uInput(userid:)&#34;
                              set lInput(runStatus:)    &#34;queued&#34;
                              set lInput(lockFile:)     &#34;$cfgFileTail&#34;
                              set lInput(moduleLists:)  &#34;none&#34;
                              set poweredOff 1
                              <a name="::QueueAUserLock(1)"><a href="./queueLib.tcl.html#::QueueAUserLock_5062">::QueueAUserLock</a></a> [array get lInput]
                          }
                          if {[regexp -nocase &#34;fail&#34; $emailRet] &amp;&amp; $automatedRerun &amp;&amp; $uInput(rerun:)} {
                             <span class="comment-line"># -------------------------------------------------------------------------------</span>
                             <span class="comment-line"># Rerun download code if in sustaining mode</span>
                             <span class="comment-line"># -------------------------------------------------------------------------------</span>
                             set goodSustaining 0
                             if {$uInput(sustaining:)} {
                                set hitSustainingRerun 1
                                set newResD [<a name="::QueueDownloadBaseline(1)"><a href="./queueLib.tcl.html#::QueueDownloadBaseline_4449">::QueueDownloadBaseline</a></a> $modType $platformType $MAIN(queueId) [array get uInput] $runningIndex]
                                if {($newResD==0)||([regexp -nocase &#34;^0&#34; $newResD]==1&amp;&amp;[regexp -nocase &#34;write error&#34; $newResD])} {
                                    set goodSustaining 1
                                    <a name="::WriteToQueueDebug(30)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;BaseLine Download PASS&#34; &#34;BASELINE DL Pass $MAIN(queueId) $runningIndex $cfgFileTail&#34;
                                } else {
                                    <a name="::WriteToQueueDebug(31)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Fail&#34; &#34;EmailReportFilesMail $MAIN(queueId) $runningIndex $cfgFileTail $targetDir FAIL&#34;
                                    <a name="::EmailReportFilesMail(2)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir FAIL -mainReturnInfo $newResD
                                    fconfigure stdin -blocking 1
                                    <a name="::UpdateTimedLockFile(2)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;lock&#34;
                                    set waitCount 0
                                    <span class="comment-line"># ----------------------------------------------</span>
                                    <span class="comment-line"># Check the failure count to see if a perminant</span>
                                    <span class="comment-line">#   lock should be made.  Use Global</span>
                                    <span class="comment-line">#         DEVREG(server,failsforlock) to hold it</span>
                                    <span class="comment-line"># ----------------------------------------------</span>
                                    incr DEVREG(active,failcount)
                                    if {$DEVREG(active,failcount) &gt;= $DEVREG(server,failsforlock) } {
                                        <span class="comment-line"># -----------------------------------------------------------</span>
                                        <span class="comment-line"># Create a lock file entry</span>
                                        <span class="comment-line"># -----------------------------------------------------------</span>
                                        if {[<a name="::locked(2)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $cfgFileTail]} {
                                            <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The test bed: $cfgFileTail is already locked&#34;
                                        } else {   ;<span class="comment-line"># lock it in $DEVREG(server,lockFile)</span>
                                            if {[set fd_out5 [<a name="::FileOpen(1)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
                                                <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Lock File Open Failed!&#34;
                                                <span class="comment-line">#return $fd_out5</span>
                                            }
                                            puts $fd_out5 &#34;!$cfgFileTail&#34;
                                            funlock $fd_out5
                                            close $fd_out5
                                            set DEVREG(active,failcount) 0
                                            <a name="::EmailReportFilesMail(3)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir AUTOLOCKED -mainReturnInfo $mainRet
                                            <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully locked test bed: $cfgFileTail&#34;
                                        }                          
                                    }
                                    while {1} {
                                        incr waitCount 10
                                        puts &#34;$cfgFileTail server waiting $waitCount of 80s after failure&#34;
                                        <span class="comment-line">#puts &#34;Please enter \&#34;restart\&#34; for server to continue immediately&#34;</span>
                                        <span class="comment-line">#gets stdin userBreakInput</span>
                                        <span class="comment-line">#puts &#34;after gets 3&#34;</span>
                                        flush stdout
                                        <span class="comment-line">#puts &#34;after flush 3&#34;</span>
                                        if {$userBreakInput!=&#34;restart&#34; &amp;&amp; $waitCount&lt;80} {sleep 10} else {<a name="::UpdateTimedLockFile(3)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;unlock&#34;;break}
                                    }
                                }
                             } else {
                                 <a name="::WriteToQueueDebug(32)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;NOT IN SUSTAING&#34; &#34;MISSED SUSTAING RERUN $MAIN(queueId) $runningIndex $cfgFileTail&#34;;
                             }
                             <span class="comment-line"># ---------------------- End  Sustaining Download Code --------------------------</span>
                             if {$DEVREG(mysql,UseDb)} {
                                  <a name="::updateRegTestModule(1)"><a href="./mysqlLib.tcl.html#::updateRegTestModule_3678">::updateRegTestModule</a></a> -reg_id $MAIN(reg_id) -name $modName -status &#34;reRun&#34;
                             }
                             <a name="::UpdateTrackDB(13)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: ReRun $modName&#34; -status &#34;green&#34; \
                                    -teefile &#34;/tmp/Tmp/$MAIN(queueId)[pid]&#34; -testcase &#34;&#34; -qid &#34;$MAIN(queueId)&#34;
                             global mainRetReRun
                             set mainRetReRun &#34;testCompleted&#34;
                             <a name="::WriteToQueueDebug(33)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;In Fail with Rerun Enabled&#34; &#34;UpdateImagesRerun $MAIN(queueId) $runningIndex $cfgFileTail&#34;;
                             catch {<a name="::UpdateImagesRerun(1)"><a href="./queueLib.tcl.html#::UpdateImagesRerun_3076">::UpdateImagesRerun</a></a> $MAIN(queueId) $runningIndex $cfgFileTail} w
                             set dirList [glob -nocomplain -- &#34;$mainPath/../${myRegPath}/$modName/short/*$MAIN(queueId)*&#34;]
                             if {$modName==&#34;epm&#34;} {
                                 set platformtorunon [string tolower $uInput(platformToRunOn:)]Image:
                                 set uInput($modName,value:) &#34;$uInput($platformtorunon)&#34;
                             }
                             if {[info exists uInput($modName,value:)]} {
                                set moduleArg $uInput($modName,value:)
                                if {[info exists uInput(relInfo:)] &amp;&amp; $uInput(relInfo:) != &#34;&#34; \
                                        &amp;&amp; [regexp -- $uInput(relInfo:) $DEVREG(server,relInfoList)]} {
                                    if {!$skipMysqlAutomate} {
                                       <a name="::WriteToQueueDebug(34)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MysqlMain: uInput($modName,value:) EXISTS - \
                                         regexp releases in uInput(relInfo:)&#34; \
                                         &#34;mysqlMain.tcl -regId $MAIN(queueId) -mode auto -qId $MAIN(queueId) -TrafficGen $tgen \
                                         -debugLevel $dbg -rerun yes -module $modName -moduleArg $moduleArg -verCheck n  -harness all \
                                         -platform $MAIN(runRegPlatform) -sustaining $goodSustaining -cfg $DEVREG(server,CFG_PATH)/$cfg&#34;
                                       set mydir [pwd]
                                       cd $mainPath
                                       catch {exec ./mysqlMain.tcl -regId $MAIN(queueId) -mode auto -qId $MAIN(queueId) -TrafficGen $tgen \
                                         -debugLevel $dbg -rerun yes -module $modName -moduleArg $moduleArg -verCheck n \
                                         -platform $MAIN(runRegPlatform) -sustaining $goodSustaining -harness all \
                                         -cfg $DEVREG(server,CFG_PATH)/$cfg  &gt;@stdout | \
                                         busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRetReRun
                                       cd $mydir
                                   }
                                } else {
                                   if {!$skipMysqlAutomate} {
                                       <a name="::WriteToQueueDebug(35)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MysqlMain: uInput($modName,value:) EXISTS - \
                                         NOT regexp releases in uInput(relInfo:)&#34; \
                                         &#34;mysqlMain.tcl -regId $MAIN(queueId) -mode auto -debugLevel $dbg -qId $MAIN(queueId) \
                                         -rerun yes -module $modName -moduleArg $moduleArg -verCheck n -TrafficGen $tgen \
                                         -platform $MAIN(runRegPlatform) -sustaining $goodSustaining -harness all \
                                         -efence $efenceProcessList -cfg $DEVREG(server,CFG_PATH)/$cfg&#34;
        
                                       catch {exec $env(BASE_PATH)/../main/mysqlMain.tcl -regId $MAIN(queueId) -mode auto -debugLevel $dbg \
                                         -rerun yes -module $modName -moduleArg $moduleArg -verCheck n -qId $MAIN(queueId) \
                                         -platform $MAIN(runRegPlatform) -sustaining $goodSustaining -TrafficGen $tgen -harness all \
                                         -efence $efenceProcessList -cfg $DEVREG(server,CFG_PATH)/$cfg &gt;@stdout | \
                                         busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRetReRun
                                    }
                                }
                            } else {
                               if {[info exists uInput(relInfo:)] &amp;&amp; $uInput(relInfo:) != &#34;&#34; \
                                    &amp;&amp; [regexp -- $uInput(relInfo:) $DEVREG(server,relInfoList)]} {
                                    if {!$skipMysqlAutomate} {
                                       <a name="::WriteToQueueDebug(36)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MysqlMain: uInput($modName,value:) NOT EXISTS - \
                                         regexp releases in uInput(relInfo:)&#34; \
                                         &#34;mysqlMain.tcl -regId $MAIN(queueId) -mode auto -qId $MAIN(queueId) -sustaining $goodSustaining \
                                         -debugLevel $dbg -rerun yes -module $modName -verCheck n -TrafficGen $tgen \
                                         -platform $MAIN(runRegPlatform) -harness all \
                                         -cfg $DEVREG(server,CFG_PATH)/$cfg&#34;
                                       set mydir [pwd]
                                       cd $mainPath
                                       catch {exec ./mysqlMain.tcl -regId $MAIN(queueId) -mode auto -qId $MAIN(queueId) \
                                         -debugLevel $dbg -rerun yes -module $modName -verCheck n -TrafficGen $tgen \
                                         -platform $MAIN(runRegPlatform) -sustaining $goodSustaining -harness all \
                                         -cfg $DEVREG(server,CFG_PATH)/$cfg  \
                                         &gt;@stdout | busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRetReRun
                                       cd $mydir
                                   }
                               } else {
                                   set mydir [pwd]
                                   cd $mainPath
                                   if {!$skipMysqlAutomate} {
                                       <a name="::WriteToQueueDebug(37)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;MysqlMain: MysqlMain: uInput($modName,value:) NOT EXISTS - NOT regexp \
                                         releases in uInput(relInfo:)&#34; \
                                         &#34;mysqlMain.tcl -regId $MAIN(queueId) -mode auto -debugLevel $dbg -qId $MAIN(queueId) \
                                         -rerun yes -module $modName -verCheck n -efence $efenceProcessList \
                                         -platform $MAIN(runRegPlatform) -sustaining $goodSustaining -TrafficGen $tgen -harness all \
                                         -cfg $DEVREG(server,CFG_PATH)/$cfg&#34;
                                       catch {exec ./mysqlMain.tcl -regId $MAIN(queueId) -mode auto -debugLevel $dbg \
                                         -rerun yes -module $modName -verCheck n -efence $efenceProcessList \
                                         -platform $MAIN(runRegPlatform) -qId $MAIN(queueId) -sustaining $goodSustaining \
                                         -cfg $DEVREG(server,CFG_PATH)/$cfg -TrafficGen $tgen -harness all \
                                         &gt;@stdout | busybox tee /tmp/Tmp/$MAIN(queueId)[pid]} mainRetReRun
                                   }
                                   cd $mydir
                               }
                            }
                            <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;reRun $MAIN(queueId) $modName mainRetReRun |$mainRetReRun|&#34;
                            set DEVREG(active,inrerun) 1;
                            file delete [lindex $dirList 0]   ;<span class="comment-line"># delete the temp config file from short dir</span>
                            switch -regexp -- $mainRetReRun {
                                &#34;^testCompleted&#34; -
                                &#34;^testSkipped&#34; {
                                   <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;inside reRun testCompleted&#34;
                                   <a name="::WriteToQueueDebug(38)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;In RERUN TestCompleted or Skipped&#34; \
                                     &#34;UpdateImagesDone $MAIN(queueId) $runningIndex PASSedOn$cfgFileTail targetDir&#34;;
                                   catch {<a name="::UpdateImagesDone(2)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex PASSedOn$cfgFileTail targetDir} why
                                   set emailRet [<a name="::EmailReportFilesMail(4)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir PASS -mainReturnInfo $mainRet]
                                   set DEVREG(active,failcount) 0
                                }
                                &#34;child killed: software termination signal&#34; {  ;<span class="comment-line"># Killed signal</span>
                                   <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;inside reRun mainkilled&#34;
                                   <a name="::WriteToQueueDebug(39)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;inside reRun mainkilled&#34; \
                                     &#34;UpdateImagesDone $MAIN(queueId) $runningIndex MainKilledOn$cfgFileTail targetDir&#34;;
                                   catch {<a name="::UpdateImagesDone(3)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex MainKilledOn$cfgFileTail targetDir} why
                                   <a name="::EmailReportFilesMail(5)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir MAINKILLED \
                                                 -uip [array get uInput]  -mainReturnInfo $mainRet
                                }
                                &#34;default&#34; {
                                   <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;inside reRun default with mainRetReRun |$mainRetReRun|&#34;
                                   <a name="::WriteToQueueDebug(40)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;inside reRun default with mainRetReRun |$mainRetReRun|&#34; \
                                     &#34;UpdateImagesDone $MAIN(queueId) $runningIndex MainFailedOn$cfgFileTail targetDir&#34;;
                                   catch {<a name="::UpdateImagesDone(4)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex MainFailedOn$cfgFileTail targetDir} why
                                   <a name="::EmailReportFilesMail(6)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir MAINFAILED -mainReturnInfo $mainRet
                                   set mydir [pwd]
                                   cd $mainPath
                                   if {!$skipMysqlAutomate} {
                                       <a name="::WriteToQueueDebug(41)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;inside reRun default with mainRetReRun |$mainRetReRun|&#34; &#34;mysqlAutomate \
                                         -regId $MAIN(queueId) -reportDir $targetDir -module $modName -regType $myRegPathSmall \
                                         -regSubType $featureSubType -platform $MAIN(runRegPlatform)  -qId $MAIN(queueId) &#34;;
                                       catch {exec ./mysqlAutomate.tcl -regId $MAIN(queueId) -reportDir $targetDir -qId $MAIN(queueId) \
                                         -module $modName -regType $myRegPathSmall -regSubType $featureSubType -platform $MAIN(runRegPlatform) \
                                         -callLocation &#34;regServer: inside reRun default MainFail mainRetReRun $cfg&#34; &gt;@stdout} automateRet
                                   }
                                   cd $mydir
                                   file delete /tmp/Tmp/$MAIN(queueId)[pid]
                                   fconfigure stdin -blocking 1 
                                   set waitCount 0
                                   <a name="::UpdateTimedLockFile(4)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;lock&#34;
                                   <span class="comment-line"># ----------------------------------------------</span>
                                   <span class="comment-line"># Check the failure count to see if a perminant</span>
                                   <span class="comment-line">#   lock should be made.  Use Global</span>
                                   <span class="comment-line">#         DEVREG(server,failsforlock) to hold it</span>
                                   <span class="comment-line"># ----------------------------------------------</span>
                                   incr DEVREG(active,failcount)
                                   if {$DEVREG(active,failcount) &gt;= $DEVREG(server,failsforlock) } {
                                       <span class="comment-line"># -----------------------------------------------------------</span>
                                       <span class="comment-line"># Create a lock file entry</span>
                                       <span class="comment-line"># -----------------------------------------------------------</span>
                                       if {[<a name="::locked(3)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $cfgFileTail]} {
                                          <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The test bed: $cfgFileTail is already locked&#34;
                                       } else {   ;<span class="comment-line"># lock it in $DEVREG(server,lockFile)</span>
                                          if {[set fd_out5 [<a name="::FileOpen(2)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
                                             <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Lock File Open Failed!&#34;
                                             <span class="comment-line">#return $fd_out5</span>
                                          }
                                          puts $fd_out5 &#34;!$cfgFileTail&#34;
                                          funlock $fd_out5
                                          close $fd_out5
                                          set DEVREG(active,failcount) 0
                                          <a name="::EmailReportFilesMail(7)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir AUTOLOCKED -mainReturnInfo $mainRet
                                          <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully locked test bed: $cfgFileTail&#34;
                                       }                          
                                   }
                                   while {1} {
                                      incr waitCount 10
                                      puts &#34;$cfgFileTail server waiting $waitCount of 80 sec after failure&#34;
                                      <span class="comment-line">#puts &#34;Please enter \&#34;restart\&#34; for server to continue immediately&#34;</span>
                                      <span class="comment-line">#gets stdin userBreakInput</span>
                                      <span class="comment-line">#puts &#34;After std in gets 1&#34;</span>
                                      flush stdout
                                      <span class="comment-line">#puts &#34;After flush 1&#34;</span>
                                      if {$userBreakInput!=&#34;restart&#34; &amp;&amp; $waitCount&lt;80} {sleep 10} else {<a name="::UpdateTimedLockFile(5)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;unlock&#34;;break}
                                   }
                                }
                             }
                             unset mainRetReRun
                          }
                       }
                       &#34;child killed: software termination signal&#34; {  ;<span class="comment-line"># Killed signal</span>
                          <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;inside mainkilled&#34;
                          <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Now calling with mainKilled&#34;
                          <a name="::WriteToQueueDebug(42)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;inside Now calling with mainKilled&#34; &#34;UpdateImagesDone $MAIN(queueId) \
                                $runningIndex MainKilledOn$cfgFileTail targetDir&#34;;
                          catch {<a name="::UpdateImagesDone(5)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex MainKilledOn$cfgFileTail targetDir} why
                          <a name="::EmailReportFilesMail(8)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir \
                                  MAINKILLED -uip [array get uInput] -mainReturnInfo $mainRet
                       }
                       &#34;default&#34; {
                          set mydir [pwd]
                          cd $mainPath
                          <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;inside default with mainRet |$mainRet|&#34;
                          <a name="::WriteToQueueDebug(43)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;inside default with mainRet |$mainRet|&#34; &#34;UpdateImagesDone $MAIN(queueId) \
                                $runningIndex MainFailedOn$cfgFileTail targetDir&#34;;
                          catch {<a name="::UpdateImagesDone(6)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex MainFailedOn$cfgFileTail targetDir} why
                          if {!$skipMysqlAutomate} {
                              <a name="::WriteToQueueDebug(44)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;inside default with mainRet |$mainRet|&#34; &#34;mysqlAutomate: \
                                    -regId $MAIN(queueId) -platform $MAIN(runRegPlatform)  -qId $MAIN(queueId) \
                                    -reportDir $targetDir -module $modName -regType $myRegPathSmall -regSubType $featureSubType&#34;;
                              catch {exec ./mysqlAutomate.tcl -regId $MAIN(queueId) \
                                    -reportDir $targetDir -module $modName -regType $myRegPathSmall \
                                    -regSubType $featureSubType -platform $MAIN(runRegPlatform)  -qId $MAIN(queueId) \
                                    -callLocation &#34;regServer: inside default MainFail with mainRet $cfg&#34; &gt;@stdout} automateRet
                          }
                          cd $mydir
                          if {$mainRet!=&#34;tee: write error&#34;} {  ;<span class="comment-line"># Will cause server crash, corner case in situation of killed </span>
                             <a name="::WriteToQueueDebug(45)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Crashed&#34; &#34;tee: write error&#34;
                             <a name="::EmailReportFilesMail(9)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir MAINFAILED -mainReturnInfo $mainRet
                             file delete /tmp/Tmp/$MAIN(queueId)[pid]
                             fconfigure stdin -blocking 1
                          }
                          set waitCount 0
                          <a name="::UpdateTimedLockFile(6)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;lock&#34;
                          <span class="comment-line"># ----------------------------------------------</span>
                          <span class="comment-line"># Check the failure count to see if a perminant</span>
                          <span class="comment-line">#   lock should be made.  Use Global</span>
                          <span class="comment-line">#         DEVREG(server,failsforlock) to hold it</span>
                          <span class="comment-line"># ----------------------------------------------</span>
                          incr DEVREG(active,failcount)
                          if {$DEVREG(active,failcount) &gt;= $DEVREG(server,failsforlock) } {
                              <span class="comment-line"># -----------------------------------------------------------</span>
                              <span class="comment-line"># Create a lock file entry</span>
                              <span class="comment-line"># -----------------------------------------------------------</span>
                              if {[<a name="::locked(4)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $cfgFileTail]} {
                                 <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The test bed: $cfgFileTail is already locked&#34;
                                 <a name="::WriteToQueueDebug(46)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Test Bed Locked&#34; &#34;The test bed: $cfgFileTail is already locked&#34;
                              } else {   ;<span class="comment-line"># lock it in $DEVREG(server,lockFile)</span>
                                 puts &#34;Checking log file&#34;
                                 if {[set fd_out5 [<a name="::FileOpen(3)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
                                    <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Lock File Open Failed!&#34;
                                    <span class="comment-line">#return $fd_out5</span>
                                 }
                                 puts $fd_out5 &#34;!$cfgFileTail&#34;
                                 funlock $fd_out5
                                 close $fd_out5
                                 set DEVREG(active,failcount) 0
                                 <a name="::EmailReportFilesMail(10)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir AUTOLOCKED -mainReturnInfo $mainRet
                                 <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully locked test bed: $cfgFileTail&#34;
                                 <a name="::WriteToQueueDebug(47)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Test Bed Locked&#34; &#34;Successfully locked test bed: $cfgFileTail&#34;
                              }
                          }
                          while {1} {
                             incr waitCount 10
                             puts &#34;$cfgFileTail server waiting $waitCount of 80s after failure&#34;
                             <span class="comment-line">#puts &#34;Please enter \&#34;restart\&#34; for server to continue immediately&#34;</span>
                             flush stdout
                             if {$userBreakInput!=&#34;restart&#34; &amp;&amp; $waitCount&lt;80} {sleep 10} \
                                   else {<a name="::UpdateTimedLockFile(7)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;unlock&#34;;break}
                          }
                       }
                    }
                    if {$lst==$MAIN(queueId)} { ;<span class="comment-line"># cfg specified for lst and tclist file in reg tree</span>
                       <span class="comment-line"># Delete lst file from modName</span>
                       if {[file exists $mainPath/../${myRegPath}/$modName/$MAIN(queueId)]} {
                          file delete $mainPath/../${myRegPath}/$modName/$MAIN(queueId)
                       }
                    }
                    <span class="comment-line"># Delete debug file from modName</span>
                    if {[file exists $mainPath/../${myRegPath}/$modName/$MAIN(queueId).dbg]} {
                       file delete $mainPath/../${myRegPath}/$modName/$MAIN(queueId).dbg
                    }
                }
            } else {
                <span class="comment-line"># Download Fail section</span>
                after 1000
                if {$MAIN(oldQueueId)!=$MAIN(queueId) || $MAIN(oldResD)!=0} {
                    <a name="::WriteToQueueDebug(48)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Fail&#34; &#34;oldQueueId $MAIN(oldQueueId) != MAIN(queueId) $MAIN(queueId) OR $MAIN(oldResD) != 0 CASE&#34;
                    if {![regexp -nocase &#34;child killed: software termination signal&#34; $MAIN(resD)]} {
                        catch {<a name="::UpdateImagesDone(7)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex DownloadFailedOn$cfgFileTail targetDir} why
                        set mydir [pwd]
                        cd $mainPath
                        if {!$skipMysqlAutomate} {
                            catch {exec ./mysqlAutomate.tcl -regId $MAIN(queueId)  -qId $MAIN(queueId) \
                            -reportDir $targetDir -module [lindex $uInput(moduleNames:) $runningIndex] \
                            -regType $myRegPathSmall -regSubType $featureSubType -platform $MAIN(runRegPlatform) \
                            -callLocation &#34;child killed: software termination signal $cfg regServer:&#34; } automateRet
                        }
                        cd $mydir
                    }
                }
                if {[regexp -nocase &#34;child killed: software termination signal&#34; $MAIN(resD)]} {   ;<span class="comment-line"># Killed signal</span>
                    <a name="::WriteToQueueDebug(49)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Fail&#34; &#34;child killed: software termination signal&#34;
                    catch {<a name="::UpdateImagesDone(8)"><a href="./queueLib.tcl.html#::UpdateImagesDone_1169">::UpdateImagesDone</a></a> $MAIN(queueId) $runningIndex DownloadKilledOn$cfgFileTail targetDir} why
                    <a name="::EmailReportFilesMail(11)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir DOWNLOADKILLED \
                                         -uip [array get uInput] -mainReturnInfo $mainRet
                } else {
                    <a name="::WriteToQueueDebug(50)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;Download Fail&#34; &#34;EmailReportFilesMail $MAIN(queueId) $runningIndex $cfgFileTail $targetDir FAIL&#34;
                    <a name="::EmailReportFilesMail(12)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir FAIL -mainReturnInfo $mainRet
                    fconfigure stdin -blocking 1
                    <a name="::UpdateTimedLockFile(8)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;lock&#34;
                    set waitCount 0
                    <span class="comment-line"># ----------------------------------------------</span>
                    <span class="comment-line"># Check the failure count to see if a perminant</span>
                    <span class="comment-line">#   lock should be made.  Use Global</span>
                    <span class="comment-line">#         DEVREG(server,failsforlock) to hold it</span>
                    <span class="comment-line"># ----------------------------------------------</span>
                    incr DEVREG(active,failcount)
                    if {$DEVREG(active,failcount) &gt;= $DEVREG(server,failsforlock) } {
                        <span class="comment-line"># -----------------------------------------------------------</span>
                        <span class="comment-line"># Create a lock file entry</span>
                        <span class="comment-line"># -----------------------------------------------------------</span>
                        if {[<a name="::locked(5)"><a href="./queueLib.tcl.html#::locked_142">::locked</a></a> $cfgFileTail]} {
                            <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The test bed: $cfgFileTail is already locked&#34;
                        } else {   ;<span class="comment-line"># lock it in $DEVREG(server,lockFile)</span>
                            if {[set fd_out5 [<a name="::FileOpen(4)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $DEVREG(server,lockFile) a+]]==-1} {
                                <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Lock File Open Failed!&#34;
                                <span class="comment-line">#return $fd_out5</span>
                            }
                            puts $fd_out5 &#34;!$cfgFileTail&#34;
                            funlock $fd_out5
                            close $fd_out5
                            set DEVREG(active,failcount) 0
                            <a name="::EmailReportFilesMail(13)"><a href="./queueLib.tcl.html#::EmailReportFilesMail_2020">::EmailReportFilesMail</a></a> $MAIN(queueId) $runningIndex $cfgFileTail $targetDir AUTOLOCKED -mainReturnInfo $mainRet
                            <a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully locked test bed: $cfgFileTail&#34;
                        } 
                    }
                    while {1} {
                        <span class="comment-line"># Delay to allow time to take action on the daemon</span>
                        incr waitCount 10
                        puts &#34;$cfgFileTail server waiting $waitCount of 80s after failure&#34;
                        <span class="comment-line">#puts &#34;Please enter \&#34;restart\&#34; for server to continue immediately&#34;</span>
                        <span class="comment-line">#gets stdin userBreakInput</span>
                        <span class="comment-line">#puts &#34;after gets 3&#34;</span>
                        flush stdout
                        <span class="comment-line">#puts &#34;after flush 3&#34;</span>
                        if {$userBreakInput!=&#34;restart&#34; &amp;&amp; $waitCount&lt;80} {sleep 10} else {<a name="::UpdateTimedLockFile(9)"><a href="./queueLib.tcl.html#::UpdateTimedLockFile_3981">::UpdateTimedLockFile</a></a> $cfgFileTail &#34;unlock&#34;;break}
                    }
                }
             }
         }
         
         if {$partnerList != &#34;null&#34;} {
             <span class="comment-line"># Release the lock on the shared queue.</span>
             <a name="::release_lock(2)"><a href="./autolock.tcl.html#::release_lock_141">::release_lock</a></a> $shareId 
             <a name="::verify_release_lock(2)"><a href="./autolock.tcl.html#::verify_release_lock_166">::verify_release_lock</a></a> $shareId
             after 5000
         }
         flush stdout
         if {$uInput(sustaining:) &amp;&amp; $hitSustainingRerun} {
            <span class="comment-line"># Set the old queueid to garbage so that the next module will download code</span>
            set MAIN(oldQueueId) 123
         }
         <a name="::UpdateTrackDB(14)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; \
                   -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
    } elseif {$MAIN(queueId)==0} {
        <span class="comment-line"># Didn't find a queue entry</span>
        <a name="::UpdateIdle(9)"><a href="./queueLib.tcl.html#::UpdateIdle_1510">::UpdateIdle</a></a> $cfgFileTail
        <span class="comment-line"># Release the lock on the shared queue.</span>
        if {$partnerList != &#34;null&#34;} {
            <a name="::release_lock(3)"><a href="./autolock.tcl.html#::release_lock_141">::release_lock</a></a> $shareId
            <a name="::verify_release_lock(3)"><a href="./autolock.tcl.html#::verify_release_lock_166">::verify_release_lock</a></a> $shareId
        }
        if {$partnerList == &#34;null&#34;} {
            if {$poweredOff != 1} {
                for {set i 1} {$i &lt;= 10} {incr i} {
                    <a name="::PowerOffDUT(2)"><a href="./poweroutlet.tcl.html#::PowerOffDUT_983">::PowerOffDUT</a></a> $i &#34;off&#34;
                }
                set poweredOff 1
            }
        }
        if {$DEVREG(active,STILLWAITING) &gt; 60} {
            set DEVREG(active,STILLWAITING) 0
            <a name="::UpdateTrackDB(15)"><a href="./resource_track.tcl.html#::UpdateTrackDB_79">::UpdateTrackDB</a></a> -text &#34;status: Waiting&#34; -status &#34;green&#34; \
                   -teefile &#34;&#34; -testcase &#34;&#34; -qid &#34;&#34;
        } else {
            incr DEVREG(active,STILLWAITING)
        }
        set currSecond [clock format [clock seconds] -format &#34;%S&#34;]
        puts &#34;$cfgFileTail: imagesQueued empty $currSecond&#34;
        flush stdout
    } elseif {$MAIN(queueId)==-1} {
        <span class="comment-line"># Checking for queue entry causing an exception</span>
        exit $MAIN(queueId)
    }
    if {$updRetValue==2} {
        <span class="comment-line"># The foll line will also forcefully delete the local image files</span>
        file delete -force $DEVREG(server,imagesQueuedDir)/$MAIN(queueId)
    }
    after [expr int(rand()*$pollTime)];
    flush stdout
}
<a name="::close_result_file(1)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
