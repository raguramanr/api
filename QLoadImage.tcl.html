<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>QLoadImage.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#QLoadImage.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>QLoadImage.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="QLoadImage.tcl-annot.html">annotations</a> | <a href="QLoadImage.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

package require Tclx

<strong><a name="::::print_usage_5">proc <a href="QLoadImage.tcl-annot.html#::::print_usage">::::print_usage</a></a></strong> {} {
    puts &#34;\r&#34;
    puts {Usage: QLoadImage.tcl -cfg &lt;cfg.cfg&gt; -platformList | -pl &lt;platforms&gt; -platformImageList | -pil &lt;paths&gt; -qId &lt;regQID&gt; -bootrom &lt;bootrom&gt; -partition | -p &lt;pri|sec&gt; -subversion &lt;subversion&gt;}
    puts {      [&lt;cfg&gt;]: f48_std.cfg}
    puts {      [&lt;platformList&gt; | &lt;pl&gt;]: list of platforms ie &#34;summitx onie_x86 bdx &#34;       }
    puts {      [&lt;platformImageList&gt; | &lt;pil&gt;]: list of images &#34;/tftp2/bd10K-12.4.0.20.xos /tftp2/bd10K-12.4.0.20.xos&#34;}
    puts {      [&lt;relmanbuild&gt; | &lt;rmb&gt;]: &#34;30.1.0.20&#34; release-manager build. If database is reachable and builds found download}
    puts {                          platformList and image path are not required. The db and locate image finds them}
    puts {      [&lt;commonPath&gt; | &lt;cp&gt;]: common path for images root /home/autotest-sc/images}
    puts {      [qId]: regression Q ID if any -  SC_######_###### or RTP_######_######}
    puts {      [reboot | r] : yes,y | no,n Default is no}                                                 
    puts {         (Script verifies the platform before download image)}
    puts {      [&lt;bootrom&gt;]: bootver (assume in root of your location share)}
    puts {      [&lt;partition | p] which partition to download to. Default is secondary}
    puts {      [&lt;xmod&gt;]: a list of xmods the need to be downloaded. Just the name 'ssh' '8900diags'}
    puts {      [&lt;randomIndex&gt;] default is unknown .  seed for result directory}
    puts {      [&lt;subversion&gt;]: subversion variable if any, used for private testing}
    puts {          }
    puts {      -------------      Currently supported Platforms s of 2018/03 ------------------}
    puts {         Either image family or rdureg image name supported. }
    puts {         summitx onie_x86 summitlite summit_sibyte i386 aspen everest summitx480  OR  }
    puts {         x480 NWI Jaguar i386 x430 x870 x690 g2stack }
    puts {}
    puts {          }
    puts {         (Typical Usage:) }
    puts {      (./QLoadImage.tcl -cfg exos1243.cfg -platformList &#34;onie_x86 summitx&#34; -platformImageList &#34;/nfsloc/onie.xos /nfsloc/summitx.xos&#34;) | -reboot &lt;yes|no&gt; }
    puts &#34;\r&#34;
}

set tftpServerLogin       &#34;extreme&#34;
set tftpServerPasswd      &#34;extreme&#34;
set tftpServerTftpboot    &#34;/tftpboot&#34;
global xmod MAIN TFTPMOUNT IMAGEFAMILIES xmodPairs xmodDUT DEVREG

<span class="comment-line"># checking command parameters</span>
if {$argc&lt;2} {
    puts &#34;Not enough parameters&#34;
    <a name="::::print_usage(1)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
    exit
}
set LIB_PATH &#34;../Lib&#34;
lappend auto_path $LIB_PATH

source ../Lib/parse_args.tcl
source ../Lib/mainLib.tcl
source ../Lib/downLoadCode.tcl
<span class="comment-line">##################################################################################</span>
<span class="comment-line">#  Parse Args</span>
<span class="comment-line">##################################################################################</span>
<a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> QLoadImage $argv {
    cfg     &#34;NULL&#34;
    platformList	&#34;NULL&#34;
    platformImageList	&#34;NULL&#34;
    pl                  &#34;NULL&#34;
    pil                 &#34;NULL&#34;
    relmanbuild         &#34;NULL&#34;
    rmb                 &#34;NULL&#34;
    commonPath          &#34;NULL&#34;
    cp                  &#34;NULL&#34;
    qId                 &#34;NULL&#34;
    bootrom             &#34;NULL&#34;
    partition           &#34;NULL&#34;
    p                   &#34;NULL&#34;
    xmod                &#34;NULL&#34;
    subversion          &#34;NULL&#34;
    randomIndex         &#34;unknown&#34;
    in                  &#34;sc&#34;
    unc                 &#34;no&#34;
    reboot              &#34;no&#34;
    r                   &#34;NULL&#34;
    build               &#34;NULL&#34;
}
set module &#34;QLoadImage&#34;

puts &#34;QLoadImage.tcl  -cfg $cfg \n \
    -platformList $platformList \n \
    -platformImageList $platformImageList \n \
    -pl $pl \n \
    -pil $pil \n \
    -relmanbuild $relmanbuild \n \
    -rmb $rmb \n \
    -commonPath $commonPath \n \
    -cp $cp \n \
    -qId $qId \n \
    -bootrom $bootrom \n \
    -partition $partition \n \
    -p $p \n \
    -xmod $xmod \n \
    -subversion $subversion \n \
    -randomIndex $randomIndex \n \
    -in $in \n \
    -unc $unc \n \
    -reboot $reboot \n \
    -r $r \n \
    -build $build&#34;

    set harness &#34;tcl&#34;
    set TRYFAILSAFE true
    <a name="::::gen_index(1)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;../Lib&#34;
<span class="comment-line">##################################################################################</span>
<span class="comment-line">#  Source the config files</span>
<span class="comment-line">##################################################################################</span>
    set sourceFile &#34;&#34;
    if [catch {source &#34;../main/runReg.cfg&#34;} rea] {
        puts &#34;*** WARNING: Unable to source queuing system main runReg.cfg:$rea..... ***&#34;
        puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
        exit -1
    }
    if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
        puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
        puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
        exit -1
    }
    if {$cfg != &#34;null&#34;} {
        set sourceFile $cfg
        if {([regexp -nocase &#34;^short&#34; $sourceFile]&amp;&amp;[regexp -nocase {/} $sourceFile]) || \
        [regexp -nocase &#34;^pt&#34; $sourceFile]} {
            set sourceFile [format %s/%s/%s $regType $module $sourceFile]
            set sourceFile [string trim $sourceFile];
            puts &#34;Using config file: ($sourceFile)&#34;
        } elseif {![regexp -nocase &#34;^cfg&#34; $sourceFile] &amp;&amp; ![regexp -nocase {/} $sourceFile]} {
            if {[file exists $sourceFile]==0} {
                set sourceFile [format %s/%s cfg $sourceFile]
                set sourceFile [string trim $sourceFile];
                puts &#34;Using config file: ($sourceFile)&#34;
            }
        }
    }
    if {[file exists $sourceFile] == 0} {
        puts &#34;Cannot find config file: $sourceFile\n&#34;
        exit
    }
    catch {source $sourceFile} reason
    set MAIN(cfg) [file tail $sourceFile]
    set curAutoRoot [<a name="::_setCurrentAutoDir(1)"><a href="./filetools.tcl.html#::_setCurrentAutoDir_149">::_setCurrentAutoDir</a></a>]
    set MAIN(autoRoot) $curAutoRoot;<span class="comment-line"># More portable</span>
    set MAIN(feature_directory) &#34;QLoadImage&#34;
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Set xterm title</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    <a name="::SetTerminalTitle(1)"><a href="./queueLib.tcl.html#::SetTerminalTitle_5146">::SetTerminalTitle</a></a> -add $qId
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Translate shortened names (platformList  &lt;-&gt; pl  etc)</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    if {$pl != &#34;NULL&#34;} {
        set platformList $pl
    }
    if {$pil != &#34;NULL&#34;} {
        set platformImageList $pil
    }
    if {$cp != &#34;NULL&#34;} {
        set commonPath $cp
    }
    if {$rmb != &#34;NULL&#34;} {
        set relmanbuild $rmb
    }
    if {$relmanbuild != &#34;NULL&#34;} {
        set build $relmanbuild
    }
    <span class="comment-line"># We will use bootPart as the partition that needs to be loaded for image to download</span>
    <span class="comment-line">#   targetPart is the location for the image to be downloaded to</span>
    <span class="comment-line">#   In other lib procs partition is the same as bootPart</span>
    if {$p!=&#34;NULL&#34;} {
        set partition $p
    }
    if {[regexp -nocase &#34;sec&#34; $partition]} {
        set bootPart primary
        set targetPart secondary
    } elseif {[regexp -nocase &#34;pri&#34; $partition]} {
        set bootPart secondary
        set targetPart primary
    } else {
        set bootPart primary
        set targetPart secondary
    }
    <span class="comment-line"># Reboot verify and short var setup</span>
    if {$r!=&#34;NULL&#34;} {
        set reboot $r
    }
    set reboot [string tolower $reboot]
    if {[regexp -nocase &#34;y&#34; $reboot]} {
        set reboot &#34;yes&#34;
    } elseif {[regexp -nocase &#34;n&#34; $reboot]} {
        set reboot &#34;no&#34;
    } else {
        set reboot no
    }
    set MAIN(qId) $qId
    set MAIN(reboot) $reboot
    set MAIN(bootPart) $bootPart
    set MAIN(targetPart) $targetPart 
    set MAIN(build) $build
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Get DUT count info</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    _getTestBedNumNodes;<span class="comment-line"># Define MAIN(DUTLIST)  MAIN(NODECOUNT)</span>
    set dut $MAIN(NODECOUNT)

<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Set paths</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    <span class="comment-line"># ----- This is necessary to get an absolute path for logging</span>
    set REG_PATH [pwd]
    set MAIN(REG_PATH) [pwd]
    set MAIN(feature_type) &#34;QLoadImage&#34;;<span class="comment-line">#</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Load expect and source Libraries</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
    log_user 0

    lappend auto_path [file join $env(HOME) &#34;ixia/lib/mpexpr-1.0&#34;]
    lappend auto_path [file join $env(HOME) &#34;ixia/lib/ixTcl1.0&#34;]
    lappend auto_path [file join $env(HOME) &#34;ixia/lib/dp4.0&#34;]

    set auto_path [linsert $auto_path 0 . ]
    <span class="comment-line"># -- Make sure directory structure exists in main folder</span>
    <a name="::_createSupportDirectories(1)"><a href="./filetools.tcl.html#::_createSupportDirectories_50">::_createSupportDirectories</a></a> -dirList &#34;Report Result Tmp Log&#34;

    <a name="::::gen_index(2)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> .

<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Register with tracking db and check for conflicts</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    set MAIN(TrackInit) [<a name="::OpenTrackingPort(1)"><a href="./resource_track.tcl.html#::OpenTrackingPort_7">::OpenTrackingPort</a></a> -cfg &#34;[file tail $cfg]&#34; -script_name &#34;QLoadImage&#34; ]

<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># General variable setup</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    set tStartTime [clock seconds]
    set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
    set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]

    set imageNotFound   0
    set romNotFound     0
    set passCount       0
    set failCount       0
    set skipCount       0
    set testDuration    0
    set testHour        0
    set testMin         0
    set testSec         0
    set resultDir        &#34;NULL&#34;;<span class="comment-line"># NULL forces creation of a new resultDir (also global resultDir)</span>
    set MAIN(RESULTPATH) &#34;Result&#34;
    set MAIN(RESULTDIR)  &#34;null&#34;;<span class="comment-line"># all script results file will be posted here while running</span>
    set MAIN(REPORTDIR)  &#34;null&#34;;<span class="comment-line"># ResultDir is renamed to this at the very end.</span>
    set skipCopy        1
    set numDUT  1
    set ReportLoginError &#34;no&#34;
    set at              &#34;download&#34;

    global currentTestNumber
    set MAIN(CURRENTTESTCASE) QLoadImage
    puts &#34;QLoadImage.tcl CUR DIR: [pwd]&#34;
    <span class="comment-line">#let's create result directory</span>
    <a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> $randomIndex
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Setup input variables based on the args passed in.  </span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    if {$relmanbuild != &#34;NULL&#34;} {
        set flist [<a name="::getCfgFamilies(1)"><a href="./mysqlLib.tcl.html#::getCfgFamilies_1831">::getCfgFamilies</a></a> $MAIN(cfg)]
        set flist [string trim $flist &#34;\{|\}&#34;]
        set flist [split $flist &#34; &#34;]
        puts &#34;flist $flist&#34;
        set platformList &#34;&#34;
        set platformImageList &#34;&#34;
        foreach f $flist {
            lappend platformList $f
            set fp [<a name="::RelManGetImagePath(1)"><a href="./LocateImage.tcl.html#::RelManGetImagePath_243">::RelManGetImagePath</a></a> -buildtag $relmanbuild -family $f]
            lappend platformImageList $fp
            if {[regexp -nocase &#34;invalid&#34; $fp]} {
                puts &#34;Attempt to find family $f on the database go invalid path&#34;
                set errorInfo &#34;&#34;
                puts stderr 1
                flush stderr
                exit 1
            }
        }
    }
    if {$platformList == &#34;NULL&#34; &amp;&amp; $pl == &#34;NULL&#34;} {
        puts &#34;*** WARNING: Both platform list variables can not be empty:$rea..... ***&#34;
        exit -1
    }
    if {$platformImageList == &#34;NULL&#34; &amp;&amp; $pil == &#34;NULL&#34;} {
        puts &#34;*** WARNING: Both platform image path lists variables can not be empty:$rea..... ***&#34;
        exit -1
    }
    set xmodString &#34;&#34;
    set MAIN(DOWNLOADXMODS) 0
    if {$xmod != &#34;NULL&#34;} {
        set xmodString &#34;Xmods to Load: &#34;
        puts &#34;We are loading xmods along with the xos images&#34;
        set MAIN(DOWNLOADXMODS) 1
        foreach xm $xmod {
            append xmodString &#34;$xm &#34;
        }
    }
   
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Setup download specific variables.</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    if {[llength $platformList] &lt; 1} {
        puts &#34;*** WARNING: The platform list is empty.  Enter ..... ***&#34;
        exit -1
    }
    if {[llength $platformImageList] &lt; 1} {
        puts &#34;*** WARNING: The platform image path list is empty.  You must enter the ..... ***&#34;
        exit -1
    }
    if {[llength $platformImageList] != [llength $platformList]} {
        puts &#34;*** WARNING: The platform image path list MUST equal the platform list  ..... ***&#34;
        exit -1
    }
    foreach pFile $platformImageList {
        if {![file exists $pFile]} {
            puts &#34;*** WARNING: File $pFile does not exist.  It cannot be downloaded  ..... ***&#34;
            exit -1
        }
    }
    <span class="comment-line"># -------------------------------------------------------------------</span>
    <span class="comment-line"># The section adds vpex and vpexonie platforms with the same image </span>
    <span class="comment-line">#   path as summitx and onie_x86 if they are not included.</span>
    <span class="comment-line"># The same for adding summitx and onie if the vpex are called and the</span>
    <span class="comment-line">#   files are not lst files.</span>
    <span class="comment-line"># -------------------------------------------------------------------</span>
    set hitvpex 0
    set hitvpexonie 0
    set hitsummit 0
    set hitonie 0
    foreach p $platformList {
        if {[lsearch $IMAGEFAMILYPLATFORMS(summitx) $p]&gt;=0} {
            set hitsummit 1
        }
        if {[lsearch $IMAGEFAMILYPLATFORMS(summitx_lst) $p]&gt;=0} {
            set hitvpex 1
        }
        if {[lsearch $IMAGEFAMILYPLATFORMS(onie_x86) $p]&gt;=0} {
            set hitonie 1
        }
        if {[lsearch $IMAGEFAMILYPLATFORMS(onie_x86_lst) $p]&gt;=0} {
            set hitvpexonie 1
        }

    }
    foreach p $platformList {
        if {[lsearch $DEVREG(server,allPlatforms) $p] &lt; 0 &amp;&amp; [lsearch $IMAGEFAMILIES $p] &lt; 0} {
            puts &#34;*** WARNING: $p is not a legal platform OR image family.  ..... ***&#34;
            exit -1
        }
        if {[lsearch $DEVREG(server,allPlatforms) $p] &gt;= 0} {
            set first [lindex [split [set $p] &#34;|&#34;] 0]
            set myfam [<a name="::GetImageFamilyFromSysType(1)"><a href="./platform.tcl.html#::GetImageFamilyFromSysType_580">::GetImageFamilyFromSysType</a></a> $first]
        } elseif {[lsearch $IMAGEFAMILIES $p] &gt;= 0} {
            set myfam $p
        } else {
            puts &#34;Error p $p is neither a platform or image family&#34;
        }
        set myi [lsearch $platformList $p]
        set myFile [lindex $platformImageList $myi]
        if {$myfam == &#34;summitx&#34; &amp;&amp; !$hitvpex} {
            lappend platformList summitx_lst
            lappend platformImageList $myFile
            set hitvpex 1
        } elseif {$myfam == &#34;summitx_lst&#34;} {
            set hitvpex 1
        }
        if {$myfam == &#34;onie_x86&#34; &amp;&amp; !$hitvpexonie} {
            lappend platformList onie_x86_lst
            lappend platformImageList $myFile
            set hitvpexonie 1
        } elseif {$myfam == &#34;onie_x86_lst&#34;} {
            set hitvpexonie 1
        }
        if {$myfam == &#34;summitx_lst&#34; &amp;&amp; !$hitsummit &amp;&amp; [regexp -nocase xos $myFile]} {
            lappend platformList summitx
            lappend platformImageList $myFile
            set hitsummit 1
        } elseif {$myfam == &#34;summitx&#34;} {
            set hitsummit 1
        }
        if {$myfam == &#34;onie_x86_lst&#34; &amp;&amp; !$hitonie &amp;&amp; [regexp -nocase xos $myFile]} {
            lappend platformList onie_x86
            lappend platformImageList $myFile
            set hitonie 1
        } elseif {$myfam == &#34;onie_x86&#34;} {
            set hitonie 1
        }
    }
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
puts &#34;\n==================================================================\n\
       Load Image to test bed DUTs\n\
       Platforms: $platformList\n\
       PlatformImages: $platformImageList\n\
       $xmodString\n\
      ==================================================================&#34;
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>

<span class="comment-line">##############################################################################</span>
<span class="comment-line">##  Get information about the DUT</span>
<span class="comment-line">##############################################################################</span>
    set fd_res [<a name="::open_result_file(1)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;Setup&#34;]

    <span class="comment-line"># --------------------------------------------------------</span>
    <span class="comment-line"># Gather DUTs_info variables that are not Software Related</span>
    <span class="comment-line">#   - loop to get the DUT count and build multitask procs</span>
    <span class="comment-line"># --------------------------------------------------------</span>
    <a name="::::_initDUTs_infoArray(1)"><a href="./swConf.tcl.html#::::_initDUTs_infoArray_11">::::_initDUTs_infoArray</a></a>;
    set numDUT $MAIN(NODECOUNT);<span class="comment-line"># _initDUTs_infoArray sets this</span>
    set getInfoList &#34;&#34;
    set pduProcs &#34;&#34;
    set pduList &#34;&#34;
    foreach dut $MAIN(DUTLIST) {
        set DUTs_info(DUT$dut,loginQuick)  10;<span class="comment-line"># set expect timeout to 10 second</span>
        set DUTs_info(DUT$dut,qloadInitLogin) 1;
        set DUTs_info(DUT$dut,imageBooted) &#34;NULL&#34;
        set DUTs_info(DUT$dut,SHOWPROCESSES) 0;
        puts &#34;***** DUT${dut}_CONNECT=[set DUT${dut}_CONNECT] ***** &#34;
        puts &#34;***** numDUT=$dut ***** &#34;
        _SetPartitionVars -dut $dut;<span class="comment-line"># Get port info from cfg file</span>
        if {[<a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0] == 0} {
            <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n!!\n!!\n!!\nCould not pre-check DUT $dut for download.\n\
                  Lets see if powerCycle recovers it\n!!\n!!\n!!&#34;
            lappend pduList &#34;$dut&#34;
            lappend pduProcs &#34;PowerCycleDUT $dut YES false&#34;
            continue;<span class="comment-line"># If device is hung. Hope for powercycler below.</span>
        }
        set DUTs_info(DUT$dut,qloadInitLogin) 0;
        <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable log display&#34;
        <span class="comment-line">#SendACmd &#34;use image $MAIN(bootPart)&#34;</span>
        lappend getInfoList  &#34;_get_HW_DUTs_info -dut $dut -checkOperational 0&#34;
        set DUTs_info(DUT$dut,loginQuick)  10;
    }
    if {[llength $pduList] &gt; 0} {
        <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;-------------- No console on DUT $pduList --------------&#34;
        <a name="::_setShowOutput(1)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt on
        <a name="::MultiTask(1)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $pduProcs
        <a name="::_setShowOutput(2)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    }
    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;-------------- Gather DUT Information --------------&#34;
    <a name="::_setShowOutput(3)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt on
    <a name="::MultiTask(2)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $getInfoList
    <a name="::_setShowOutput(4)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    <a name="::::_printMultiTaskOutput(1)"><a href="./swConf.tcl.html#::::_printMultiTaskOutput_3651">::::_printMultiTaskOutput</a></a>;<span class="comment-line"># show the output in order + in result file</span>
<span class="comment-line"># ----------------------------------------------------------------------------</span>
<span class="comment-line"># Prepare for download.</span>
<span class="comment-line">#    - If PDU+noSkip global  on all DUTs don't check anything..straight to the setup script</span>
<span class="comment-line">#    - If partial PDU or skip - unc all none PDU to bootPart. Then setup script</span>
<span class="comment-line">#</span>
<span class="comment-line"># ----------------------------------------------------------------------------</span>
    foreach dut $MAIN(DUTLIST) {
        set DUTs_info(DUT$dut,loginQuick)  0;
        if {$MAIN(bootPart) == $DUTs_info(DUT$dut,imageBooted)} {
            set wayToBootPart($dut) &#34;null&#34;
        } elseif {[regexp -nocase &#34;sec&#34; $MAIN(bootPart)]} {
            set wayToBootPart($dut) &#34;unconfigSw&#34;
        } elseif {[info exists POWERCYCLE_DUT(1)] &amp;&amp; [info exists SWDEVSERVER] &amp;&amp; $SWDEVSERVER} {
            if {[regexp -nocase &#34;$SKIPPCTOBOOTROM&#34; $DUTs_info(DUT$dut,sysType)]} {
                set wayToBootPart($dut) &#34;unconfigSw&#34;
            } elseif {[info exists SKIPPCTOBOOTROMFLAG] &amp;&amp; $SKIPPCTOBOOTROMFLAG} {
                set wayToBootPart($dut) &#34;unconfigSw&#34;
            } elseif {[info exists swidSwapList]} {
                set wayToBootPart($dut) &#34;setupScript&#34;
            } else {
                set wayToBootPart($dut) &#34;setupScript&#34;
            }
        } else {
            set wayToBootPart($dut) &#34;unconfigSw&#34;
        }
    }
    <span class="comment-line"># ----------------------------------------------------------------------------</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># Run either setupscript or cli unconfigure switch if powercycle not available.</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># ----------------------------------------------------------------------------</span>
    <a name="::::_multiRunSetupScript(1)"><a href="./swConf.tcl.html#::::_multiRunSetupScript_442">::::_multiRunSetupScript</a></a>

    <span class="comment-line"># Old get_DUTs is going away once json version is available... and forked.</span>
    if {[set rc [<a name="::::get_DUTs_info(1)"><a href="./swConf.tcl.html#::::get_DUTs_info_881">::::get_DUTs_info</a></a>]] != 0} {
        <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
        <a name="::close_result_file(1)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;
        return -1;
    }

    <span class="comment-line"># ------------------------------------------------------------------------</span>
    <span class="comment-line"># Verify that all DUTs are on the boot parition</span>
    <span class="comment-line">#      Just in case powercycle to bootrom didn't work</span>
    <span class="comment-line"># ------------------------------------------------------------------------</span>
    set reTryBoot &#34;&#34;
    for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
        if {$MAIN(bootPart) != $DUTs_info(DUT$i,imageBooted)} {
            set wayToBootPart($i) &#34;unconfigSw&#34;
            <a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${i}_CONNECT] -masterCheck 0 -CheckOperational 0
            <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image $MAIN(bootPart)&#34;
            lappend reTryBoot $i
        }
    }
    if {[llength $reTryBoot] &gt; 0} {
        <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUTS $reTryBoot were not on the correct boot partition. Recover.&#34;
        <a name="::::_multiRunSetupScript(2)"><a href="./swConf.tcl.html#::::_multiRunSetupScript_442">::::_multiRunSetupScript</a></a> -dutListIn $reTryBoot
    }

<a name="::close_result_file(2)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;

set fd_res [<a name="::open_result_file(2)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;QLoadImage&#34;]
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Init arrays inwhich platforms (lower) are the keys.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Then:  tftp image from the local regserver path to the tftp server.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Note: for the queueing system /var/spool/regression/imagesQueued/&lt;mod&gt;/file</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
set q 0;
set goodImageHit 0;
set goodXImageHit 0;

<span class="comment-line"># IMAGEFAMILYSYSTYPES($iFamily)  DEVREG(platImageType,$lowerPlat) IMAGEFAMILIES</span>
<span class="comment-line">#  DEVREG(server,allPlatforms)</span>
<span class="comment-line"># Initialize the TftpFile for all supported image Families</span>
foreach ifam $IMAGEFAMILIES {
    set TftpFile($ifam)  &#34;NULL&#34;
    set platType($ifam)  &#34;NULL&#34;
    set XmodPathList($ifam) &#34;&#34;
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># Figure out thePlat from the cfgs</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
set xmodPlatforms &#34;&#34;
set xmodPairs {}
set xmodByPlat(null) &#34;&#34;
for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
    <span class="comment-line">#  Determine if this platform requires the xmods #</span>
    <span class="comment-line">#  The REQUIRED_XMOD variable is set in the common.cfg</span>
    <span class="comment-line">#  In download we do not know which image is going to install</span>
    <span class="comment-line">#  so we will ignore the versions and hope the user passed</span>
    <span class="comment-line">#  in the xmods appropriately</span>
    <span class="comment-line">#  REQUIRED_XMOD(8900diags,SysTypes) $manhattanBlade</span>
    <span class="comment-line">#  REQUIRED_XMOD(8900diags,SupportStartRelease) &#34;16.2&#34;</span>
    <span class="comment-line">#  REQUIRED_XMOD(8900diags,SupportEndRelease) &#34;null&#34;</span>
    set xmodDUT($i) 0
    if {$MAIN(DOWNLOADXMODS)} {
        <span class="comment-line"># -- Loop through submitted platforms to match dut number SysName and hwList</span>
        <span class="comment-line">#      This is required b/c we don't know which duts support the xmod</span>
        foreach thePlat $platformList {
            set thePlatLower [string tolower $thePlat]
            if {[lsearch $DEVREG(server,allPlatforms) $thePlat] &gt;= 0} {
                set imageFam $DEVREG(platImageType,[string tolower $thePlat])
                puts &#34;Convert platform $thePlat to image family $imageFam&#34;
            } elseif {[lsearch $IMAGEFAMILIES $thePlat] &gt;= 0} {
                set imageFam $thePlatLower
            } else {
                puts &#34;Unrecognized image $thePlat: Should be $IMAGEFAMILIES\nOR\n$DEVREG(server,allPlatforms)\n&#34;
                exit;
            }
            <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Searching for xmod download for $thePlat - family $imageFam&#34;
            if {![info exists xmodByPlat($imageFam)]} {
                set xmodByPlat($imageFam) &#34;&#34;
            } 
            if {[lsearch -exact -nocase $DEVREG(server,allPlatforms) $thePlat]&gt;=0 || 
                       [lsearch $IMAGEFAMILIES $thePlat] &gt;= 0} {
                if {[regexp -nocase &#34;$IMAGEFAMILYSYSTYPES($imageFam)&#34; &#34;$DUTs_info(DUT${i},sysType)&#34;]} {
                    <span class="comment-line"># On a DUT that matches rdureg alias, loop through passed xmods </span>
                    <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;XMOD check matched the platform $thePlat / family $imageFam&#34;
                    foreach xm $xmod {
                        <span class="comment-line"># check the hwList and systype to see if xmod should be loaded here</span>
                        if {[regexp -nocase $REQUIRED_XMOD($xm,SysTypes) \
                              $DUTs_info(DUT${i},hwList)] || 
                              [regexp -nocase $REQUIRED_XMOD($xm,SysTypes) \
                              $DUTs_info(DUT${i},platform)]} {
                            <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Enable xmod vars $imageFam $xm&#34;
                            set xmodTftpFiles($imageFam,$xm) &#34;NULL&#34;
                            lappend xmodPlatforms $imageFam
                            lappend xmodByPlat($imageFam) [string trim $xm]
                            lappend xmodPairs &#34;$i $xm&#34;
                            set xmodDUT($i) 1
                        }
                    }
                }
            }
        }
    }
}
<span class="comment-line"># ----------------------------------------------------------------------------</span>
<span class="comment-line"># Match the plats and images and move them to the tftp server</span>
<span class="comment-line"># ----------------------------------------------------------------------------</span>
set q 0
foreach thePlat $platformList {
    set thePlatLower [string tolower $thePlat]
    if {[lsearch $DEVREG(server,allPlatforms) $thePlat] &gt;= 0} {
        set imageFam $DEVREG(platImageType,[string tolower $thePlat])
        puts &#34;Convert platform $thePlat to image family $imageFam&#34;
    } elseif {[lsearch $IMAGEFAMILIES $thePlat] &gt;= 0} {
        set imageFam $thePlat
    } else {
        puts &#34;Unrecognized image $thePlat&#34;
        exit;
    }
    set Md5Sum($imageFam)    0
    set platImage [lindex $platformImageList $q]
    if {[regexp -nocase {\.xos$} [string trim $platImage]]} {
        set platType($imageFam) xos
        set xosFile($imageFam) [string trimright [lindex $platformImageList $q] &#34;.xos&#34;]
    } elseif {[regexp -nocase {\.lst$} [string trim $platImage]]} {
        set platType($imageFam) lst
        set xosFile($imageFam) [string trimright [lindex $platformImageList $q] &#34;.lst&#34;]
    }
    set ImagePath($imageFam) [lindex $platformImageList $q]
    if {$MAIN(DOWNLOADXMODS)} {
        puts &#34;In DUT xmod search&#34;
        foreach xm $xmod {
            if {[info exists xmodByPlat($imageFam)]} {
                if {[lsearch $xmodByPlat($imageFam) [string trim $xm]]&gt;=0} {
                    set xf $xosFile($imageFam)-${xm}.xmod
                    lappend XmodPathList($imageFam) $xm
                    lappend XmodPathList($imageFam) $xf
                    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n@@@\n@@@\nappending xmod XmodPathList($imageFam) \&#34;$xm $xosFile($imageFam)-${xm}.xmod\&#34;&#34;
                }
            } else {
                puts &#34;missed xmod by plat $xm info does not exist for $imageFam&#34;
            }
        }
    }
    <span class="comment-line"># ------------------------------------------------------------------</span>
    <span class="comment-line"># If the file exists, tftp it from the regserver path to tftp server</span>
    <span class="comment-line"># ------------------------------------------------------------------</span>
    if {[file exists $ImagePath($imageFam)]} {
        set tftpFile [file tail $ImagePath($imageFam)]
        set goodImageHit 1;
        set pid [pid]
        set TftpFile($imageFam) [format %d%d$imageFam%s $pid $q $tftpFile]
        set fd_out [open &#34;Tmp/tmp_$pid$tStartTime&#34; &#34;w&#34;];
        puts $fd_out &#34;put $ImagePath($imageFam) $TftpFile($imageFam)&#34;
        puts $fd_out &#34;quit&#34;
        close $fd_out
        <span class="comment-line"># If the tftp server is mounted to this regression server, just cp the file</span>
        if {$TFTPMOUNT != &#34;NULL&#34; &amp;&amp; [file exists $TFTPMOUNT/default_do_not_erase]} {
            if {[catch {exec cp -L $ImagePath($imageFam) $TFTPMOUNT/$TftpFile($imageFam)} reason]} {
                puts &#34;Error to TFTP: Cannot copy $ImagePath($imageFam) to \
                     $TFTPMOUNT/$TftpFile($imageFam) ...$reason&#34;;
                foreach TFTPServerIP $tftpServerList {
                    puts &#34;Putting $ImagePath($imageFam) onto tftp Server $TFTPServerIP \
                           as $TftpFile($imageFam)&#34;
                    if {[catch {exec /usr/bin/tftp $TFTPServerIP &lt; ./Tmp/tmp_$pid$tStartTime} reason]} {
                        puts &#34;error: $reason&#34;
                        <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                        exit -1
                    }
                }                       
            } else {
                puts &#34;Copy $ImagePath($imageFam) to $TFTPMOUNT/$TftpFile($imageFam)&#34;
            }
        } else {
            foreach TFTPServerIP $tftpServerList {
                puts &#34;Putting $ImagePath($imageFam) onto tftp Server $TFTPServerIP as $TftpFile($imageFam)&#34;
                if {[catch {exec /usr/bin/tftp $TFTPServerIP &lt; ./Tmp/tmp_$pid$tStartTime} reason]} {
                    puts &#34;error: $reason&#34;
                    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                    exit -1
                }
            }
        }
        file delete ./Tmp/tmp_$pid$tStartTime
    } else {
        puts &#34;ImagePath($imageFam) $ImagePath($imageFam) does not exist&#34;
        exit -1
    }
    <span class="comment-line"># ------------------------------------------------------------------</span>
    <span class="comment-line"># If the xmod is passed and file exists, tftp it from the regserver path to tftp server</span>
    <span class="comment-line"># ------------------------------------------------------------------</span>
    set xmodSent &#34;&#34;
    if {$MAIN(DOWNLOADXMODS)} {
        puts &#34;Look for xmod source file - list: $XmodPathList($imageFam)&#34;
        foreach {xm XmodPath} $XmodPathList($imageFam) {
            puts &#34;-- xm $xm : XmodPath = $XmodPath&#34;
            set tftpXFile [file tail $XmodPath]
            set goodXImageHit 1;
            set pid [pid]
            set TftpXFile($imageFam) [format %d%d$imageFam%s $pid $q $tftpXFile]
            set xmodTftpFiles($imageFam,$xm) $TftpXFile($imageFam)
            set fd_out [open &#34;Tmp/tmp_X$pid$tStartTime&#34; &#34;w&#34;];
            puts $fd_out &#34;put $XmodPath $TftpXFile($imageFam)&#34;
            puts $fd_out &#34;quit&#34;
            close $fd_out
            <span class="comment-line"># If the tftp server is mounted to this regression server, just cp the file</span>
            if {$TFTPMOUNT != &#34;NULL&#34; &amp;&amp; [file exists $TFTPMOUNT/default_do_not_erase]} {
                if {[catch {exec cp -L $XmodPath \
                           $TFTPMOUNT/$TftpXFile($imageFam)} reason]} {
                    puts &#34;Error to TFTP: Cannot copy $XmodPath to \
                               $TFTPMOUNT/$TftpXFile($imageFam) ...$reason&#34;;
                    foreach TFTPServerIP $tftpServerList {
                        puts &#34;Putting $XmodPath onto tftp Server $TFTPServerIP \
                                    as $TftpXFile($imageFam)&#34;
                        if {[catch {exec /usr/bin/tftp $TFTPServerIP \
                                          &lt; ./Tmp/tmp_X$pid$tStartTime} reason]} {
                            puts &#34;xmod tftp error: $reason&#34;
                            <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                            exit -1
                        }
                    }
                } else {
                    puts &#34;Copy $XmodPath to $TFTPMOUNT/$TftpXFile($imageFam)&#34;
                }
            } else {
                foreach TFTPServerIP $tftpServerList {
                    puts &#34;Putting $XmodPath onto tftp Server \
                               $TFTPServerIP as $TftpXFile($imageFam)&#34;
                    if {[catch {exec /usr/bin/tftp $TFTPServerIP \
                                          &lt; ./Tmp/tmp_X$pid$tStartTime} reason]} {
                        puts &#34;xmod tftp error: $reason&#34;
                        <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                        exit -1
                    }
                }
            }
            file delete ./Tmp/tmp_X$pid$tStartTime
        }
    } elseif {$MAIN(DOWNLOADXMODS) &amp;&amp; [llength $xmodPlatforms] == 0} {
        puts &#34;XmodPath $XmodPath does not exist&#34;
        <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
        exit -1
    }
    incr q
}
puts &#34;@@@@\n@@@@\nALL FILE COPIES SHOULD BE DONE NOW\n@@@@\n@@@@&#34;
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Do some prep for download:</span>
<span class="comment-line">#   Match image families passed in to DUT sysType</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
    global DUT${i}_Stacking_msma_slot;<span class="comment-line"># For determining if Stack</span>
    set DUTs_info(DUT$i,filetodownload) &#34;NULL&#34;
    set DUTs_info(DUT$i,fileToVerify)   &#34;NULL&#34;
    set DUTs_info(DUT$i,bpeFileToVerify) &#34;NULL&#34;
    <span class="comment-line"># image family of THIS DUT</span>
    set dutImageFamily [<a name="::GetImageFamilyFromSysType(2)"><a href="./platform.tcl.html#::GetImageFamilyFromSysType_580">::GetImageFamilyFromSysType</a></a> $DUTs_info(DUT$i,sysType)]
    <span class="comment-line"># ---------------------------------------------------</span>
    <span class="comment-line"># Special cases that change the imageFamily go here</span>
    <span class="comment-line"># ---------------------------------------------------</span>
    if {[info exists DUT${i}_Stacking_msma_slot] &amp;&amp; [set DUT${i}_Stacking_msma_slot] &gt; 0} {
        if {[regexp -nocase &#34;480&#34; $DUTs_info(DUT$i,hwList)]} {
            set dutImageFamily summitx480
        }
    }

    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n#####--------! ! ! ! ! ! ! ! ! ! ! ! ! -------#######\n\
                      Platform for DUT$i is $DUTs_info(DUT$i,platform) -- $DUTs_info(DUT$i,sysType)&#34;
    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nAssigning DUT$i image to $dutImageFamily :\n\
                      $TftpFile($dutImageFamily)&#34;
    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------------------------------------------#######&#34;
    <span class="comment-line">#</span>
    <span class="comment-line"># Set the per DUT main image download variables</span>
    <span class="comment-line">#</span>
    if {$platType($dutImageFamily) == &#34;lst&#34;} {
        set DUTs_info(DUT$i,filetodownload) $TftpFile($dutImageFamily)
        if {[catch {exec tar -tf $ImagePath($dutImageFamily)} out]} {
            puts &#34;\n@@\n@@\nFailed to inspect the tar file\n$out\n@@\n@@&#34;
        } else {
            set lines [split $out &#34;\n&#34;]
            foreach line $lines {
                if {[regexp -nocase &#34;vpex&#34; $line]} {
                    puts &#34;Setting BPE verify to [file tail $line]&#34;
                    set DUTs_info(DUT$i,bpeFileToVerify) [file tail $line]
                } elseif {[regexp -nocase &#34;xos&#34; $line]} {
                    puts &#34;Setting lst xos to verify [file tail $line]&#34;
                    set DUTs_info(DUT$i,fileToVerify) [file tail $line]
                } else {
                    puts &#34;No need to verify [file tail $line]&#34;
                }
            }
        }
    } else {
        set DUTs_info(DUT$i,filetodownload) $TftpFile($dutImageFamily)
        set DUTs_info(DUT$i,fileToVerify) $TftpFile($dutImageFamily)
    }

    if {$xmodDUT($i)} {
        <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n#####------------------------------------------#######&#34;
        foreach xmPart $xmodPairs {
            <span class="comment-line"># if index 0 is not equal to this dut continue</span>
            if {[lindex $xmPart 0] != $i} {continue;}
            set xm [lindex $xmPart 1]
            <span class="comment-line"># set xmodFile $xosFile($dutImageFamily)-${xm}.xmod</span>
            set xmodFile $xmodTftpFiles($dutImageFamily,$xm)
            set DUTs_info(DUT$i,${xm}_imagename) $xmodFile
            <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34; XMOD $DUTs_info(DUT$i,${xm}_imagename)&#34;
        }
        <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------------------------------------------#######&#34;
    }
    lappend multiDownList &#34;_qloadSingleDut -dut $i&#34;
}

<span class="comment-line">##############################################################################</span>
<span class="comment-line">##############################################################################</span>
;<span class="comment-line"># create the report directory</span>
set optionalPath &#34;&#34;
<a name="::create_report_directory(1)"><a href="./result.tcl.html#::create_report_directory_890">::create_report_directory</a></a> $sourceFile yes $optionalPath &#34;&#34; $subversion $qId

if {$imageNotFound||$romNotFound} {
    set dlOK 1
} else {
    puts &#34;\nDownload the tftpimage $multiDownList\n&#34;
    <a name="::_setShowOutput(5)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log off -res_fmt on
    <a name="::MultiTask(3)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $multiDownList
    <a name="::_setShowOutput(6)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    <a name="::::_printMultiTaskOutput(2)"><a href="./swConf.tcl.html#::::_printMultiTaskOutput_3651">::::_printMultiTaskOutput</a></a>;<span class="comment-line"># show the output in order + in result file</span>
}

<span class="comment-line">#   _setMultiTaskVar DUTs_info(DUT$dut,dlReqD) 0</span>
<span class="comment-line">#   _setMultiTaskVar DUTs_info(DUT$dut,qloadStatus) 1</span>


set passCheck 1
for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
    if {$DUTs_info(DUT$i,filetodownload) == &#34;NULL&#34;} {continue;}
    set showSwitchOutput &#34;&#34;
    <a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${i}_CONNECT] -masterCheck 0 -CheckOperational 0
    lappend showSwitchOutput &#34;{Slot.*$targetPart|Switch.*$targetPart|MM.*$targetPart|MSM.*$targetPart} \
                  {$DUTs_info(DUT$i,fileToVerify)} inLine exists&#34;
    if {$xmodDUT($i)} {
        foreach xmPart $xmodPairs {
            <span class="comment-line"># if index 0 is not equal to this dut break</span>
            if {[lindex $xmPart 0] != $i} {continue;}
            set xm [lindex $xmPart 1]
            <span class="comment-line">#DUTs_info(DUT$i,${xm}_imagename)</span>
            lappend showSwitchOutput &#34;{Slot.*$targetPart|Switch.*\
               $targetPart|MM.*$targetPart|MSM.*$targetPart} \
               {$DUTs_info(DUT$i,${xm}_imagename)} inLine exists&#34;
        }
    }
    if {$DUTs_info(DUT$i,bpeFileToVerify) != &#34;NULL&#34;} {
        lappend showSwitchOutput &#34;{Slot.*$targetPart|Switch.*\
           $targetPart|MM.*$targetPart|MSM.*$targetPart} \
           {$DUTs_info(DUT$i,bpeFileToVerify)} inLine exists&#34;        
    }
    if {[<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show version image&#34; $showSwitchOutput -time {s: 1 i: 3 d: 8 f: 8 r} -comment \
              &#34;check the partion file name is $DUTs_info(DUT$i,filetodownload)&#34;]==&#34;error&#34;} {
        set passCheck 0
    }
    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable log display&#34;
}

if { $reboot == &#34;yes&#34; &amp;&amp; $passCheck } {
    for { set i 1 } { $i &lt;= $dut } {incr i } {
        <a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set i]\_CONNECT]
        if {[regexp -nocase &#34;pri&#34; $targetPart]} {
            <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image pri&#34;
        } else {
            <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image sec&#34;
        }
    }
    set rebootList &#34;&#34;
    for { set i 1 } { $i &lt;= $dut } {incr i } {
        <a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set i]\_CONNECT]
        lappend rebootList &#34;CheckReboot $i -masterCheck 0 -save no&#34;
    }
    <a name="::MultiTask(4)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $rebootList
    <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking the partition and image installed.&#34;

    for { set i 1 } { $i &lt;= $dut } {incr i } {
        <a name="::Login(6)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set i]\_CONNECT]
        <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show switch&#34;
    }
}
<span class="comment-line"># --------------------------------------------------------------------------------------------</span>
<span class="comment-line"># Remove files from tftp -- removed as another point of failure and cronjob cleans tftpserver</span>
<span class="comment-line"># --------------------------------------------------------------------------------------------</span>

<span class="comment-line"># Verify that the images downloaded correctly.</span>

sleep 5
if {!$passCheck} {
    <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
    set dlOK 1
} else {
    <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Download via QLoadImage PASSED&#34;
    set dlOK 0
}

set tEndTime [clock seconds]
set testDuration [expr $tEndTime-$tStartTime]
set testSec  [expr $testDuration % 60]
set testMin  [expr $testDuration / 60]
set testHour [expr $testMin / 60]
set testMin  [expr $testMin % 60]

<a name="::close_result_file(3)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>

<span class="comment-line">#create_report_directory $sourceFile yes $optionalPath &#34;&#34; $subversion $qId</span>
<a name="::gen_text_report(1)"><a href="./report.tcl.html#::gen_text_report_602">::gen_text_report</a></a> &#34;[<a name="::get_result_dir(2)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> { $randomIndex }]/report.exr&#34; &#34;stdout&#34; &#34;[file tail [pwd]]&#34; $sourceFile

<span class="comment-line">#move the complete result directory to report directory</span>
<a name="::move_result_directory(1)"><a href="./result.tcl.html#::move_result_directory_1006">::move_result_directory</a></a>
<a name="::TrackingCleanup(1)"><a href="./resource_track.tcl.html#::TrackingCleanup_70">::TrackingCleanup</a></a>

puts &#34;\n\n*** Time for Downloading $cfg Code = $testDuration seconds - Returning Download Status: $dlOK&#34;
puts &#34;***    ( $testHour hours, $testMin minutes, $testSec seconds )\n\n&#34;

set errorInfo &#34;&#34;
puts stderr $dlOK
flush stderr

exit $dlOK
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
