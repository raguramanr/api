<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>CLIFileParser.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#CLIFileParser.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>CLIFileParser.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="CLIFileParser.tcl-annot.html">annotations</a> | <a href="CLIFileParser.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: LoadCLIFile   </span>
<span class="comment-line"># Description: Loads a .cli file into the parser with tcl list scheme</span>
<span class="comment-line"># Input args: a file name normally with .cli extension </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#         LoadCLIFile xxxxx.cli</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::LoadCLIFile_11">proc <a href="CLIFileParser.tcl-annot.html#::::LoadCLIFile">::::LoadCLIFile</a></a></strong> {filename} {
   set fd_in [open &#34;$filename&#34; &#34;r&#34;]   
   while {[gets $fd_in line] != -1} {
      <span class="comment-line">#result_debug &#34;----- Line=|$line|&#34;</span>
      if {([string length $line] &gt; 1) &amp;&amp; ([string trim $line &#34; \t&#34;] != &#34;&#34; ) } {
         if {[regexp -nocase &#34;Get.*CLIPort|GetVrString&#34; $line]} {
            set line [subst $line]
         }
         lappend mainList $line
      }
   } 
   close $fd_in
   return $mainList
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetGroupList   </span>
<span class="comment-line"># Description: Retrieve a group of CLI lists(lines) till a cmd keyword     </span>
<span class="comment-line"># Input args: CLIList listLength indexName</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#	 set groupList [GetGroupList $CLIList $listLength index]</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetGroupList_35">proc <a href="CLIFileParser.tcl-annot.html#::::GetGroupList">::::GetGroupList</a></a></strong> {CLIList listLength indexName} {
upvar $indexName index

set groupList &#34;&#34;
set line [lindex $CLIList $index]
lappend groupList $line
incr index
<span class="comment-line"># -- get all the lines until Command or ShowCLI keyword</span>
for {set i $index} {$i &lt; $listLength } {incr i} {
   set line [lindex $CLIList $i]
   if {[<a name="::IsInKeywordList(1)"><a href="./CLIFileParser.tcl.html#::IsInKeywordList_71">::IsInKeywordList</a></a> $line] } { 
      set index $i
      return $groupList
   }
   set line $line;
   lappend groupList $line
}
set index $i
return $groupList
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: IsInKeywordList   </span>
<span class="comment-line"># Description: Return 1 if Command: is in the line </span>
<span class="comment-line">#              Return 1 if ShowCLI: is in the line</span>
<span class="comment-line">#              Return 1 if ShowCLI_Once: is in the line</span>
<span class="comment-line">#              Return 1 if SendAFile: is in the line</span>
<span class="comment-line">#              Return 1 if DeleteAFile: is in the line</span>
<span class="comment-line">#              Else return 0</span>
<span class="comment-line"># Input args: a string line</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Returned vlaue: 1 or 0</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#        IsInKeyWordList $line</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::IsInKeywordList_71">proc <a href="CLIFileParser.tcl-annot.html#::::IsInKeywordList">::::IsInKeywordList</a></a></strong> {line} {

if {[regexp -nocase &#34;command:&#34; $line] } {
   return 1
} elseif {[regexp -nocase &#34;showcli:&#34; $line] } {
   return 1
} elseif {[regexp -nocase &#34;showcli_once:&#34; $line] } {
   return 1
} elseif {[regexp -nocase &#34;sendafile:&#34; $line] } {
   return 1
} elseif {[regexp -nocase &#34;deleteafile:&#34; $line] } {
   return 1
}
return 0
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: FilterCommands   </span>
<span class="comment-line"># Description: Return a list of CLI commands that are filtered</span>
<span class="comment-line">#              based on image version and platform type     </span>
<span class="comment-line"># Input args: CLIList softwareVersion platform verCmds</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#	set filterList [FilterCommands $groupList [GetVersion DUT1 0] [GetPlatform] verCmds]      </span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::FilterCommands_97">proc <a href="CLIFileParser.tcl-annot.html#::::FilterCommands">::::FilterCommands</a></a></strong> {CLIList softwareVersion platform verCmds} {
upvar $verCmds versionBasedCmds
set returnList &#34;&#34;
set verList &#34;&#34;
set platform [string tolower $platform]
set listLength [llength $CLIList]
   <span class="comment-line"># -- get the commands that belong to the test platform and release software </span>
   for {set i 0}  {$i &lt; $listLength} {incr i} {
      set line [lindex $CLIList $i]
      <span class="comment-line">##result_debug &#34;line -- $line&#34;</span>
      if {[regexp -nocase &#34;start_platform&#34; $line] } {
         <span class="comment-line"># -- get the command for tested platform </span>
         if {[info exist platformArray]} {unset platformArray }
         while {1} {
            incr i
            set line [lindex $CLIList $i]
            <span class="comment-line"># -- not account for nested platform and version</span>
            if {[regexp -nocase &#34;end_platform&#34; $line] } {
               puts &#34;platform: $platform&#34;
               if {[info exist platformArray($platform)]} {
                  set platformList $platformArray($platform)
               } elseif {[info exist platformArray(default)]} {
                  set platformList $platformArray(default)               
               } else {
                  <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No platform data found for this platform $platform&#34;
                  set platformList &#34;&#34;               
               }
               puts &#34;platformList: $platformList&#34;
               foreach line $platformList {
                  lappend returnList [string trim $line &#34; \t&#34;]
               }
               break
            }
            set firstword [string tolower [lindex $line 0]]
            if {[regexp -nocase &#34;&lt;.*&gt;&#34; $firstword] } {
               regsub -all {&gt;} $firstword {} platformFound
               regsub -all {&lt;} $platformFound {} platformFound
               regsub -all { } $platformFound {} platformFound
               set platformFound [string tolower $platformFound]
               puts &#34;platform: $platformFound&#34;
            } else {
               if {[info exist platformArray($platformFound)]} {
                  set previousPlatformList $platformArray($platformFound) 
               } else { set previousPlatformList &#34;&#34; }
               lappend previousPlatformList $line
               set platformArray($platformFound) $previousPlatformList
            }
         }
      } elseif {[regexp -nocase &#34;start_version&#34; $line] } {
         <span class="comment-line"># -- get command for the tested release software</span>
         if {[info exist versionArray]} {unset versionArray }   
         <span class="comment-line">##result_debug &#34;CLIList ==&gt; $CLIList&#34;;  </span>
         while {1} {
            incr i
            set line [lindex $CLIList $i]
            if {[regexp -nocase &#34;end_version&#34; $line] } { 
                set rlist [<a name="::Start_Version_Parser(1)"><a href="./CLIParser.tcl.html#::Start_Version_Parser_18">::Start_Version_Parser</a></a> $versionArray];
                foreach command $rlist {         
                    lappend returnList [string trim $command &#34; \t&#34;]
                }               
                break;
            } else {
                lappend versionArray $line;
            }
         }
      } elseif {[regexp -nocase &#34;start_vr&#34; $line] } {
         <span class="comment-line"># -- get command for the tested release software</span>
         if {[info exist vrArray]} {unset versionArray }   
         <span class="comment-line">##result_debug &#34;CLIList ==&gt; $CLIList&#34;;  </span>
         while {1} {
            incr i
            set line [lindex $CLIList $i]
            if {[regexp -nocase &#34;end_vr&#34; $line] } { 
                set rlist [<a name="::Start_VR_Parser(1)"><a href="./CLIParser.tcl.html#::Start_VR_Parser_234">::Start_VR_Parser</a></a> $versionArray];
                foreach command $rlist {         
                    lappend returnList [string trim $command &#34; \t&#34;]
                }               
                break;
            } else {
                lappend vrArray $line;
            }
         }
      } elseif {![<a name="::IsInKeywordList(2)"><a href="./CLIFileParser.tcl.html#::IsInKeywordList_71">::IsInKeywordList</a></a> $line]} {
         lappend returnList [string trimleft $line &#34; \t&#34;]
      }
   }
   <span class="comment-line">##result_debug &#34;returnList = $returnList&#34;;</span>
   return $returnList
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: RunCommandAndCheckCLI   </span>
<span class="comment-line"># Description: Send the CLI commands within Command: group if flag is &#34;true&#34;; </span>
<span class="comment-line">#              and verify the CLI display by using commands in ShowCLI: group.</span>
<span class="comment-line"># Input args: CLIList {flag &#34;true&#34;}</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line"># 	 RunCommandAndCheckCLI $CLIList &#34;false&#34;     </span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::RunCommandAndCheckCLI_197">proc <a href="CLIFileParser.tcl-annot.html#::::RunCommandAndCheckCLI">::::RunCommandAndCheckCLI</a></a></strong> {CLIList {flag &#34;true&#34;}} {
global DUT1_DefaultBlade

set listLength [llength $CLIList]
set index 0
   while {$index &lt; $listLength} {
      set groupList [<a name="::GetGroupList(1)"><a href="./CLIFileParser.tcl.html#::GetGroupList_35">::GetGroupList</a></a> $CLIList $listLength index]
      set keywordLine [lindex $groupList 0]
      <span class="comment-line">##result_debug &#34;groupList = $groupList&#34;      </span>
      <span class="comment-line">##result_debug &#34;keywordLine = $keywordLine&#34;</span>
      <span class="comment-line"># -- process the command and showcli section</span>
      if {[regexp -nocase &#34;Command:&#34; $keywordLine ]} {
         <span class="comment-line">#set versionCommands &#34;&#34;</span>
         set filterCommand [<a name="::FilterCommands(1)"><a href="./CLIFileParser.tcl.html#::FilterCommands_97">::FilterCommands</a></a> $groupList [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 0] [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>] versionCommands]
         <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SendInTheCommand: $filterCommand&#34;
         foreach CLICommand $filterCommand {
            if {[string range $CLICommand 0 0] == &#34;#&#34; } {
               puts &#34;$CLICommand&#34;
            } elseif {[regexp -nocase &#34;sleep*&#34; $CLICommand] } {           
              set wait [lindex $CLICommand 1]
              <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping for $wait seconds&#34;
              sleep $wait
            } else {
               <span class="comment-line"># -- check for platform dependent</span>
               if {[regexp -nocase &#34;&lt;.*&gt;&#34; $CLICommand] } {
                  regsub -all {&gt;} $CLICommand {} CLICommand
                  switch -regexp [<a name="::GetPlatform(2)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>] {
                     &#34;BD&#34; -
                     &#34;XCM*&#34; {set blade &#34;$DUT1_DefaultBlade:&#34; }
                     &#34;Asp*&#34; {set blade &#34;$DUT1_DefaultBlade:&#34; }
                     &#34;Summit*&#34; {set blade &#34;&#34; }
                     default {set blade &#34;&#34; }
                  }
                  regsub -all {&lt;} $CLICommand $blade CLICommand            
               }        
               if { $flag == &#34;true&#34; } { 
                  <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> $CLICommand
               } else { puts &#34;$CLICommand&#34; }           
            }
         }
      } elseif {[regexp -nocase &#34;ShowCLI:&#34; $keywordLine ]} {
         <span class="comment-line">#set versionCommands &#34;&#34;</span>
         set filterList [<a name="::FilterCommands(2)"><a href="./CLIFileParser.tcl.html#::FilterCommands_97">::FilterCommands</a></a> $groupList [<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 0] [<a name="::GetPlatform(3)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>] versionCommands]
         <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;GetTheOutput: $filterList&#34;
         set checkOutput 0
         set checkOutputList &#34;&#34;
         set textBuffer &#34;&#34;
         <span class="comment-line">#set fd_in [open &#34;Tmp/tmp_CheckCLIOutput&#34; &#34;w&#34;]   </span>
         foreach line $filterList {
            <span class="comment-line"># -- check for platform dependent</span>
            if {[regexp -nocase &#34;&lt;.*&gt;&#34; $line] } {
               regsub -all {&gt;} $line {} line
               switch -regexp [<a name="::GetPlatform(4)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>] {
                  &#34;BD&#34; -
                  &#34;XCM*&#34; {set blade &#34;$DUT1_DefaultBlade:&#34; }
                  &#34;Asp*&#34; {set blade &#34;$DUT1_DefaultBlade:&#34; }
                  &#34;Summit*&#34; {set blade &#34;&#34; }
                  default {set blade &#34;&#34; }
               }
               regsub -all {;&lt;|&lt;} $line $blade line 
            }
            <span class="comment-line">#replace parentheses              </span>
            regsub -all {\(} $line {.} line
            regsub -all {\)} $line {.} line
            <span class="comment-line">#replace bracket         </span>
            regsub -all {\[} $line {.} line
            regsub -all {\]} $line {.} line
            if {[string range $line 0 0] == &#34;#&#34; } {
               puts &#34;$line&#34;
            } elseif {[regexp -nocase &#34;sleep*&#34; $line] } {           
              set wait [lindex $line 1]
              <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping for $wait seconds&#34;
              sleep $wait           
            } elseif {[regexp -nocase &#34;OutPut:&#34; $line ]} {
               set checkOutput 1
            } elseif {$checkOutput} {
               <span class="comment-line">#result_debug &#34;--line--&gt; $line&#34;;</span>
               
               if {[string range $line 0 0] == &#34;\{&#34; } {
                  set str [string trimright $line &#34; \}&#34; ]
                  set line [string range $str 1 end]
                  <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Processed Line: $line&#34;
                  lappend checkOutputList $line
               } else {
                  lappend checkOutputList &#34;\{$line\} exist&#34;
               }
               <span class="comment-line">#result_debug &#34;--checkOutputList--&gt; $checkOutputList&#34;;</span>
            } else {
               <span class="comment-line">#SendACmd $line NULL $fd_in</span>
               set textBuffer &#34;$textBuffer {$line}&#34;  
            }
         }
         <span class="comment-line">#close $fd_in  </span>
         <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;&gt;&gt;&gt;textBuffer: $textBuffer&#34;          
         <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;&gt;&gt;&gt;checkOutputList: $checkOutputList&#34;
         foreach line $textBuffer { 
            <a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> $line $checkOutputList -comment &#34;for commands: $line&#34;                     
         }
         <span class="comment-line">#CheckKeyValueShort &#34;Tmp/tmp_CheckCLIOutput&#34; $checkOutputList &#34;for commands: $textBuffer&#34;</span>
      }
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckSkipVersion  </span>
<span class="comment-line"># Description: Check whether to run upload/download test for the loaded </span>
<span class="comment-line">#              CLI file based on a list of vesions in the first line. </span>
<span class="comment-line">#	       If any of the listed versions match DUT's version, the CLI</span>
<span class="comment-line">#	       file will be bypassed the test.</span>
<span class="comment-line"># Input args: firstLine {dutVersion &#34;$DUTs_info(DUT1,version)&#34;}</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#         if {[CheckSkipVersion $1stLine]} {puts &#34;this file is skipped for CLI test&#34;}</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckSkipVersion_312">proc <a href="CLIFileParser.tcl-annot.html#::::CheckSkipVersion">::::CheckSkipVersion</a></a></strong> {firstLine {dutVersion &#34;$DUTs_info(DUT1,version)&#34;}} {

global DUTs_info

  if {[regexp -nocase &#34;skipVersion:&#34; $firstLine] &amp;&amp; \
       [llength $firstLine] &gt; 1 } {
      set versionList [lrange $firstLine 1 end]
      regsub -all {[\.bBvV]} $dutVersion &#34; &#34; dutVersion
      foreach version $versionList {
                
        if {[regexp -nocase {b[0-9]+\+} $version]} {
          set range &#34;up&#34;
        } elseif {[regexp -nocase {b[0-9]+\-} $version]} {
          set range &#34;down&#34;
        } else {
          set range &#34;exact&#34;
        }
          
        regsub -all {[\.bBvV\+\-]} $version &#34; &#34; version
        switch $range {
          &#34;exact&#34; {set match 1
                   for {set index 0} {$index &lt; [llength $version]} {incr index} {
                      if {[lindex $version $index] != [lindex $dutVersion $index]} {
                         set match  0
                         break
                      }  
                   }
                  }
          &#34;up&#34;    { if { ([lindex $version 0] == [lindex $dutVersion 0]) &amp;&amp; \
                         ([lindex $version 1] == [lindex $dutVersion 1]) &amp;&amp; \
                         ([lindex $version 2] == [lindex $dutVersion 2]) &amp;&amp; \
                         ([lindex $version 3] &lt;= [lindex $dutVersion 3]) } {
                       set match 1
                    } else {
                       set match 0
                    }      
                  }
          &#34;down&#34;  { if { ([lindex $version 0] == [lindex $dutVersion 0]) &amp;&amp; \
                         ([lindex $version 1] == [lindex $dutVersion 1]) &amp;&amp; \
                         ([lindex $version 2] == [lindex $dutVersion 2]) &amp;&amp; \
                         ([lindex $version 3] &gt;= [lindex $dutVersion 3]) } {
                       set match 1
                    } else {
                       set match 0
                    }      
                  }         
        }
             
        if {$match} { break }  
      }
      
      if {$match} { 
 	 return 1
      } else {
         return 0   
      }
  } else {
      return 0
  }  
}  
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
