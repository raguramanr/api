<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>IpxUtil.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#IpxUtil.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>IpxUtil.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="IpxUtil.tcl-annot.html">annotations</a> | <a href="IpxUtil.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetIpxOption</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: This proc is used to get IPXRIP packet options. A number of options are returned</span>
<span class="comment-line">#              based on optionName value</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: rawFrame, optionName</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: list of optionName values or 1 as default</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set routes [GetIpxOption $frame &#34;RouteInfo&#34;]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifyTraffic</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetIpxOption_20">proc <a href="IpxUtil.tcl-annot.html#::::GetIpxOption">::::GetIpxOption</a></a></strong> {rawFrame optionName} {

   set type [string range $rawFrame 36 40]
   <span class="comment-line"># if tagged, get rid of type and tag field from 36 to 47</span>
   if {$type == &#34;81 00&#34;} {
     set leftRawFrame [string range $rawFrame 0 35] 
     set rightRawFrame [string range $rawFrame 48 [string length $rawFrame]] 
     set rawFrame [format &#34;%s%s&#34; $leftRawFrame $rightRawFrame]
   }

   set MessageType [<a name="::GetMessageType(1)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $rawFrame]
   switch -- $optionName {
      &#34;SourceNetwork&#34; {
         switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
            <span class="comment-line"># ENETII &amp; ENET8023</span>
               return [string range $rawFrame 96 106]
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               return [string range $rawFrame 105 115]
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line">#ENETSNAP</span>
               return [string range $rawFrame 120 130]
            } default {
               return 1
            }
         }
      }
      &#34;SourceNode&#34; {
         switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
            <span class="comment-line"># ENETII &amp; ENET8023</span>
               return [string range $rawFrame 108 124]
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               return [string range $rawFrame 117 133]
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line">#ENETSNAP</span>
               return [string range $rawFrame 132 148]
            } default {
               return 1
            }
         }
      }
      &#34;SourceSocket&#34; {
            switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
            <span class="comment-line"># ENETII &amp; ENET8023</span>
               return [string range $rawFrame 126 130]
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               return [string range $rawFrame 135 139]
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line">#ENETSNAP</span>
               return [string range $rawFrame 150 154]
            } default {
               return 1
            }
         }
      } &#34;DestNetwork&#34; {
         switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
            <span class="comment-line"># ENETII &amp; ENET8023</span>
               return [string range $rawFrame 60 70]
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               return [string range $rawFrame 69 79]
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line">#ENETSNAP</span>
               return [string range $rawFrame 84 94]
            } default {
               return 1
            }
         }
      } &#34;DestNode&#34; {
         switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
            <span class="comment-line"># ENETII &amp; ENET8023</span>
               return [string range $rawFrame 72 88]
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               return [string range $rawFrame 81 97]
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line">#ENETSNAP</span>
               return [string range $rawFrame 96 112]
            } default {
               return 1
            }
         }
      } &#34;DestSocket&#34; {
            switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
            <span class="comment-line"># ENETII &amp; ENET8023</span>
               return [string range $rawFrame 90 94]
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               return [string range $rawFrame 99 103]
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line">#ENETSNAP</span>
               return [string range $rawFrame 114 118]
            } default {
               return 1
            }
         }
      } default {
         <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unknown optionName supplied: $optionName&#34;
         <span class="comment-line">#just return the type</span>
         return 1
      } &#34;RouteInfo&#34; {
         switch -glob -- $MessageType {
            &#34;ENETII_IPXRIP_REQUEST&#34; -
            &#34;ENETII_IPXRIP_REPLY&#34; -
            &#34;ENETII_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP&#34; -
            &#34;ENET8023_IPXRIP_REQUEST&#34; -
            &#34;ENET8023_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENETII &amp; ENET8023</span>
               set startLoc 138
               set numToCount 22
            } &#34;ENET8022_IPXRIP_REQUEST&#34; -
              &#34;ENET_8022_IPXRIP&#34; -
              &#34;ENET8022_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENET8022</span>
               set startLoc 147
               set numToCount 22
            } &#34;ENETSNAP_IPXRIP_REQUEST&#34; -
              &#34;ENETSNAP_IPXRIP&#34; -
              &#34;ENETSNAP_IPXRIP_REPLY&#34; {
               <span class="comment-line"># ENETSNAP</span>
               set startLoc 162
               set numToCount 22
            }  &#34;ENETII_IPXSAP&#34; -
               &#34;ENETII_IPXSAP_REPLY&#34; -
               &#34;ENETII_IPXSAP_REQUEST&#34; {
               set startLoc 138
               set numToCount 190
            } &#34;ENET8022_IPXSAP&#34; -
              &#34;ENET8022_IPXSAP_REPLY&#34; -
              &#34;ENET8022_IPXSAP_REQUEST&#34; {
               set startLoc 147
               set numToCount 190
            } &#34;ENET8023_IPXSAP&#34; -
              &#34;ENET8023_IPXSAP_REPLY&#34; -
              &#34;ENET8023_IPXSAP_REQUEST&#34; {
               set startLoc 138
               set numToCount 190
            } &#34;ENETSNAP_IPXSAP&#34; -
              &#34;ENETSNAP_IPXSAP_REPLY&#34; -
              &#34;ENETSNAP_IPXSAP_REQUEST&#34; {
               set startLoc 162
               set numToCount 190
            } default {
<span class="comment-line">#              result_debug &#34;Unknown Type: $type&#34;</span>
               <span class="comment-line">#just return the type</span>
               return 1
            }
         }
         set route &#34;&#34;
         for {set startLoc $startLoc} {[expr $startLoc + $numToCount] &lt; [expr [string length $rawFrame]-12]} {incr startLoc [expr $numToCount + 2]} {
            lappend routes [string range $rawFrame $startLoc [expr $startLoc + $numToCount]]
         }
         return $routes
      }
      &#34;GNSTypeAndName&#34; {
         switch -glob -- $MessageType {
            &#34;ENETII_IPXSAP_GNSREPLY&#34; -
            &#34;ENET8023_IPXSAP_GNSREPLY&#34; {
               set type [string range $rawFrame 138 142]
               set name [string range $rawFrame 144 288]
               regsub -all &#34; &#34; [string trimleft $name &#34; &#34;] &#34;&#34; names
               set server [string range [<a name="::ConvertHexToAscii(1)"><a href="./IpxUtil.tcl.html#::ConvertHexToAscii_916">::ConvertHexToAscii</a></a> &#34;$names&#34;] 0 16]
               return &#34;$type $server&#34;
            }
            &#34;ENET8022_IPXSAP_GNSREPLY&#34; {
               set type [string range $rawFrame 147 151]
               set name [string range $rawFrame 153 297]
               regsub -all &#34; &#34; [string trimleft $name &#34; &#34;] &#34;&#34; names               
               set server [string range [<a name="::ConvertHexToAscii(2)"><a href="./IpxUtil.tcl.html#::ConvertHexToAscii_916">::ConvertHexToAscii</a></a> &#34;$names&#34;] 0 16]
               return &#34;$type $server&#34;
            }
            &#34;ENETSNAP_IPXSAP_GNSREPLY&#34; {
            } default {
<span class="comment-line">#              result_debug &#34;Unknown Type: $type&#34;</span>
               <span class="comment-line">#just return the type</span>
               return 1
            }
         }
      }
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: ixia_SendIpxPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: This internal proc is used to send ipx packets from test equipment</span>
<span class="comment-line">#</span>
<span class="comment-line">#     IMP: Starts ports' capture (startPortsCapture) on rxPortId by default.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: args</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: Stream sent</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#  set frameSent [ixia_SendIpxPackets -direction $direction -txPortId $txPortId -rxPortId $rxPortId \</span>
<span class="comment-line">#              -etherType $etherType -sNetwork $sNetwork -sSocket $sSocket \</span>
<span class="comment-line">#              -dNetwork $dNetwork -dSocket $dSocket -dNode $dNode -rxProto $rxProto \</span>
<span class="comment-line">#              -packetType $packetType -numFrames $numFrames -frameSize $frameSize \</span>
<span class="comment-line">#              -frameRate $frameRate -dataPattern $dataPattern -streamType $streamType \</span>
<span class="comment-line">#              -fcsError $fcsError -wTag $wTag -tagNo $tag -tagCfi $tagCfi \</span>
<span class="comment-line">#              -sourceNodeCounterMode $sourceNodeCounterMode]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: SendTraffic</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ixia_SendIpxPackets_288">proc <a href="IpxUtil.tcl-annot.html#::::ixia_SendIpxPackets">::::ixia_SendIpxPackets</a></a></strong> {args} {
   <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> ixia_SendIpxPackets $args {
      txPortId &#34;1&#34;
      rxPortId &#34;2&#34;
      etherType &#34;ethernetII&#34;
      rxProto &#34;ethernetII&#34;
      sNetwork &#34;00 00 00 00&#34;
      sSocket &#34;0400&#34;
      dNetwork &#34;00 00 00 00&#34;
      sNode &#34;00 00 00 00 00 00&#34;
      dNode &#34;00 00 00 00 00 00&#34;
      dSocket &#34;0400&#34;
      packetType &#34;typeUnknown&#34;
      numFrames &#34;1&#34;
      frameSize &#34;64&#34;
      frameRate &#34;default&#34;
      dataPattern &#34;0000&#34;
      streamType &#34;stopStream&#34;
      fcsError &#34;good&#34;
      direction &#34;1Way&#34;
      wTag &#34;false&#34;
	   tagNo &#34;002&#34;
	   tagCfi &#34;resetCFI&#34;
      tagMode &#34;vIdle&#34;
	   tagRepeat &#34;1&#34;
	   userPriority &#34;0&#34;
      percentage &#34;100&#34;
      priority &#34;0&#34;
      sendLearn &#34;true&#34;
      saMode &#34;idle&#34;
      daMode &#34;idle&#34;
      chid &#34;1&#34;
      enableUdf &#34;false&#34;
      offset &#34;52&#34;
      counterType &#34;c32&#34;
      initVal &#34;08 00&#34;
      destNodeCounterMode &#34;1&#34;
      sourceNodeCounterMode &#34;1&#34;
   }
   
   global spawn_id
   global one2oneArray
   global preambleSize
   global DUTs_info
   global startCardNum
   <a name="::globalSetDefault(1)"><a href="./ePTUtils.tcl.html#::globalSetDefault_1">::globalSetDefault</a></a>
   protocolStackSetDefault
   
   set macBroadcast &#34;FF FF FF FF FF FF&#34;
   set numIxiaCd [<a name="::::GetNumIxiaCd(1)"><a href="./SystemSetup.tcl.html#::::GetNumIxiaCd_546">::::GetNumIxiaCd</a></a> $txPortId]

   <a name="::MapIxiaPortId(1)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId txChas txCard txPort
   if { $rxPortId == 0 } {
      set rxPortId $txPortId
   }
   <a name="::MapIxiaPortId(2)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $rxPortId rxChas rxCard rxPort

   set date [clock format [clock seconds] -format &#34;%m-%d-%Y %I.%M.%S%p&#34;]
   <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n*** date=$date&#34;
   set time1 [clock seconds]
   puts &#34;2nd txPort:$txPort, txCard:$txCard, rxPort:$rxPort, rxCard:$rxCard&#34;

   set patternOffset	32
   set preambleSize 8

   <span class="comment-line"># Create mapping</span>
   <a name="::map(1)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> new -type one2one
   <a name="::map(2)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> config -type one2one
   set txSideGwMac &#34;&#34;
   set rxSideGwMac &#34;&#34;
   if { $sendLearn == &#34;true&#34; } {
      <a name="::map(3)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> add $txChas $txCard $txPort $txChas $txCard $txPort
      learn config -numframes 1   
      <a name="::protocol(1)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -ethernetType $etherType
      <a name="::protocol(2)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -name ipx
      if {([llength $tagNo]&gt;=1) &amp;&amp; ($wTag == &#34;true&#34;)} {
         <a name="::protocol(3)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -enable802dot1qTag $wTag
         <a name="::vlan(1)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID [lindex $tagNo 0]
      } else {
         <a name="::protocol(4)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -enable802dot1qTag false
      }
      <a name="::vlan(2)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set	$txChas $txCard $txPort
      <a name="::stream(1)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> set $txChas $txCard $txPort 1
      <a name="::ClearPortsStats(1)"><a href="./ePTRx.tcl.html#::ClearPortsStats_951">::ClearPortsStats</a></a> &#34;$txPortId&#34;
      <a name="::StartPortsCapture(1)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> &#34;$txPortId&#34;
      catch {send_ripx_frames one2oneArray}
      set capturedFrames [<a name="::GetCapturedFrames(1)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $txPortId]
      set txSideGwMac [<a name="::GetSourceMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetSourceMacAddress_40">::GetSourceMacAddress</a></a> [lindex $capturedFrames 0]]
      <a name="::map(4)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> del $txChas $txCard $txPort $txChas $txCard $txPort
      <a name="::map(5)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> add $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort
      <a name="::protocol(5)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -ethernetType $rxProto
      <a name="::protocol(6)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -name ipx
      if {([llength $tagNo]&gt;1) &amp;&amp; ($wTag == &#34;true&#34;)} {
         <a name="::protocol(7)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -enable802dot1qTag $wTag
         <a name="::vlan(3)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID [lindex $tagNo 1]
      } else {
         <a name="::protocol(8)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -enable802dot1qTag false
      }
      <a name="::vlan(4)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set	$rxChas $rxCard $rxPort
      <a name="::stream(2)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> set $rxChas $rxCard $rxPort 1
      <a name="::ClearPortsStats(2)"><a href="./ePTRx.tcl.html#::ClearPortsStats_951">::ClearPortsStats</a></a> &#34;$rxPortId&#34;
      <a name="::StartPortsCapture(2)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> &#34;$rxPortId&#34;
       catch {send_ripx_frames one2oneArray}
      set capturedFrames [<a name="::GetCapturedFrames(2)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $rxPortId]
      set rxSideGwMac [<a name="::GetSourceMacAddress(2)"><a href="./MessageDecoding.tcl.html#::GetSourceMacAddress_40">::GetSourceMacAddress</a></a> [lindex $capturedFrames 0]]
      <a name="::map(6)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> del $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort      
   }
   if {$txSideGwMac==&#34;&#34;} {
      set txSideGwMac $DUTs_info(DUT1,sysMAC)
   }
   <a name="::map(7)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> add $txChas $txCard $txPort $rxChas $rxCard $rxPort
   if { $direction == &#34;2Way&#34; } {
      <a name="::map(8)"><a href="./ePTClient.tcl.html#::map_366">::map</a></a> add $rxChas $rxCard $rxPort $txChas $txCard $txPort
   }

   <a name="::StartPortsCapture(3)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> &#34;$txPortId&#34;


   <span class="comment-line"># Config streams for validation traffic</span>
   foreach txMap [lsort [array names one2oneArray]] {
      scan $txMap &#34;%d,%d,%d&#34; chid c p
      <a name="::port(1)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> get $chid $c $p
      set txSpeed	[<a name="::port(2)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> cget -speed]
      <a name="::stream(3)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> setDefault
      if {$enableUdf != &#34;false&#34;} {
         <a name="::udf(1)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> setDefault
         if {$etherType==&#34;ieee8022&#34;} {
            <a name="::udf(2)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -enable $enableUdf
            <a name="::udf(3)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset $offset
            <a name="::udf(4)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -countertype $counterType
            <span class="comment-line"># IXIA GBIC did not support</span>
            set udf1InitVal [string range $initVal 0 10]
            set udf2InitVal [string range $initVal 12 13]
            <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the udf1InitVal $udf1InitVal, udf2InitVal $udf2InitVal&#34;
            <a name="::udf(5)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -initval $udf1InitVal
            <a name="::udf(6)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> set 1
            
            <a name="::udf(7)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -enable $enableUdf
            <a name="::udf(8)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset 50
            <a name="::udf(9)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -countertype c8
            <a name="::udf(10)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -initval $udf2InitVal
            <a name="::udf(11)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> set 2
         } else {
            <a name="::udf(12)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -enable $enableUdf
            <a name="::udf(13)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset $offset
            <a name="::udf(14)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -countertype $counterType
            <a name="::udf(15)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -initval $initVal
            <a name="::udf(16)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> set 1
         }
      }

      <a name="::stream(4)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -numFrames $numFrames
      <a name="::stream(5)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -name S_${c}_${p}
      <a name="::stream(6)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -framesize $frameSize
      <a name="::stream(7)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -dma $streamType
      if { $frameRate == &#34;default&#34; } {
         set frameRate [<a name="::decideFrameRate(1)"><a href="./ePTMisc.tcl.html#::decideFrameRate_423">::decideFrameRate</a></a> $txSpeed $frameSize $percentage]
      } else {
         set percentage [<a name="::decidePercentage(1)"><a href="./ePTMisc.tcl.html#::decidePercentage_471">::decidePercentage</a></a> $txSpeed $frameSize $frameRate]
      }
<a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;@@@ frameRate=$frameRate&#34;
      <a name="::stream(8)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -rateMode usePercentRate
      <a name="::stream(9)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -percentPacketRate $percentage

      <span class="comment-line">#set ifg [calculateGap $frameRate $frameSize $preambleSize $txSpeed]</span>
      <a name="::stream(10)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -fcs $fcsError
      <span class="comment-line">#stream config -ifg $ifg</span>
      <span class="comment-line">#stream config -isg $ifg</span>
      <span class="comment-line">#stream config -ibg $ifg</span>
      <a name="::stream(11)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -fir false		;<span class="comment-line"># for timestamp</span>
      <a name="::stream(12)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -dataPattern	userpattern -pattern $dataPattern
      if {$sNode==&#34;00 00 00 00 00 00&#34;} {
         set sNode [<a name="::port(3)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> cget -MacAddress]      
      }
      set rxMap $one2oneArray($txMap)
      scan [join $rxMap] &#34;%d %d %d&#34; rxch rxc rxp
   
      <a name="::port(4)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> get $rxch $rxc $rxp
      set destAddr [<a name="::port(5)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> cget -MacAddress]
      
      <a name="::stream(13)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -saRepeatCounter $saMode
      <a name="::stream(14)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -daRepeatCounter $daMode
      if { $saMode != &#34;idle&#34; } { <a name="::stream(15)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -numSA $numFrames }
      if { $daMode != &#34;idle&#34; } { <a name="::stream(16)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -numDA $numFrames }

      <a name="::stream(17)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -sa $sNode
      if {[string compare &#34;$sNetwork&#34; &#34;$dNetwork&#34;]==0} {
         <a name="::stream(18)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -da $dNode
      } else {
         <a name="::stream(19)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> config -da $txSideGwMac
      }

      <a name="::protocol(9)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> setDefault
	   <a name="::protocol(10)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -ethernetType $etherType
	   <a name="::protocol(11)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -name ipx
	   <a name="::protocol(12)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -enable802dot1qTag $wTag

      <a name="::ipx(1)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> setDefault
      if {($chid == $txChas) &amp;&amp; ($c == $txCard) &amp;&amp; ($p == $txPort) } {
	      <a name="::ipx(2)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -sourceNetwork $sNetwork
<span class="comment-line">#	      ipx config -sourceNetworkMaskSelect	$sNwMask</span>
         <a name="::ipx(3)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -sourceNode $sNode
         <a name="::ipx(4)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -sourceSocket $sSocket
	      <a name="::ipx(5)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -destNetwork $dNetwork
	      <a name="::ipx(6)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -destNode $dNode
         <a name="::ipx(7)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -destSocket $dSocket
	  } else {
         <a name="::ipx(8)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -sourceNetwork $dNetwork
<span class="comment-line">#	      ipx config -sourceNetworkMaskSelect	$dNwMask</span>
         <a name="::ipx(9)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -sourceNode $dNode
         <a name="::ipx(10)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -sourceSocket $dSocket
	      <a name="::ipx(11)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -destNetwork $sNetwork
	      <a name="::ipx(12)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -destNode $sNode
         <a name="::ipx(13)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -destSocket $sSocket
     }
     
     <span class="comment-line"># Put this length override kludge for stupid ixia correct format packet.</span>
<span class="comment-line">#     if {[regexp -nocase &#34;Summit*&#34; [GetPlatform]]} {</span>
<span class="comment-line">#        ipx config -length &#34;43&#34;</span>
<span class="comment-line">#        ipx config -lengthOverride &#34;true&#34;</span>
<span class="comment-line">#     }</span>
     if {$sourceNodeCounterMode&gt;0} {
         <span class="comment-line">## This interface does not work in ixia.</span>
         <span class="comment-line">## own defined udf for incremental sourceNode</span>
         <a name="::udf(17)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> setDefault
         <a name="::udf(18)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -enable $enableUdf
         <a name="::udf(19)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -countertype $counterType
         set LaterPartMac [string range $sNode 6 end]
         if {$etherType == &#34;ethernetII&#34;} {
            <a name="::udf(20)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset 38
         } elseif {$etherType == &#34;ieee8022&#34;} {
            <a name="::udf(21)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset 42
            <a name="::udf(22)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -countertype c24
            set LaterPartMac [string range $sNode 9 end]
         } elseif {$etherType == &#34;ieee8023&#34;} {
            <a name="::udf(23)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset 38
         } elseif {$etherType == &#34;ieee8023snap&#34;} {
            <a name="::udf(24)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -offset 46
         }
         <a name="::udf(25)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -repeat $numFrames
         <a name="::udf(26)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> config -initval $LaterPartMac
         <a name="::udf(27)"><a href="./ePTClient.tcl.html#::udf_2121">::udf</a></a> set 3
         <span class="comment-line">## Ideally following should be used but it has problems</span>
<span class="comment-line">#        puts &#34;the sourceNodeCounterMode:$sourceNodeCounterMode&#34;</span>
<span class="comment-line">#        ipx config -sourceNodeCounterMode $sourceNodeCounterMode</span>
<span class="comment-line">#        ipx config -sourceNodeRepeatCounter $numFrames</span>
     }

<span class="comment-line">#	  ipx config -sourceNetworkCounterMode $sNwRepeatCounterMode</span>
<span class="comment-line">#	  ipx config -sourceNetworkRepeatCounter $sNwRepeatCounter</span>
<span class="comment-line">#	  ipx config -sourceNodeCounterMode $sNoRepeatCounterMode</span>
<span class="comment-line">#	  ipx config -sourceNodeCounterMode $sNoRepeatCounterMode</span>

	  <a name="::ipx(14)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> config -packetType $packetType
	  
	  <a name="::ipx(15)"><a href="./ePTClient.tcl.html#::ipx_1107">::ipx</a></a> set $chid $c $p
	  
     <a name="::vlan(5)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -cfi $tagCfi
     <a name="::vlan(6)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -mode $tagMode
     <a name="::vlan(7)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -repeat $tagRepeat
     <a name="::vlan(8)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -userPriority $userPriority
      
     if {[llength $tagNo] &gt;1} {
        if {[lindex $tagNo 0]!=0} {
           <a name="::vlan(9)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID [lindex $tagNo 0]
           <a name="::vlan(10)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set $txChas $txCard $txPort
        } else {
        	  <a name="::protocol(13)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a> config -enable802dot1qTag false
        }
        <a name="::vlan(11)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID [lindex $tagNo 1]
        <a name="::vlan(12)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set $rxChas $rxCard $rxPort
     } else {
        <a name="::vlan(13)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID [lindex $tagNo 0]
        <a name="::vlan(14)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set $txChas $txCard $txPort
     }
      
     <a name="::stream(20)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> set $chid $c $p 1

     <span class="comment-line">#set packet group to default, otherwise will cause ICMP bad CRC</span>
     packetGroup setDefault						
     packetGroup setTx $chid $c $p 1

     <span class="comment-line"># Define filter &amp; capture</span>
     <a name="::filter(1)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -captureFilterEnable true
     <a name="::filter(2)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -captureTriggerEnable true
     <a name="::filter(3)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -userDefinedStat1Enable true
     <a name="::filter(4)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -userDefinedStat1DA addr1
     <a name="::filter(5)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -captureFilterPattern anyPattern
     <a name="::filter(6)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -captureTriggerPattern anyPattern
     <a name="::filter(7)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -captureTriggerDA anyAddr
     <a name="::filter(8)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> config -captureFilterDA anyAddr
     <a name="::filter(9)"><a href="./ePTClient.tcl.html#::filter_846">::filter</a></a> set $rxch $rxc $rxp

     <a name="::filterPallette(1)"><a href="./ePTClient.tcl.html#::filterPallette_915">::filterPallette</a></a> config -DA1 $destAddr
     <a name="::filterPallette(2)"><a href="./ePTClient.tcl.html#::filterPallette_915">::filterPallette</a></a> config -pattern1 $dataPattern
     <a name="::filterPallette(3)"><a href="./ePTClient.tcl.html#::filterPallette_915">::filterPallette</a></a> config -patternOffset1 $patternOffset
     <a name="::filterPallette(4)"><a href="./ePTClient.tcl.html#::filterPallette_915">::filterPallette</a></a> set $rxch $rxc $rxp
   }
   <a name="::writeConfigToHardware(1)"><a href="./mapping.tcl.html#::writeConfigToHardware_148">::writeConfigToHardware</a></a> one2oneArray
   <a name="::StartPortsCapture(4)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> &#34;$txPortId $rxPortId&#34;

   for {set c $startCardNum} {$c&lt;=[expr $startCardNum + $numIxiaCd - 1]} {incr c 1} { <a name="::ixiaConf_clearStat(1)"><a href="./ePTMisc.tcl.html#::ixiaConf_clearStat_258">::ixiaConf_clearStat</a></a> $c }
   <a name="::ixiaStartCaptureCards(1)"><a href="./ePTMisc.tcl.html#::ixiaStartCaptureCards_274">::ixiaStartCaptureCards</a></a> $numIxiaCd $startCardNum
   <a name="::startTx(1)"><a href="./mapping.tcl.html#::startTx_94">::startTx</a></a> one2oneArray
   set time2 [clock seconds]
   <a name="::stream(21)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> get $txChas $txCard $txPort 1
   set streamSent [<a name="::stream(22)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a> cget -packetView]
   <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;*** Frame sent from ($txChas $txCard $txPort) = $streamSent&#34;
   <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;*** Time for Ixia TX setup = [expr $time2-$time1] secs&#34;

   <span class="comment-line"># Make sure TX done</span>
   if { $streamType == &#34;stopStream&#34; } {
      if { ($saMode != &#34;contIncrement&#34;) &amp;&amp; ($saMode != &#34;contDecrement&#34;) &amp;&amp;  
           ($daMode != &#34;contIncrement&#34;) &amp;&amp; ($daMode != &#34;contDecrement&#34;) } {
         <a name="::ixiaCheckTxDone(1)"><a href="./ePTMisc.tcl.html#::ixiaCheckTxDone_334">::ixiaCheckTxDone</a></a> $txChas $txCard $txPort $numFrames $txPortId
         if { $direction == &#34;2Way&#34; } {
            <a name="::ixiaCheckTxDone(2)"><a href="./ePTMisc.tcl.html#::ixiaCheckTxDone_334">::ixiaCheckTxDone</a></a> $rxChas $rxCard $rxPort $numFrames $txPortId
         }
      }
   }
   after 1000
   set time3 [clock seconds]
   <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;*** Time for Ixia TX done = [expr $time3-$time2] secs\n&#34;
   return $streamSent
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: VerifyIpxRouteInfo</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:</span>
<span class="comment-line">#     This proc is used to compare IPX route info on a given list of </span>
<span class="comment-line">#     ixia ports and a DUT. Important reference commands include &#34;sh ipxro&#34;</span>
<span class="comment-line">#     on DUT (associated proc GetColumnValues).</span>
<span class="comment-line">#     Sleeps for 70 secs for IPXRIP update capture. Calculate DUT number </span>
<span class="comment-line">#     associated with a given port automagically.</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     portInfoList: It is a list of Ixia port number, vlan's xnetid and</span>
<span class="comment-line">#                   IPXRIP type on that port</span>
<span class="comment-line">#    update_time: Default param to pass update interval</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:</span>
<span class="comment-line"># Return Values:</span>
<span class="comment-line">#     returns true(1) on success (All routes matched)</span>
<span class="comment-line">#     returns false (0) on failure (Any of the route remained unmatched)</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#    if {VerifyIpxRouteInfo {{1 809a ENETII_IPXRIP_REPLY} \</span>
<span class="comment-line">#                            {4 235e ENETSNAP_IPXRIP_REPLY}}} {</span>
<span class="comment-line">#       puts &#34;success&#34;</span>
<span class="comment-line">#    } else {</span>
<span class="comment-line">#       puts &#34;failure&#34;</span>
<span class="comment-line">#    }</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifyTraffic</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyIpxRouteInfo_645">proc <a href="IpxUtil.tcl-annot.html#::::VerifyIpxRouteInfo">::::VerifyIpxRouteInfo</a></a></strong> {portInfoList {update_time 70}} {

   global portMappingList
   set con &#34;_CONNECT&#34;
   set DUT &#34;DUT&#34;
   
   if {![llength $portInfoList]} {
      return 0
   }
   
   <span class="comment-line"># Start capture before sleep</span>
   foreach portInfo $portInfoList {
      lappend portList [lindex $portInfo 0]
   }
   
   <a name="::ClearPortsStats(3)"><a href="./ePTRx.tcl.html#::ClearPortsStats_951">::ClearPortsStats</a></a> &#34;$portList&#34;
   <a name="::StartPortsCapture(5)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> &#34;$portList&#34;

   <span class="comment-line"># Wait for 70 secs to capture RIP updates</span>
   <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait for $update_time secs to capture IPX route updates&#34;
   after [expr $update_time * 1000]
   
   <span class="comment-line"># Capture stats on each ixia port</span>
   set i 0
   foreach port $portList {
      set frameList [<a name="::GetCapturedFrames(3)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $port]
      <span class="comment-line">#result_debug &#34;frameList on $port:$frameList&#34;</span>
      set capturedRoute &#34;&#34;;
      foreach frame $frameList {
         if {[<a name="::GetMessageType(2)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame] == &#34;[lindex [lindex $portInfoList $i] 2]&#34;} {
            set routes [<a name="::GetIpxOption(1)"><a href="./IpxUtil.tcl.html#::GetIpxOption_20">::GetIpxOption</a></a> $frame &#34;RouteInfo&#34;]
            foreach route $routes {
               if {[lsearch $capturedRoute $route] == -1} {
                  lappend capturedRoute $route
               }
            }
         }
      }
      set capturedRoute$port $capturedRoute
      incr i
   }
   
   set cap &#34;capturedRoute&#34;
   foreach port $portInfoList {
      set portNum [lindex $port 0]
      set portNet [string toupper [lindex $port 1]]

      set dut &#34;&#34;
      foreach p $portMappingList {
         if {[lindex $p 0] == &#34;$portNum&#34;} {
            set dut [lindex $p 2]
            break
         }
      }

      <span class="comment-line">################################################</span>
      set subTest &#34;Verify that ipx packets have complete route info on port$portNum&#34;
      <span class="comment-line">################################################</span>
      result_h2 &#34;$subTest&#34;
      <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$subTest&#34;

      global $DUT$dut$con
      <a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [expr $$DUT$dut$con]
      <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;dis clipaging&#34;
         <span class="comment-line">#EnableDebugMode</span>
         <span class="comment-line">#SendACmd &#34;!echo dump_stack &gt; /sys/module/watchdog/parameters/watchdog_warn_behavior&#34;</span>
      
      set capRoutes &#34;&#34;
      set ColumnVals &#34;&#34;
      <span class="comment-line">#result_debug &#34;the mesagetype:[lindex $port 2]&#34;</span>
      <span class="comment-line">#result_debug &#34;the capturedPort Values: [expr $$cap$portNum]&#34;</span>
      
      if {[regexp -nocase &#34;SAP&#34; [lindex $port 2]]} {
         set ColumnVals [<a name="::GetColumnValues(1)"><a href="./OptionCheck.tcl.html#::GetColumnValues_593">::GetColumnValues</a></a>  &#34;sh ipxser&#34; {{0 3} {5 21} {23 26} {28 35} {37 53} {55 58}} &#34;----&#34; &#34;Total number&#34;]
         <span class="comment-line">#result_debug &#34;the columnVals for SAP:$ColumnVals&#34;</span>
         if {([llength [lindex $ColumnVals 0]]) &amp;&amp; \
             ([llength [expr $$cap$portNum]])} {
            set routesNotMatched &#34;&#34;
         } else {
            set routesNotMatched &#34;no routes captured on switch&#34;
            sleep 3 
            set ColumnVals [<a name="::GetColumnValues(2)"><a href="./OptionCheck.tcl.html#::GetColumnValues_593">::GetColumnValues</a></a>  &#34;sh ipxser&#34; {{0 3} {5 21} {23 26} {28 35} {37 53} {55 58}} &#34;----&#34; &#34;Total number&#34;]
            if {([llength [lindex $ColumnVals 0]]) &amp;&amp; \
                ([llength [expr $$cap$portNum]])} {
               set routesNotMatched &#34;&#34;
            }
         }

         foreach routeInfo [expr $$cap$portNum] {
            <span class="comment-line">#result_debug &#34;the routeInfo $routeInfo&#34;</span>
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 0 4] &#34; 0&#34;] &#34;&#34; operation
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 6 148] &#34; &#34;] &#34;&#34; server
            set Server [string range [<a name="::ConvertHexToAscii(3)"><a href="./IpxUtil.tcl.html#::ConvertHexToAscii_916">::ConvertHexToAscii</a></a> &#34;$server&#34;] 0 16]
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 150 161] &#34; 0&#34;] &#34;&#34; network
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 162 178] &#34; &#34;] &#34;:&#34; node
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 180 185] &#34; &#34;] &#34;&#34; port
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 187 191] &#34; 0&#34;] &#34;&#34; hops
            lappend capRoutes &#34;$operation $Server $hops $network $node $port&#34;
         }
         <span class="comment-line">#result_debug &#34;the capRoutes:$capRoutes&#34;</span>
         for {set i 0} {$i &lt; [llength [lindex $ColumnVals 0]]} {incr i} {
            set actualOp [string trimleft [string toupper [lindex [lindex $ColumnVals 0] $i]] &#34; 0&#34;]
            set actualSe [string trimleft [string toupper [lindex [lindex $ColumnVals 1] $i]] &#34; 0&#34;]
            set actualHo [string trimleft [string toupper [format %x [lindex [lindex $ColumnVals 2] $i]]] &#34; 0&#34;]
            set actualNw [string trimleft [string toupper [lindex [lindex $ColumnVals 3] $i]] &#34; 0&#34;]
            set actualNo [string toupper [lindex [lindex $ColumnVals 4] $i]]
            set actualPo [string toupper [lindex [lindex $ColumnVals 5] $i]]

            if {[lsearch $capRoutes &#34;$actualOp $actualSe $actualHo $actualNw $actualNo $actualPo&#34;]==-1} {
               lappend routesNotMatched &#34;$actualOp $actualSe $actualHo $actualNw $actualNo $actualPo&#34;
            }
         }
      } elseif {[regexp -nocase &#34;RIP&#34; [lindex $port 2]]} {
         set ColumnVals [<a name="::GetColumnValues(3)"><a href="./OptionCheck.tcl.html#::GetColumnValues_593">::GetColumnValues</a></a>  &#34;sh ipxro&#34; {{0 9} {10 15} {16 21} {30 33}} &#34;Network&#34; &#34;Total number&#34;]
         <span class="comment-line">#result_debug &#34;the columnVals for RIP:$ColumnVals&#34;;</span>
         set routesNotMatched &#34;&#34;
         if {([llength [lindex $ColumnVals 0]]) &amp;&amp; \
             ([llength [expr $$cap$portNum]])} {
            set routesNotMatched &#34;&#34;
         } else {
            set routesNotMatched &#34;no routes captured on switch&#34;
         }
         foreach routeInfo [expr $$cap$portNum] {
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 0 10] &#34; 0&#34;] &#34;&#34; network
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 12 16] &#34; 0&#34;] &#34;&#34; hops
            regsub -all &#34; &#34; [string trimleft [string range $routeInfo 18 22] &#34; 0&#34;] &#34;&#34; tics
            lappend capRoutes &#34;$network $hops $tics&#34;
         }
         for {set i 0} {$i &lt; [llength [lindex $ColumnVals 0]]} {incr i} {
            set actualNw [string toupper [lindex [lindex $ColumnVals 0] $i]]
            if {$actualNw == &#34;$portNet&#34;} {
               continue
            }
            set actualHops 0
            set actualTics 0
            set actualAge 0
            if {[lindex $ColumnVals 1]!=&#34;&#34;} {
               set actualHops [string toupper [format %x [lindex [lindex $ColumnVals 1] $i]]]
            }
            if {[lindex $ColumnVals 2]!=&#34;&#34;} {
               set actualTics [string toupper [format %x [lindex [lindex $ColumnVals 2] $i]]]
            }
            set actualAge [lindex [lindex $ColumnVals 2] $i]
            if {([lsearch $capRoutes &#34;$actualNw $actualHops $actualTics&#34;]==-1)&amp;&amp;($actualAge&lt;60)} {
               lappend routesNotMatched &#34;$actualNw $actualHops $actualTics&#34;
            }
         }
      }

      if {[llength $routesNotMatched] &gt; 0} {
         <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;IPX route check failed, routes unmatched: $routesNotMatched&#34;
      } else {
         <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;IPX route check passed, all routes:$capRoutes matched.&#34;
      }
      <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   }
   return &#34;1&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: VerifyProtoUpdateInterval</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:</span>
<span class="comment-line">#     This proc is used to verify a given IPXRIP/IPXSAP/others update time on a port</span>
<span class="comment-line">#     Calls capture function to capture packets on tester and verifies</span>
<span class="comment-line">#     their time stamping spaced by intervalInSec secs.</span>
<span class="comment-line">#     It uses a tolerance of +/- .01 percent in intervalInSec (by default)</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     intervalInSec: Update Interval in seconds</span>
<span class="comment-line">#     port: Test equipment port number to verify on. can be a list</span>
<span class="comment-line">#     packetType: Ethernet encapsulation packet type expected...</span>
<span class="comment-line">#               (Valid values can be ENETII/ENET8022/ENET8023/ENETSNAP_IPXRIP_REPLY</span>
<span class="comment-line">#                Valid values can be ENETII/ENET8022/ENET8023/ENETSNAP_IPXSAP_REPLY)</span>
<span class="comment-line">#               (pimV2Hello...)</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:</span>
<span class="comment-line"># Return Values:</span>
<span class="comment-line">#     returns true(1) on success (Update interval matched)</span>
<span class="comment-line">#     returns false (0) on failure (Any of 3 captured not spaced by intervalInSec)</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#</span>
<span class="comment-line"># if {VerifyIpxUpdateInterval &#34;60 9 ENETSNAP_IPXRIP_REQUEST&#34;} {</span>
<span class="comment-line">#   result_ok &#34;Default IPXRIP update time verified correct, PASS&#34;</span>
<span class="comment-line"># } else {</span>
<span class="comment-line">#   result_error &#34;Default IPXRIP update time not correct, FAIL&#34;</span>
<span class="comment-line"># }</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifyTraffic</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::VerifyProtoUpdateInterval_836">proc <a href="IpxUtil.tcl-annot.html#::::VerifyProtoUpdateInterval">::::VerifyProtoUpdateInterval</a></a></strong> {intervalInSec portList packetType {tolerance 20}} {

foreach port $portList {
   <a name="::ClearPortsStats(4)"><a href="./ePTRx.tcl.html#::ClearPortsStats_951">::ClearPortsStats</a></a> &#34;$port&#34;
   <a name="::StartPortsCapture(6)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> &#34;$port&#34;
   <span class="comment-line">################################################</span>
   set subTest &#34;Verify $packetType packets generated every $intervalInSec seconds on port $port&#34;
   <span class="comment-line">################################################</span>
   result_h2 &#34;$subTest&#34;
   <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$subTest&#34;

   <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait around [expr $intervalInSec * 3] secs to capture $packetType packets on tester ports&#34;
   after [expr $intervalInSec * 3000 - 1234]

   set capturedFrames [<a name="::GetCapturedFrames(4)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> &#34;$port&#34;]
   set timeStamps [<a name="::GetCapturedFramesTimeStamp(1)"><a href="./ePTRx.tcl.html#::GetCapturedFramesTimeStamp_1010">::GetCapturedFramesTimeStamp</a></a> &#34;$port&#34;]
   set TimeStamps &#34;&#34;

   <span class="comment-line"># Look for only IPX packets in all captured packets</span>
   for {set i 0} {$i &lt; [llength $capturedFrames]} {incr i} {
      <span class="comment-line">#result_debug &#34;The messagetype captured:[GetMessageType [lindex $capturedFrames $i]]&#34;</span>
      if {[<a name="::GetMessageType(3)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> [lindex $capturedFrames $i]] == &#34;$packetType&#34;} {
         lappend TimeStamps [lindex $timeStamps $i]
      }
   }

   <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the timestamps:$TimeStamps&#34;
   set interval 0
   set result &#34;ng&#34;
   if {[regexp -nocase {[2-9]} [llength $TimeStamps]]} {
      for {set i 0} {$i &lt; [expr [llength $TimeStamps]-1]} {incr i} {
         set secondTimeStamp [lindex $TimeStamps [expr $i + 1]]
         set firstTimeStamp [lindex $TimeStamps $i]
         <span class="comment-line"># Store in mili seconds</span>
 <span class="comment-line">#        set secTimeStamp [string range $secondTimeStamp 0 [expr [string length $secondTimeStamp] - 10]]</span>
 <span class="comment-line">#        set firTimeStamp [string range $firstTimeStamp 0 [expr [string length $firstTimeStamp] - 10]]</span>
         <span class="comment-line">#result_debug &#34;the firTimeStamp:$firTimeStamp, secTimeStamp:$secTimeStamp&#34;</span>
         set interval [mpexpr abs($secondTimeStamp - $firstTimeStamp)/1000000000]
         set diff [mpexpr abs( $intervalInSec - $interval)]
         set percent [mpexpr double($diff)/ double($intervalInSec)*100.0]
         <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The interval=$interval, percent=$percent&#34;
         <span class="comment-line"># Count for a percentage of .01 tolerance</span>
         if {$percent &lt;= $tolerance} {
            set result &#34;ok&#34;
            break  ;<span class="comment-line"># break as soon as one correct timespace found</span>
         } else {
            set result &#34;ng&#34;
         }
      }
   }
   if {$result == &#34;ok&#34;} {
      <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;port$port:$packetType update interval $intervalInSec verified correct, PASS&#34;
      <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   } elseif {$result==&#34;ng&#34;} {
      <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;port$port:$packetType update interval incorrect, expected $intervalInSec but got $interval, FAIL&#34;
      <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   }
}
   return 0
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: ConvertHexToAscii</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: A internal proc that returns the hex packet format to ascii value for </span>
<span class="comment-line">#              a given novell server type</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: server</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return Values:</span>
<span class="comment-line">#      returns the ascii value of server</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#           ConvertHexToAscii &#34;$server&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifyTraffic</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ConvertHexToAscii_916">proc <a href="IpxUtil.tcl-annot.html#::::ConvertHexToAscii">::::ConvertHexToAscii</a></a></strong>  {server} {

   set hexPrefix &#34;\\x&#34;
   set asciiVal &#34;&#34;
   
   for {set i 0} {$i &lt; [string length $server]} {incr i 2} {
      set hexVal [string range $server $i [expr $i + 1]]
      lappend asciiVal [string toupper [eval format %s &#34;$hexPrefix$hexVal&#34;]]
      if {[regexp {[^A-Z^a-z^0-9^ ^_^-]} $asciiVal]} {
         break
      }
   }
   regsub -all {[^A-Z^a-z^0-9^_^-]} $asciiVal &#34;&#34; asciiVal
   return [join $asciiVal &#34;&#34;]
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckServerTypeInGnsResponse</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: This proc verifies the server type in rawPacket's GNS response.</span>
<span class="comment-line">#              the desired serverType and serverName are supplied in in args along with rawFrame</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: rawFrame, serverType, serverName</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return Values:</span>
<span class="comment-line">#      1 on success or 0 on failure</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         CheckServerTypeInGnsResponse $rawFrame &#34;00 04&#34; $serverName</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: VerifyTraffic</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckServerTypeInGnsResponse_951">proc <a href="IpxUtil.tcl-annot.html#::::CheckServerTypeInGnsResponse">::::CheckServerTypeInGnsResponse</a></a></strong> {rawFrame serverType serverName} {

   set serverType [format %04d [string trimleft $serverType &#34; 0&#34;]]
   set serverType &#34;[string range $serverType 0 1] [string range $serverType 2 3]&#34;
   <a name="::report_start_test(3)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;checking GNS reply for serverType:$serverType, serverName:$serverName&#34;
   set typename [<a name="::GetIpxOption(2)"><a href="./IpxUtil.tcl.html#::GetIpxOption_20">::GetIpxOption</a></a> $rawFrame &#34;GNSTypeAndName&#34;]

   if {[regexp -nocase &#34;$serverType $serverName&#34; $typename]} {
      <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;GNS Reply ok with serverType: $serverType, serverName:$serverName, PASS&#34;
      <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
      return &#34;1&#34;
   } else {
      <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Wrong GNS Reply serverType and serverName:$typename, FAIL&#34;
      <a name="::report_end_test(5)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
      return 0
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetPortIdsOnSameBlade</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: This proc checks the ports from portMappingList, finds ports on the same</span>
<span class="comment-line">#              blade for required number of vlans. For non-slot platforms like summit</span>
<span class="comment-line">#              it returns an error.</span>
<span class="comment-line">#              This proc currently only works for any DUT</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: numPortsPerVlan: number of ports per vlan</span>
<span class="comment-line">#             numVlans: total number of vlans for which ports are desired</span>
<span class="comment-line">#             [dut] dut number to scan for, default is 1</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: portsList: List of ports to be returned to caller</span>
<span class="comment-line"># Return Values:</span>
<span class="comment-line">#      1 on success, -1 on failure.</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#      set resultOfSameBladePorts [GetPortIdsOnSameBlade $numPortsPerVlan $numVlans portIdsList]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: GetSwitchInfo</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetPortIdsOnSameBlade_991">proc <a href="IpxUtil.tcl-annot.html#::::GetPortIdsOnSameBlade">::::GetPortIdsOnSameBlade</a></a></strong> {numPortsPerVlan numVlans portIdsList args} {

   upvar $portIdsList portsList
   set portsList &#34;&#34;
   
   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> GetPortIdsOnSameBlade $args {
      dut     1
   }

   global stackable i386Stackable
   if {[regexp -nocase &#34;$stackable|$i386Stackable&#34; [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT$dut]]} {
      <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found a non-slot platform for GetPortIdsOnSameBlade&#34;
      return -2
   }

   global DUTs_info
   set slots &#34;&#34;
   foreach portId $DUTs_info(portmappinglist) {
      if {[lindex $portId 2]==$dut} {
         lappend portIdList [lindex $portId 0]
         lappend slotList [lindex [split [lindex $portId 1] :] 0]
      }
   }
<span class="comment-line">#   result_debug &#34;the portIdList $portIdList, slotList $slotList&#34;</span>
   
   for {set i 0} {$i&lt;$numVlans} {incr i} {
      foreach slot $slotList {
         set portIds &#34;&#34;
         set flag 0
         for {set k 0} {$k&lt;[llength $slotList]} {incr k} {
            if {[lindex $slotList $k]==$slot&amp;&amp;[lsearch $slots $slot]==-1} {
               if {[llength $portsList]} {
                  foreach po $portsList {
                     if {[lsearch $po [lindex $portIdList $k]]==-1 &amp;&amp; [lsearch $portIds [lindex $portIdList $k]]==-1} {
                        lappend portIds [lindex $portIdList $k]
 <span class="comment-line">#                       result_debug &#34;1.the slot $slot and portsList $portsList and slots $slots and portIds $portIds&#34;</span>
                     }
                  }
               } else {
                  lappend portIds [lindex $portIdList $k]
               }
            }
            if {[llength $portIds]==$numPortsPerVlan} {
               set flag 1
               break
            }
         }
         if {$flag} {lappend portsList $portIds; lappend slots $slot; break}
      }
   }
   if {[llength $portsList]} {
      return 1
   } else {
      return -1
   }
}

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: ConfigIPXServiceNetwork   </span>
<span class="comment-line"># Description: proc to configuration the IPX gateway vlan enet_server to IPX service.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             ConfigIPXServiceNetwork;</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ConfigIPXServiceNetwork_1058">proc <a href="IpxUtil.tcl-annot.html#::::ConfigIPXServiceNetwork">::::ConfigIPXServiceNetwork</a></a></strong> {} {
    global switchPort2DefaultRouter;  
    global whichDutNow;
    global IPXSRVR_TAG;
    global IPXSRVR_NWNUM;
    global IPXSRVR_PROTOCOL;
    global ixiaCh1; 
   
    <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nConfigIPXServiceNetwork: Setting up IPX gateway VLAN on DUT$whichDutNow.&#34;;
    if {[regexp -nocase $switchPort2DefaultRouter &#34;mgmt&#34;]} {
        <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;CAN NOT USE MGMT PORT FOR IPX NETWORK!!!&#34;;
        return;
    }

    if {![info exists IPXSRVR_TAG]} {
        <span class="comment-line"># Generate the tag number.</span>
        set ipad [split $ixiaCh1 .];
        set ipF3 [lindex $ipad 2];
        set IPXSRVR_TAG [expr $ipF3 + 100];
    }
  
    if {![info exists IPXSRVR_NWNUM]} {
        set IPXSRVR_NWNUM [<a name="::GetIPXNetworkNumber(1)"><a href="./IpxUtil.tcl.html#::GetIPXNetworkNumber_1125">::GetIPXNetworkNumber</a></a>];
    }

    if {![info exists IPXSRVR_PROTOCOL]} {
        set IPXSRVR_PROTOCOL &#34;enet_snap&#34;;
    }

    <span class="comment-line"># Build IPX network.</span>
    set gwPort [<a name="::GetDUTPort(1)"><a href="./ePTPortMapping.tcl.html#::GetDUTPort_78">::GetDUTPort</a></a> $switchPort2DefaultRouter $whichDutNow];
    <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable port $gwPort&#34;;       
    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;create vlan enet_server&#34;;
    <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config enet_server tag $IPXSRVR_TAG&#34;;
    <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config enet_server add port $gwPort tag&#34;;
    <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config enet_server xnetid $IPXSRVR_NWNUM $IPXSRVR_PROTOCOL&#34;;
} ;<span class="comment-line"># ConfigIPXServiceNetwork</span>

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: UnconfigIPXServiceNetwork   </span>
<span class="comment-line"># Description: proc to delete the IPX gateway vlan enet_server to IPX service.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             UnconfigGatewayNetwork;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UnconfigIPXServiceNetwork_1106">proc <a href="IpxUtil.tcl-annot.html#::::UnconfigIPXServiceNetwork">::::UnconfigIPXServiceNetwork</a></a></strong> {} {
    global switchPort2DefaultRouter; 
    global defaultRouter;
    global whichDutNow;
 
    <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nUnconfigIPXServiceNetwork{}: delete gateway vlan on DUT$whichDutNow&#34;
    <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete enet_server&#34;;
}

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: GetIPXNetworkNumber  </span>
<span class="comment-line"># Description: Use the ixia network number to create the IPX network number</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: IPX network number</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             GetIPXNetworkNumber</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">#################################################################################</span>
<strong><a name="::::GetIPXNetworkNumber_1125">proc <a href="IpxUtil.tcl-annot.html#::::GetIPXNetworkNumber">::::GetIPXNetworkNumber</a></a></strong> {} {
    global ixiaCh1; 
    
    <span class="comment-line"># To generate the IPX network number, the IXIA's IP address is treated</span>
    <span class="comment-line"># as a string.  The dots are removed, and the last four characters of</span>
    <span class="comment-line"># that result will form the IPX network number.</span>
    regsub -all {\.} $ixiaCh1 &#34;&#34; tmp;
    set lng [string length $tmp];
    set st [expr $lng - 4];
    set value [string range $tmp $st end];
    
    return $value;
}

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
