<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>robot.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#robot.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>robot.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="robot.tcl-annot.html">annotations</a> | <a href="robot.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">###############################################################################</span>
<span class="comment-line"># procedure: ExecuteRobotTRM</span>
<span class="comment-line">#</span>
<span class="comment-line"># a procedure to launch robot via the resource manager</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::ExecuteRobotTRM_8">proc <a href="robot.tcl-annot.html#::::ExecuteRobotTRM">::::ExecuteRobotTRM</a></a></strong> {qId userInput args} {
    global DEVREG tftpServerList ROBOT

    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> ExecuteRobotTRM $args {
        help      &#34;null&#34;
    }


    <span class="comment-line"># to be moved to common.cfg</span>
    set tftp [lindex $tftpServerList 0]

    set ROBOT(branch) &#34;CIT_PROD_AUTOMATION&#34;
    set ROBOT(TRMIP) &#34;10.52.15.99&#34;
    set ROBOT(TRM_CLI) &#34;java -jar TRMClient.jar -c START_AND_EXIT &#34;
    set ROBOT(BASEDIR) &#34;/robot/SQA_ROBOT_AUTOMATION/&#34;
    set ROBOT(YAMLRELDIR) &#34;ExtremeAutomation/Resources/TestEnvironments/Swdev/Rdu/&#34;
    set ROBOT(SUITERELDIR) &#34;ExtremeAutomation/Tests/Unit/NetworkElements/&#34;
    set ROBOT(JARSREL) &#34;ExtremeAutomation/Library/JavaManager/jars&#34;
    set ROBOT(JARDIR) ${ROBOT(BASEDIR)}${ROBOT(JARSREL)}


    <span class="comment-line">#  ----------------   Test Beds   ------------------------------</span>
    set ROBOT_YAML(x440g2,0) &#34;Physical/Exos/cit_x440g2_2node_1.yaml&#34;
    set ROBOT_YAML(x450g2,0) &#34;Physical/Exos/cit_x450g2_2node_1.yaml&#34;
    set ROBOT_YAML(x460g2,0) &#34;Physical/Exos/cit_x460g2_2node_1.yaml&#34;
    set ROBOT_YAML(x620,0)   &#34;Physical/Exos/cit_x620_2node_1.yaml&#34;
    set ROBOT_YAML(i386,0)   &#34;Virtual/Exos/exosvm_1node_1.yaml&#34;
    <span class="comment-line">#  -------------------------------------------------------------</span>

    array set uInput $userInput
    set familyList &#34;&#34;
    set sNameList &#34;cougar|summit|jaguar&#34;
    set oNameList &#34;onie|870|690&#34;
    set iNameList &#34;386|exosvm&#34;
    set user &#34;null&#34;
    set modStat &#34;&#34;
    set yTail &#34;&#34;
    foreach n [array names uInput] {
        if {[regexp &#34;Image:&#34; $n] &amp;&amp; [regexp -nocase &#34;$sNameList&#34; $uInput($n)]} {
            if {[lsearch $familyList &#34;summitX&#34;] &lt; 0} {
                lappend familyList &#34;summitX&#34;
                set famFile(summitX) $uInput($n)
            }
        } elseif {[regexp &#34;Image:&#34; $n] &amp;&amp; [regexp -nocase &#34;$oNameList&#34; $uInput($n)]} {
            if {[lsearch $familyList &#34;onie&#34;] &lt; 0} {
                lappend familyList &#34;onie&#34;
                set famFile(onie) $uInput($n)
            }
        } elseif {[regexp &#34;Image:&#34; $n] &amp;&amp; [regexp -nocase &#34;$iNameList&#34; $uInput($n)]} {
            if {[lsearch $familyList &#34;i386&#34;] &lt; 0} {
                lappend familyList &#34;i386&#34;
                set famFile(i386) $uInput($n)
            }
        } elseif {[regexp &#34;Image:&#34; $n] &amp;&amp; $uInput($n) == &#34;NULL&#34;} {
            <span class="comment-line"># Do nada</span>
        } elseif {[regexp &#34;Image:&#34; $n]} {
            puts &#34;call the wrapper proc to check $uInput($n)&#34;
        } else {
            <span class="comment-line">#puts &#34;Found name: $n   with value $uInput($n)&#34;</span>
            if {$n == &#34;platformToRunOn:&#34;} {
                set plat [string trim $uInput($n)]
                set yTail [file tail $ROBOT_YAML($plat,0)]
                set modStat &#34;runningOn$yTail&#34;
                puts &#34;\n\n\nFound plat $plat \n\n&#34;
            }
            if {$n == &#34;moduleNames:&#34;} {
                set mod [string trim [lindex $uInput($n) 0]]
            }
            if {$n == &#34;userid:&#34;} {
                set user [string trim $uInput($n)]
            }
        }
    }
    <span class="comment-line"># Put the images on the tftpserver in Robot format = RTP_######_######{family}.xos</span>
    foreach ifl $familyList {
        if {[file exists $famFile($ifl)]} {
            if {[catch {exec cp -L $famFile($ifl) /tftpmount/${qId}${ifl}.xos} reason]} {
                puts &#34;Copy of $famFile($ifl) to tftp failed&#34;
            } else {
                puts &#34;Copy $ifl to tftp: mv $famFile($ifl) /tftpmount/${qId}${ifl}.xos&#34;
            }
        } else {
            puts &#34;Error $ifl file $famFile($ifl) does not exist&#34;
        }
    }

    <span class="comment-line"># ---------------   Handle the TRM parts   -------------------------------</span>
    <span class="comment-line"># Build the -r test bed part</span>
    set ymlf ${ROBOT(BASEDIR)}${ROBOT(YAMLRELDIR)}$ROBOT_YAML($plat,0);<span class="comment-line"># Everything is 0 index for now</span>
    if {![file exists $ymlf]} {
        puts &#34;\n\nError where is the yml $ymlf&#34;
        return -1;
    } else {
        set rFile ${ROBOT(YAMLRELDIR)}$ROBOT_YAML($plat,0);
        <span class="comment-line">#puts &#34;\nFound $rFile\n&#34;</span>
    }
    <span class="comment-line"># Build the -e test plan / suite folder location to run</span>
    set suiteDir ${ROBOT(BASEDIR)}${ROBOT(SUITERELDIR)}${mod}/TestCases
    if {![file isdirectory $suiteDir]} {
        puts &#34;\n\nError where is the suite directory $suiteDir&#34;
    } else {
        set eLink ${ROBOT(SUITERELDIR)}${mod}/TestCases
    }
    if {![file isdirectory $ROBOT(JARDIR)]} {
        puts &#34;\n\nError where is the jar directory $ROBOT(JARDIR)&#34;
        return -1;
    }
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    <span class="comment-line"># TRM CMD Creation</span>
    <span class="comment-line"># ---------------------------------------------------------------------</span>
    set trmCmd &#34;-f $mod -r $rFile -e $eLink &#34;
    if {$user != &#34;null&#34; &amp;&amp; $user != &#34;release-manager&#34;} {
        append trmCmd &#34;-u $user &#34;
    }
    if {$ROBOT(branch) != &#34;origin&#34; &amp;&amp; $ROBOT(branch) != &#34;&#34;} {
        append trmCmd &#34;-g $ROBOT(branch) &#34;
    }
    append trmCmd &#34;-b {'\&#34;--listener /Report_Data/devRegListener.py  -v MODULE:$mod -v TFTPSERVER:$tftp -v QUEUEID:$qId\&#34;'} &#34;
    append trmCmd &#34;-z $ROBOT(TRMIP)&#34;
    append ROBOT(TRM_CLI) $trmCmd
    puts &#34;catch exec $ROBOT(TRM_CLI)&#34;

    set myD [pwd]
    puts &#34;Change to the jar dir for execution: $ROBOT(JARDIR)&#34;
    cd $ROBOT(JARDIR)
    puts &#34;At pre TRM [pwd]&#34;
    set trmReturn &#34;&#34;
    if {[catch {exec {*}$ROBOT(TRM_CLI)} trmReturn]} {
        puts &#34;TRM CALL FAILED: $ROBOT(TRM_CLI)&#34;
    }
    cd $myD
    puts &#34;post [pwd]&#34;

    puts &#34;TRM returned $trmReturn&#34;

    <span class="comment-line">#Test Started: be99cfa9-c093-4e09-b4e9-5a68bb4fc7e9</span>
    regexp -nocase {Test Started: ([a-f0-9]+\-[a-f0-9]+\-[a-f0-9]+\-[a-f0-9]+\-[a-f0-9]+)} \
              $trmReturn a guid
    if {[info exists guid]} {
        puts &#34;TRM returned a guid of $guid&#34;
        set uInput(runStatus:) $modStat
        <a name="::_createRobotImagesFinished(1)"><a href="./robot.tcl.html#::_createRobotImagesFinished_240">::_createRobotImagesFinished</a></a> $qId [array get uInput]
    } else {
        puts &#34;Error in guid parser. Exiting&#34;
        set modStat &#34;MainFailedOn$yTail&#34;
        set uInput(runStatus:) $modStat
        <a name="::_createRobotImagesFinished(2)"><a href="./robot.tcl.html#::_createRobotImagesFinished_240">::_createRobotImagesFinished</a></a> $qId [array get uInput]
        return;
    }

    puts &#34;Assigned regression label $qId .  Robot GUID $guid&#34;
    if {$DEVREG(mysql,UseDb)} {
        set bId &#34;0&#34;;
        set bType &#34;Private&#34;;
        set bTag &#34;&#34;;
        set bCom &#34;&#34;;
        set bBranch $uInput(branchAndPD:);
        catch {regexp -nocase {buildID:([0-9]+)\s+buildType:([a-zA-Z]+)\s+branch:([^ ]+)\s+tag:([a-z0-9\._\-]+)?\s+comment:(.*)\}} \
        $uInput(branchAndPD:) dummy bId bType bBranch bTag bCom} cout
        <span class="comment-line">#puts &#34;branchAndPD: $uInput(branchAndPD:)\n\nMatched:\nbId $bId\nbType $bType\nbranch $bBranch\ntag$bTag\ncomment $bCom&#34;</span>
        set bBranch [string trim $bBranch]
        set bTag [string trim $bTag]
        set bComment [string trim $bCom]

        <a name="::InsertQueueEntry(1)"><a href="./mysqlLib.tcl.html#::InsertQueueEntry_3527">::InsertQueueEntry</a></a> -id_label &#34;$qId&#34; -build_id &#34;$bId&#34; -reg_server &#34;$DEVREG(server,FULLHOST)&#34; \
            -user &#34;$uInput(userid:)&#34; -platform &#34;$uInput(platformToRunOn:)&#34; -type &#34;$bType&#34; -status &#34;Queued&#34; \
            -branch &#34;$bBranch&#34; -tag &#34;$bTag&#34; -comment &#34;$bComment&#34; -robot_guid &#34;$guid&#34;


        set rId [<a name="::getRegIdFromQId(1)"><a href="./mysqlLib.tcl.html#::getRegIdFromQId_3603">::getRegIdFromQId</a></a> $qId]
        puts &#34;The reg_id from the database is: $rId&#34;
        <span class="comment-line"># --- Now post each module to the test_module table ---</span>
        set u 0
        foreach mod $uInput(moduleNames:) {
            set myLst [lindex $uInput(moduleLists:) $u]
            <a name="::InsertQModuleEntry(1)"><a href="./mysqlLib.tcl.html#::InsertQModuleEntry_3633">::InsertQModuleEntry</a></a> -reg_id $rId -name $mod -list $myLst -status &#34;queued&#34;
            incr u
        }
    }
}
<span class="comment-line">##############################################################################</span>
<span class="comment-line"># procedure: _getUniqueRegQID</span>
<span class="comment-line">#    Proc to create the unique imagesQueued/RTP_######_##### directory</span>
<span class="comment-line">#    for a new entry.  Avoid duplicates</span>
<span class="comment-line">##############################################################################</span>
<strong><a name="::::_getUniqueRegQID_193">proc <a href="robot.tcl-annot.html#::::_getUniqueRegQID">::::_getUniqueRegQID</a></a></strong> {} {
    global DEVREG

    <span class="comment-line"># --- Code the create the regression dir if it is not present ---</span>
    if {![file isdirectory $DEVREG(server,regressionDir)]} {
        if {[catch {file mkdir $DEVREG(server,regressionDir)} reason]} {
                puts &#34;Error: Can not create regression dir...$reason&#34;
                exit -1
        }
        chmod 0777 $DEVREG(server,regressionDir)
    }
    if {![file isdirectory $DEVREG(server,imagesQueuedDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesQueuedDir)} reason]} {
            puts &#34;Error: Can not create imagesQueuedDir dir...$reason&#34;
            exit -1
        }
        chmod 0777 $DEVREG(server,imagesQueuedDir)
    }
    set noId 1
    set fc 0
    while {$noId} {
        set qId [format %s_%s $DEVREG(server,location) [clock format [clock seconds] \
                         -format %y%m%d_%H%M%S]]  ;<span class="comment-line"># for now this is the queueId</span>
        set queueDir &#34;$DEVREG(server,imagesQueuedDir)/$qId&#34;
        if {![file isdirectory $queueDir]} {
            <span class="comment-line"># --- Create the queuedir.  If exists get a new name ---</span>
            if {[catch {file mkdir $queueDir} reason]} {
                puts &#34;Error: Can not create queueDir dir...$reason&#34;
                if {$fc&gt;3} {
                    return -1
                }
                incr fc
            } else {
                set noId 0;
                return $qId
            }
        } else {
            incr fc
            after 1001;
        }
    }
}
<span class="comment-line">###################################################################################</span>
<span class="comment-line"># procedure: _createRobotImagesFinished</span>
<span class="comment-line">#     A dummy imagesFinished directory with just an info file</span>
<span class="comment-line"># </span>
<span class="comment-line">###################################################################################</span>
<strong><a name="::::_createRobotImagesFinished_240">proc <a href="robot.tcl-annot.html#::::_createRobotImagesFinished">::::_createRobotImagesFinished</a></a></strong> {qId userInput} {
    global DEVREG

    array set uInput $userInput

    if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
        if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
            puts &#34;Error: Can not create dir...$reason&#34;
            return;
        }
        chmod 0777 $DEVREG(server,imagesFinishedDir)
    }
    if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId]} {
        if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)/$qId} reason]} {
            puts &#34;Error: Can not create dir...$reason&#34;
            return;
        }
        chmod 0777 $DEVREG(server,imagesFinishedDir)/$qId
    }
    if {[set fd_out [<a name="::FileOpen(1)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> &#34;$DEVREG(server,imagesFinishedDir)/$qId/info&#34; w]]==-1} {
        puts &#34;could not create $fd_out&#34;
        return;
    }
    foreach varName [array names uInput] {
        puts $fd_out &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $uInput($varName)]&#34;
    }
    close $fd_out
    chmod 0777 $DEVREG(server,imagesFinishedDir)/$qId/info
}
<span class="comment-line">###################################################################################</span>
<span class="comment-line"># procedure: _createRobotReportDir</span>
<span class="comment-line">#</span>
<span class="comment-line">###################################################################################</span>
<strong><a name="::::_createRobotReportDir_273">proc <a href="robot.tcl-annot.html#::::_createRobotReportDir">::::_createRobotReportDir</a></a></strong> {qId mod} {
    global DEVREG MAIN

    set sub [<a name="::_getRobotSubFolder(1)"><a href="./robot.tcl.html#::_getRobotSubFolder_345">::_getRobotSubFolder</a></a> $qId];<span class="comment-line"># The year and month of the qId.  &#34;1801&#34;</span>
    if {![file isdirectory $DEVREG(server,robotResultMnt)/$sub]} {
        if {[catch {file mkdir $DEVREG(server,robotResultMnt)/$sub} reason]} {
            puts &#34;Error: Can not create robot subdir...$reason&#34;
            return;
        }
        chmod 0777 $DEVREG(server,robotResultMnt)/$sub
    }
    if {![file isdirectory $DEVREG(server,robotResultMnt)/$sub/$qId]} {
        if {[catch {file mkdir $DEVREG(server,robotResultMnt)/$sub/$qId} reason]} {
            puts &#34;Error: Can not create dir...$reason&#34;
            return;
        }
        chmod 0777 $DEVREG(server,robotResultMnt)/$sub/$qId
    }
    if {![file isdirectory $DEVREG(server,robotResultMnt)/$sub/$qId/$mod]} {
        if {[catch {file mkdir $DEVREG(server,robotResultMnt)/$sub/$qId/$mod} reason]} {
            puts &#34;Error: Can not create dir...$reason&#34;
            return;
        }
        chmod 0777 $DEVREG(server,robotResultMnt)/$sub/$qId/$mod
    }
    if {![file isdirectory $DEVREG(server,robotResultMnt)/$sub/$qId/$mod/Report]} {
        if {[catch {file mkdir $DEVREG(server,robotResultMnt)/$sub/$qId/$mod/Report} reason]} {
            puts &#34;Error: Can not create dir...$reason&#34;
            return;
        }
        chmod 0777 $DEVREG(server,robotResultMnt)/$sub/$qId/$mod/Report
    }
    return $DEVREG(server,robotResultMnt)/$sub/$qId/$mod/Report
}
<span class="comment-line">###################################################################################</span>
<span class="comment-line"># Procedure: get_robot_yaml_info</span>
<span class="comment-line">#</span>
<span class="comment-line">#    Get cfg location and type from cfg/robot.cfg file</span>
<span class="comment-line">#</span>
<span class="comment-line">###################################################################################</span>
<strong><a name="::::get_robot_yaml_info_313">proc <a href="robot.tcl-annot.html#::::get_robot_yaml_info">::::get_robot_yaml_info</a></a></strong> {} {
    global MAIN DEVREG robplatform

    if {$MAIN(harness) != &#34;robot&#34;} {
        puts &#34;This is not a robot test bed&#34;
        return;
    }
    if {[array exists robplatform]} {
        puts &#34;cfg/robot.cfg has not been sourced&#34;
    }
    foreach platform_code [array names robplatform] {
        set pCList $robplatform($platform_code)
        set pCfg [lindex $pCList 0]   ;<span class="comment-line"># cit_x460g2_2node_1.yaml</span>
        set pCfgPath [lindex $pCList 1]      ;<span class="comment-line"># TestEnvironments/Swdev/Rdu/Physical/Exos/</span>
        set pArea [lindex $pCList 2]        ;<span class="comment-line"># robotunit</span>
        set pType [lindex $pCList 3]    ;<span class="comment-line"># cit2node</span>
        if {$pCfg == $MAIN(cfg)} {
            set DEVREG(server,CFG_PATH) $pCfgPath
            set DEVREG(server,CFG_AREA) $pArea
            set DEVREG(server,CFG_TYPE) $pType
            return $platform_code
        }
    }
}
<span class="comment-line">###################################################################################</span>
<span class="comment-line"># Procedure: _getRobotSubFolder $qId</span>
<span class="comment-line">#    On the NAS we are going to store results in a format:</span>
<span class="comment-line">#    /{nas_mount}/&lt;{year}{month}/queueid/feature</span>
<span class="comment-line">#</span>
<span class="comment-line">#    This procedure determins the yearmonth from the given queue_id</span>
<span class="comment-line">#   </span>
<span class="comment-line">###################################################################################</span>
<strong><a name="::::_getRobotSubFolder_345">proc <a href="robot.tcl-annot.html#::::_getRobotSubFolder">::::_getRobotSubFolder</a></a></strong> {qId} {

    set eList [split $qId &#34;_&#34;]
    set ymBig [lindex $eList 1]
    return [string range $ymBig 0 3]

}
<span class="comment-line">###################################################################################</span>
<span class="comment-line"># Procedure: _copyRobotImagesToTftp</span>
<span class="comment-line">#</span>
<span class="comment-line">###################################################################################</span>
<strong><a name="::::_copyRobotImagesToTftp_356">proc <a href="robot.tcl-annot.html#::::_copyRobotImagesToTftp">::::_copyRobotImagesToTftp</a></a></strong> {userInput args} {
    global DEVREG tftpServerList ROBOT

    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _copyRobotImagesToTftp $args {
        qId       &#34;null&#34;
        help      &#34;null&#34;
    }

    array set uInput $userInput
    set familyList &#34;&#34;
    foreach n [array names uInput] {
        if {[regexp -nocase &#34;(\[a-zA-Z0-9_]+)Image:&#34; $n a p] &amp;&amp; $uInput($n) != &#34;NULL&#34;} {
            set lowerPlat [string tolower $p]
            if {[lsearch $familyList $DEVREG(platImageType,$lowerPlat)] &lt; 0} {
                lappend familyList $DEVREG(platImageType,$lowerPlat)
                set famFile($DEVREG(platImageType,$lowerPlat)) &#34;$DEVREG(server,imagesQueuedDir)/$qId/[file tail $uInput($n)]&#34;
            }
        } elseif {[regexp &#34;Image:&#34; $n] &amp;&amp; $uInput($n) == &#34;NULL&#34;} {
            <span class="comment-line"># Do nada</span>
        } elseif {[regexp &#34;Image:&#34; $n]} {
            puts &#34;call the wrapper proc to check $uInput($n)&#34;
        } else {
            <span class="comment-line">#puts &#34;Found name: $n   with value $uInput($n)&#34;</span>
            if {$n == &#34;platformToRunOn:&#34;} {
                set fplat [string trim $uInput($n)]
                <span class="comment-line">#set yTail [file tail $ROBOT_YAML($plat,0)]</span>
                <span class="comment-line">#set modStat &#34;runningOn$yTail&#34;</span>
                puts &#34;\n\n\nFound plat $fplat \n\n&#34;
            }
        }
    }
    <span class="comment-line"># Put the images on the tftpserver in Robot format = RTP_######_######{family}.xos</span>
    foreach ifl $familyList {
        if {[file exists $famFile($ifl)]} {
            if {[catch {exec cp -L $famFile($ifl) /tftpmount/${qId}${ifl}.xos} reason]} {
                puts &#34;Copy of $famFile($ifl) to tftp failed&#34;
            } else {
                puts &#34;Copy $ifl to tftp: mv $famFile($ifl) /tftpmount/${qId}${ifl}.xos&#34;
            }
        } else {
            puts &#34;Error $ifl file $famFile($ifl) does not exist&#34;
        }
    }
}
<span class="comment-line">#######################################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#######################################################################################</span>
<strong><a name="::::UpdateRobotImagesDone_404">proc <a href="robot.tcl-annot.html#::::UpdateRobotImagesDone">::::UpdateRobotImagesDone</a></a></strong> {qId runIndex rstatus} {
    global DEVREG MAIN env
    <a name="::WriteToQueueDebug(1)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateRobotImagesDone args&#34; &#34;qId $qId\nrunIndex $runIndex\nrstatus: $rstatus&#34;;

    set runningQueueFile &#34;$DEVREG(server,imagesRunningDir)/$qId&#34;
    set skipUpdate 1
    if {![catch {glob -- $DEVREG(server,imagesRunningDir)/$qId} queues]} { ;<span class="comment-line"># qId is already running</span>
        <span class="comment-line">#open the current running info file</span>
        if {[set fd_q [<a name="::FileOpen(2)"><a href="./queueLib.tcl.html#::FileOpen_58">::FileOpen</a></a> $runningQueueFile/info r+]]==-1} {
            return $fd_q
        }
        while {[gets $fd_q infoLine]!=-1} {
            set userInput([lindex $infoLine 0]) [lrange $infoLine 1 end]
        }
        <span class="comment-line"># Make sure this is a robot run</span>
        if {$userInput(harness:) != &#34;robot&#34;} {
            puts &#34;How.. this should be a robot run&#34;
            close $fd_q
            return -1
        }
        <span class="comment-line">#set MAIN(resultList) [getRunRegTestModuleStatus $MAIN(reg_id) $MAIN(module)]</span>
        set updateStr PASSOn$MAIN(cfg)
        if {[regexp -nocase &#34;fail&#34; $rstatus]} {
            set updateStr FAILOn$MAIN(cfg)
        }
        set preRunStat $userInput(runStatus:)
        set userInput(runStatus:) [lreplace $userInput(runStatus:) $runIndex $runIndex &#34;$updateStr&#34;]
        <a name="::WriteToQueueDebug(2)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateRobotImagesDone replace runStatus with updateStr&#34; \
         &#34;Init status: $preRunStat\nupdateStr: $updateStr\n\
          New userInput(runStatus:): $userInput(runStatus:)&#34;
        <span class="comment-line"># Everything in the info file is finished running</span>
        if {[lsearch -regexp $userInput(runStatus:) &#34;queued|running|reRunOn&#34;]==-1} {
            <a name="::WriteToQueueDebug(3)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateRobotImagesDone Run Completed&#34; \
                &#34;userInput(runStatus:): $userInput(runStatus:)&#34;
            <span class="comment-line"># Jenkins check</span>
            if {$DEVREG(active,jenkins)} {
                puts &#34;Jenkins update reg_run rId status $rrStatus&#34;
                if {[regexp -nocase &#34;fail&#34; $userInput(runStatus:)]} {
                    <a name="::updateJenkinsRegIdStatus(1)"><a href="./mysqlLib.tcl.html#::updateJenkinsRegIdStatus_4098">::updateJenkinsRegIdStatus</a></a> -q_id $qId -reg_id &#34;$MAIN(reg_id)&#34; -status ${rrStatus}_Fail -url &#34;$DEVREG(active,jenkins_url)&#34;
                } else {
                    <a name="::updateJenkinsRegIdStatus(2)"><a href="./mysqlLib.tcl.html#::updateJenkinsRegIdStatus_4098">::updateJenkinsRegIdStatus</a></a> -q_id $qId -reg_id &#34;$MAIN(reg_id)&#34; -status ${rrStatus}_Pass -url &#34;$DEVREG(active,jenkins_url)&#34;
                }
            }
            <span class="comment-line"># UseDb is on. update the runreg table</span>
            if {$DEVREG(mysql,UseDb)} {
                puts &#34;Update reg_run rId status Complete&#34;
                <a name="::updateRegIdStatus(1)"><a href="./mysqlLib.tcl.html#::updateRegIdStatus_3793">::updateRegIdStatus</a></a> -reg_id &#34;$MAIN(reg_id)&#34; -status &#34;Complete&#34;
            }
            if {![file isdirectory $DEVREG(server,imagesFinishedDir)]} {
                if {[catch {file mkdir $DEVREG(server,imagesFinishedDir)} reason]} {
                    <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Can not create imagesFinishedDir dir...$reason&#34;
                }
            }
            if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId]} {
                if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$qId&#34;} reason]} {
                    <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId...$reason&#34;;
                }
            }
            if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)]} {
                if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)&#34;} reason]} {
                    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)...$reason&#34;;
                }
            }
            if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/Report]} {
                if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/Report&#34;} reason]} {
                    <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/Report...$reason&#34;;
                }
            }
            set rfs [glob $MAIN(robotRepDir)/*.*]
            foreach rf $rfs {
                if {[catch {file copy $rf $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/Report} reason]} {
                    <a name="::WriteToQueueDebug(4)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateRobogtImagesDone FAIL COPY&#34; \
                     &#34;fail copy to $rf to $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/Report&#34;
                    <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot file copy $rf $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/Report...$reason&#34;;
                }
            }
            seek $fd_q 0 start
            foreach varName [array names userInput] {
                puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
            }
            ftruncate $runningQueueFile/info [tell $fd_q]
            close $fd_q
            if {[catch {file rename -force $runningQueueFile/info \
                   &#34;$DEVREG(server,imagesFinishedDir)/$qId/info&#34;} reason]} {;<span class="comment-line"># Force chosen as first run might create it already</span>
                <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot rename $runningQueueFile/info to $DEVREG(server,imagesFinishedDir)/$qId/info...$reason&#34;;
            } else {
                file delete $runningQueueFile
            }
            <span class="comment-line"># Delete the imagesQueued if it is there. Which it is for robot</span>
            if {[file isdirectory $DEVREG(server,imagesQueuedDir)/$qId]} {   ;<span class="comment-line"># delete the queuedDir</span>
                if {[catch {exec $env(BASE_PATH)/rmProc -rf $DEVREG(server,imagesQueuedDir)/$qId} reason]} {
                    <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not remove $DEVREG(server,imagesQueuedDir)/$qId, $reason&#34;
                    return -1
                }
            }
            return 1
        } else {
            if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId]} {
                if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$qId&#34;} reason]} {
                    <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId...$reason&#34;;
                    return -1
                }
            }
            if {![file isdirectory $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)]} {
                if {[catch {file mkdir &#34;$DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)&#34;} reason]} {
                    <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot create dir $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)...$reason&#34;;
                    return -1
                }
            }
            set rfs [glob $MAIN(robotRepDir)/*.*]
            foreach rf $rfs {
                if {[catch {file copy $rf $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)/} reason]} {
                    <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot file copy $rf $DEVREG(server,imagesFinishedDir)/$qId/$MAIN(module)...$reason&#34;;
                    return -1
                }
            }
            seek $fd_q 0 start
            foreach varName [array names userInput] {
                puts $fd_q &#34;[format &#34;%-20s %-20s&#34; &#34;$varName&#34; $userInput($varName)]&#34;
            }
            ftruncate $runningQueueFile/info [tell $fd_q]
            close $fd_q
            return 1
        }
    } else {  ;<span class="comment-line"># qId not Found, an error</span>
        <a name="::WriteToQueueDebug(5)"><a href="./queueLib.tcl.html#::WriteToQueueDebug_1582">::WriteToQueueDebug</a></a> &#34;UpdateRobogtImagesDone&#34; \
                 &#34;QID NOT FOUND IN imagesRunning $qId...$queues&#34;
        <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Cannot find $DEVREG(server,imagesRunningDir)/$qId...$queues&#34;;
        return -1
    }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
