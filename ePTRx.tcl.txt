##################################################################
# $RCSfile: ixiaRx.tcl,v $ - SQA Library
#
# Copyright (c) 1999 by Extreme Networks Inc.
# 
# Revision control history
# ------------------------
# $Header: /export/cvsroot/automation/Lib/ixiaRx.tcl,v 2.33.6.37 2010/08/24 01:39:52 ghundertmark Exp $
#
# Extreme Networks modification history
# -------------------------------------
# $Log: ixiaRx.tcl,v $
# Revision 2.33.6.37  2010/08/24 01:39:52  ghundertmark
# Merge branch 12_4 to trunk
#
# Revision 2.33.6.37  2010/08/24 01:39:52  ghundertmark
# Merge branch 12_4 to trunk
#
# Revision 2.33.6.36  2009/07/07 22:39:03  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.33.6.35.2.2  2010/08/19 02:22:08  ghundertmark
# Local changes on NAS branch
#
# Revision 2.33.6.35.2.1  2009/07/07 22:37:05  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.33.6.35  2009/07/01 10:55:41  nellinivasu
# Merged From Branch 'branch-dev_v12-1-rel4'
#
# Revision 2.33.6.34  2009/04/14 00:46:34  lagrawal
# merge from dev branch
#
# Revision 2.33.6.33.6.1  2009/03/04 06:53:06  ghundertmark
# check for divid by zero
#
# Revision 2.33.6.33  2008/08/05 03:44:07  lagrawal
# merge from branch-fixes_v12-1-rel0
#
# Revision 2.33.6.32.4.1  2008/06/07 01:33:19  lagrawal
# murge from branch-dev_v12-1-rel0
#
# Revision 2.33.6.32.2.1  2008/06/06 22:09:22  autotest-sc
# Murged from exos_br_12_1 to branch-dev_v12-1-rel0
#
# Revision 2.33.6.32  2008/05/08 15:21:17  nellinivasu
# Moved proc SetPortFilter from Clearflow module to Lib.
#
# Revision 2.33.6.31  2007/11/05 22:26:10  achilukuri
# Fixed EnablePortFilter proc
#
# Revision 2.33.6.30  2007/11/02 20:08:48  achilukuri
# Fixed the EnablePortFilter proc
#
# Revision 2.33.6.29  2007/10/22 16:24:12  achilukuri
# Added pattern1 option to EnablePortFilter proc
#
# Revision 2.33.6.27  2007/06/25 23:20:37  rabhavikatti
# Modified for STXS4 card type
#
# Revision 2.33.6.26  2007/05/01 23:02:17  ghundertmark
# Add proc to return time stamps specific to the indexed packet numbers
# on an ixia port GetCapturedFramesTimeStampIndexed
#
# Revision 2.33.6.25  2007/04/30 11:41:41  ghundertmark
# Alter CheckRateTxRx sum checking, fix negative check percentage for failed case
#
# Revision 2.33.6.24  2007/03/20 20:48:36  ghundertmark
# Fix sumTx vr sumRx in CheckRatesTxRx
#
# Revision 2.33.6.23  2007/02/01 18:50:24  ghundertmark
# Add enhancement to checkratesrxtx to allow check of rxtotals
#
# Revision 2.33.6.22  2007/01/29 20:12:09  skumar
# StartCapture twice to avoid leftover pkt in DisablePorts
#
# Revision 2.33.6.21  2007/01/03 22:01:11  skumar
# Do not call package req at top
#
# Revision 2.33.6.20  2006/11/17 15:00:36  skumar
# Fixed the loopback on txs cards
#
# Revision 2.33.6.19  2006/10/23 19:10:20  skumar
# DisableIxiaPorts clears the buffer
#
# Revision 2.33.6.18  2006/10/05 19:29:24  skumar
# Enable/disable using simulateCableDisconnect
#
# Revision 2.33.6.17  2006/09/29 22:38:16  djain
# Commit for Release Q1FY07-Rel11.4
#
# Revision 2.33.6.16  2006/07/12 22:27:33  smohanty
# Merged from exos-br-11_4 for L1 switch integration
#
# Revision 2.33.6.15.2.1  2006/07/01 00:06:16  smohanty
# Modified for L1 switch integration
#
# Revision 2.33.6.15  2006/06/30 22:35:35  ghundertmark
# Q4FY06 Release commit
#
# Revision 2.33.6.14  2006/06/23 17:50:16  ghundertmark
# Correct percent_tolerance in CheckRatesTxRx
#
# Revision 2.33.6.13  2006/06/22 15:37:43  ghundertmark
# add checkratesTxRx, which compares tx and rx on a per port basis instead of just a tx to multiple rx... compared to checkrates
#
# Revision 2.33.6.12  2006/05/25 01:51:23  skumar
# Added proc to get oversize rx rate, option in CheckRate
#
# Revision 2.33.6.11  2006/04/27 01:14:26  smohanty
# Added ClearPortsStats in proc StartPortsCapture to clear all the previous
# statistics of the port.
#
# Revision 2.33.6.10  2006/04/25 02:48:12  smohanty
# Modified GetCapturedFrames for not getting any packets if it is more than
# a specified number of packets. By default the threshhold is 200
#
# Revision 2.33.6.9  2006/02/23 20:29:40  agoyal
# merge from branch-12
#
# Revision 2.33.6.7.2.1  2006/02/18 19:09:04  agoyal
# add procedure to return number of captured packets
#
# Revision 2.33.6.7  2005/12/08 02:50:58  skumar
# Removed list val for patternMask in EnableFilter
#
# Revision 2.33.6.6  2005/06/21 18:44:04  skumar
# Fixed DisablePortFilter to enable capture/filter triggers
#
# Revision 2.33.6.5  2005/02/13 08:26:05  skumar
# Redo anyPattern code in EnablePortFilter
#
# Revision 2.33.6.4  2004/12/06 21:44:06  skumar
# Updated portFilter routine for EAPS tests
#
# Revision 2.33.6.3  2004/06/16 20:09:52  cshaw
# merge from main trunk again for ixOS3.70 stuff
#
# Revision 2.44  2004/02/13 19:45:22  alim
# Changed name of EnablePorts to EnableIxiaPorts and added code to check linkStatus (DisablePorts as well)
#
# Revision 2.43  2003/07/13 02:59:07  skumar
# Info for better debugability
#
# Revision 2.33.6.2  2004/04/01 21:57:02  skumar
# Commit as part of release5
#
# Revision 2.33.6.1  2003/08/20 03:20:05  cshaw
# trunk-exos release
#
# Revision 2.33.4.1  2003/06/23 21:28:45  cshaw
# Merged in EW trunk
#
# Revision 2.42  2003/04/18 19:36:19  autotest
# Added GetNumOversizedFramesReceived.
#
# Revision 2.41.8.1  2003/04/14 17:14:24  cshaw
# modify GetCapturedFramesTimeStamp to allow timestamp be written to file
#
# Revision 2.41  2002/12/10 22:58:08  skumar
# Merged from br-1-0.
#
# Revision 2.40  2002/12/04 19:27:17  autotest
# Fix ixia problem in loopback/normal sequence. Retains prev port's config.
#
# Revision 2.39  2002/11/22 17:52:55  skumar
# Port get in DisablePorts to avoid taking prev written port config. Fixes bug in DisablePorts.
#
# Revision 2.38.2.1  2002/12/10 21:12:43  skumar
# Merged from br-1-0.
#
# Revision 2.40  2002/12/04 19:27:17  autotest
# Fix ixia problem in loopback/normal sequence. Retains prev port's config.
#
# Revision 2.39  2002/11/22 17:52:55  skumar
# Port get in DisablePorts to avoid taking prev written port config. Fixes bug in DisablePorts.
#
# Revision 2.38  2002/10/28 22:08:48  cshaw
# Add GetRxArpRequest
#
# Revision 2.37  2002/09/04 23:23:40  aleu
# add proc CheckMatchPacketType{}
#
# Revision 2.36  2002/08/13 02:21:05  tquach
# add comment
#
# Revision 2.35  2002/07/22 21:46:47  tquach
# Add comment
#
# Revision 2.34  2002/07/19 00:33:04  skumar
# Change port specific calls *ixClearPortStats* to ixClearStats.
#
# Revision 2.33  2002/06/28 19:07:28  aleu
# added EnablePortFilter{} & DisablePortFilter{}
#
# Revision 2.32  2002/06/07 19:21:54  tquach
# Fixed checkrate
#
# Revision 2.31  2002/05/06 21:31:43  aleu
# remove all cardSpeed global var
#
# Revision 2.30  2001/12/19 00:28:30  tquach
# Change checkrate
#
# Revision 2.29  2001/11/21 03:07:51  tquach
# Change CheckRate function because of receiving 1 or 2 packages problem
#
# Revision 2.28  2001/11/08 01:27:26  aleu
# add GetByteRatereceived{} and GetByteRateSent{}
#
# Revision 2.27  2001/11/06 23:38:46  tquach
# Change percent tolerance
#
# Revision 2.26  2001/07/27 19:11:29  skumar
# Fixed the gigPort related commands in Enable/DisablePorts.
#
# Revision 2.25  2001/07/24 22:12:01  tquach
# Add fix for 1000GBIC card
#
# Revision 2.24  2001/06/07 00:42:07  skumar
# Minor changes in ixiaUserDefinedStat1.
#
# Revision 2.23  2001/04/13 23:12:49  skumar
# Added getTaggedFrameRateReceived proc.
#
# Revision 2.22  2000/10/26 19:35:05  tnguyen
# Fix version function call for 2.1
#
# Revision 2.21  2000/10/25 18:48:07  skumar
# Changes take care of write to report file if fd_res given to
# GetCapturesFrames.
#
# Revision 2.20  2000/10/21 02:49:55  skumar
# Put version check for GetNumBytes due to ixia bug in 2.1.
#
# Revision 2.19  2000/10/20 17:36:57  tnguyen
# Add StartPortsTransmit function and Add another header for CheckRates
#
# Revision 2.18  2000/10/17 18:10:28  tnguyen
# Fix a bug in check rate and add a comment line to this function
#
# Revision 2.17  2000/10/10 21:50:27  skumar
# Changed result_warning->result_error.
# Certain changes for output formatting.
#
# Revision 2.16  2000/09/25 18:26:48  tnguyen
# Call capturing ports instead of capturing cards
#
# Revision 2.15  2000/09/24 22:33:22  skumar
# Added functions CheckRates, GetCapturedFramesTimeStamp.
#
# Revision 2.14  2000/09/12 22:56:12  tnguyen
# Add functions to enable and disable ports
#
# Revision 2.13  2000/08/15 22:00:21  skumar
# Fixed a typo from ixiaSop to ixiaStop.
#
# Revision 2.12  2000/08/04 22:25:34  tnguyen
# Global change of commonly used funtions to conform with new conventions
#
# Revision 2.11  2000/08/04 18:29:37  jfan
# Change "put" to "result_debug"
#
# Revision 2.10  2000/08/04 15:59:59  tnguyen
# Add wrapper functions for many ixia functions
#
# Revision 2.9  2000/04/28 17:25:56  jlequang
# Fist stage of incorporating old BD-extension to Thanh's
# new enhancement.
#
# Revision 2.8  2000/04/07 00:23:48  tnguyen
# Various modifications to the whole project in Lib, L2 and L3.  Commit changes for all these folders at the same time.
#
# Revision 2.7  2000/01/07 00:00:24  jfan
# Add "after 1000" to insure Ixia statistics updated
#
# Revision 2.6  1999/10/11 16:19:24  jfan
# Disable some debugging messages because they are not currently used
#
# Revision 2.5  1999/09/27 22:27:25  jfan
# Use result_debug, result_ok & result_error for messages
#
# Revision 2.4  1999/08/10 18:10:34  jfan
# Added ixiaCapture_ip and ixiaCaptureOnePort_ip
#
# Revision 2.3  1999/08/06 22:54:49  andrew
# Style change
#
# Revision 2.2  1999/07/23 23:23:06  aedem
# Removed load {expect.dll} line
#
# Revision 2.1  1999/07/23 14:50:23  aedem
# Merge for 2.0
#
# Revision 1.1.1.1.2.2  1999/07/23 18:40:14  aedem
# Updated to use the new result formatting functions
#
# Revision 1.1.1.1.2.1  1999/06/30 15:16:12  aedem
# Updated for Linux and Ixia 2.0 Beta
#
# Revision 1.1.1.1  1999/06/25 17:53:46  jfan
# Initial import.
#
#
##################################################################

set auto_path [linsert $auto_path 0 . ]

################################################################## 
# Procedure Name: ixiaCapture
#   
# Description: Start capturing packets for all ports
#               
#     
#
# Input args:
#                Chid - chassis id
#                
# Output args: none
#
# Typical usage: 
#      return [ixiaCaptureOnePort $chasis $card $port $fd_res]
#
# Category: Setup
################################################################## 

proc ixiaCapture {{fd_res "NULL"} \
                  {chid 1}        \
                  {fd_in "NULL"}} {
   global spawn_id
#   global one2oneArray

#   foreach txMap [lsort [array names one2oneArray]] {
#      set rxMap $one2oneArray($txMap)
#	  scan $txMap "%d,%d,%d" x y z
#      scan [join $rxMap] "%d %d %d" chid c p
      capture get $chid $c $p
      set numCapFrames [capture cget -nPackets]
      captureBuffer get $chid $c $p 1 $numCapFrames

      puts "--- txMap=$txMap rxMap=$rxMap"
      puts $fd_res "--- txMap=$txMap rxMap=$rxMap"
      if { $fd_in != "NULL" } { puts $fd_in "^ $txMap $rxMap" }
      stat get statAllStats $chid $c $p
      set uds1 [stat cget -userDefinedStat1]
      puts "frames sent = [stat cget -framesSent]"
      puts "frames received = [stat cget -framesReceived]"
      puts "capture cget -nPackets = $numCapFrames"
      puts $fd_res "frames sent = [stat cget -framesSent]"
      puts $fd_res "frames received = [stat cget -framesReceived]"
      puts $fd_res "capture cget -nPackets = $numCapFrames"
      if { $fd_in != "NULL" } { 
         puts $fd_in "[stat cget -framesSent]"
         puts $fd_in "[stat cget -framesReceived]"
      }

      for {set i 0} {$i <= $numCapFrames} {incr i} {
         captureBuffer getframe $i
         puts "captureBuffer cget -frame = [captureBuffer cget -frame]"
         puts $fd_res "captureBuffer cget -frame = [captureBuffer cget -frame]"
         if {$fd_in != "NULL"} { puts $fd_in "[captureBuffer cget -frame]" }
#         puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]"
      }
#   }
}

################################################################## 
# Procedure Name: ixiaCaptureOnePort
#   
# Description: Start capturing packets for a port
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                
# Output args: 
#             if file = NULL, it will return a list containing raw captured data
#
# Typical usage: 
#      return [ixiaCaptureOnePort $chasis $card $port $fd_res]
#
# Category: Setup
################################################################## 
if { 0 } {
proc ixiaCaptureOnePort {{ch 1}          \
                         {cd 1}          \
                         {pt 1}          \
                         {fd_res "NULL"} \
                         {fd_in "NULL"}} {
   set rc [capture get $ch $cd $pt];
#   puts "capture get returned rc=$rc";
#   set numCapFrames [capture cget -nPackets];
#   set rc [captureBuffer get $ch $cd $pt 1 $numCapFrames];
   set rc [captureBuffer get $ch $cd $pt 1];
 #  puts "capture cget -nPackets = $numCapFrames";
  # puts "captureBuffer get returned rc=$rc";
   #puts "--- ($ch $cd $pt)";
#   if { $fd_res != "NULL" } {
#      puts $fd_res "--- ($ch $cd $pt)";
#   }
   if { $fd_in != "NULL" } {
    #  puts $fd_in "^ ($ch $cd $pt)";
   }

#   stat get statAllStats $ch $cd $pt;
#   set uds1 [stat cget -userDefinedStat1];
  # puts "frames sent = [stat cget -framesSent]";
  # puts "frames received = [stat cget -framesReceived]";
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]";
      puts $fd_in "[stat cget -framesReceived]";
   }
#   for {set i 0} {$i <= $numCapFrames} {incr i}
#      set rc [captureBuffer getframe $i]
      set rawFrames [captureBuffer cget -frame]
      #puts "rawFrames $rawFrames"
      return $rawFrames;
}
    #  puts "captureBuffer getframe returned rc=$rc";
#      puts "capturebuffer cget -timestamp = [captureBuffer cget -timestamp]";
     # puts "captureBuffer cget -frame = [captureBuffer cget -frame]";
#      if { $fd_res != "NULL" } {
#         puts $fd_res "Traffic on port $pt=[captureBuffer cget -frame]";
#      }
#      if {$fd_in != "NULL"} {
#         puts $fd_in "[captureBuffer cget -frame]";
#      } else {
#        lappend rawFrames "[captureBuffer cget -frame]";
#      }
#      puts "Inside Capture One Port Raw Frames : $rawFrames"
#      puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]";
#   ##
#      if {$fd_in == "NULL"} {
#        puts "Inside Capture If"
#      }
#      if { [ info exists rawFrames ] != "1" } {
#         set rawFrames {};
#      }
#      puts "Inside Capture One Port Raw Frames : $rawFrames"
#     return $rawFrames;
#
}
proc ixiaCaptureOnePort {{ch 1}          \
                         {cd 1}          \
                         {pt 1}          \
                         {fd_res "NULL"} \
                         {fd_in "NULL"}} {
   set rc [capture get $ch $cd $pt];
#   puts "capture get returned rc=$rc";
   set numCapFrames [capture cget -nPackets];
 #  puts "capture cget -nPackets = $numCapFrames";
   set rc [captureBuffer get $ch $cd $pt 1 $numCapFrames];
  # puts "captureBuffer get returned rc=$rc";
   #puts "--- ($ch $cd $pt)";
#   if { $fd_res != "NULL" } {
#      puts $fd_res "--- ($ch $cd $pt)";
#   }
   if { $fd_in != "NULL" } {
    #  puts $fd_in "^ ($ch $cd $pt)";
   }

#   stat get statAllStats $ch $cd $pt;
#   set uds1 [stat cget -userDefinedStat1];
  # puts "frames sent = [stat cget -framesSent]";
  # puts "frames received = [stat cget -framesReceived]";
   if { $fd_in != "NULL" } {
      puts $fd_in "[stat cget -framesSent]";
      puts $fd_in "[stat cget -framesReceived]";
   }

   for {set i 1} {$i <= $numCapFrames} {incr i} {
      set rc [captureBuffer getframe $i];
    #  puts "captureBuffer getframe returned rc=$rc";
#      puts "capturebuffer cget -timestamp = [captureBuffer cget -timestamp]";
     # puts "captureBuffer cget -frame = [captureBuffer cget -frame]";
      if { $fd_res != "NULL" } {
         puts $fd_res "Traffic on port $pt=[captureBuffer cget -frame]";
      }
      if {$fd_in != "NULL"} {
         puts $fd_in "[captureBuffer cget -frame]";
      } else {
         lappend rawFrames "[captureBuffer cget -frame]";
      }
#      puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]";
   }
   if {$fd_in == "NULL"} {
      if { [ info exists rawFrames ] != "1" } {
         set rawFrames {};
      }
      return $rawFrames;
   }
}

################################################################## 
# Procedure Name: ixiaStat
#   
# Description: Get Ixia statistics for a port
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                
#                
# Output args: 
#             it will return a list containing statistics for that  port
#
# Typical usage: 
#      return [ixiaStat $chasis $card $port $fd_res]
#
# Category: Setup
################################################################## 

proc ixiaStat {{ch 1}          \
               {cd 1}          \
               {pt 1}          \
               {fd_res "NULL"} \
               {fd_in "NULL"}} {
   global spawn_id

   after 1000
   puts "--- ($ch $cd $pt)"
   puts $fd_res "--- ($ch $cd $pt)"
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }
   capture get $ch $cd $pt
   stat get statAllStats $ch $cd $pt
#   set uds1 [stat cget -userDefinedStat1]
   puts "frames sent = [stat cget -framesSent]"
   puts "frames received = [stat cget -framesReceived]"
   puts $fd_res "frames sent = [stat cget -framesSent]"
   puts $fd_res "frames received = [stat cget -framesReceived]"
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]"
      puts $fd_in "[stat cget -framesReceived]"
   }
}


################################################################## 
# Procedure Name: ixiaUserDefinedStat1
#   
# Description: Ixia statistics - get a port statistic based on user define stat 1
#     
#               
# Input args:
#              portId - port id  
#                                
# Output args: 
#              return $SentReceivedPackets
#
# Typical usage: 
#              [ixiaUserDefinedStat1 $portId $filePt]
#
# Category: Setup
################################################################## 

proc ixiaUserDefinedStat1 {{portId 1}          \
               {fd_res "NULL"} \
               {fd_in "NULL"}} {
   global spawn_id

   after 1000
   MapIxiaPortId $portId ch cd pt
   if {$fd_res != "NULL"} {puts $fd_res "--- ($ch $cd $pt)"}
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }
   capture get $ch $cd $pt
   stat get statAllStats $ch $cd $pt
   set frReceived [stat cget -userDefinedStat1]
   set frSent [stat cget -framesSent]
   puts "Frames sent = $frSent"
   if {$fd_res!="NULL"} {puts $fd_res "Frames sent = $frSent"}
   puts "Total frames received = [stat cget -framesReceived] (not used)"
   puts "Filtered frames UDS1 received = $frReceived"
   if {$fd_res!="NULL"} {puts $fd_res "Filtered frames UDS1 received = $frReceived"}
   if { $fd_in != "NULL" } { 
      puts $fd_in "$frSent"
      puts $fd_in "$frReceived"
   } else {
      set SentReceivedPackets "$frSent $frReceived"
      return $SentReceivedPackets
   }
}

################################################################## 
# Procedure Name: ixiaStatFlood
#   
# Description: Ixia statistics - get a port statistics
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                fd_res - file pointer
#                fd_in - file pointer
#                                
# Output args: none
#              
#
# Typical usage: 
#              [ixiaStatFlood $chasis $card $port $fd_res $fd_in]
#
# Category: utility
################################################################## 

proc ixiaStatFlood {{ch 1}          \
                    {cd 1}          \
                    {pt 1}          \
                    {fd_res "NULL"} \
                    {fd_in "NULL"}} {
   global spawn_id

   puts "--- ($ch $cd $pt)"
   puts $fd_res "--- ($ch $cd $pt)"
	if { $fd_in != "NULL" } {
		puts $fd_in "^ ($ch $cd $pt)"
	}
   capture get $ch $cd $pt
   stat get statAllStats $ch $cd $pt
   puts "frames sent = [stat cget -framesSent]\nflooding frames received = [stat cget -userDefinedStat1]"
   puts $fd_res "frames sent = [stat cget -framesSent]\nflooding frames received = [stat cget -userDefinedStat1]"
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]"
      puts $fd_in "[stat cget -userDefinedStat1]"
   }
}

################################################################## 
# Procedure Name: ixiaPayloadOnePort
#   
# Description: Return statistic on a Ixia's port.
#              It will return the transmit rate or receive rate based on the port 
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id 
#                direction - traffic direction 
#                fd_res - file pointer
#                                
# Output args: 
#              TxRate
#
# Typical usage: 
#              [ixiaPayloadOnePort $chasis $card $port $direction $fd_res]
#
# Category: utility
################################################################## 

proc ixiaPayloadOnePort {{ch 1}            \
                         {cd 1}            \
                         {pt 1}            \
                         {direction "tx"}  \
                         {fd_res "NULL"}} {
   global spawn_id

   result_debug "--- ($ch $cd $pt)"
#   capture get $ch $cd $pt
   stat getRate statAllStats $ch $cd $pt
   set txRate [stat cget -framesSent]
   set rxRate [stat cget -framesReceived]

   result_debug "frames sent rate = $txRate\nframes received rate = $rxRate"

   if { $direction == "tx" } {
      return $txRate
   } else {
      return $rxRate
   }
}

################################################################## 
# Procedure Name: ixiaCapture_ip
#   
# Description: Capture IP packets for all ports
#               
# Input args:
#                Chid - chassis id
#                fd_res - file pointer
#                fd_in - file pointer
#                                
# Output args: 
#                Return information in a file
#
# Typical usage: 
#              [ixiaCapture_ip $fd_res $chid $fd_in]
#
# Category: utility
################################################################## 

proc ixiaCapture_ip {{fd_res "NULL"} \
                     {chid 1}        \
                     {fd_in "NULL"}} {
   global spawn_id
#  global one2oneArray

#  foreach txMap [lsort [array names one2oneArray]] {
#     set rxMap $one2oneArray($txMap)
#  scan $txMap "%d,%d,%d" x y z
#     scan [join $rxMap] "%d %d %d" chid c p
      capture get $chid $c $p
      set numCapFrames [capture cget -nPackets]
      captureBuffer get $chid $c $p 1 $numCapFrames

      puts "--- txMap=$txMap rxMap=$rxMap"
      puts $fd_res "--- txMap=$txMap rxMap=$rxMap"
      if { $fd_in != "NULL" } { puts $fd_in "^ $txMap $rxMap" }
      stat get statAllStats $chid $c $p
      set uds1 [stat cget -userDefinedStat1]
      puts "    frames sent = [stat cget -framesSent]"
      puts "    frames received = [stat cget -framesReceived]"
      puts "    capture cget -nPackets = $numCapFrames"
      puts $fd_res "    frames sent = [stat cget -framesSent]"
      puts $fd_res "    frames received = [stat cget -framesReceived]"
      puts $fd_res "    capture cget -nPackets = $numCapFrames"
      if { $fd_in != "NULL" } { 
         puts $fd_in "[stat cget -framesSent]"
         puts $fd_in "[stat cget -framesReceived]"
      }

      for {set i 0} {$i <= $numCapFrames} {incr i} {
         captureBuffer getframe $i
         puts "    captureBuffer cget -frame = [captureBuffer cget -frame]"
         puts $fd_res "    captureBuffer cget -frame = [captureBuffer cget -frame]"
         if {$fd_in != "NULL"} { puts $fd_in "[captureBuffer cget -frame]" }
      }
      puts "-------------------\n"
      puts $fd_res "-------------------\n"
   }
   puts "\r"
   puts $fd_res "\r"
}

################################################################## 
# Procedure Name: ixiaCaptureOnePort_ip
#   
# Description: Capture IP packets for a port
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                dList - 
#                fd_res - file pointer
#                                
# Output args:  
#                Write information in a file
#
# Typical usage: 
#              [ixiaCaptureOnePort_ip $chasis $card $port $dList $fd_res]
#
# Category: utility
################################################################## 

proc ixiaCaptureOnePort_ip {{ch 1}			 \
                            {cd 1}			 \
                            {pt 1}			 \
		            {dList {}}  	 \
                            {fd_res "NULL"}	 \
						    {fd_in "NULL"}} {
   global spawn_id

   capture get $ch $cd $pt
   set numCapFrames [capture cget -nPackets]
   captureBuffer get $ch $cd $pt 1 $numCapFrames

   puts "--- ($ch $cd $pt)"
   puts $fd_res "--- ($ch $cd $pt)"
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }

   stat get statAllStats $ch $cd $pt
   set uds1 [stat cget -userDefinedStat1]
   puts "    frames sent = [stat cget -framesSent]"
   puts "    frames received = [stat cget -framesReceived]"
   puts "    capture cget -nPackets = $numCapFrames"
   puts $fd_res "    frames sent = [stat cget -framesSent]"
   puts $fd_res "    frames received = [stat cget -framesReceived]"
   puts $fd_res "    capture cget -nPackets = $numCapFrames"
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]"
      puts $fd_in "[capture cget -nPackets]"
   }

   for {set i 0} {$i <= $numCapFrames} {incr i} {
      captureBuffer getframe $i
      puts "    captureBuffer cget -frame = [captureBuffer cget -frame]"
      puts $fd_res "    captureBuffer cget -frame = [captureBuffer cget -frame]"
      if {$fd_in != "NULL"} { puts $fd_in "[captureBuffer cget -frame]" }

      set capframe [captureBuffer getframe $i]
      ip decode $capframe
      foreach item [lsort $dList] {
result_debug "--- item=$item"
		 set value [ip cget -$item]
         result_debug "    $item=$value"
         if { $fd_in != "NULL" } { 
            result_debug "    $item=$value"
		 }
	  }
   }
   puts "\r"
}

################################################################## 
# Procedure Name: StartPortsCapture
#   
# Description: Start ports capture
#               
# Input args:
#              portIdList - port list
#                                
# Output args: 
#              none  
#
# Typical usage: 
#              [StartPortsCapture $portIdList]
#
# Category: setup
################################################################## 
proc StartPortsCapture {portIdList} {

  # foreach portId $portIdList {
  #    MapIxiaPortId $portId chas card port
  #    ixStartPortCapture  $chas $card $port
  #    puts "ixStartPortCapture  $chas $card $port"      
  # }

  global portMappingList
  
  ClearPortsStats $portIdList

  ClearPortsStats $portIdList 

#  foreach p $portIdList {
#     set portList [lindex $portMappingList [expr $p-1]]
#     result_debug "INFO: DUT[lindex $portList 2] [lindex $portList 1] egresses to portId [lindex $portList 0]"
#  }
  foreach portId $portIdList {
      MapIxiaPortId $portId chas card port
      lappend plist "$chas $card $port"
  }

  ixStartCapture $plist

}

################################################################## 
# Procedure Name: StopPortsCapture
#   
# Description: Stop ports capture
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##              [StopPortsCapture $portIdList]
#
# Category: setup
################################################################## 
proc StopPortsCapture {portIdList} {

   #foreach portId $portIdList {
   #   MapIxiaPortId $portId chas card port
   #   ixStopPortCapture  $chas $card $port
   #}

   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixStopCapture $plist

}

################################################################## 
# Procedure Name: StopPortsTransmit
#   
# Description: Stop Ports Transmit
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##              [StopPortsCapture $portIdList]
#
# Category: setup
################################################################## 
proc StopPortsTransmit {portIdList} {
   #foreach portId $portIdList {
   #   MapIxiaPortId $portId txChas txCard txPort
   #   ixStopPortTransmit  $txChas $txCard $txPort
   #}  

   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixStopTransmit $plist
}

################################################################## 
# Procedure Name: StartPortsTransmit
#   
# Description: Start Ports Transmit
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##             [StartPortsTransmit $portIdList]
#
# Category: setup
################################################################## 
proc StartPortsTransmit {portIdList} {
   #foreach portId $portIdList {
   #   MapIxiaPortId $portId txChas txCard txPort
   #   ixStartPortTransmit  $txChas $txCard $txPort
   #}  

   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixStartTransmit $plist
}
       
################################################################## 
# Procedure Name: ClearPortsStats
#   
# Description: Clear all Ports Stats
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##              [ClearPortsStats $portIdList]
#
# Category: setup
##################################################################            
proc ClearPortsStats {portIdList} {
   #foreach portId $portIdList {
   #   MapIxiaPortId $portId txChas txCard txPort
   #   ixClearPortStats $txChas $txCard $txPort
   #}

   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixClearStats $plist

}

################################################################## 
# Procedure Name: GetCapturedFrames
#   
# Description: Get the captured frames
#               
# Input args:
#              portId - Port id
#                                
# Output args: 
#              return the captured frames
#              
# Typical usage: 
#             [GetCapturedFrames $portId]
#
# Category: setup
################################################################## 
proc GetCapturedFrames {portId {fd_res "NULL"} {packThreshold 200}} {
#   puts "portId: $portId"
   set numRece [GetNumFramesReceived $portId]
   if {$numRece > $packThreshold} {
      result_debug "High number of packets ($numRece) captured. \
                    Return without getting any packets"
      return
   }
   MapIxiaPortId $portId chasis card port
   return [ixiaCaptureOnePort $chasis $card $port $fd_res]
}

################################################################## 
# Procedure Name: GetCapturedFramesTimeStamp
#   
# Description: Get the captured frames time stamp
#               
# Input args:
#              portId - Port id
#                                
# Output args: 
#              return the captured frames time stamp
#              
# Typical usage: 
##             [GetCapturedFramesTimeStamp $portId]
#
# Category: setup
################################################################## 
proc GetCapturedFramesTimeStamp {portId {fd_res "NULL"}} {
#  puts "portId: $portId"
   MapIxiaPortId $portId chasis card port
   return [ixiaCapturedFramesTimeStamp $chasis $card $port $fd_res]
}


################################################################## 
# Procedure Name: GetCapturedFramesTimeStampIndexed
#   
# Description: Get the captured frames time stamp
#               
# Input args:  indexList - List of index numbers "1 4 9 10"
#              portId - Port id
#                                
# Output args: 
#              return a list of captured frames time stamps
#              for the indexes input.  Time is the 6 MSDigits
#              
# Typical usage: 
##             [GetCapturedFramesTimeStampIndexed $indexList $portId]
#
# Category: setup
##################################################################
proc GetCapturedFramesTimeStampIndexed {{indexList "1 2 3"} {portId 1}} {
   set zeroTime 0
   set hitFirst 0
   foreach pCount $indexList {
      set timeString [lindex [GetCapturedFramesTimeStamp $portId] $pCount]
      set timeLength [string length $timeString]
      switch $timeLength {
         "18" {
            lappend actTimeList [string range $timeString 0 8]
            set currentTime [string range $timeString 0 8]
         }         
         "17" {
            lappend actTimeList [string range $timeString 0 7]
            set currentTime [string range $timeString 0 7]
         }
         "16" {
            lappend actTimeList [string range $timeString 0 6]
            set currentTime [string range $timeString 0 6]
         }
         "15" {
            lappend actTimeList [string range $timeString 0 5]
            set currentTime [string range $timeString 0 5]
         }
         "14" {
            lappend actTimeList [string range $timeString 0 4]
            set currentTime [string range $timeString 0 4]
         }
         "13" {
            lappend actTimeList [string range $timeString 0 3]
            set currentTime [string range $timeString 0 3]
         }
         default {
            result_debug "Illegal time length $timeLength $timeString"
            lappend actTimeList ""
         }
      }
      if {$hitFirst == 0} {
         set hitFirst 1;
         set zeroTime $currentTime
         
      }
      result_debug "Normalized Time: [expr $currentTime - $zeroTime] \
                    TimeStamp: $currentTime"
   }
return $actTimeList
}
################################################################## 
# Procedure Name: EnablePorts
#   
# Description: Turn on loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [EnablePorts $portIdList]
#
# Category: setup
################################################################## 
proc EnablePorts {portIdList} {
    EnableIxiaPorts $portIdList;
}

################################################################## 
# Procedure Name: EnableIxiaPorts
#   
# Description: Turn on loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [EnableIxiaPorts $portIdList]
##             [EnableIxiaPorts $portIdList 0]  ;# Do not wait for link
#
# Category: setup
################################################################## 
proc EnableIxiaPorts {portIdList {maxWait 15}} {

    result_debug "Enabling Ixia ports $portIdList"

    foreach portId $portIdList {
	MapIxiaPortId $portId chasis card port
	#SK  Get the port before re-writing to avoid messing up the old port info.
	port get $chasis $card $port
	
        set ixiaCardType [getIxiaCardType $portId]
        result_debug "port $portId IXIA CARD IS $ixiaCardType"
        if {![regexp -nocase "TXS|GBIC|STX" $ixiaCardType]} { ;# LM dont have cabledisconnect
           port config -loopback false
        } else {
           port config -enableSimulateCableDisconnect false
        }
	
	# add this line for GBIC card
	port config -rxTxMode gigNormal
	
	port set $chasis $card $port
	port write $chasis $card $port
	
# ---   Required for Ixia ports shared across setups by a Extreme
#       Device as L1 Switch
        exDevIxiaPortEnable -portId $portId

	if {$maxWait == 0} {
	    continue
	}

	set maxWaitCounter $maxWait
	while { $maxWaitCounter } {
	    port get $chasis $card $port
	    if {[port cget -linkState] == 1} {
		result_debug "FOUND LINK UP for portId:$portId!"
		break
	    } else {
		result_debug "Waiting for portId:$portId linkUp.."
		sleep 1
		incr maxWaitCounter -1
	    }
	}
	if {$maxWaitCounter == 0} {
	    result_warning "WARNING: No linkUp for Ixia portId:$portId"
	}
   }
}

################################################################## 
# Procedure Name: DisablePorts
#   
# Description: Turn off loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [DisablePorts $portIdList]
#
# Category: setup
################################################################## 
proc DisablePorts {portIdList} {
   DisableIxiaPorts $portIdList;
}
################################################################## 
# Procedure Name: DisableIxiaPorts
#   
# Description: Turn off loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [DisableIxiaPorts $portIdList]
#
# Category: setup
################################################################## 
proc DisableIxiaPorts {portIdList} {

   result_debug "Disabling Ixia ports $portIdList"

   #an indirect way to disable a port
   foreach portId $portIdList {
      MapIxiaPortId $portId chasis card port

      #SK  Get the port before re-writing to avoid messing up the old port info.
      port get $chasis $card $port

      set ixiaCardType [getIxiaCardType $portId]
      result_debug "port $portId IXIA CARD IS $ixiaCardType"

      #SK: Following code needed to clear the buffer on disabled port.
      #SK: Put the port on loopback, start port capture to clear the buffer
      if {![regexp -nocase "TXS|GBIC" $ixiaCardType]} {
         port config -loopback true
      } else {
         port config -loopback true
         port config -rxTxMode gigLoopback
      }
      port set $chasis $card $port
      port write $chasis $card $port
      StartPortsCapture $portId
      StartPortsCapture $portId
      if {![regexp -nocase "TXS|GBIC" $ixiaCardType]} {
         port config -loopback false
      } else {
         port config -loopback false
	 port config -rxTxMode gigNormal
      }
      
      #SK: Actual disable port
      if {![regexp -nocase "TXS|GBIC|STX" $ixiaCardType]} {
         port config -loopback true
      } else {
         port config -enableSimulateCableDisconnect true
      }

      port set $chasis $card $port
      port write $chasis $card $port

# --- Required for Ixia ports shared across setups by a Extreme
#     Device as L1 Switch
      exDevIxiaPortDisable -portId $portId
   }
}

################################################################## 
# Procedure Name: GetNumBytesSent

################################################################## 
# Procedure Name: GetNumBytesSent
#   
# Description: Get the number of bytes sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return bytes sent
#              
# Typical usage: 
#              [GetNumBytesSent $portId]
#
# Category: setup
################################################################## 
proc GetNumBytesSent {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   version get
#   set ver [version cget -productVersion]
   set bytesSent [stat cget -bytesSent]
   #this bytesSent is only half of the actual bytes sent (Ixia bug)
   port get $chasisId $card $port
#   if {([port cget -speed] == 100) && ([regexp -nocase "2.1" $ver])} {
#      return [expr $bytesSent/2]
#   } else { return $bytesSent }
return $bytesSent
}

################################################################## 
# Procedure Name: GetNumBytesReceived
#   
# Description: Get the number of bytes received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return bytes received
#              
# Typical usage: 
#              [GetNumBytesReceived $portId]
#
# Category: setup
################################################################## 
proc GetNumBytesReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   set bytesRecv [stat cget -bytesReceived]
   #remove the stupid comma
   regsub -all {,} $bytesRecv {} bytesRecv
   return $bytesRecv
}

################################################################## 
# Procedure Name: GetNumFramesSent
#   
# Description: Get the number of frames sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frames sent
#              
# Typical usage: 
#              [GetNumFramesSent $portId]
#
# Category: setup
##################################################################
proc GetNumFramesSent {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -framesSent]
}

################################################################## 
# Procedure Name: GetNumFramesReceived
#   
# Description: Get the number of frames received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frames received
#              
# Typical usage: 
#              [GetNumFramesReceived $portId]
#
# Category: setup
##################################################################
proc GetNumFramesReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -framesReceived]
}

proc GetNumOversizedFramesReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -oversize]
}

################################################################## 
# Procedure Name: GetFrameRateSent
#   
# Description: Get the number of frame rate sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frame rate sent
#              
# Typical usage: 
#              [GetFrameRateSent $portId]
#
# Category: setup
##################################################################
proc GetFrameRateSent {portId} {
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -framesSent]
}

proc GetOversizedFrameRateReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -oversize]
}

################################################################## 
# Procedure Name: GetFrameRateReceived
#   
# Description: Get the number of frame rate received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frame rate received
#              
# Typical usage: 
#              [GetFrameRateReceived $portId]
#
# Category: setup
##################################################################
proc GetFrameRateReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -framesReceived]
}

################################################################## 
# Procedure Name: GetTaggedFrameRateReceived
#   
# Description: Get the number of tagged frame rate received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return tagged frame rate received
#              
# Typical usage: 
#              [GetTaggedFrameRateReceived $portId]
#
# Category: setup
##################################################################
proc GetTaggedFrameRateReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -vlanTaggedFramesRx]
}

################################################################## 
# Procedure Name: GetByteRateSent
#   
# Description: Get the number of byte rate sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return byte rate sent
#              
# Typical usage: 
#              [GetByteRateSent $portId]
#
# Category: setup
##################################################################
proc GetByteRateSent {portId} {
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -bytesSent]
   
}

################################################################## 
# Procedure Name: GetByteRateReceived
#   
# Description: Get the number of byte rate received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return byte rate received
#              
# Typical usage: 
#              [GetByteRateReceived $portId]
#
# Category: setup
##################################################################
proc GetByteRateReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -bytesReceived]
   
}

################################################################## 
# Procedure Name: GetRxArpRequest
#   
# Description: Get the number of ARP request received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return numer of ARP request received
#              
# Typical usage: 
#              [GetRxArpRequest $portId]
#
# Category: utility
##################################################################
proc GetRxArpRequest {{portId "1"}} {
	MapIxiaPortId $portId chasis card port
	stat get statAllStats $chasis $card $port
	return [stat cget -rxArpRequest]
}

##################################################################    
# Description: CheckRates
#     This proc can be used to check the tx and Rx packet rate.
#     It accepts Rx ports' list to check on multiple rx ports.
#     It calls GetFrameRateSent and GetFrameRateReceived.
# Input args: txPortId, rxPortIdList, percent_tolerance
# Output args: None.
# Typical usage:
# CheckRates $txPort $rxPortList
##################################################################    

proc CheckRates {txPortId rxPortIdList {comment ""} {percent_tolerance .011} args } {
   set rtValue "ok"
  parse_args CheckRates $args {
    reportResults 1
     oversize "false"
     reportResults 1
  }

   
   if {$txPortId > 100 } {
      set txRate $txPortId
   } else { set txRate [GetFrameRateSent $txPortId] }

   if {$reportResults} {
      report_start_test "Checking Rates $comment"
   }

   foreach var $rxPortIdList {
  
      set rxPort [lindex $var 0]
      set rxPercent [lindex $var 1]
      set tag [lindex $var 2]
      if {$tag!=""} {
         set rxRate [GetTaggedFrameRateReceived $rxPort]
      } else {
         set rxRate [GetFrameRateReceived $rxPort]
      }
      if {$oversize=="true"} {
         set rxRate [GetOversizedFrameRateReceived $rxPort]
      }
   
      if {$reportResults} {
         report_start_test "Comparing txRate($txPortId)=$txRate and rxRate($rxPort)=$rxRate"
      }
      result_debug "Comparing txRate($txPortId)=$txRate and rxRate($rxPort)=$rxRate"

      if { $txRate == 0 } {         
         if { $rxRate == 0 } {
            if {$reportResults == 1} {
        	    result_error "txRate($txPortId)=rxRate($rxPort)=0"
		} else {
	            result_debug "txRate($txPortId)=rxRate($rxPort)=0"
		}
	         set rtValue "error"
         } else {
            if {$reportResults == 1} {
	         result_error "txRate($txPortId)=0 but rxRate($rxPort)=$rxRate"
		 } else {
	         result_debug "txRate($txPortId)=0 but rxRate($rxPort)=$rxRate"
		 }
	         set rtValue "error"
         }
      } else {
         set exp_rxRate [expr abs (double($txRate) * $rxPercent/100)]
         if {$rxRate < $exp_rxRate} {
             set diff [expr abs( double($exp_rxRate) - double($rxRate) )]
         } else {
             set diff [expr abs( double($rxRate) - double($exp_rxRate) )]
         }
         result_debug "Rate $exp_rxRate Diff $diff"
         if {$exp_rxRate < 0.0001 } {
            if {($txRate > 1000) && ($rxRate <= 10)} {
                set pPercent 0;
            } else {
                set pPercent [expr $diff * $percent_tolerance] ;# not sure this is right             
            }
         } else {
            set pPercent [expr double($diff) / double($exp_rxRate) * 100.0]
         }           
         result_debug "--- pPercent=$pPercent"
         if { $pPercent <= $percent_tolerance } {
            result_ok "TxRate:$txRate, rxRate:$rxRate check Passed"
	      set rtValue "ok"
	 } elseif { $diff <= 5 } {
            result_ok "TxRate:$txRate, rxRate:$rxRate check Passed"
	      set rtValue "ok"	         
         } else {
	if {$reportResults == 1} {
            result_error "TxRate:$txRate, rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
            result_error [format "Difference (%01.2f%%) exceeds tolerance (%01.2f%%). Tx Rate is $txRate, Rx Rate is $rxRate.\n" $pPercent $percent_tolerance]
	  } else {
	    result_debug "TxRate:$txRate, rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
            result_debug [format "Difference (%01.2f%%) exceeds tolerance (%01.2f%%). Tx Rate is $txRate, Rx Rate is $rxRate.\n" $pPercent $percent_tolerance]
	  }
            set rtValue "error"
         }
      }
      if {$reportResults} {
         report_end_test
      }
   }
   if {$reportResults} {
      report_end_test
   }
   return $rtValue
}

##################################################################    
# Description: CheckRatesTxRx
#     This proc can be used to check the tx and Rx packet rate.
#     It accepts Tx and Rx ports' list to check on multiple rx ports.
#     It calls GetFrameRateSent and GetFrameRateReceived.
#
#     Differs from CheckRates in that specific Tx port %s are matched to
#     specific rx port %s.  negTest is used to verify 0% receives
#
# Input args: infoList, percent_tolerance
# Output args: None.
#
# lappend infoList {{1 1} {9 100 1}} :port1 tagged tx to port9 tagged expect 100%
# lappend infoList {{2 1} {10 100 1}}
# lappend infoList {{3} {11 50}} :port3 untag tx to port9 untag expect 50%
# lappend infoList {{4} {12 100}}
# lappend infoList {{negTest} {1 0}} :port1 expects 0%
# lappend infoList {{negTest} {2 0}}
# lappend infoList {{negTest} {3 0}}
# lappend infoList {{negTest} {4 0}}
# Typical usage:
# CheckRatesTxRx $infoList
# Category: utility
##################################################################    

proc CheckRatesTxRx {infoList {comment ""} {percent_tolerance .011} {sumRx "No"} {expectedSum 100}} {
    set rtValue "ok"
    
    report_start_test "Checking Rates $comment"
    set getSumTx 1
    set sumRxList ""
    foreach var $infoList {
        set txInfoList [lindex $var 0]
        set rxInfoList [lindex $var 1]
        result_debug "Transmit Information = $txInfoList"
        result_debug "Receive Information = $rxInfoList"
        # set tx vars
        set txPort [lindex $txInfoList 0]
        set txTag [lindex $txInfoList 1]
        #   set the sumTx for sumRx comparison
        if {$getSumTx && $txPort != "negTest"} {
           set sumTx [GetFrameRateSent $txPort]
           set getSumTx 0
        }
        # set rx vars
        set rxPort [lindex $rxInfoList 0]
        set rxPercent [lindex $rxInfoList 1]
        set rxTag [lindex $rxInfoList 2]
        #######################################################
        # Setup the the RX port rates
        #######################################################
        if {$rxTag!=""} {
            set rxRate [GetTaggedFrameRateReceived $rxPort]
        } else {
            set rxRate [GetFrameRateReceived $rxPort]
        }
        lappend sumRxList $rxRate
        #######################################################
        # Setup Negative Test rx Port Verification
        #######################################################
        if {$txPort == "negTest"} {
            report_start_test "Negative Test: Expecting 0% on rxRate($rxPort)=$rxRate"
            result_debug "Negative Test: Expecting 0% on rxRate($rxPort)=$rxRate"
            result_debug "--- rxPercent=$rxPercent"
            if { $rxRate < [expr [GetPortIdSpeed $rxPort] * $percent_tolerance] } {
                    result_ok "Negative Test: $rxPort RxRate:$rxRate check Passed"
                    set rtValue "ok"
            } else {
                    set pPercent [expr [GetPortIdSpeed $rxPort] * $percent_tolerance]
                    result_error "Negative Test: $rxPort rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
                    set rtValue "error"
            }

            report_end_test
            continue;

        }
        #######################################################
        # Setup the the TX port rates
        #######################################################
        set txRate [GetFrameRateSent $txPort]
        
        result_debug "tx1 = [GetFrameRateReceived 1] tx2 = [GetFrameRateReceived 2] \
                      tx3 = [GetFrameRateReceived 3] tx4 = [GetFrameRateReceived 4]"
        #######################################################
        # Start port compare
        #######################################################
        set exp_rxRate [expr abs (double($txRate) * $rxPercent/100)]
        report_start_test "txRate($txPort)=$txRate to rxRate($rxPort)=$rxRate (want $exp_rxRate)"
        result_debug "Sending txRate($txPort)=$txRate to rxRate($rxPort)=$rxRate"
        
        if {$rxRate < $exp_rxRate} {
            set diff [expr abs( double($exp_rxRate) - double($rxRate) )]
        } else {
            set diff [expr abs( double($rxRate) - double($exp_rxRate) )]
        }
        result_debug "Expected Rate at rxRate($rxPort) = $exp_rxRate Difference = $diff"
        if {$exp_rxRate < 0.0001 } {
            # If expected rate = 0
            if {$txRate != 0} {
                set pPercent [expr double($diff) / double($txRate)] ;# not sure this is right
        } else {
                set pPercent 0
            }
                         
        } else {
            set pPercent [expr double($diff) / double($exp_rxRate)] ;# perc missed by
        }           
        result_debug "--- pPercent=$pPercent"
        if { $pPercent <= $percent_tolerance } {
            result_ok "$txPort TxRate:$txRate, $rxPort RxRate:$rxRate check Passed"
            set rtValue "ok"
        } elseif { $diff <= 5 } {
            result_ok "$txPort TxRate:$txRate, $rxPort rxRate:$rxRate check Passed"
            set rtValue "ok"	         
        } else {
            result_error "$txPort TxRate:$txRate, $rxPort rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
            result_error [format "Difference (%01.2f%%) exceeds tolerance (%01.2f%%). Tx Rate is $txRate, Rx Rate is $rxRate.\n" $pPercent $percent_tolerance]
            set rtValue "error"
        }
        report_end_test
   }
   if {$sumRx == "SumRx"} {
      #set expectCount [expr double($sumTx) * $rxPercent / 100]
      set expectCount [expr (double($expectedSum) / double(100)) * $sumTx]
      set rSum 0
      foreach sRate $sumRxList {
         set rSum [expr abs( double($rSum) + double($sRate) )]
      }
      set diff [expr abs( double($rSum) - double($expectCount) )]
      if {$expectCount != 0} {
         set pPercent [expr double($diff) / double($expectCount)]
      } else {
         if {$rSum < 100} {
            set pPercent 0.0
         } else {
            set pPercent 0.20
         }
      }
      report_start_test "Sum Rx Totals: $rSum (want ${expectCount})"
      if {$pPercent < 0.18} {
         result_ok "Expected Rx Sum: $expectCount  Actual Sum: $rSum  Diff: $diff"
      } else {
         result_error "Expected Rx Sum: $expectCount  Actual Sum: $rSum  Diff: $diff"
      }
      report_end_test
   }
   report_end_test
   return $rtValue
}    


################################################################## 
# Procedure Name: ixiaCapturedFramesTimeStamp
#   
# Description: Ixia capture frames timestamp
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                fd_res - file pointer
#                                            
# Output args: 
#              return $timeStamps
# 
# Typical usage: 
#              [ixiaCapturedFramesTimeStamp $chasis $card $port $fd_res]
#
# Category: utility
################################################################## 
proc ixiaCapturedFramesTimeStamp {{ch 1}          \
                         {cd 1}          \
                         {pt 1}          \
                         {fd_res "NULL"} \
						 {fd_in "NULL"}} {
   global spawn_id

   capture get $ch $cd $pt
   set numCapFrames [capture cget -nPackets]
   captureBuffer get $ch $cd $pt 1 $numCapFrames


   for {set i 1} {$i <= $numCapFrames} {incr i} {
      captureBuffer getframe $i
      puts "capturebuffer cget -timestamp = [captureBuffer cget -timestamp]"
      if { $fd_res != "NULL" } { 
         puts $fd_res "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]"
      }
      if {$fd_in != "NULL"} { 
         puts $fd_in "[captureBuffer cget -timestamp]" 
      } else {
         lappend timeStamps "[captureBuffer cget -timestamp]"
      }
#      puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]"
   }
   if {$fd_in == "NULL"} { 
     if { [ info exists timeStamps ] != "1" } { set timeStamps {} }
      return $timeStamps
   }
}

##################################################################    
# Description:
#     This proc can be used to enable filter on the rx Ports.
#     Each rx port filters and counts the received frames based on UDS1.
# Input args: PortIdList, daMacList, saMacList, daIpList
# Output args: None.
# Typical usage example:
#  ixiaPortFilterStat1 "1 2" "$daMAc1 $daMac2" "$saMac1 $saMac2" "$daIpAddress"
################################################################## 
proc EnablePortFilter { portIdList {daMacList "{00 00 00 00 00 00}"} \
			   {saMacList "{00 00 00 00 00 00}"} \
			   {daIpList ""} {patternMask {00 00 00 00}} {pattern1 ""} {patternOffset1 "32"} {saMaskLst "{00 00 00 00 00 00}"} {daMaskLst "{00 00 00 00 00 00}"}} {

   global one2oneArray
   result_debug "\nEnabling filter UDS1 for ports: $portIdList"
   if {[llength $portIdList] < 1} {
     result_debug "empty port list: can't enable port filter"
     return
   }   
   map new -type  one2one
   map config -type  one2one
   set pos 0  
   foreach portId $portIdList {
      set daMac [lindex $daMacList $pos] 
      if {$daMac == ""} {
        set daMac "00 00 00 00 00 00"
      }
      set saMac [lindex $saMacList $pos] 
      if {$saMac == ""} {
        set saMac "00 00 00 00 00 00"
      }
      set daIp [lindex $daIpList $pos]
      #----- addding saMask and daMask for the source and dest mac
      set saMask [lindex $saMaskLst $pos]
      if {$saMask == ""} {
        set saMask "00 00 00 00 00 00"
      }
      set daMask [lindex $daMaskLst $pos]
      if {$daMask == ""} {
        set daMask "00 00 00 00 00 00"
      }
   
      MapIxiaPortId $portId ch c p
      map add $ch $c $p $ch $c $p
      filter setDefault        
      filter config -userDefinedStat1Enable  true
      filter config -captureFilterEnable                true
      filter config -captureTriggerEnable               true
      if {[regexp -nocase "00 00 00 00 00 00" $saMac]} {
        filter config -userDefinedStat1SA      anyPattern
      } else {
        filter config -userDefinedStat1SA      addr1
      }
      if {[regexp -nocase "00 00 00 00 00 00" $daMac]} {
        filter config -userDefinedStat1DA      anyPattern
      } else {
        filter config -userDefinedStat1DA      addr1
      }

      filter config -captureFilterPattern       anyPattern
      filter config -captureTriggerPattern   anyPattern
      filter config -captureTriggerDA   anyAddr
      filter config -captureFilterDA    anyAddr


 if {$daIp != ""} {
        filter config -userDefinedStat1Pattern    pattern1
      }
if {$pattern1 != "" } {
   filter config -userDefinedStat1Pattern    pattern1
}

      filter                       set               $ch $c $p
      filterPallette setDefault
      filterPallette config -DA1  $daMac
      filterPallette config -SA1  $saMac
      filterPallette config -DAMask1 $daMask
      filterPallette config -SAMask1 $saMask
 if {$daIp != ""} {
      filterPallette config -matchType1   matchIpDAEthernetII
      set fir ""
      set sec ""
      set thi ""
      set fou ""
      scan $daIp %d.%d.%d.%d fir sec thi fou
      if {($fir!="")&&($sec!="")&&($thi!="")&&($fou!="")} {
         set pattern1 [string toupper [format "%02x %02x %02x %02x" $fir $sec $thi $fou]]
      } else {

         set pattern1 ""
      }

 filterPallette config -pattern1 $pattern1
      filterPallette config -patternOffset1 32
}
 if {$patternMask!="00 00 00 00"} {
         filterPallette config -patternMask1 $patternMask
      }
if {$pattern1 != "" } {
filterPallette               config            -pattern1           $pattern1 
filterPallette               config            -patternOffset1     $patternOffset1              
}

filterPallette               set               $ch $c $p
      
      result_debug "port $portId: DA1=$daMac; SA1=$saMac; pattern1=$pattern1 patternOffset1 $patternOffset1"
      incr pos
   }
#   parray one2oneArray
#   writeConfigToHardware one2oneArray

}

################################################################## 
# Procedure Name: DisablePortFilter
#   
# Description: Turn off the ixia ports filter
#               
# Input args:
#              portIdList - port list
#                                
# Output args: none
#              
#
# Typical usage: 
#              [DisablePortFilter $portIdList]
#
# Category: setup
################################################################## 
proc DisablePortFilter { portIdList } {
   
   global one2oneArray
   result_debug "\nDisabling filter UDS1 for ports: $portIdList"
   if {[llength $portIdList] < 1} {
     result_debug "empty port list: can't disable port filter"
     return
   }
   map new -type  one2one
   map config -type  one2one
   foreach portId $portIdList {
      MapIxiaPortId $portId ch c p
      map add $ch $c $p $ch $c $p
      filter setDefault
      filter config -captureTriggerEnable true ;# needed to capture pkts
      filter config -captureFilterEnable true ;# needed to capture pkts
      filter set $ch $c $p
      filterPallette setDefault
      filterPallette set $ch $c $p
   }
   writeConfigToHardware one2oneArray
}

################################################################## 
# Procedure Name: CheckMatchPacketType   
# Description: 
#	check and return the no. of matched packets from the captured frames list on 
#	given ixia port no. by comparing the specified packet type (required), source ip,
#	destination ip, source Mac, and destination Mac.  The latter 4 optional parameters
#	can be bypassed with default value "dontcare".   		     
# Input args: portId pktType args(-scrIp -destIp -srcMac -destMac)
# Output args: none
# Typical usage: 
#	set matchCnt [CheckMatchPacketType 1 "ARP_REQUEST" -srcIp "10.10.10.1"]   
# Category: Utility
##################################################################
proc CheckMatchPacketType {portId pktType args } {
  parse_args CheckMatchPacketType $args {
  	srcIp "dontcare"
  	destIp "dontcare"
  	srcMac "dontcare"
  	destMac "dontcare"
  }
  result_debug "CheckMatchPacketType{}: checking $pktType in the captured packets on port $portId"
  set frameList [GetCapturedFrames $portId]
  set matchCnt 0    
  foreach frame $frameList {
    set sIpMatch 0
    set dIpMatch 0
    set sMacMatch 0
    set dMacMatch 0
    set msgtype [GetMessageType $frame]
    if {$srcIp == "dontcare" || $srcIp == [GetSourceIPAddress $frame]} {set sIpMatch 1}
    if {$destIp == "dontcare" || $destIp == [GetDestIPAddress $frame]} {set dIpMatch 1}
    if {$srcMac == "dontcare" || $srcMac == [GetSenderMacAddress $frame]} {set sMacMatch 1}
    if {$destMac == "dontcare" || $destMac == [GetTargetMacAddress $frame]} {set dMacMatch 1}   
    if {($msgtype == $pktType) && $sIpMatch && $dIpMatch && $sMacMatch && $dMacMatch } {
       incr matchCnt
       result_debug "matched $msgtype packet #$matchCnt:"
       result_debug "$frame"       
    }
  }
  result_debug "CheckMatchPacketType{}: total $matchCnt matched $pktType packets identified"
  return $matchCnt
}  
################################################################## 
# Procedure Name: getNumOfCapturedPackets   
# Description: 
#	gets the number of packets in a ports capture buffer
# Input args: portid 
# Output args: none
# Typical usage: 
#	set numCapPackets [getNumOfCapturedPackets ]
# Category: Utility
##################################################################
proc getNumOfCapturedPackets {portid } {
      set numCapFrames 0

      MapIxiaPortId $portid chassis card port
      capture get $chassis $card $port
      set numCapFrames [capture cget -nPackets]

      return $numCapFrames
}
##################################################################
# Procedure Name: StartPortsTransmitDuration
#
# Description: Start Ports Transmit for duration
#
# Input args:
#              portIdList - Port list
#              duration   - time in secs
#
# Output args: none
#
# Typical usage:
##             [StartPortsTransmitDuration $portIdList 210]
#
# Category: setup
##################################################################
proc StartPortsTransmitDuration {portIdList duration} {


foreach portId $portIdList {
   MapIxiaPortId $portId chas card port
   lappend plist "$chas $card $port"
}

if [ixSetScheduledTransmitTime plist $duration] {
   ixPuts $::ixErrorInfo }
}

##################################################################
# Procedure Name: GetNumFilteredFramesReceived
#
# Description: Get the number of Filtered frames received on a port
#              with filter enabled using EnablePortFilter proc
#
# Input args:
#              portId - Port Id
#
# Output args:
#              return Filtered frames received
#
# Typical usage:
#              [GetNumFilteredFramesReceived $portId]
#
# Category: setup
##################################################################
proc GetNumFilteredFramesReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -userDefinedStat1]
}


##################################################################
# Description:
#     This proc can be used to enable filter on the rx Ports.
#     Each rx port filters and counts the received frames based on UDS1.
# Input args: PortIdList, daMacList, saMacList, daIpList
# Output args: None.
# Typical usage example:
#  ixiaPortFilterStat1 "1 2" "$daMAc1 $daMac2" "$saMac1 $saMac2" "$daIpAddress"
##################################################################

proc SetPortFilter { portId pattern1 offset1} {

   global one2oneArray
   result_debug "\nEnabling filter UDS1 for ports: $portId"

#   map new -type  one2one
#   map config -type  one2one

   MapIxiaPortId $portId ch c p
   map add $ch $c $p $ch $c $p
#   filter setDefault
   filter config -captureFilterEnable                true
   filter config -captureTriggerEnable               true

   filter config -captureFilterPattern       anyPattern
   filter config -captureTriggerPattern   anyPattern
   filter config -captureTriggerDA   anyAddr
   filter config -captureFilterDA    anyAddr
   filter config -userDefinedStat1Enable  true
   filter config -userDefinedStat1SA      anyPattern
   filter config -userDefinedStat1DA      anyPattern
   filter config -userDefinedStat1Pattern    pattern1
#   filter set $ch $c $p

#   filterPallette setDefault
   filterPallette config -pattern1 $pattern1
   filterPallette config -patternOffset1 $offset1
   filterPallette config -patternMask1 "00 00 00 00"
#   filterPallette set $ch $c $p

   result_debug "port $portId: pattern=$pattern1; offset=$offset1; "
   set portList [list $ch:$c:$p]
    if [ ixWriteConfigToHardware portList -noVerbose -noProtocolServer] {
      result_error "writeStreams:: Error in writing the Config to hardware $ch $c $p"
      return -1
   }


}

