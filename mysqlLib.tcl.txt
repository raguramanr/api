catch {package require mysqltcl}
catch {package require ftp};
catch {package require http 1.0};

global this_db
set this_db ""

proc conn_to_db { host db  {user regression_user} {password extreme}} {
  global mysqlstatus mysql_handler this_db MAIN
  set this_db $db

  set connected "no"

  if {0} {
  if {[info exists mysql_handler]} {
    set status [mysqlstate $mysql_handler]
    #puts "status $status"
    if {$status == "IN_USE"} {
      set connected "yes"
    }
  }
  }

  if {[info exists mysql_handler]} {
     catch {mysqlclose $mysql_handler} result
  }
  set mysqlstatus(code) 0
  if {$connected == "no"} {
    catch {mysqlconnect -host $host -user $user -password $password -db $db} mysql_handler
    #puts $mysqlstatus(code);
    if {$mysqlstatus(code) !=0} {
        puts stderr $mysqlstatus(message)
        puts "First attempt to connect failed: $mysqlstatus(message)"
        #mysqlclose $mysql_handler
        catch {mysqlconnect -host $host -user $user -password $password -db $db} mysql_handler
        #puts $mysqlstatus(code);
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            #mysqlclose $mysql_handler
            return $mysqlstatus(code)
        }
    }
    #mysqlexec  $mysql_handler "SET max_allowed_packet=50000000"
    set MAIN(RESDBHANDLE) $mysql_handler
    return $mysqlstatus(code)
  } else {
    set MAIN(RESDBHANDLE) $mysql_handler
    return $status
  }
}

##########################################################################
# proc disconnect_db
#
# Disconnect from a mysql handle
#
# Typical Usage:
#   disconnect_db mysql_handler
#
##########################################################################
proc disconnect_db {dbhandle} {

    global $dbhandle
    if {[info exists $dbhandle]} {
        if [catch {mysqlclose [set $dbhandle]} res] {
            puts "Failed to close handle $dbhandle: $res"
        }
    } else {
        puts "Variable $dbhandle does not exist"
    }

}
##########################################################################
#
#
#
#
# Initial use in the queuing system.  This allows for connection to a
#   local db as well as the regserver database for posting directly.
#
##########################################################################
proc conn_to_multi_db { host db } {
    global mysqlstatus mysql_handler this_db mysql_pipe
    set this_db $db
    set user regression_user
    set password extreme

    set connected "no"

    if {[info exists mysql_pipe($db)]} {
        set status [mysqlstate $mysql_pipe($db)]
        puts "status $status"
        if {$status == "IN_USE"} {
            set connected "yes"
        } else {
            catch {mysqlclose $mysql_pipe($db)} result
        }
    }

    if {$connected == "no"} {
        catch {mysqlconnect -host $host -user $user -password $password -db $db} mysql_pipe($db)
        #puts $mysqlstatus(code);
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            #mysqlclose $mysql_handler
            return -1
        }
puts "1 Returning pipe $mysql_pipe($db)"  
        return $mysql_pipe($db)
    } else {
puts "2 Returning pipe $mysql_pipe($db)"
        return $mysql_pipe($db)
    }
}
###########################################################################
proc conn_to_autoweb_db { host } {
  global mysqlstatus mysql_handler my_db
  set user regression_user
  set password extreme
  catch {mysqlconnect -host $host -user $user -password $password -db $my_db} mysql_handler
  #puts $mysqlstatus(code);
  if {$mysqlstatus(code) !=0} {
      puts stderr $mysqlstatus(message)
      #mysqlclose $mysql_handler
     return $mysqlstatus(code)
  }
  #mysqlexec  $mysql_handler "SET max_allowed_packet=50000000"
  return $mysqlstatus(code)
}

proc conn_to_devweb_db { host } {
  global mysqlstatus mysql_handler
  set user regression_user
  set password extreme
  catch {mysqlconnect -host $host -user $user -password $password -db devweb_db} mysql_handler
  #puts $mysqlstatus(code);
  if {$mysqlstatus(code) !=0} {
      puts stderr $mysqlstatus(message)
      #mysqlclose $mysql_handler
     return $mysqlstatus(code)
  }
  #mysqlexec  $mysql_handler "SET max_allowed_packet=50000000"
  return $mysqlstatus(code)
}
##############################################################################
# Connect to a db and return a handle.. no globals.. short and sweet
#
##############################################################################
proc quick_db_connect { host db} {
    global mysqlstatus
    set user regression_user
    set password extreme
    if {[catch {mysqlconnect -host $host -user $user -password $password -db $db} handle]} {
        puts "\nFAILED TO Connect to db -host $host -user $user"
        return "fail"
    }
    puts "\nConnect to db -host $host -user $user"
    return $handle
}


proc InsertIntoBuildTable {args} {
  parse_args InsertIntoBuildTable $args {
    system_id "2"
    build_major_release ""
    build_minor_release ""
    build_number ""
    build_branch_number ""
    build_by ""
    build_time ""
    host ""
    db_name ""
    target_phase ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set insert_clause [append insert_clause "insert into build_table (system_id, "]
  set insert_clause [append insert_clause "build_major_release, "]
  set insert_clause [append insert_clause "build_minor_release, "]
  set insert_clause [append insert_clause "build_number, "]
  set insert_clause [append insert_clause "build_branch_number, "]
  set insert_clause [append insert_clause "build_by, "]
  set insert_clause [append insert_clause "build_time, "]
  set insert_clause [append insert_clause "db_name, "]
  set insert_clause [append insert_clause "target_phase)"]

  set insert_clause [append insert_clause "values (\"$system_id\", "]
  set insert_clause [append insert_clause "\"$build_major_release\", "]
  set insert_clause [append insert_clause "\"$build_minor_release\", "]
  set insert_clause [append insert_clause "\"$build_number\", "]
  set insert_clause [append insert_clause "\"$build_branch_number\", "]
  set insert_clause [append insert_clause "\"$build_by\", "]
  set insert_clause [append insert_clause "\"$build_time\", "]
  set insert_clause [append insert_clause "\"$db_name\", "]
  set insert_clause [append insert_clause "\"$target_phase\")"]
  puts "$insert_clause\r"

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  return 0
}

proc InsertIntoFeatureTable {args} {
  parse_args InsertIntoFeatureTable $args {
    system_id "2"
    start_release_id ""
    end_release_id ""
    feature_type ""
    feature_sub_type ""
    feature_name ""
    feature_expected_exec_time ""
    feature_rse ""
    feature_rsm ""
    feature_aa ""
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set insert_clause [append insert_clause "insert into feature_table (system_id, "]
  set insert_clause [append insert_clause "start_release_id, "]
  set insert_clause [append insert_clause "end_release_id, "]
  set insert_clause [append insert_clause "feature_type, "]
  set insert_clause [append insert_clause "feature_sub_type, "]
  set insert_clause [append insert_clause "feature_name, "]
  set insert_clause [append insert_clause "feature_expected_exec_time, "]
  set insert_clause [append insert_clause "feature_rse, "]
  set insert_clause [append insert_clause "feature_rsm, "]
  set insert_clause [append insert_clause "feature_aa) "]

  set insert_clause [append insert_clause "values (\"$system_id\", "]
  set insert_clause [append insert_clause "\"$start_release_id\", "]
  set insert_clause [append insert_clause "\"$end_release_id\", "]
  set insert_clause [append insert_clause "\"$feature_type\", "]
  set insert_clause [append insert_clause "\"$feature_sub_type\", "]
  set insert_clause [append insert_clause "\"$feature_name\", "]
  set insert_clause [append insert_clause "\"$feature_expected_exec_time\", "]
  set insert_clause [append insert_clause "\"$feature_rse\", "]
  set insert_clause [append insert_clause "\"$feature_rsm\", "]
  set insert_clause [append insert_clause "\"$feature_aa\")"]
  #puts "$insert_clause\r"

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  return 0
}



proc InsertIntoRegressionTable {args} {
  parse_args InsertIntoRegressionTable $args {
    queue_id ""
    build_id ""
    platform_id ""
    total_number_of_runs "1"
    html_pd ""
    feature_type ""
    feature_sub_type ""
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set insert_clause [append insert_clause "insert into regression_table "]
  set insert_clause [append insert_clause "(queue_id, "]
  set insert_clause [append insert_clause "build_id, "]
  set insert_clause [append insert_clause "platform_id, "]
  set insert_clause [append insert_clause "html_pd, "]
  set insert_clause [append insert_clause "feature_type, "]
  set insert_clause [append insert_clause "feature_sub_type, "]
  set insert_clause [append insert_clause "total_number_of_runs) "]

  set insert_clause [append insert_clause "values (\"$queue_id\", "]
  set insert_clause [append insert_clause "\"$build_id\", "]
  set insert_clause [append insert_clause "\"$platform_id\", "]
  set insert_clause [append insert_clause "\"$html_pd\", "]
  set insert_clause [append insert_clause "\"$feature_type\", "]
  set insert_clause [append insert_clause "\"$feature_sub_type\", "]
  set insert_clause [append insert_clause "\"$total_number_of_runs\")"]

  #puts "InsertIntoRegressionTable insert_clause: \n$insert_clause"
  set rslt [mysqlexec  $mysql_handler $insert_clause]
  puts "InsertIntoRegressionTable returns: $rslt"
  #mysqlclose $mysql_handler
  return 0
}


proc IncrNmbrRunsInRegressionTable {args} {
  parse_args InsertIntoRegressionTable $args {
    regression_id "1"
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set total_number_of_runs [mysqlsel $mysql_handler "SELECT total_number_of_runs FROM regression_table WHERE regression_id = \"$regression_id\"" -list]
  #puts "total_number_of_runs = $total_number_of_runs"
  incr total_number_of_runs

  set update_clause [append update_clause "update regression_table "]
  set update_clause [append update_clause "set total_number_of_runs=\"$total_number_of_runs\" "]
  set update_clause [append update_clause "where regression_id=\"$regression_id\""]

  mysqlexec  $mysql_handler $update_clause
  #mysqlclose $mysql_handler
  return 0
}

proc createFileBlob { fileDir fileBlob } {
  upvar $fileBlob fileBlobTmp

  set fList [split $fileDir "."]
  set isHtml 0
  if {[lindex $fList [expr [llength $fList] -1]] == "html"} {
      set isHtml 1
  }
  set maxSize 6000000
  if {[file exists "$fileDir"] == 0} {
    set fileBlobTmp "\n\n\n $fileDir does not exist\n\n\n"
    return 0
  }

  set fileBlobSize [file size "$fileDir"]
  puts "fileBlobSize $fileBlobSize"

  if {[catch {open "$fileDir" r} fd]} {
    puts " !!!! ERROR : $fd    !!!!"
    return -1
  }

  #puts "$fileBlob opened"

  set fileBlobTmp "";
  # we limit the uploaded string to 6MB bytes
  if {$fileBlobSize > $maxSize} {
    set fileBlobTmp "File too large - truncated to 6MB\n\n\n";
    puts "File too large - truncated to 6MB";
  }
  
  # let's read the file up to size of 6MB
  set totalLength 0;
  set contAppending "yes";
  set nlSize [string bytelength "\n"];
  while {([gets $fd line] != -1) && ($contAppending == "yes")} {
    set lineSize [string bytelength $line]
    set totalLength [expr $totalLength + $lineSize +$nlSize];
    if {$totalLength > $maxSize} {
      set contAppending "no";
      puts "truncating at size $totalLength";
    } else {
      set fileBlobTmp [append fileBlobTmp $line];
      set fileBlobTmp [append fileBlobTmp "\n"];
    }
  }
  if {1} {
      set fileBlobTmp [string map {"\x22" "&#34;" "\x3c" "&#60;" "\x3e" "&#62;"} $fileBlobTmp];
  }
  # if this is report.txt clear the extra color info characters
  if { [regexp "report.txt" $fileDir] } {
    set fileBlobTmp [string map {"\033[1;31m" "" "\033[1;32m" "" \
                                 "\033[1;33m" "" "\033[1;34m" "" \
                                 "\033[35m" "" "\033[36m" "" \
                                 "\033[0m" ""} $fileBlobTmp];
  }
  #set fileBlobTmp [string map {"\x22" "\x27" "\x3c" "\x3c\x20" "\x3e" "\x20\x3e"} $fileBlobTmp]
  #set fileBlobTmp [string map {"\x22" "\x5c\x22"} $fileBlobTmp]
  #puts $fileBlobTmp
  #puts "Blob length: [string bytelength $fileBlobTmp]"

  close $fd
  return 0
}


proc InsertIntoTestFileTable {args} {
  parse_args InsertIntoTestFileTable $args {
    file_content ""
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set insert_clause [append insert_clause "insert into test_file_table "]
  set insert_clause [append insert_clause "(file_content) "]

  set insert_clause [append insert_clause "values (\"$file_content\")"]

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  return 0
}

#####################################################################################
# Procedure: InsertIntoAuxLogTable
#
#
#
#####################################################################################
proc InsertIntoAuxLogTable {args} {
    parse_args InsertIntoAuxLogTable $args {
        log_id     ""
        fa_cause   "software"
        cr         ""
        cr_status  ""
        handle     ""
    }

    set insert_clause [append insert_clause "insert into aux_log_table "]
    set insert_clause [append insert_clause "(log_id, "]
    set insert_clause [append insert_clause "fa_cause, "]
    set insert_clause [append insert_clause "cr, "]
    set insert_clause [append insert_clause "cr_status) "]

    set insert_clause [append insert_clause "values (\"$log_id\", "]
    set insert_clause [append insert_clause "\"$fa_cause\", "]
    set insert_clause [append insert_clause "\"$cr\", "]
    set insert_clause [append insert_clause "\"$cr_status\")"]

    mysqlexec  $handler $insert_clause

}
proc InsertIntoReportTable {args} {
  parse_args InsertIntoReportTable $args {
    regression_id ""
    feature_id ""
    build_id ""
    run_number ""
    run_type "regular"
    test_result ""
    test_report_file_content ""
    test_report_date ""
    test_report_duration ""
    test_quick_duration ""
    test_pass_duration ""
    test_all_duration ""
    test_main_file_content ""
    test_dut1_log_file_content ""
    test_dut2_log_file_content ""
    test_dut3_log_file_content ""
    test_dut4_log_file_content ""
    test_dut5_log_file_content ""
    test_system_setup_file_content ""
    test_exec_time_file_content ""
    test_info_file_content ""
    test_topology_file_content ""
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set insert_clause [append insert_clause "insert into report_table "]
  set insert_clause [append insert_clause "(regression_id, "]
  set insert_clause [append insert_clause "feature_id, "]
  set insert_clause [append insert_clause "build_id, "]
  set insert_clause [append insert_clause "run_number, "]
  set insert_clause [append insert_clause "run_type, "]
  set insert_clause [append insert_clause "test_result, "]
  set insert_clause [append insert_clause "test_report_file_content, "]
  set insert_clause [append insert_clause "test_report_date, "]
  set insert_clause [append insert_clause "test_report_duration, "]
  set insert_clause [append insert_clause "test_quick_duration, "]
  set insert_clause [append insert_clause "test_pass_duration, "]
  set insert_clause [append insert_clause "test_all_duration, "]
  set insert_clause [append insert_clause "test_main_file_content, "]
  set insert_clause [append insert_clause "test_dut1_log_file_content, "]
  set insert_clause [append insert_clause "test_dut2_log_file_content, "]
  set insert_clause [append insert_clause "test_dut3_log_file_content, "]
  set insert_clause [append insert_clause "test_dut4_log_file_content, "]
  set insert_clause [append insert_clause "test_dut5_log_file_content, "]
  set insert_clause [append insert_clause "test_system_setup_file_content, "]
  set insert_clause [append insert_clause "test_exec_time_file_content, "]
  set insert_clause [append insert_clause "test_info_file_content, "]
  set insert_clause [append insert_clause "test_topology_file_content) "]

  set insert_clause [append insert_clause "values (\"$regression_id\", "]
  set insert_clause [append insert_clause "\"$feature_id\", "]
  set insert_clause [append insert_clause "\"$build_id\", "]
  set insert_clause [append insert_clause "\"$run_number\", "]
  set insert_clause [append insert_clause "\"$run_type\", "]
  set insert_clause [append insert_clause "\"$test_result\", "]
  set insert_clause [append insert_clause "\"$test_report_file_content\", "]
  set insert_clause [append insert_clause "\"$test_report_date\", "]
  set insert_clause [append insert_clause "\"$test_report_duration\", "]
  set insert_clause [append insert_clause "\"$test_quick_duration\", "]
  set insert_clause [append insert_clause "\"$test_pass_duration\", "]
  set insert_clause [append insert_clause "\"$test_all_duration\", "]
  set insert_clause [append insert_clause "\"$test_main_file_content\", "]
  set insert_clause [append insert_clause "\"$test_dut1_log_file_content\", "]
  set insert_clause [append insert_clause "\"$test_dut2_log_file_content\", "]
  set insert_clause [append insert_clause "\"$test_dut3_log_file_content\", "]
  set insert_clause [append insert_clause "\"$test_dut4_log_file_content\", "]
  set insert_clause [append insert_clause "\"$test_dut5_log_file_content\", "]
  set insert_clause [append insert_clause "\"$test_system_setup_file_content\", "]
  set insert_clause [append insert_clause "\"$test_exec_time_file_content\", "]
  set insert_clause [append insert_clause "\"$test_info_file_content\", "]
  set insert_clause [append insert_clause "\"$test_topology_file_content\")"]

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  return 0
}

proc InsertAllIntoReportTable {args} {
  parse_args InsertAllIntoReportTable $args {
    regression_id ""
    feature_id ""
    build_id   ""
    run_number "1"
    run_type "regular"
    report_directory ""
    host ""
  }

  global mysql_handler

  set d1 [exec date +%Y-%m-%d]
  set d2 [exec date +%k:%M:%S]
  set d [append d $d1]
  set d [append d " "]
  set d [append d $d2]
  #puts $d

  set regularInsert 1



  if {  $run_type == "results" } {
    # is there a downloadImage entry ? - reuse it
    set report_id_list [mysqlsel $mysql_handler "SELECT report_id  FROM report_table \
                       WHERE regression_id = \"$regression_id\"  \
                       AND   feature_id  = \"$feature_id\" \
                       AND   run_type  = \"downloadImage\" \
                       ORDER BY report_id DESC LIMIT 1 " -list]
    puts "llength of report_id_list: [llength $report_id_list]"
    if {([llength $report_id_list] != 0)} {
      set report_id [lindex $report_id_list 0]
      # reuse this report_id
      createFileBlob $report_directory/report.txt reportBlob
      set update_clause "UPDATE  report_table SET test_report_file_content = \"$reportBlob\", \
                         test_report_date = \"$d\", \
                         run_number = \"$run_number\", \
                         test_info_file_content = \"$report_directory\", \
                         run_type = \"$run_type\" \
                         WHERE report_id = \"$report_id\""
        #puts "InsertAllIntoReportTable: update_clause $update_clause"
	mysqlexec $mysql_handler $update_clause
        set regularInsert 0
    } else {
      set regularInsert 1
    }
  }

  if { $regularInsert == "1" } {
    set prams_clause [append parat_clause "-regression_id \"\$regression_id\" "]
    set prams_clause [append parat_clause "-feature_id \"\$feature_id\" "]
    set prams_clause [append parat_clause "-build_id \"\$build_id\" "]
    set prams_clause [append parat_clause "-run_number \"\$run_number\" "]
    set prams_clause [append parat_clause "-run_type \"\$run_type\" "]
    set prams_clause [append parat_clause "-test_report_date \"$d\" "]
    set prams_clause [append parat_clause "-test_info_file_content \"$report_directory\" "]
  
    if {[createFileBlob $report_directory/report.txt reportBlob] == 0} {
      set prams_clause [append parat_clause "-test_report_file_content \"\$reportBlob\" "]
    } 
    #puts $prams_clause
    eval InsertIntoReportTable  $prams_clause -host $host
  }



}



proc InsertIntoLogTable {args} {
    parse_args InsertIntoLogTable $args {
        report_id ""
        feature_id ""
        build_id ""
        feature_test_script_name ""
        feature_test_file_content ""
        log_file_content ""
        host ""
        status ""
        pd_number ""
        duration  ""
    }

    global mysql_handler MAIN CRINFO

    if {[llength $pd_number] > 1} {
        set pd [lindex $pd_number 0]
    } else {
        set pd $pd_number
    }

    set d1 [exec date +%Y-%m-%d]
    set d2 [exec date +%k:%M:%S]
    set d [append d $d1]
    set d [append d " "]
    set d [append d $d2]

    set insert_clause [append insert_clause "insert into log_table "]
    set insert_clause [append insert_clause "(report_id, "]
    set insert_clause [append insert_clause "feature_id, "]
    set insert_clause [append insert_clause "build_id, "]
    set insert_clause [append insert_clause "feature_test_script_name, "]
    set insert_clause [append insert_clause "feature_test_file_content, "]
    set insert_clause [append insert_clause "status, "]
    set insert_clause [append insert_clause "pd_number, "]
    set insert_clause [append insert_clause "log_duration, "]
    set insert_clause [append insert_clause "log_date, "]
    set insert_clause [append insert_clause "log_file_content) "]

    set insert_clause [append insert_clause "values (\"$report_id\", "]
    set insert_clause [append insert_clause "\"$feature_id\", "]
    set insert_clause [append insert_clause "\"$build_id\", "]
    set insert_clause [append insert_clause "\"$feature_test_script_name\", "]
    set insert_clause [append insert_clause "\"$feature_test_file_content\", "]
    set insert_clause [append insert_clause "\"$status\", "]
    set insert_clause [append insert_clause "\"$pd\", "]
    set insert_clause [append insert_clause "\"$duration\", "]
    set insert_clause [append insert_clause "\"$d\", "]
    set insert_clause [append insert_clause "\"$log_file_content\") "]

    mysqlexec  $mysql_handler $insert_clause

    if {$pd_number != "" && $MAIN(USETRACKER)} {
        set setid_clause "select LAST_INSERT_ID()";
        set lid [mysqlsel  $mysql_handler $setid_clause -flatlist]
        if {$lid < 10} {
            _writeMALog "--- Use Tracker FAILED FAILED to get the last log_id entered ---"
            puts "log_id $lid is not valid.  Return"
            return 0
        }
        foreach c $pd_number {
            set insert_clause2 ""
            if {[info exists CRINFO($c,globalState)] && [info exists CRINFO($c,status)]} {
                set crstat "$CRINFO($c,globalState) $CRINFO($c,status)"
            } else {
                set crstat ""
            }
            set insert_clause2 [append insert_clause2 "insert into aux_log_table "]
            set insert_clause2 [append insert_clause2 "(log_id, "]
            set insert_clause2 [append insert_clause2 "fa_cause, "]
            set insert_clause2 [append insert_clause2 "cr, "]
            set insert_clause2 [append insert_clause2 "cr_status) "]

            set insert_clause2 [append insert_clause2 "values (\"$lid\", "]
            set insert_clause2 [append insert_clause2 "\"software\", "]
            set insert_clause2 [append insert_clause2 "\"$c\", "]
            set insert_clause2 [append insert_clause2 "\"$crstat\")"]

            _writeMALog "--- Use Tracker aux_log $insert_clause2"
            mysqlexec $mysql_handler $insert_clause2
        }
    }


  return 0
}


# finding a log file by name
proc FindLogFile {startDir} {
    set pwd [pwd]
    global procByLog MAIN TCSTATUSARRAY
    
    # CD to the report directory
    if [catch {cd "$startDir"} err] {
        puts stderr $err
        return {}
    }

    set fList {"quickTestsList.txt" "passTestsList.txt" "allTestsList.txt" "newTestsList.txt" "DebugList.txt"}

    set allTestList ""
    set newLogFile ""
    foreach f $fList {
        if {[file exists $f]} {
            set fp [open "$f" r]
            while {[gets $fp line] != -1} {
                lappend allTestList $line
            }
        }
    }
    set allTestString [join $allTestList " "]
    set allTestList [split $allTestString " "]

    set logFiles {}
    foreach match [glob -nocomplain -- "*\.txt"] {
        set rs [regexp {([0-9]+[-.][0-9a-z_.-]*)([a-zA-Z]+)} $match]
        #puts stdout "match result rs $rs match $match"
        set rs2 [regexp -nocase "skipTestsList2" $match]
        if { ($rs == 1) && ($rs2 != 1) } {
            set logFiles  [lappend logFiles  $match]
            #puts stdout [file join $startDir $match]
        }
        set rs3 [regexp {^(T[_\-][0-9]+)|^(F[\-_][0-9]+)|^(FIT_[a-zA-Z0-9\._\-])} $match]
        if { ($rs3 == 1) && ($rs2 != 1) && [lsearch $logFiles $match] < 0} {
            set logFiles  [lappend logFiles  $match]
            #puts "match result 3 $rs3 2 $rs2 match $match"
        }
    }

    if {[llength $allTestList] > 0} {
        set a 1
        foreach myLog $allTestList {
            if {[regexp "^T|^F" $myLog]} {
                if {[lsearch $logFiles ${myLog}.txt] >= 0 && [lsearch $newLogFile ${myLog}.txt] < 0} {
                    lappend newLogFile ${myLog}.txt
                } else {
                    foreach dirLog $logFiles {
                        set tmpScr [string trimleft $myLog "T_"]
                        set tmpScr [string trimleft $tmpScr "T-"]
                        set tmpScr [string trimleft $tmpScr "F-"]
                        set tmpScr [string trimleft $tmpScr "F_"]
                        if {[regexp "^F.*$tmpScr\.txt|^T.*$tmpScr\.txt" $dirLog] && [lsearch $newLogFile $dirLog] < 0} {
                             lappend newLogFile $dirLog
                             set procByLog($dirLog) $myLog
                             #puts "Hit $a  pushing ${myLog}.txt  blob $tmpScr  should it be $dirLog"
                        }
                    }
                }
            } else {
                if {[lsearch $logFiles ${myLog}.txt] >= 0 && [lsearch $newLogFile ${myLog}.txt] < 0} {
                    lappend newLogFile ${myLog}.txt
                }
            }
            incr a
        }
      
        set logFiles $newLogFile
    }
    set itestList ""
    foreach match [glob -nocomplain -- "*\.html"] {
        set rs [regexp {([0-9]+[-.][0-9a-z_.-]*)([a-zA-Z]+)} $match]
        set rs 1
        #puts stdout "match result rs $rs match $match"
        set rs2 [regexp -nocase "skipTestsList2" $match]
        if { ($rs == 1) && ($rs2 != 1) } {
            #set logFiles  [lappend logFiles  $match]
            lappend itestList $match
            #puts stdout [file join $startDir $match]
        }
    }
    if {[llength $itestList] > 0} {
        set itestList [lsort $itestList]
        set logFiles [concat $logFiles $itestList];
    }

    # -----  New method for finding log files using testfile_map file -----
    if {[file exists testfile_map.txt]} {
        if {[catch {source testfile_map.txt} why]} {
            puts "sourcing the testfile_map.txt failed"
            _writeMALog "--- sourcing the testfile_map.txt failed"
        } else {
            if {[info exists procs_executed]} {
                foreach testp $procs_executed {
                    if {[info exists procFile(\"$testp\")] && \
                       [file exists $procFile(\"$testp\")] && \
                       [lsearch $logFiles $procFile(\"$testp\")] < 0} {
                        puts "Adding log file using new method. Old on missed"
                        _writeMALog "--- Adding log file using new method. Old on missed"
                        lappend logFiles $procFile(\"$testp\")
                    } else {
                        if {[info exists procFile(\"$testp\")]} {
                            puts "found $procFile(\"$testp\") in logFiles"
                        }
                    }
                }
            }
        }
    }
    # ----- Since we are in the report directory... lets get the results too.
    if {[file exists TCLStatusVars.txt]} {
        if {[catch {source TCLStatusVars.txt} why]} {
            puts "sourcing the TCLStatusVars.txt failed"
        } else {
            if {[info exists ReportCases]} {
                _writeMALog "--- TCLStatusVars.txt found $ReportCases"
                foreach testp $ReportCases {
                    if {[info exists RepResArray($testp)]} {
                        if {[regexp -nocase "fail" $RepResArray($testp)]} {
                            set TCSTATUSARRAY($testp,logresult) "failed"
                            set TCSTATUSARRAY($testp,result)    "failed"
                        } elseif {[regexp -nocase "skip" $RepResArray($testp)]} {
                            set TCSTATUSARRAY($testp,logresult) "passed"
                            set TCSTATUSARRAY($testp,result)    "skipped"
                        } else {
                            set TCSTATUSARRAY($testp,logresult) "passed"
                            set TCSTATUSARRAY($testp,result)    "passed"
                        }
                    }
                    if {[info exists RepDurArray($testp)]} {
                        set TCSTATUSARRAY($testp,duration) $RepDurArray($testp)
                    } else {
                        set TCSTATUSARRAY($testp,duration) 0;
                    }
                }
            }
        }
    }
    # CD back to the original directory 
    if [catch {cd "$pwd"} err] {
        puts stderr $err
        return {}
    }
    return $logFiles
}
###########################################################################
# Write to mysqlAutomate log
###########################################################################
proc _writeMALog {txt} {
    global logFileId

    if {[info exists logFileId] && [regexp -nocase "file" $logFileId]} {
        puts $logFileId "$txt"
    }

}
###########################################################################
#
###########################################################################
proc InsertAllIntoLogTable {args} {
    parse_args InsertAllIntoLogTable $args {
        report_id ""
        feature_id ""
        build_id ""
        logDir ""
        sourceDir ""
        host ""
    }

    global logFileId procByLog TCSTATUSARRAY MAIN CRINFO

    # --- Get Tracker CRs ---
    set thandle [tracker_db_connect]

    set logFiles [FindLogFile $logDir]
    puts "DANY InsertAllIntoLogTable logFiles: $logFiles"
    puts $logFileId "DANY InsertAllIntoLogTable logFiles: $logFiles"
    foreach logFile $logFiles {
        set crString ""
        set logFileTmp $logFile
        # set featureTestScriptName [string trimright $logFile ".txt"]
        set logFileSplit [split $logFile "."]
        set suffix [lindex $logFileSplit [expr [llength $logFileSplit] - 1]]
        set logFileSplitSize [expr [llength $logFileSplit] - 2]
        set logFileSplitTrimmed [lrange $logFileSplit 0 $logFileSplitSize]
        set featureTestScriptName [join $logFileSplitTrimmed "."]

        if {$suffix == "html"} {
            set srcFile [string trimright $logFile html]
        } else {
            set srcFile [string trimright $logFile txt]
        }
        set myProcName [string trimright $srcFile "."]
        if { [regexp -nocase "clitest" $sourceDir] } {
            set srcFile [append srcFile cli]
            set srcFile [file join $sourceDir $srcFile]
        } elseif {$suffix == "html"} {
            set srcFile [append srcFile fftp]
            set srcFile "$srcFile"
        } else {
            if {[regexp "^F|^T" $srcFile] && [info exists procByLog($logFile)]} {
                set srcFile $procByLog($logFile).tcl
                set myProcName $procByLog($logFile)
                set srcFile [file join $sourceDir $srcFile]
            } else {
                set srcFile [append srcFile tcl]
                set srcFile [file join $sourceDir $srcFile]
            }
        }
        set logFile [file join $logDir $logFile]
        puts $logFile
        puts $logFileId $logFile
        createFileBlob $logFile logFileBlob
        puts $srcFile
        puts $logFileId $srcFile
        # no source file for 1.txt
        if {$logFileTmp == "1.txt"} {
            set srcFileBlob "\n\n\nno source file for 1.txt\n\n\n"
        } elseif {$suffix == "html"} {
            # We are assuming that all html files are iTest results
            set srcFileBlob "\n\n\nno source file for $srcFile\n\n\n"
        }  else {
            createFileBlob $srcFile srcFileBlob
        }
        # ---- Results if they exists ----  TCSTATUSARRAY
        set stat ""
        if {[info exists TCSTATUSARRAY($myProcName,logresult)] && \
            ($TCSTATUSARRAY($myProcName,logresult) == "passed" || \
             $TCSTATUSARRAY($myProcName,logresult) == "failed")} {
            set stat $TCSTATUSARRAY($myProcName,logresult)
            if {[info exists MAIN(USETRACKER)] && $MAIN(USETRACKER) && $stat == "failed"} {
                set CRS [GetTestCaseCRS -testcase "$myProcName" ]
                set crString "$CRS"
            }
        }
        set dur ""
        if {[info exists TCSTATUSARRAY($myProcName,duration)]} {
            set dur $TCSTATUSARRAY($myProcName,duration);
        }
        InsertIntoLogTable -report_id $report_id -feature_id $feature_id -build_id $build_id \
            -feature_test_script_name $myProcName -status $stat -duration $dur \
            -feature_test_file_content $srcFileBlob -pd_number "$crString" \
            -log_file_content $logFileBlob -host $host 
    }
    close_mysql_handle $MAIN(TRACKERHANDLE)
    if {$MAIN(USETRACKER) && [info exists MAIN(CRLIST)] && [info exists MAIN(CRTESTCASELIST)]} {
        set crFile [file join $logDir "CR_TestCaseData.txt"]
        set fp [open $crFile "w+"]
        set crc [llength $MAIN(CRLIST)]
        set i 1
        puts $fp "\{"
        puts $fp "\"CR_TestCases\": \[ \"[join $MAIN(CRTESTCASELIST) "\",\""]\" \],"
        puts $fp "\"Tracker\": \{"
        foreach c $MAIN(CRLIST) {
            #CRINFO($cr,globalState) $gState;
            #CRINFO($cr,status) $status;
            #CRINFO($cr,auto) $auto;
            #CRINFO($cr,testcase)
            if {[info exists CRINFO($c,globalState)] && [info exists CRINFO($c,status)]} {
                _writeMALog "---- TRACKER ON Posting $c $CRINFO($c,globalState) $CRINFO($c,status) "
                #set cList [list "CR" "$c" "globalState" "$CRINFO($c,globalState)" \
                #     "status" "$CRINFO($c,status)"]
                #set js "[listToJson -mlist $cList -elem "$CRINFO($c,testcase)"]"
                #puts $fp $js
                if {$i == $crc} {
                    puts $fp "    \"$CRINFO($c,testcase)\": \{\"CR\": \"$c\", \
                       \"globalState\": \"$CRINFO($c,globalState)\", \
                       \"status\": \"$CRINFO($c,status)\"\}"
                } else {
                    puts $fp "    \"$CRINFO($c,testcase)\": \{\"CR\": \"$c\", \
                       \"globalState\": \"$CRINFO($c,globalState)\", \
                       \"status\": \"$CRINFO($c,status)\"\},"
                }
                incr i
            }
        }
        puts $fp "  \}";# End tracker brace
        puts $fp "\}";# End file brace
        close $fp
    } else {
        _writeMALog "---- TRACKER Nothing to Post Status: MAIN(USETRACKER)=[info exists MAIN(USETRACKER)]"
        _writeMALog "     TRACKER MAIN(CRLIST)=[info exists MAIN(CRLIST)] MAIN(CRTESTCASELIST)=[info exists MAIN(CRTESTCASELIST)]"
    }
} 


# finding Info files
proc FindInfoFiles {startDir} {
  global MAIN TCSTATUSARRAY
  set pwd [pwd]
  if [catch {cd "$startDir"} err] {
    puts stderr $err
    return {}
  }
  set infoFiles {}
  foreach match [glob -nocomplain -- "*\.txt"] {
    set rs  [regexp {^([0-9]+[-.][0-9a-z_.-]*)([a-zA-Z]+)} $match]
    set rs2 [regexp {^(T[_\-][0-9]+)|^(F[\-_][0-9]+)|^FIT} $match]
    #puts stdout "match result rs $rs match $match"
    if { $rs == 0 && $rs2 == 0} {
      set infoFiles  [lappend infoFiles  $match]
      #puts stdout [file join $startDir $match]
    }
  }
  #puts stdout $infoFiles
  if [catch {cd "$pwd"} err] {
    puts stderr $err
    return {}
  }
  return $infoFiles
}


proc InsertIntoXfilexTable {args} {
  parse_args InsertIntoXfilexTable $args {
    xfile_id ""
    report_id ""
    xfile_name ""
    xfile_type ""
    xfile_content ""
    xfile_comment ""
    xfile_status "none"
    xfile_create_date ""
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}
  #puts "InsertIntoXfilexTable entering"

  set d1 [exec date +%Y-%m-%d]
  set d2 [exec date +%k:%M:%S]
  set d [append d $d1]
  set d [append d " "]
  set d [append d $d2]

  set insert_clause [append insert_clause "insert into xfile_table "]
  set insert_clause [append insert_clause "(xfile_id, "]
  set insert_clause [append insert_clause "report_id, "]
  set insert_clause [append insert_clause "xfile_name, "]
  set insert_clause [append insert_clause "xfile_type, "]
  set insert_clause [append insert_clause "xfile_content, "]
  set insert_clause [append insert_clause "xfile_comment, "]
  set insert_clause [append insert_clause "xfile_status, "]
  set insert_clause [append insert_clause "xfile_create_date) "]

  set insert_clause [append insert_clause "values (\"$xfile_id\", "]
  set insert_clause [append insert_clause "\"$report_id\", "]
  set insert_clause [append insert_clause "\"$xfile_name\", "]
  set insert_clause [append insert_clause "\"$xfile_type\", "]
  set insert_clause [append insert_clause "\"$xfile_content\", "]
  set insert_clause [append insert_clause "\"$xfile_comment\", "]
  set insert_clause [append insert_clause "\"$xfile_status\", "]
  set insert_clause [append insert_clause "\"$d\") "]

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  return 0
}


proc InsertAllInfoFilesIntoXfileTable {args} {
  parse_args InsertAllInfoFilesIntoXfileTable $args {
    report_id ""
    logDir ""
    host ""
  }

  global logFileId

  set infoFiles [FindInfoFiles $logDir]
  puts "DANY InsertAllInfoFilesIntoXfileTable infoFiles: $infoFiles"
  puts $logFileId "DANY InsertAllInfoFilesIntoXfileTable infoFiles: $infoFiles"
  foreach infoFile $infoFiles {
    set infoFileTmp $infoFile
    # set infoFileName [string trimright $infoFile ".txt"]

    set infoFileSplit [split  $infoFile "."]
    set infoFileSplitSize [expr [llength $infoFileSplit] - 2]
    set infoFileSplitTrimmed [lrange $infoFileSplit 0 $infoFileSplitSize]
    set infoFileName [join $infoFileSplitTrimmed "."]

    set infoFile [file join $logDir $infoFile]
    puts $infoFile
    puts $logFileId $infoFile
    createFileBlob $infoFile infoFileBlob

    InsertIntoXfilexTable -report_id $report_id -xfile_name $infoFileName \
                          -xfile_type "text" -xfile_content $infoFileBlob -host $host

  }
}

proc random {{range 10000}} {
    return [expr {int(rand()*$range)}]
}

# finding Binary files
proc FindBinaryFiles {startDir} {
  set pwd [pwd]
  if [catch {cd "$startDir"} err] {
    puts stderr $err
    return {}
  }
  set binaryFiles {}
  foreach match [glob -nocomplain -- "*"] {
    set rs [regexp {([[:alnum:]_]*)\.txt} $match]
    #puts stdout "match result rs $rs match $match"
    if { $rs == 0 } {
      set binaryFiles  [lappend binaryFiles  $match]
      #puts stdout [file join $startDir $match]
    }
  }
  #puts stdout $binaryFiles
  if [catch {cd "$pwd"} err] {
    puts stderr $err
    return {}
  }
  return $binaryFiles
}


proc InsertIntoHostTempDir {args} {
  parse_args InsertIntoHostTempDir $args {
    file_name ""
    pref_file_name ""
    logDir ""
    host ""
  }

  global my_db_server_ftp_login 
  global my_db_server_ftp_password

  set remoteDir "/tmp"

  puts "InsertIntoHostTempDir file_name $file_name"
  puts "InsertIntoHostTempDir pref_file_name $pref_file_name"
  puts "InsertIntoHostTempDir logDir $logDir"
  puts "InsertIntoHostTempDir host $host"


  set ftpHandle [ftp::Open $host $my_db_server_ftp_login $my_db_server_ftp_password]
  if {$ftpHandle >= 0} {
   ftp::Type $ftpHandle binary
   ftp::Cd $ftpHandle $remoteDir
   append logDir "/$file_name"
   ftp::Put $ftpHandle $logDir $pref_file_name
   ftp::Close $ftpHandle
   return 0
  } else {
    # did not work
    return -1
  }
}



proc InsertAllBinaryFilesIntoXfileTable {args} {
  parse_args InsertAllBinaryFilesIntoXfileTable $args {
    report_id ""
    logDir ""
    host ""
  }

  global logFileId this_db

  set binaryFiles [FindBinaryFiles $logDir]
  puts "DANY InsertAllBinaryFilesIntoXfileTable binaryFiles: $binaryFiles"
  foreach file_name $binaryFiles {
    # add random prefix
    set randNmbr [random]
    set pref_file_name "$randNmbr.$file_name"
    puts "pref_file_name $pref_file_name"

    InsertIntoHostTempDir -file_name $file_name -pref_file_name $pref_file_name -logDir $logDir -host $host

    set bin_upl_url [http_formatQuery report_id $report_id xfile_name $pref_file_name]
    #set insertBinaryFileURL "http://$host:8080/insertBinaryFile.php"
    if {$this_db == "autoweb_db_6" || $this_db == "autoweb_db_7"} {
      set insertBinaryFileURL "http://$host/phpdb4/insertBinaryFile.php"
    } else {
      set insertBinaryFileURL "http://$host/insertBinaryFile.php"
    }
    set insertBinaryFileURL [append insertBinaryFileURL "?$bin_upl_url"]
    puts "insertBinaryFileURL $insertBinaryFileURL"
    puts $logFileId "insertBinaryFileURL $insertBinaryFileURL"
    set token [http_get $insertBinaryFileURL -timeout 1000000 ]
    upvar #0 $token httpState
    while { [string match eof $httpState(state)] != 1 } {
      puts stderr "$httpState(state) [string match eof $httpState(state)]"
      flush stderr
      after 100
     }
    #puts "DANY 2 $httpState(body)"
  }
}



proc deleteReport {report_id} {
  # delete the report with this report_id
  global mysql_handler
  puts "DANY deleteReport  report_id: $report_id"
  mysqlexec $mysql_handler "DELETE FROM report_table WHERE report_id = \"$report_id\"" 
}
##############################################################################################
#
#
##############################################################################################
proc deleteReportDb {report_id hdl} {
    # delete the report with this report_id
    mysqlexec $hdl "DELETE FROM report_table WHERE report_id = \"$report_id\""
}
##############################################################################################
#
#
##############################################################################################
proc deleteLogsReportId {report_id} {
  # delete all the logs with this report_id
  global mysql_handler
  puts "DANY deleteLogsReportId  report_id: $report_id"
  mysqlexec $mysql_handler "DELETE FROM log_table WHERE report_id = \"$report_id\"" 
}
##############################################################################################
#
#
##############################################################################################
proc deleteLogsReportIdDb {report_id hdl} {
    mysqlexec $hdl "DELETE FROM log_table WHERE report_id = \"$report_id\""
}
##############################################################################################
#
#
##############################################################################################
proc deleteReportsAndLogsDb {args} {
    parse_args deleteReportsAndLogsDb $args {
        regression_id "null"
        feature_id "null"
        feature_directory "null"
        feature_type "functional"
        hdl ""
    }

    if {$feature_directory != "null" && $feature_id == "null"} {
        set feature_id [getFeatureIdByDirectoryDb -feature_directory $feature_directory \
               -hdl $hdl -feature_type $feature_type]
    }
    set report_ids [mysqlsel $hdl \
        "SELECT report_id FROM report_table WHERE regression_id = \"$regression_id\" AND feature_id = \"$feature_id\"" -flatlist]
    foreach report_id $report_ids {
        puts "deleteReporWithLogs  found report_id: $report_id"
        # delete all the logs with this report_id for this feature_id
        deleteLogsReportIdDb $report_id $hdl
        # delete the report
        deleteReportDb $report_id $hdl
    }
}

proc deleteReporWithLogs {args} {
  parse_args deleteReporWithLogs $args {
    regression_id ""
    run_number ""
    feature_id ""
    host ""
  }
  global mysql_handler
  puts "DANY deleteReporWithLogs  regression_id: $regression_id run_number: $run_number feature_id: $feature_id"
  set report_ids [mysqlsel $mysql_handler "SELECT report_id FROM report_table WHERE regression_id = \"$regression_id\" AND run_number = \"$run_number\" AND feature_id = \"$feature_id\"" -flatlist]
 puts "DANY deleteReporWithLogs report_ids: $report_ids"
 foreach report_id $report_ids {
    puts "DANY deleteReporWithLogs  found report_id: $report_id"
    # delete all the logs with this report_id for this feature_id
    deleteLogsReportId $report_id
    # delete the report
    deleteReport $report_id
 }
}
#####################################################################################################
# proc getAllModules
#
# In args: variables to be used in the current scope
#    a = all feature directories in the db
#    b = nodes required for a feature directory 2node or 5node   b(dir) = 2 or 5 or 1
# Typical usage:
#    set c(dummy) 1
#    conn_to_db $mysqlIP $my_db
#    getAllModules a b
#
#
#    Feature L2 requires a $b(L2) node test bed
#
#####################################################################################################
proc getAllModules { moduleDirectories nodeReqByFeature } {
    upvar $moduleDirectories moduleDirectoriesTmp
    upvar $nodeReqByFeature nodeByFeature


    global mysql_handler

    set moduleDirectoriesTmp [mysqlsel $mysql_handler "SELECT feature_directory FROM feature_table WHERE status = 'Active'" -list]
    set qout [mysqlsel $mysql_handler "SELECT feature_directory,feature_sub_type FROM feature_table WHERE status = 'Active'" -list]
    foreach r $qout {
        set d [lindex $r 0]
        set st [lindex $r 1]
        if {$st == "standard"} {
            set n 2
        } elseif {$st == "routing"} {
            set n 5
        } else {
            set n 1
        }
        set nodeByFeature($d) $n
    }
}

# this return list of failing test cases from run 1
# if the list is non emty cleanup is added
proc GetFailingTestsForModule {args} {
    parse_args GetFailingTestsForModule $args {
	    regression_id ""
	    feature_directory ""
        feature_type ""
	    host ""
        skipCRCases "no"
    }

    if {$skipCRCases == "no"} {
        set crpart ""
    } else {
        set crpart " AND pd_number=\"\" "
    }
    
    global mysql_handler
    #if {[conn_to_autoweb_db $host] !=0 } {
	#return -1
    #} else {
	#mysqluse $mysql_handler autoweb_db_2
    #}

    set failing_tests_list ""
    # get the feature_id of this feature
    set feature_id [mysqlsel $mysql_handler "SELECT feature_id FROM feature_table WHERE status = 'Active' \
                    AND feature_type = \"$feature_type\" AND feature_directory = \"$feature_directory\"" -list]
    puts "DANY GetFailingTestsForModule feature_id: $feature_id"
    # get the report_id of this feature from the first run
    set res_list [mysqlsel $mysql_handler "SELECT report_id, test_result FROM report_table WHERE regression_id = \"$regression_id\" AND feature_id = \"$feature_id\"  AND run_number = \"1\"" -flatlist]
    set report_id [lindex $res_list 0]
    set test_result [lindex $res_list 1]
    puts "DANY GetFailingTestsForModule report_id: $report_id"
    puts "DANY GetFailingTestsForModule test_result: $test_result"
    if {($test_result == "passed") || ($test_result == "aborted")} {
	puts "DANY GetFailingTestsForModule PASSED/ABORTED failing_tests_list: $failing_tests_list"
	return "all"    ;# Actually nothing ... but we're handling keyword "all" differently in mysqlMain and mysqlRunallmonitor
    }
  # get the list of failing tests for this feature if any
  set failing_tests_list [mysqlsel $mysql_handler "SELECT feature_test_script_name FROM log_table WHERE (report_id = \"$report_id\" AND status = \"failed\" $crpart) OR (report_id = \"$report_id\" AND ((feature_test_script_name REGEXP \"init$\") OR (feature_test_script_name REGEXP \"end$\"))) ORDER BY log_id ASC" -list]
   
  if {$failing_tests_list == "" || $failing_tests_list == "NULL"} {
         set failing_tests_list [mysqlsel $mysql_handler "SELECT feature_test_script_name FROM log_table WHERE (report_id = \"$report_id\" AND status = \"failed\" $crpart ) OR (report_id = \"$report_id\" AND ((feature_test_script_name REGEXP \"init\") OR (feature_test_script_name REGEXP \"end\"))) ORDER BY log_id ASC" -list]

  }

  if {$failing_tests_list != "NULL" && $failing_tests_list != "" } {
    # add call to cleanup
    set failing_tests_list [concat $failing_tests_list cleanup]
  }
   if {[llength $failing_tests_list] == 1} {
       if {[lindex $failing_tests_list 0] == "cleanup"} {
              return "all"
       }

  }



  puts "DANY GetFailingTestsForModule failing_tests_list: $failing_tests_list"
    if { $failing_tests_list == "" } {
	return "all"
    } else {
        # filter away CoreDump, Failed and Aborted predefined meta test cases
        set failing_tests_list [GetFilteredListCoreDumpFailedAborted $failing_tests_list]
	return $failing_tests_list
    }
}

proc GetFailingTestsForModule_autoreg {args} {
    parse_args GetFailingTestsForModule_autoreg $args {
	regression_id ""
	feature_directory ""
	host ""
    }
    
    global mysql_handler
    #if {[conn_to_autoweb_db $host] !=0 } {
	#return -1
    #} else {
	#mysqluse $mysql_handler autoweb_db_2
    #}

    set failing_tests_list ""
    # get the feature_id of this feature
    set feature_id [mysqlsel $mysql_handler "SELECT feature_id FROM feature_table WHERE status = 'Active' AND feature_directory = \"$feature_directory\"" -list]
    puts "DANY GetFailingTestsForModule feature_id: $feature_id"
    # get the report_id of this feature from the first run
    set res_list [mysqlsel $mysql_handler "SELECT report_id, test_result FROM report_table WHERE regression_id = \"$regression_id\" AND feature_id = \"$feature_id\"  AND run_number = \"1\"" -flatlist]
    set report_id [lindex $res_list 0]
    set test_result [lindex $res_list 1]
    puts "DANY GetFailingTestsForModule report_id: $report_id"
    puts "DANY GetFailingTestsForModule test_result: $test_result"
    if {($test_result == "passed") || ($test_result == "aborted")} {
	puts "DANY GetFailingTestsForModule PASSED/ABORTED failing_tests_list: $failing_tests_list"
	return "all"    ;# Actually nothing ... but we're handling keyword "all" differently in mysqlMain and mysqlRunallmonitor
    }
  # get the list of failing tests for this feature if any
  set failing_tests_list_with_log_id [mysqlsel $mysql_handler "SELECT log_id,feature_test_script_name FROM log_table WHERE (report_id = \"$report_id\" AND status = \"failed\" AND pd_number=\"\") OR (report_id = \"$report_id\" AND ((feature_test_script_name REGEXP \"init$\") OR (feature_test_script_name REGEXP \"end$\"))) ORDER BY log_id ASC" -list]
 
    set failList ""
  foreach ele $failing_tests_list_with_log_id {

       set log_id [lindex $ele 0]
       set fa_cause [mysqlsel $mysql_handler "SELECT fa_cause FROM aux_log_table WHERE log_id = \"$log_id\"" -flatlist]
       set  fa_cause [string  trim $fa_cause "{}"] 
       if {$fa_cause == ""} {
            puts "fa_cause: $fa_cause"

             lappend failList [lindex $ele 1]

        }

  }
    
  set  passList [string trim [mysqlsel $mysql_handler "SELECT xfile_content  from xfile_table WHERE xfile_name='passTestsList' AND report_id = \"$report_id\"" -flatlist] "{}" ]

set  quickList [string trim [mysqlsel $mysql_handler "SELECT xfile_content from xfile_table WHERE xfile_name='quickTestsList' AND report_id = \"$report_id\"" -flatlist] "{}" ]

set  passAndQuickList [concat $quickList $passList]

puts "Grant pass and quick list : $passAndQuickList"
set failListfil ""
foreach elem $failList {

   #if {![regexp {init|end} $elem]} {

          if {[lsearch $passAndQuickList $elem] != -1} {

                  lappend failListfil $elem

           }

   #}

}

  puts "Grant failing_tests_list : $failListfil"
 set failing_tests_list $failListfil

 if {$failing_tests_list != "NULL"} {
    # add call to cleanup
    set failing_tests_list [concat $failing_tests_list cleanup]
  }
  puts "DANY GetFailingTestsForModule failing_tests_list: $failing_tests_list"
    if { $failing_tests_list == "" } {
	return "all"
    } else {
        # filter away CoreDump, Failed and Aborted predefined meta test cases
        set failing_tests_list [GetFilteredListCoreDumpFailedAborted $failing_tests_list]
	return $failing_tests_list
    }
}


proc GetFilteredListCoreDumpFailedAborted { origList } {

    set keys "CoreDump Failed Aborted"

    foreach key $keys {
        while { [lsearch $origList $key] >= 0 } {
            set origList [ldelete $origList $key]
        }
    }

    return [string trim $origList]

}

proc DetermineCfgRegTypeSubTypeFromRegId { regId } {

    global mysql_handler

    puts "DetermineCfgRegTypeSubTypeFromRegId regId = $regId"
    WriteToQueueDebug "DetermineCfgRegTypeSubTypeFromRegId: regTypeList query" "SELECT feature_type, feature_sub_type, platform_id \
            FROM regression_table WHERE regression_id = $regId"
    set regTypeList [mysqlsel $mysql_handler "SELECT feature_type, feature_sub_type, platform_id \
	    FROM regression_table WHERE regression_id = '$regId'" -flatlist]

    puts "DetermineCfgRegTypeSubTypeFromRegId regTypeList = $regTypeList"

    if { $regTypeList == "" } {
	return -1
    }

    set regType     [lindex $regTypeList 0]
    set regSubType  [lindex $regTypeList 1]
    set platformId  [lindex $regTypeList 2]
    puts  "platformId=$platformId"
    set cfg [mysqlsel $mysql_handler "SELECT platform_cfg_file_name FROM platform_table WHERE platform_id='$platformId'" -flatlist]
    WriteToQueueDebug "DetermineCfgRegTypeSubTypeFromRegId: cfg query" "SELECT platform_cfg_file_name FROM platform_table WHERE platform_id=$platformId"
    WriteToQueueDebug "DetermineCfgRegTypeSubTypeFromRegId: for regId $regId" "RETURNING -- $cfg $regType $regSubType"
    global logFileId
    if {[info exists logFileId] && $logFileId != ""} {
        puts $logFileId "-------------------------------------------------------"
        puts $logFileId "DetermineCfgRegTypeSubTypeFromRegId: cfg query SELECT platform_cfg_file_name FROM platform_table WHERE platform_id=$platformId"
        puts $logFileId "DetermineCfgRegTypeSubTypeFromRegId: for regId $regId RETURNING -- $cfg $regType $regSubType"
        puts $logFileId "-------------------------------------------------------"
    }
    return "$cfg $regType $regSubType"
}

proc DetermineBuildNumFromRegId { regId } {

    global mysql_handler

    set buildId [mysqlsel $mysql_handler "SELECT build_id FROM regression_table WHERE regression_id = '$regId'" -flatlist]

    set buildnumList [mysqlsel $mysql_handler "SELECT build_minor_release,build_number FROM build_table WHERE build_id = '$buildId'" -flatlist]

    set buildNum [join $buildnumList "."]

    return $buildNum
}

proc UpdateRegressionTableWithBuildIdPlId { regression_id build_id platform_id } {
    global mysql_handler

    if { $platform_id != "null"} {
	set update_clause "UPDATE  regression_table SET build_id='$build_id', \
                                                        platform_id='$platform_id', \
                                                        html_pd = 'no module' \
                           WHERE regression_id = '$regression_id'"
    } else {
	set update_clause "UPDATE  regression_table SET build_id='$build_id', \
                                                        html_pd = 'no module'  WHERE \
		regression_id = '$regression_id'"
    }
	mysqlexec $mysql_handler $update_clause
}

proc GetRegressionIdFromQueueId { queue_id build platform_id module } {

    global mysql_handler
    
    # try to find the regression id by queue_id and module (for the first run after the image download phase)
    # if this does not work find it by queue_id and platform_id

    set sel_clause "SELECT regression_id FROM regression_table WHERE \
            queue_id = '$queue_id' AND html_pd = '$module'";
    puts "sel_clause for regression_id_list: $sel_clause"
    set regression_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
    puts "llength of regression_id_list: [llength $regression_id_list]"
    
    if {([llength $regression_id_list] != 0)} {
      set regression_id [lindex $regression_id_list 0]
      # we have entry in the regression_table
      # update it's build_id if build is not null
      if { $build != "null" } {
        # this will create an entry in build_table if it's not already there
        puts "@@@@\n@@@@\nBuild = $build\n@@@@@\n@@@@@"
        set build_id [GetBuildIdFromBuild $build]
        UpdateRegressionTableWithBuildIdPlId $regression_id $build_id $platform_id 
      }
    } else {
        # this is for mysqlAutomate pass
      # try to  find it by queue_id and platform_id
      set sel_clause "SELECT regression_id FROM regression_table WHERE \
              queue_id = '$queue_id' AND platform_id = '$platform_id'";
      puts "sel_clause for regression_id_list: $sel_clause"
      set regression_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
      puts "llength of regression_id_list: [llength $regression_id_list]"
    
      if {([llength $regression_id_list] != 0)} {
        set regression_id [lindex $regression_id_list 0]
      } else {
        # this is for mysqlMain pass
        set sel_clause "SELECT regression_table.regression_id \
                        FROM regression_table, report_table, feature_table  \
                        WHERE regression_table.queue_id ='$queue_id' \
                        AND regression_table.regression_id = report_table.regression_id \
                        AND report_table.feature_id = feature_table.feature_id \
                        AND feature_table.feature_directory='$module'"
        puts "sel_clause for regression_id_list: $sel_clause"
        set regression_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
        puts "llength of regression_id_list: [llength $regression_id_list]"
      
        if {([llength $regression_id_list] != 0)} {
          set regression_id [lindex $regression_id_list 0]
        } else {
          set regression_id "null"
        }
      }
    }


    return $regression_id
}

proc GetRegressionId { args } {

    parse_args GetRegressionId $args {
	queue_id "NULL"
	build_id "NULL"
	platform_id "NULL"
	feature_type "functional"
	feature_sub_type "standard"
        download_phase_module "NULL"
    }

    global mysql_handler

    puts "we do not have regression_id - let's see if we can get it from the regression_table"
    puts "build_id: $build_id"
    puts "platform_id: $platform_id"


    if { $download_phase_module == "NULL"} {
        puts "not a download image case"

        set sel_clause "SELECT regression_id FROM regression_table WHERE \
	        queue_id = '$queue_id' AND \
	        build_id = '$build_id' AND \
	        platform_id = '$platform_id' AND \
	        feature_type = '$feature_type' AND \
	        feature_sub_type = '$feature_sub_type'"
        puts "sel_clause for regression_id_list: $sel_clause"
        set regression_id [mysqlsel $mysql_handler $sel_clause -flatlist]
        puts "llength of regression_id_list: [llength $regression_id]"
    
        if {([llength $regression_id] != 0)} {
	    puts "we found regression_id: $regression_id - lets set total_number_of_runs to 1"
	    # lets set total_number_of_runs to 1
	    set update_clause "UPDATE  regression_table SET total_number_of_runs='1' WHERE \
		    regression_id = '$regression_id'"
	    mysqlexec $mysql_handler $update_clause
        } else {
	    puts "we did not found regression_id - create entry in the regression table"
	    #set feature_type $regType
	    InsertIntoRegressionTable -queue_id $queue_id -build_id $build_id -platform_id $platform_id \
		    -feature_type $feature_type -feature_sub_type $feature_sub_type -html_pd $download_phase_module
	    # get the new regression_id
            # unused html_pd fiels is using for detecting the right entry for the first run
            # if there was a image download phase
	    set regression_id [mysqlsel $mysql_handler $sel_clause -flatlist]
	    puts "InsertIntoRegressionTable regression_id $regression_id queue_id $queue_id \
                                  build_id $build_id platform_id $platform_id \
                                  feature_type $feature_type feature_sub_type $feature_sub_type \
                                  html_pd $download_phase_module"
        }


    } else {
        puts "download image case"
	    puts "we did not found regression_id - create entry in the regression table"
	    #set feature_type $regType
	    InsertIntoRegressionTable -queue_id $queue_id -build_id $build_id -platform_id $platform_id \
		    -feature_type $feature_type -feature_sub_type $feature_sub_type -html_pd $download_phase_module
	    # get the new regression_id
            # unused html_pd fiels is using for detecting the right entry for the first run
            # if there was a image download phase
        set sel_clause "SELECT regression_id FROM regression_table WHERE \
	        queue_id = '$queue_id' AND \
	        build_id = '$build_id' AND \
	        platform_id = '$platform_id' AND \
	        html_pd = '$download_phase_module' AND \
	        feature_type = '$feature_type' AND \
	        feature_sub_type = '$feature_sub_type'"
        puts "sel_clause 2 for regression_id_list: $sel_clause"
	    set regression_id [mysqlsel $mysql_handler $sel_clause -flatlist]
	    puts "InsertIntoRegressionTable regression_id $regression_id queue_id $queue_id \
                                  build_id $build_id platform_id $platform_id \
                                  feature_type $feature_type feature_sub_type $feature_sub_type \
                                  html_pd $download_phase_module"
    }

    return $regression_id
}

proc GetBuildIdFromBuild { build } {

    global mysql_handler
    set major ""
    set minor ""
    set patch ""
    set buildnumber ""
    regexp {([0-9]+)\.([0-9]+)\.([0-9]+)[\.b]([0-9]+.*)} $build match major minor patch buildnumber
    set minorver $major.$minor.$patch
    set build_list [mysqlsel $mysql_handler "SELECT build_id FROM build_table WHERE build_minor_release='$minorver' AND build_number='$buildnumber'" -flatlist]
    #if we do not have a build_id
    if { [llength $build_list] == 0 } {
	puts "we do not have build_id get one"
	
	if ![regexp {([0-9]+)\.([0-9]+)\.([0-9]+)[\.b]([0-9]+.*)} \
		$build match \
		major minor patch buildnumber] {
	    puts "$build not in good format."
	    return "error"
	}
	puts "major: $major"
	puts "minor: $minor"
	puts "patch: $patch"
	puts "buildnumber: $buildnumber"
	set build_major_release "$major.$minor"
	puts "build_major_release: $build_major_release"
	set build_minor_release "$major.$minor.$patch"
	puts "build_minor_release: $build_minor_release"
	set build_number "$buildnumber"
	puts "build_number: $build_number"
	set sel_clause "SELECT build_id FROM build_table WHERE \
		build_major_release = '$build_major_release' AND \
		build_minor_release = '$build_minor_release' AND \
		build_number = '$build_number'"
	set build_list [mysqlsel $mysql_handler $sel_clause -flatlist]
	puts "llength of build_list: [llength $build_list]"
	if { [llength $build_list] != 0 } {
	    set build_id [lindex $build_list 0]
	    puts "we found build_id: $build_id"
	} else {
	    puts "we did not found build_id - enter it into the build table"
	    puts "get system_id from the database"
	    set system_id [mysqlsel $mysql_handler "SELECT system_id FROM system_table WHERE system_name = 'exos'" -flatlist]
	    puts "got system_id: $system_id"
	    InsertIntoBuildTable -system_id $system_id -build_major_release $build_major_release \
		    -build_minor_release $build_minor_release -build_number $build_number
	    # get the new build_id
	    set build_id [mysqlsel $mysql_handler $sel_clause -flatlist]
	}
    } else {
	set build_id [lindex $build_list 0]
	puts "we found build_id: $build_id"	
    }

    puts "build_id = $build_id"
    return $build_id
}
#############################################################################################
# Procedure: get_platform_code
#
# Get the database regression code based on types, blade and platform from main/runReg.cfg
#    The cfg file is also used by runReg to get the code for mysqlAutomate and mysqlMain exec.
#
#############################################################################################
proc get_platform_code {{regType functional} {regSubType None} {platform None} {blade None}} {
    global regplatform
    global cfg
    global cfgFileTail
    global MAIN

    if {![info exists cfg] || $cfg == ""} {set cfg "NOT SET"}
    if {![info exists cfgFileTail] || $cfgFileTail == ""} {set cfgFileTail "NOT SET"}
    WriteToQueueDebug "get_platform_code: top" \
        "platform $platform, regSubType $regSubType, blade $blade, \
        regType $regType ,cfg $cfg , cfgFileTail $cfgFileTail ";
    foreach platform_code_this [array names regplatform] {
        #puts "$platform_code_this == $regplatform($platform_code_this)"
        set platform_code_lst_this $regplatform($platform_code_this)
        set platform_this [lindex $platform_code_lst_this 0]   ;# Summit
        set blade_this [lindex $platform_code_lst_this 1]      ;# X250e-48t p2_x250_ipr.cfg functional ipRoute1
        set cfg_this [lindex $platform_code_lst_this 2]        ;# p2_x250_ipr.cfg functional ipRoute1
        set regType_this [lindex $platform_code_lst_this 3]    ;# functional
        set regSubType_this [lindex $platform_code_lst_this 4] ;# ipRoute1
        if {($cfg_this == $cfgFileTail) && \
                ($regType_this == $regType) && \
                ($regSubType_this == $regSubType)} {
            WriteToQueueDebug "get_platform_code:  RETURN" \
                "returning $platform_code_this - input args $regType $regSubType \
                $platform_this $blade_this";
            result_debug "\n==================== new new =========================\n\
                get_platform_code RETURN: \n\
                runReg Platform: $platform_code_this \n\
                cfgFile=$cfgFileTail\n\
                regType=$regType_this\n\
                regSubType=$regSubType_this\n\
                blade=$blade_this\n\
                ===================================================== "
            return "$platform_code_this"
        }
        if {[info exists cfgFileTail] && $cfg_this == $cfgFileTail && \
                $regType_this == $regType} {
            WriteToQueueDebug "get_platform_code: RETURN on cfg only match" \
                "returning $platform_code_this - input args $regType $regSubType \
                $platform_this $blade_this";
            result_debug "\n==================== new new =========================\n\
                get_platform_code RETURN: \n\
                runReg Platform: $platform_code_this \n\
                MATCH USING ONLY -> cfgFile=$cfgFileTail\n\
                regType=$regType_this\n\
                regSubType=$regSubType_this\n\
                blade=$blade_this\n\
                ===================================================== "         
            return "$platform_code_this"
        }
    }
    WriteToQueueDebug "get_platform_code: Last Result" "return plat not found";
    return "not_found"
}


proc conn_db {host db user passwd} {
  global mysqlstatus mysql_handler
  set user regression_user
  set password extreme
  catch {mysqlconnect -host $host -user $user -password $password -db $db} mysql_handler
  #puts $mysqlstatus(code);
  if {$mysqlstatus(code) !=0} {
      puts stderr $mysqlstatus(message)
      #mysqlclose $mysql_handler
     return $mysqlstatus(code)
  }
  #mysqlexec  $mysql_handler "SET max_allowed_packet=50000000"
  return $mysqlstatus(code)
}

proc getPlatformId {platform} {
  global mysql_handler regplatform

  set platform_code_lst $regplatform($platform)
  set cfg_file [lindex $platform_code_lst 2]

  set sel_clause "SELECT platform_id FROM platform_table WHERE platform_cfg_file_name='$cfg_file'"
  set platform_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  set platform_id [lindex $platform_id_lst 0];# only single result
  return $platform_id
}

proc getCfgFamilies {cfg} {
    global mysqlstatus mysqlIP my_db

    set user regression_user
    set password extreme
    if {[catch {mysqlconnect -host $mysqlIP -user $user -password $password -db $my_db} myhandle]} {
        puts "Could not connecto the the database: $myhandle"
        return -1;
    }

    set sel_clause "SELECT target_os, additional_os FROM platform_table WHERE platform_cfg_file_name='$cfg'"
    set qlst [mysqlsel $myhandle $sel_clause -list]
    set targos [lindex $qlst 0]
    set addoslst  [split [lindex $qlst 1] " "]
    lappend flist $targos
    set outList [concat $flist $addoslst]
    catch {close $myhandle} oops
    return $outList
}

proc getBuidId {build_major} {
  global mysql_handler

  set sel_clause "SELECT build_id FROM build_table WHERE build_major_release ='$build_major' ORDER BY build_id DESC LIMIT 1"
  set build_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  # only single result
  set build_id [lindex $build_id_lst 0]
  return $build_id
}

proc getFeatureId {module} {
  global mysql_handler

  set sel_clause "SELECT feature_id FROM feature_table WHERE feature_name ='$module' AND status = 'Active'"
  set feature_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  # only single result
  set feature_id [lindex $feature_id_lst 0]
  return $feature_id
}

proc getFeatureIdByDirectory {module} {
  global mysql_handler

  set sel_clause "SELECT feature_id FROM feature_table WHERE feature_directory ='$module' AND status = 'Active'"
  set feature_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  # only single result
  set feature_id [lindex $feature_id_lst 0]
  return $feature_id
}
###############################################################################
# Get feature id from specific db handle
#
###############################################################################
proc getFeatureIdByDirectoryDb {args} {

    parse_args getFeatureIdByDirectoryDb $args {
        feature_directory ""
        feature_type "functional"
        hdl ""
    }

    set sel_clause "SELECT feature_id FROM feature_table WHERE feature_directory = '$feature_directory' \
          AND feature_type = '$feature_type' AND status = 'Active'"
    set feature_id_lst [mysqlsel $hdl $sel_clause -flatlist]
    # only single result
    set feature_id [lindex $feature_id_lst 0]
    return $feature_id

}


proc getRegressionId {build_id platform_id tcList} {
  global mysql_handler

  if {$tcList == "quick"} {
     set test_this_duration test_quick_duration
  } elseif {$tcList == "pass"} {
     set test_this_duration test_pass_duration
  } else {
     set test_this_duration test_all_duration
  }

  set sel_clause "SELECT regression_table.regression_id FROM regression_table, report_table \
                  WHERE regression_table.build_id ='$build_id' \
                  AND regression_table.platform_id ='$platform_id' \
                  AND regression_table.regression_id = report_table.regression_id \
                  AND report_table.$test_this_duration != '0' ORDER BY regression_id DESC LIMIT 1"
  set regression_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  # only single result
  set regression_id [lindex $regression_id_lst 0]
  #puts "getRegressionId sel_clause \n $sel_clause \n"
  #puts "getRegressionId regression_id $regression_id\n"
  return $regression_id
}

proc getReportId {regression_id feature_id} {
  global mysql_handler

  set sel_clause "SELECT report_id FROM report_table WHERE regression_id ='$regression_id' AND feature_id ='$feature_id'"
  set report_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  # only single result
  set report_id [lindex $report_id_lst 0]
  #puts "getReportId sel_clause \n $sel_clause \n"
  #puts "getReportId report_id $report_id\n"
  return $report_id
}
##############################################################################
#
#
##############################################################################
proc getRegressionIdDb {args} {

    parse_args getRegressionIdDb $args {
        build_id "2"
        platform_id ""
        tcList ""
        queue_id "null"
        hdl ""
    }

    if {$queue_id == "null"} {
        if {$tcList == "quick"} {
            set test_this_duration test_quick_duration
        } elseif {$tcList == "pass"} {
            set test_this_duration test_pass_duration
        } else {
            set test_this_duration test_all_duration
        }

        set sel_clause "SELECT regression_table.regression_id FROM regression_table, report_table \
              WHERE regression_table.build_id ='$build_id' \
              AND regression_table.platform_id ='$platform_id' \
              AND regression_table.regression_id = report_table.regression_id \
              AND report_table.$test_this_duration != '0' ORDER BY regression_id DESC LIMIT 1"
    } else {
        set sel_clause "SELECT regression_id FROM regression_table \
              WHERE queue_id ='$queue_id' ORDER BY regression_id DESC LIMIT 1"
    }
    set regression_id_lst [mysqlsel $hdl $sel_clause -flatlist]
    # only single result
    set regression_id [lindex $regression_id_lst 0]
    #puts "getRegressionId sel_clause \n $sel_clause \n"
    #puts "getRegressionId regression_id $regression_id\n"
    return $regression_id
}

proc getReportIdDb {args} {

    parse_args getReportIdDb $args {
        regression_id "null"
        feature_id "null"
        hdl "null"
    }

    set sel_clause "SELECT report_id FROM report_table WHERE regression_id ='$regression_id' AND feature_id ='$feature_id'"
    set report_id_lst [mysqlsel $hdl $sel_clause -flatlist]
    # only single result
    set report_id [lindex $report_id_lst 0]
    #puts "getReportId sel_clause \n $sel_clause \n"
    #puts "getReportId report_id $report_id\n"
    return $report_id
}

proc getExpectedDurationSingleTestCase {feature_id test_case platform_id build_id} {
  global mysql_handler

  set sel_clause "SELECT log_duration FROM report_table, log_table, regression_table \
                  WHERE regression_table.build_id ='$build_id' \
                    AND regression_table.platform_id = '$platform_id' \
                    AND report_table.regression_id = regression_table.regression_id \
                    AND report_table.feature_id = '$feature_id' \
                    AND log_table.report_id = report_table.report_id \
                    AND log_table.feature_test_script_name = '$test_case' \
                    AND log_table.log_duration != '0' ORDER BY log_id DESC LIMIT 1"
  set log_duration_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  #puts "getExpectedDurationSingleTestCase sel_clause \n  $sel_clause\n"
  #puts "log_duration_lst $log_duration_lst\n"
  # only single result
  set log_duration [lindex $log_duration_lst 0]
  return $log_duration
}

proc getExpectedDurationFromLog {feature_id platform_id build_id tcList} {

  global mysql_handler

  set total_log_duration 0
puts "feature_id $feature_id, platform_id $platform_id, build_id $build_id, tcList $tcList"
  foreach test_case $tcList {
    set log_duration_this [getExpectedDurationSingleTestCase $feature_id $test_case $platform_id $build_id]
    if {($log_duration_this == "0") || \
        ($log_duration_this == "") || \
        ($log_duration_this == "null") || \
        ($log_duration_this == "NULL")} {
      return "null";
    } else {
      set total_log_duration [expr $total_log_duration + $log_duration_this]
    }
  }
  return $total_log_duration
}



proc getExpectedDurationFromReport {report_id tcList} {
  global mysql_handler

  if {$tcList == "quick"} {
     set test_this_duration test_quick_duration
  } elseif {$tcList == "pass"} {
     set test_this_duration test_pass_duration
  } else {
     set test_this_duration test_all_duration
  }
  set sel_clause "SELECT $test_this_duration FROM report_table WHERE report_id ='$report_id'"
  set expected_duration_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  #puts "getExpectedDurationFromReport sel_clause \n  $sel_clause\n"
  #puts "expected_duration_lst $expected_duration_lst\n"
  # only single result
  set expected_duration [lindex $expected_duration_lst 0]
  return $expected_duration
}


proc getExpectedDuration { platform build_major module tcList host db user passwd } {
  global mysql_handler

  conn_db $host $db $user $passwd
  set expected_duration "null"
  if {($tcList!="")&&($tcList!="null")&&($tcList!="NULL")} {
    set platform_id [getPlatformId $platform]
    set build_id [getBuidId $build_major]
    set feature_id [getFeatureId $module]
    if {($tcList=="all")||($tcList=="pass")||($tcList=="quick")} {
      set regression_id [getRegressionId $build_id $platform_id $tcList]
      set report_id [getReportId $regression_id $feature_id]
      set expected_duration [getExpectedDurationFromReport $report_id $tcList]
    } else {
puts "the test $tcList"
      set expected_duration [getExpectedDurationFromLog $feature_id $platform_id $build_id $tcList]
    }
  }
  if {($expected_duration=="")||($expected_duration=="null")||($expected_duration=="NULL")} {
    set expected_duration "null"
  }
  return $expected_duration
}
proc InsertIntoLimgFileTable {args} {
  parse_args InsertIntoLimgFileTable $args { 
    limg_file_id ""
    report_id ""
    limg_file_name ""
    limg_file_type ""
    limg_file_content ""
    limg_file_comment ""
    limg_file_status "none"
    limg_file_create_date ""
    host "" 
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } { 
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}
  #puts "InsertIntoLimgFileTable entering"

  set d1 [exec date +%Y-%m-%d]
  set d2 [exec date +%k:%M:%S]
  set d [append d $d1]
  set d [append d " "]
  set d [append d $d2]

  set insert_clause [append insert_clause "insert into limg_file_table "]
  set insert_clause [append insert_clause "(limg_file_id, "]
  set insert_clause [append insert_clause "report_id, "]
  set insert_clause [append insert_clause "limg_file_name, "]
  set insert_clause [append insert_clause "limg_file_type, "]
  set insert_clause [append insert_clause "limg_file_content, "]
  set insert_clause [append insert_clause "limg_file_comment, "]
  set insert_clause [append insert_clause "limg_file_status, "]
  set insert_clause [append insert_clause "limg_file_create_date) "]

  set insert_clause [append insert_clause "values (\"$limg_file_id\", "]
  set insert_clause [append insert_clause "\"$report_id\", "]
  set insert_clause [append insert_clause "\"$limg_file_name\", "]
  set insert_clause [append insert_clause "\"$limg_file_type\", "]
  set insert_clause [append insert_clause "\"$limg_file_content\", "]
  set insert_clause [append insert_clause "\"$limg_file_comment\", "]
  set insert_clause [append insert_clause "\"$limg_file_status\", "]
  set insert_clause [append insert_clause "\"$d\") "]

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  return 0
}

proc InsertAllInfoFilesIntoLimgFileTable {args} {
  parse_args InsertAllInfoFilesIntoXfileTable $args {
    report_id ""
    logDir ""
    host ""
  }

  set infoFiles [FindInfoFiles $logDir]
  puts "DANY InsertAllInfoFilesIntoLimgFileTable infoFiles: $infoFiles"
  foreach infoFile $infoFiles {
    set infoFileTmp $infoFile
    # set infoFileName [string trimright $infoFile ".txt"]

    set infoFileSplit [split  $infoFile "."]
    set infoFileSplitSize [expr [llength $infoFileSplit] - 2]
    set infoFileSplitTrimmed [lrange $infoFileSplit 0 $infoFileSplitSize]
    set infoFileName [join $infoFileSplitTrimmed "."]

    set infoFile [file join $logDir $infoFile]
    puts $infoFile
    createFileBlob $infoFile infoFileBlob

    InsertIntoLimgFileTable -report_id $report_id -limg_file_name $infoFileName \
                          -limg_file_type "text" -limg_file_content $infoFileBlob -host $host

  }

}

proc CreateEmailResultLink {args} {
  parse_args CreateEmailResultLink $args {
    queue_id ""
    feature_directory ""
    mydb_name "devweb_db"
    host "regserver1"
    mydb_host "regserver1"
  }

  global mysql_handler

  conn_to_db $mydb_host $mydb_name

  set query "SELECT feature_table.feature_id, \
                feature_table.feature_name, \
                regression_table.regression_id, \
                build_table.build_id, \
                build_table.build_minor_release, \
                build_table.build_number, \
                platform_table.platform_name, \
                platform_table.platform_blade, \
                platform_table.number_nodes, \
                aa_table.aa_first_name, \
                aa_table.aa_last_name \
                FROM feature_table, build_table, platform_table, \
                     report_table, regression_table, aa_table \
                WHERE regression_table.queue_id=\"$queue_id\" \
                AND feature_table.feature_directory= \"$feature_directory\" \
                AND report_table.feature_id = feature_table.feature_id \
                AND report_table.regression_id = regression_table.regression_id \
                AND report_table.run_number = '1' \
                AND regression_table.build_id = build_table.build_id \
                AND regression_table.platform_id = platform_table.platform_id \
                AND aa_table.aa_id = feature_table.aa_id"

  set query_result_list [mysqlsel $mysql_handler $query -list]

  set query_result_list [lindex $query_result_list 0]
  set feature_id [lindex $query_result_list 0]
  set feature_name [lindex $query_result_list 1]
  set regression_id [lindex $query_result_list 2]
  set build_id [lindex $query_result_list 3]
  set build_minor_release [lindex $query_result_list 4]
  set build_number [lindex $query_result_list 5]
  set platform_name [lindex $query_result_list 6]
  set platform_blade [lindex $query_result_list 7]
  set number_nodes [lindex $query_result_list 8]
  set aa_first_name [lindex $query_result_list 9]
  set aa_last_name [lindex $query_result_list 10]

  set aa_name "$aa_first_name $aa_last_name"
  set build_name "$build_minor_release.$build_number"

  set href "<http://$host/generateQuingResultsSinglePlatform.php?feature_id=$feature_id&feature_name=$feature_name&build_id=$build_id&build_name=$build_name&platform_name=$platform_name&platform_blade=$platform_blade&number_nodes=$number_nodes&regression_id=$regression_id&queue_id=$queue_id&aa_name=$aa_name&host=$mydb_host>"

  return $href
}

# Takes as input the numNodes and returns all platforms with that many numNodes; used for reordering regression modules
proc GetAllPlatformIds { numNodes } {
    global mysql_handler

    set sel_clause "SELECT platform_id from platform_table where number_nodes='$numNodes'";
    set platform_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]

    return $platform_id_lst
}
########################################################################
# Takes as input the numNodes and platform_name and returns all 
#       all platforms_ids with that many numNodes of that platform name
#   - Initially used for reordering regression modules
#
#  Usage:
#  set idList [GetPlatformTypeIds 2 ASPEN]
########################################################################
proc GetPlatformTypeIds { numNodes platform } {
    global mysql_handler

    set sel_clause "SELECT platform_id from platform_table where number_nodes='$numNodes' AND platform_name='$platform'";
    set platform_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]

    return $platform_id_lst
}
# What is the currently running platform ID?
proc GetCurrentPlatformId { platform blade numNodes } {
    global mysql_handler

    set sel_clause "SELECT platform_id from platform_table where platform_name='$platform' and platform_blade='$blade' and number_nodes='$numNodes'";
    set platform_id [mysqlsel $mysql_handler $sel_clause -flatlist]

    return $platform_id
}

proc getEfenceProcessList {args} {
    parse_args getEfenceProcessList $args {
      module ""
      cfg ""
      regType "functional"
    }
    global mysql_handler
    puts "getEfenceProcessList module $module cfg $cfg"

    # is this a stackable?
    set sel_clause "SELECT platform_type from platform_table where platform_cfg_file_name='$cfg'";
    set platform_type [mysqlsel $mysql_handler $sel_clause -flatlist]
    puts "getEfenceProcessList platform_type $platform_type"

    if {$platform_type == "stackable"} {
      set efence_processes ""
    } else {
      set sel_clause "SELECT efence_processes from feature_table where status = 'Active' AND feature_directory='$module' and feature_type='$regType'";
      set efence_processes [mysqlsel $mysql_handler $sel_clause -flatlist]
      #this is comma separated list with possible spaces
      set efence_processes [join $efence_processes " "]
      set efence_processes [string map {" " ""} $efence_processes]
      set efence_processes [split $efence_processes ,]
    }
    puts "getEfenceProcessList efence_processes $efence_processes"
    return $efence_processes
}



# enter protected region 
proc getLock {name wait_limit} {
  global mysql_handler

  set sel_clause "SELECT GET_LOCK('$name', $wait_limit)";
  set rslt [mysqlsel $mysql_handler $sel_clause -flatlist]
  return $rslt
}

# leave protected region 
proc releaseLock {name} {
  global mysql_handler

  set sel_clause "SELECT RELEASE_LOCK('$name')";
  set rslt [mysqlsel $mysql_handler $sel_clause -flatlist]
  return $rslt
}

proc DeleteCurrentRunTableEntry {args} {
  parse_args DeleteCurrentRunTableEntry $args {
    current_run_id ""
    host ""
  }

  global mysql_handler
  mysqlexec $mysql_handler "DELETE FROM current_run_table WHERE current_run_id = \"$current_run_id\""

}
# --------------------------------------------------------------
#  Return the expected duration of an automated feature based on
#    previous automation runs
# --------------------------------------------------------------
proc GetExpectedDuration {args} {
    parse_args GetExpectedDuration $args {
        regression_id ""
        feature_directory ""
        feature_id ""
        platform_id ""
        host ""
    }
    global mysql_handler
    global DebugOn
    global DebugOnHi

    set rslt [catch {
        set d1 [exec date +%Y-%m-%d]
        set d2 [exec date +%k:%M:%S]
        set d [append d $d1]
        set d [append d " "]
        set d [append d $d2]
        #puts $d
        
        set sel_clause2 [append sel_clause2 "SELECT report_table.test_report_duration, \
            report_table.test_quick_duration, \
            report_table.test_pass_duration, \
            report_table.test_all_duration \
            FROM regression_table, report_table "]
        set sel_clause2 [append sel_clause2 "WHERE regression_table.platform_id = '$platform_id' "]
        set sel_clause2 [append sel_clause2 "AND regression_table.regression_id = report_table.regression_id "]
        set sel_clause2 [append sel_clause2 "AND report_table.feature_id = '$feature_id' "]
        set sel_clause2 [append sel_clause2 "AND report_table.run_number = '1' "]
        set sel_clause2 [append sel_clause2 "ORDER BY report_table.report_id DESC LIMIT 5 "]
        set timeInfoList [mysqlsel $mysql_handler $sel_clause2 -list]
        #puts "test_report_duration_lst $test_report_duration_lst\r"
        # find the shortest test_report_duration
        set expected_duration 0
        set e_quick_duration 0
        set e_pass_duration 0
        set e_all_duration 0
        set i 0
        foreach testList $timeInfoList {
            set test_report [lindex $testList 0]
            set test_quick [lindex $testList 1]
            set test_pass [lindex $testList 2]
            set test_all [lindex $testList 3]
            set expected_duration [expr $expected_duration + $test_report]
            set e_quick_duration [expr $e_quick_duration + $test_quick]
            set e_pass_duration [expr $e_pass_duration + $test_pass]
            set e_all_duration [expr $e_all_duration + $test_all]
            incr i
        }
        if {$i>0} {
            set expected_duration [expr $expected_duration / $i]
            set e_quick_duration [expr $e_quick_duration / $i]
            set e_pass_duration [expr $e_pass_duration / $i]
            set e_all_duration [expr $e_all_duration / $i]
        }
        # ------------------------------------------------------
        # If there are less than 5 results set the time 1
        #    This is for cases of first run test cases
        #    and also allows setting real zero time
        # ------------------------------------------------------
        if {[llength $timeInfoList] < 5 && ($expected_duration == "" || $expected_duration == 0} {
            set expected_duration 1
        }
        # ------------------------------------------------------
        # S K I P   a feature by setting it to 0
        #
        # ------------------------------------------------------
        #if {($e_all_duration == "" ||  $e_all_duration < 10 ) && \
        #    ($e_pass_duration == "" ||  $e_pass_duration < 10 ) && \
        #    ($e_quick_duration == "" ||  $e_quick_duration < 10 ) } {
        #    set expected_duration 0
        #}
        if {$DebugOn} {puts "$feature_directory expected_duration $expected_duration";   flush stdout; after 50;}
    } reason]
    return $expected_duration
}
# --------------------------------------------------------------
#  Populate the array FeatureInfo($featureObj,execTime)
#      - FeatureInfo(ACL,execTime) = 1234
#      - FeatureIdInfo(1,execTime) = 1234
# --------------------------------------------------------------
proc GetFeatureInfo {args} {
    parse_args GetFeatureInfo $args {
        regression_id ""
        platform_id ""
        regType ""
        regSubType ""
        build_minor_release ""
    }

    global mysql_handler
    global FeatureInfo
    global FeatureIdInfo
    global DebugOn
    global DebugOnHi
    global ForceTimeUpdate

    if {$DebugOn} {puts "========\nGet ALL POSSIBLE modules to run from the database\n=========";  flush stdout; after 50;}
    set regSubTypeThis $regSubType
    if {$regSubTypeThis == "ipRoute1"} {
    	set regSubTypeThis "routing"
    }
    set allTypeModules [mysqlsel $mysql_handler "SELECT feature_id, feature_directory, feature_expected_exec_time, \
        feature_type, feature_sub_type \
        FROM feature_table WHERE status = 'Active' AND feature_type = '$regType' AND feature_sub_type = '$regSubType' AND (end_release_id IS NULL OR end_release_id = '' OR end_release_id >= '$build_minor_release') AND (start_release_id = '' OR start_release_id IS NULL OR start_release_id <= '$build_minor_release')" -list]
    if {$allTypeModules == ""} {
    	result_error "No modules list for regType:$regType regSubType:$regSubType"
    	return 0
    }
    # -----------------------------------------------------------------
    #  Get the real execution time for this module on this hardware.
    # -----------------------------------------------------------------
    set allTimeFeatures [mysqlsel $mysql_handler "SELECT feature_id, mean_exec_time, last_updated_epoch \
        FROM platform_feature_table WHERE platform_id = '$platform_id'" -list]

    if {$allTimeFeatures == "" && $platform_id != ""} {
        # If there are no times returned for this platform we need to enter them
        if {$DebugOn} {puts "========\nFOUND No Feature Mean Exec Times.  Populate this platform\n========="; flush stdout; after 50;}
        foreach fList $allTypeModules {
            set fId   [lindex $fList 0]
            set fName [lindex $fList 1]
            lappend fNames $fName
            set fTime [lindex $fList 2]
            set fType [lindex $fList 3]
            set fSType [lindex $fList 4]
            set insert_clause ""
    
            set newTime [GetExpectedDuration -regression_id $regression_id \
                -feature_directory $fName -feature_id $fId \
                -platform_id $platform_id]
            if {$newTime == "" || $newTime == "NULL"} {
                set newTime 0
            }
            if {$DebugOn} {puts "Feature $fName exec time $newTime"; flush stdout; after 50;}
            # Insert new values because this platform has no entries in the table.
            set insert_clause [append insert_clause "insert into platform_feature_table (platform_id, "]
            set insert_clause [append insert_clause "feature_id, "]
            set insert_clause [append insert_clause "mean_exec_time, "]
            set insert_clause [append insert_clause "last_updated_epoch) "]
            
            set insert_clause [append insert_clause "values (\"$platform_id\", "]
            set insert_clause [append insert_clause "\"$fId\", "]
            set insert_clause [append insert_clause "\"$newTime\", "]
            set insert_clause [append insert_clause "\"[clock seconds]\")"]
            if {$DebugOn} {puts "Insert $insert_clause"; flush stdout; after 50;}
    
            mysqlexec  $mysql_handler $insert_clause

            set FeatureInfo($fName,execTime) $newTime
            set FeatureIdInfo($fId,execTime) $newTime
        }
    } elseif {$ForceTimeUpdate} {
        # ---------------------------------------------------------------
        #  A list of ALL features
        # ---------------------------------------------------------------
        if {$DebugOn} {puts "========\nIn Force update\n========="; flush stdout; after 50;}
        foreach fList $allTypeModules {
            set insert_clause ""
            set update_clause ""
            set fId   [lindex $fList 0]
            set fName [lindex $fList 1]
            lappend fNames $fName
            set fTime [lindex $fList 2]
            set fType [lindex $fList 3]
            set fSType [lindex $fList 4]
            # -----------------------------------------------------------
            # A list of features for this platform id from the time table
            # -----------------------------------------------------------
            set hitFeature 0
            foreach ftList $allTimeFeatures {
                set insert_clause ""
                set update_clause ""
                set f_Id   [lindex $ftList 0]
                set met [lindex $ftList 1]
                set lue [lindex $ftList 2]

                # -------------------------------------------------------
                # There is a time entry for this feature on this platform
                #   update the entry.
                # -------------------------------------------------------
                if {$f_Id == $fId} {
                    set newTime [GetExpectedDuration -regression_id $regression_id \
                    -feature_directory $fName -feature_id $f_Id \
                    -platform_id $platform_id]
                    if {$newTime == "" || $newTime == "NULL"} {
                        set newTime 0
                    }

                    set update_clause "UPDATE  platform_feature_table SET mean_exec_time='$newTime', \
                    last_updated_epoch='[clock seconds]' \
                    WHERE feature_id = '$f_Id' AND platform_id = '$platform_id'"
                    if {$DebugOn} {puts "Update Clause: $update_clause \n"; flush stdout; after 50;}
                    mysqlexec  $mysql_handler $update_clause

                    set FeatureInfo($fName,execTime) $newTime
                    set FeatureIdInfo($fId,execTime) $newTime
                    set FeatureInfo($fName,last_updated_execTime) [clock seconds]
                    set FeatureIdInfo($fId,last_updated_execTime) [clock seconds]

                    set hitFeature 1
                }
            }
            if {!$hitFeature} {
                # --------------------------------------------------------------
                # There is not entry for this in the platform_feature_table.
                #   insert it.
                # --------------------------------------------------------------
                if {$DebugOn} {puts "D I D   N O T   H I T   F E A T U R E";  flush stdout; after 50;}
                set newTime [GetExpectedDuration -regression_id $regression_id \
                -feature_directory $fName -feature_id $fId \
                -platform_id $platform_id]
                if {$newTime == "" || $newTime == "NULL"} {
                    set newTime 0
                }
                # Insert new values because this platform has no entries in the table.
                set insert_clause [append insert_clause "insert into platform_feature_table (platform_id, "]
                set insert_clause [append insert_clause "feature_id, "]
                set insert_clause [append insert_clause "mean_exec_time, "]
                set insert_clause [append insert_clause "last_updated_epoch) "]
                
                set insert_clause [append insert_clause "values (\"$platform_id\", "]
                set insert_clause [append insert_clause "\"$fId\", "]
                set insert_clause [append insert_clause "\"$newTime\", "]
                set insert_clause [append insert_clause "\"[clock seconds]\")"]
                if {$DebugOn} {puts "Insert Clause: $insert_clause \n"; flush stdout; after 50;}

                mysqlexec  $mysql_handler $insert_clause
    
                set FeatureInfo($fName,execTime) $newTime
                set FeatureIdInfo($fId,execTime) $newTime
                set FeatureInfo($fName,last_updated_execTime) [clock seconds]
                set FeatureIdInfo($fId,last_updated_execTime) [clock seconds]
            }
        }
    } else {
        if {$DebugOn} {puts "FORCE is not enabled and time query is not empty\nVerify existing and get new if necessary"; flush stdout; after 50;}
        foreach ftList $allTimeFeatures {
            set f_Id   [lindex $ftList 0]
            set met [lindex $ftList 1]
            set lue [lindex $ftList 2]
            set FeatureIdInfo($f_Id,execTime) $met
            set FeatureIdInfo($f_Id,last_updated_execTime) $lue
        }
        foreach fList $allTypeModules {
            set insert_clause ""
            set update_clause ""
            set fId   [lindex $fList 0]
            set fName [lindex $fList 1]
            set fTime [lindex $fList 2]
            set fType [lindex $fList 3]
            set fSType [lindex $fList 4]
            if {![info exists FeatureIdInfo($fId,execTime)]} {
                if {$DebugOn} {puts "Feature $fName does not exist.  Insert it"; flush stdout; after 50;}
                # -------------------------------------------------------------------
                # Check to see if been set for this feature above.  If no there is
                #   no entry in the platform_feature_table.  Create it.
                # -------------------------------------------------------------------
                set newTime [GetExpectedDuration -regression_id $regression_id \
                    -feature_directory $fName -feature_id $fId \
                    -platform_id $platform_id]
                if {$newTime == "" || $newTime == "NULL"} {
                    set newTime 0
                }
                # Insert new values because this platform has no entries in the table.
                set insert_clause [append insert_clause "insert into platform_feature_table (platform_id, "]
                set insert_clause [append insert_clause "feature_id, "]
                set insert_clause [append insert_clause "mean_exec_time, "]
                set insert_clause [append insert_clause "last_updated_epoch) "]
                
                set insert_clause [append insert_clause "values (\"$platform_id\", "]
                set insert_clause [append insert_clause "\"$fId\", "]
                set insert_clause [append insert_clause "\"$newTime\", "]
                set insert_clause [append insert_clause "\"[clock seconds]\")"]
                #puts "$insert_clause\r"
                if {$DebugOn} {puts "Insert clause: $insert_clause"; flush stdout; after 50;}
        
                mysqlexec  $mysql_handler $insert_clause
        
                set fMet $newTime
                set fLue [clock seconds]
                set FeatureInfo($fName,execTime) $fMet
                set FeatureInfo($fName,last_updated_execTime) $fLue
                set FeatureIdInfo($fId,execTime) $fMet
                set FeatureIdInfo($fId,last_updated_execTime) $fLue

            } elseif {[info exists FeatureIdInfo($fId,last_updated_execTime)] && \
                   [expr $FeatureIdInfo($fId,last_updated_execTime) - [clock seconds]] > 5200000} {
                if {$DebugOn} {puts "Time is greater than 2 months update"; flush stdout; after 50;}
                # -------------------------------------------------------------------
                # If the last updated time has be set for this feature above
                #  check to see if the time is older than 2 months.  If so
                #  update
                # -------------------------------------------------------------------
                set newTime [GetExpectedDuration -regression_id $regression_id \
                    -feature_directory $fName -feature_id $fId \
                    -platform_id $platform_id]
                if {$newTime == "" || $newTime == "NULL"} {
                    set newTime 0
                }
                set update_clause "UPDATE  platform_feature_table SET mean_exec_time='$newTime', \
                last_updated_epoch='[clock seconds]' \
                WHERE feature_id = '$fId' AND platform_id = '$platform_id'"
        
                if {$DebugOn} {puts "Update clause: $update_clause"; flush stdout; after 50;}
                mysqlexec  $mysql_handler $update_clause
        
                set fMet $newTime
                set fLue [clock seconds]
                set FeatureInfo($fName,execTime) $fMet
                set FeatureInfo($fName,last_updated_execTime) $fLue
                set FeatureIdInfo($fId,execTime) $fMet
                set FeatureIdInfo($fId,last_updated_execTime) $fLue
            } elseif {[info exists FeatureIdInfo($fId,last_updated_execTime)] && \
                      [info exists FeatureIdInfo($fId,execTime)]} {
                set fMet $FeatureIdInfo($fId,execTime)
                set fLue $FeatureIdInfo($fId,last_updated_execTime)
                set FeatureInfo($fName,execTime) $fMet
                set FeatureInfo($fName,last_updated_execTime) $fLue
                if {$DebugOn} {puts "--- Feature $fName (platform_id $platform_id , feature_id $fId ): Found execTim $fMet\n Lue: $fLue"; flush stdout; after 50;}
            } else {
                puts "Time variables are missing so I had to quit."
                return 0;
            }
        }
    }
    set q 0
    foreach fList $allTypeModules {
        set insert_clause ""
        set update_clause ""
        set fId   [lindex $fList 0]
        set fName [lindex $fList 1]
        lappend fNames $fName
        set fTime [lindex $fList 2]
        set fType [lindex $fList 3]
        set fSType [lindex $fList 4]
        if {![info exists FeatureIdInfo($fId,execTime)] || ![info exists FeatureIdInfo($fId,last_updated_execTime)]} {
            if {$DebugOn} {puts "Feature $fName does not have variables set"; flush stdout; after 50;}
            return 0;
        } else {
            if {$DebugOn} {puts "Feature $fName times are set"; flush stdout; after 50;}
            set met $FeatureIdInfo($fId,execTime)
            set lue $FeatureIdInfo($fId,last_updated_execTime)
        }
        
        # -----------------------------------------------------------
        # Update or insert if the time is not there
        # -----------------------------------------------------------
        if {$DebugOn} {puts "========\nfId $fId plat_id $platform_id\nfName $fName\nfTime $met\nfType $fType\nfSType $fSType\n========="; flush stdout; after 50;}

        set FeatureInfo($fName,feature_id) $fId
        set FeatureIdInfo($fId,feature_directory) $fName
        set FeatureIdInfo($fId,feature_name) $fName
        set FeatureInfo($fName,feature_type) $fType
        set FeatureIdInfo($fId,feature_type) $fType
        set FeatureInfo($fName,feature_sub_type) $fSType
        set FeatureIdInfo($fId,feature_sub_type) $fSType
        incr q;
    }
    # -----------------------------------------------------------
    # Update or insert if the time is not there
    # -----------------------------------------------------------
    set fNames ""
    set finalTimeFeatureIDs [mysqlsel $mysql_handler "SELECT feature_id \
        FROM platform_feature_table WHERE platform_id = '$platform_id' ORDER BY mean_exec_time DESC" -flatlist]
    if {$DebugOnHi||$DebugOn} {puts "========\n========\n========\nF I N I S H   G E T   F E A T U R E S\n========\n========\n========="; flush stdout; after 50;}
    return $finalTimeFeatureIDs
}

# --------------------------------------------------------------
#
#
# --------------------------------------------------------------
proc CreateCurrentRunTableEntry {args} {
  parse_args CreateCurrentRunTableEntry $args {
    regression_id ""
    feature_directory ""
    host ""
  }

  global mysql_handler
  #if {[conn_to_autoweb_db $host] !=0 } {
    #return -1
  #} else {
    #mysqluse $mysql_handler autoweb_db_2
  #}

  set rslt [catch {

  set d1 [exec date +%Y-%m-%d]
  set d2 [exec date +%k:%M:%S]
  set d [append d $d1]
  set d [append d " "]
  set d [append d $d2]
  #puts $d

  set feature_id [getFeatureIdByDirectory $feature_directory ]

  # find the platform
  set sel_clause "SELECT platform_id from regression_table WHERE regression_id ='$regression_id'" 
  set platform_id_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
  # only single result
  set platform_id [lindex $platform_id_lst 0]

  # delete all the old entries for that platform
  mysqlexec $mysql_handler "DELETE FROM current_run_table WHERE platform_id = \"$platform_id\""
  
  #get expected_duration
  set sel_clause2 [append sel_clause2 "SELECT report_table.test_report_duration FROM regression_table, report_table "]
  set sel_clause2 [append sel_clause2 "WHERE regression_table.platform_id = '$platform_id' "]
  set sel_clause2 [append sel_clause2 "AND regression_table.regression_id = report_table.regression_id "]
  set sel_clause2 [append sel_clause2 "AND report_table.feature_id = '$feature_id' "]
  set sel_clause2 [append sel_clause2 "AND report_table.run_number = '1' "]
  set sel_clause2 [append sel_clause2 "ORDER BY report_table.report_id DESC LIMIT 5 "]
  puts "sel_clause2 $sel_clause2\r"
  set test_report_duration_lst [mysqlsel $mysql_handler $sel_clause2 -flatlist]
  puts "test_report_duration_lst $test_report_duration_lst\r"
  # find the shortest test_report_duration
  set expected_duration 0
  set i 0
  foreach test_report_duration $test_report_duration_lst {
    if {$i == 0} {
      set expected_duration $test_report_duration
    }
    if {$test_report_duration < $expected_duration} {
      set expected_duration $test_report_duration
    }
    incr i
  }
  puts "expected_duration $expected_duration\r"

  set insert_clause [append insert_clause "insert into current_run_table (regression_id, "]
  set insert_clause [append insert_clause "platform_id, "]
  set insert_clause [append insert_clause "feature_id, "]
  set insert_clause [append insert_clause "expected_duration, "]
  set insert_clause [append insert_clause "feature_start_time) "]

  set insert_clause [append insert_clause "values (\"$regression_id\", "]
  set insert_clause [append insert_clause "\"$platform_id\", "]
  set insert_clause [append insert_clause "\"$feature_id\", "]
  set insert_clause [append insert_clause "\"$expected_duration\", "]
  set insert_clause [append insert_clause "\"$d\")"]
  puts "insert_clause $insert_clause\r"

  mysqlexec  $mysql_handler $insert_clause
  #mysqlclose $mysql_handler
  
  # get the new current_run_id
  set current_run_id [mysqlinsertid  $mysql_handler]
  puts "current_run_id $current_run_id\r"
  } reason]
  if {$rslt} {
    result_debug "CreateCurrentRunTableEntry failed - reason: $reason"
    puts "CreateCurrentRunTableEntry failed - reason: $reason" 
    return "error"
  } else {
    return $current_run_id
  }
  
}

proc CheckAndPauseRegression {args} {
    parse_args CheckAndPauseRegression $args {
        regression_id     ""
        feature_directory ""
        admin_email       ""
        host              ""
        db                "null"
        pauseType         "user"
        regCfg            ""
    }
    global mysql_handler MAIN
    if {$db != "null"} {
        set conn [conn_to_db $host $db]
    }
    
    # get feature_id
    set feature_id [getFeatureIdByDirectory $feature_directory ]
    #puts "feature_id $feature_id"
    
    # get reserved field
    set sel_clause "SELECT current_run_id, reserved, aa_id FROM current_run_table \
                  WHERE regression_id ='$regression_id' AND feature_id ='$feature_id'"
    #puts "sel_clause $sel_clause"
    set rslt_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
    #puts "rslt_lst $rslt_lst"
    # only single result
    set current_run_id [lindex $rslt_lst 0]
    #puts "current_run_id $current_run_id"
    set reserved [lindex $rslt_lst 1]
    #puts "reserved $reserved"
    set aa_id [lindex $rslt_lst 2]
    #puts "aa_id $aa_id"
    # get aa data
    set sel_clause2 "SELECT aa_first_name, aa_last_name, aa_email FROM aa_table \
                  WHERE aa_id ='$aa_id'"
    #puts "sel_clause2 $sel_clause2"
    set rslt_lst2 [mysqlsel $mysql_handler $sel_clause2 -flatlist]
    set aa_first_name [lindex $rslt_lst2 0]
    #puts "aa_first_name $aa_first_name"
    set aa_last_name [lindex $rslt_lst2 1]
    #puts "aa_last_name $aa_last_name"
    set aa_email [lindex $rslt_lst2 2]
    #puts "aa_email $aa_email"

    if {$pauseType == "user"} {
        set msg "Regression: $regression_id, feature: \
            $feature_directory was paused at your request.\n\
            Please resume the regression when you are done.\nAlso \
            please leave the DUTs in the secondary partition and \
            with the original regression builds."
        set sbj "$regCfg Regression paused"
        set msg3 "Regression: $regression_id was resumed at your request."
        set sbj3 "$regCfg Regression resumed"
        
        set msg2 "Regression: $regression_id, feature: \
            $feature_directory was paused by $aa_first_name $aa_last_name ($aa_email)"
        set sbj2 "$regCfg Regression paused"
        set msg4 "Regression: $regression_id was resumed by $aa_first_name $aa_last_name ($aa_email)"
        set sbj4 "$regCfg Regression resumed"        
    } else {
        set msg "Regression: $regression_id, feature: \
            $feature_directory has been PAUSED due to FATAL errors.\n\
            Please resume the regression after troubleshooting the system.\nAlso \
            please leave the DUTs in the secondary partition and \
            with the original regression builds."
        set sbj "$regCfg Regression PAUSED due to FATAL ERRORS"
        set msg3 "Regression: $regression_id has been resumed."
        set sbj3 "$regCfg Regression resumed after troubleshooting"
        
        set msg2 "Regression: $regression_id, feature: \
            $feature_directory has been PAUSED due to FATAL errors"
        set sbj2 "$regCfg Regression PAUSED by mysqlRunAllMonitor"
        set msg4 "Regression: $regression_id was resumed after troubleshooting"
        set sbj4 "$regCfg Regression resumed"
        # -----------------------------------------------------------
        #  If this proc is called by other than default 'user' value
        #   currently assume it was called from fatal error lock
        # -----------------------------------------------------------
         
        set update_clause "UPDATE  current_run_table SET reserved='paused', aa_id='33' WHERE \
                     current_run_id = '$current_run_id'"
        puts "Grant the mysql_handler is $mysql_handler"
        mysqlexec $mysql_handler $update_clause
        sendMailNotification $admin_email $sbj2 $msg2
        set reserved "locked";
    }
    set was_paused false
    while {($reserved == "yes") || ($reserved == "paused") || ($reserved == "locked")} {
        # --------------------------------------------------------
        #  Regression table is set to reserved or locked.
        #     - set the record in the db to paused
        #     - loop and continue to check reserved state until
        #          pause is removed.
        # --------------------------------------------------------
        if {$reserved == "yes"} {
            set was_paused true
            puts $msg2
            set update_clause "UPDATE  current_run_table SET reserved='paused' WHERE \
                         current_run_id = '$current_run_id'"
            mysqlexec $mysql_handler $update_clause
            sendMailNotification $aa_email $sbj $msg
            sendMailNotification $admin_email $sbj2 $msg2
        }
        # --------------------------------------------------------
        #  Wait 60 secs before checking state again.
        # --------------------------------------------------------
        sleep 60
        # --------------------------------------------------------
        #  Check the reserved state again
        # --------------------------------------------------------
        set rslt_lst [mysqlsel $mysql_handler $sel_clause -flatlist]
        set reserved [lindex $rslt_lst 1]
    }
    # ------------------------------------------------------------
    #  Send an email if the regression was paused and has been
    #     freed
    # ------------------------------------------------------------
    if {$was_paused} {
        if {$pauseType == "user"} {
            # ------------------------------------------
            # Email test bed was previously paused via the
            #     web interface pause mechanism
            # ------------------------------------------
            sendMailNotification $aa_email $sbj3 $msg3
            sendMailNotification $admin_email $sbj4 $msg4
        } else {
            # ------------------------------------------
            # Email test bed was previously locked due
            #     to fatal errors
            # ------------------------------------------
            sendMailNotification $admin_email $sbj4 $msg4
        }
    }
    set MAIN(was_paused) $was_paused
    if {$db != "null"} {
        disconnect_db mysql_handler
    }
}
##################################################################
# Go through the 4 phases and return the next modu
#
#
#
#
##################################################################
proc GetModulePhased {args} {
    parse_args GetModulePhased $args {
        build_id ""
        regression_id ""
        my_platform_id ""
        regType ""
        regSubType ""
        incrBuilds ""
        build_minor_release ""
    }

    global mysql_handler
    global FeatureInfo
    global FeatureIdInfo
    global PlatformInfo
    global RegressionInfo
    global DebugOn
    global DebugOnHi
    global ForceTimeUpdate
    global exclude
    global UniquePIDList 
    global stopWithPhase

    # ------------------------------------------------------------
    #  Set up local variables
    # ------------------------------------------------------------
    set BCMChassis "ASPEN"
    set SummitStack "OldStack NewStack"
    set SummitStackables  "OldStackables NewStackables"
    set Genesis   "Genesis"
    set Pioneer   "Voyager"

    set myFeaturesIDs [GetFeatureInfo -regression_id "$regression_id" -regType $regType \
                    -regSubType $regSubType -platform_id $my_platform_id -build_minor_release $build_minor_release]
    # ------------------------------------------------------------
    #  P L A T F O R M    T A B L E
    #  Get all platform info
    #      - PlatformInfo($pId,platform_name)
    #      - PlatformInfo($pId,number_nodes)
    # ------------------------------------------------------------
    set sel_clause "SELECT platform_id, platform_name, number_nodes FROM platform_table \
                  WHERE platform_id >'0'"
    set rslt_lst [mysqlsel $mysql_handler $sel_clause -list]

    if {[llength $rslt_lst] == 0} {
        puts "Failed to get platform information"
        return 0;
    }

    foreach pInfoList $rslt_lst {
        set pId   [lindex $pInfoList 0]
        set platform_name [lindex $pInfoList 1]
        set number_nodes  [lindex $pInfoList 2]
        set PlatformInfo($pId,platform_name) $platform_name
        set PlatformInfo($pId,number_nodes) $number_nodes
        set PlatformInfo($pId,regplatname) ""
    }
    # ------------------------------------------------------------
    # Get runReg table info
    # ------------------------------------------------------------
    if {[regexp -nocase "rout" $regSubType]} {
        set rr_subType " AND regplatform_subtype = 'ipRoute1'"
    } elseif {[regexp -nocase "stand" $regSubType]} {
        set rr_subType " AND regplatform_subtype = 'standard'"
    } else {
        set rr_subType ""
    }
    set sel_clause "SELECT regplatform_name, regplatform_index, platform_id FROM runreg_table \
                  WHERE regplatform_regtype = '$regType' $rr_subType "
    set rslt_lstx [mysqlsel $mysql_handler $sel_clause -list]

    if {[llength $rslt_lstx] == 0} {
        puts "Failed to get runReg information"
    } else {
        foreach pInfo2List $rslt_lstx {
            set pId   [lindex $pInfo2List 2]
            set regplatname [lindex $pInfo2List 0]
            set regplatindex  [lindex $pInfo2List 1]
            set PlatformInfo($pId,regplatname) $regplatname
            set PlatformInfo($pId,regplatindex) $regplatindex
        }
    }

    if {[info exists PlatformInfo($my_platform_id,platform_name)]} {
        set my_platform_name $PlatformInfo($my_platform_id,platform_name)
        set my_platform_numnodes $PlatformInfo($my_platform_id,number_nodes)
        set my_regplat_name $PlatformInfo($my_platform_id,regplatname)
        puts "\n----\nMy plat ID: $my_platform_id\nMy Platform Name: $my_platform_name\nMy Platform NumNodes: my_platform_numnodes\n----"        
    } else {
        puts "Failed to get platform information"
        return 0;
    }
    puts "Grant my_platform_name : $my_platform_name"
    if [regexp -nocase "$my_platform_name" $BCMChassis] {
        set my_chipset_platforms $BCMChassis
        if {$DebugOn} {puts "========\nmy_chipset_platforms $BCMChassis\n=========";   flush stdout; after 50;}
    } elseif [regexp -nocase "$my_platform_name" $SummitStack] {
        set my_chipset_platforms $SummitStack
        if {$DebugOn} {puts "========\nmy_chipset_platforms $SummitStack\n=========";  flush stdout; after 50;}
    } elseif [regexp -nocase "$my_platform_name" $SummitStackables] {
        set my_chipset_platforms $SummitStackables
        if {$DebugOn} {puts "========\nmy_chipset_platforms $SummitStackables\n=========";  flush stdout; after 50;}
    } elseif [regexp -nocase "$my_platform_name" $Genesis] {
        set my_chipset_platforms $Genesis
        if {$DebugOn} {puts "========\nmy_chipset_platforms $Genesis\n=========";  flush stdout; after 50;}
    } elseif [regexp -nocase "$my_platform_name" $Pioneer] {
        set my_chipset_platforms $Pioneer
        if {$DebugOn} {puts "========\nmy_chipset_platforms $Pioneer\n=========";  flush stdout; after 50;}
   
    }  else {
        puts "Failed-- no platform to chipset match"
        return 0;
    }
    puts "S L E E P   2 secs  W H I L E   B I G    Q U E R Y   E N D S"
    sleep 2
    # ------------------------------------------------------------
    #  R E G R E S S I O N     T A B L E
    #  Get all regression ids for this build_id
    #    - PlatformInfo($pId,regression_id)  
    #    - regression_id_list (all regids for this build)
    #
    #  For incremental regression runs, we would like to take
    #   regression id's for previous builds into account.
    # ------------------------------------------------------------
    if {$incrBuilds != "NULL"} {
        # At the bottom we will creating a modified query that
        #    takes all build_ids into account when getting
        #    regression_ids that have run previously
        #
        set incrBuild_Id_List ""
        set incrBuild_Id_QString ""
        # Get the build ids for the incremental builds
        set build_list [split $incrBuilds "_"]

        foreach incrBuild $build_list {
            puts "Get incremental Build ID"
            
            if ![regexp {([0-9]+)\.([0-9]+)\.([0-9]+)[\.b]([0-9]+.*)} \
                $incrBuild  match \
                major minor patch build] {
                    error \
                    "incremental $incrBuild not in good format."
                    return "error"
            }
            puts "==================================================="
            puts "major: $major"
            puts "minor: $minor"
            puts "patch: $patch"
            puts "build: $build"
            set build_major_release "$major.$minor"
            puts "build_major_release: $build_major_release"
            set build_minor_release "$major.$minor.$patch"
            puts "build_minor_release: $build_minor_release"
            set build_number "$build"
            puts "build_number: $build_number"
            set sel_clause "SELECT build_id FROM build_table WHERE \
            build_major_release = '$build_major_release' AND \
            build_minor_release = '$build_minor_release' AND \
            build_number = '$build_number'"
            set incr_build_id [mysqlsel $mysql_handler $sel_clause -flatlist]
            puts "llength of build_id_list: [llength $build_id]"
            if {([llength $incr_build_id] != 0)} {
                puts "we found incr_build_id: $incr_build_id"
                lappend incrBuild_Id_List "build_id = '$incr_build_id'"
            } else {
                puts "we did not found incremental build_id - enter it into the build table"
            }
        }
        set incrBuild_Id_QString [join $incrBuild_Id_List " OR "]
        puts "SELECT regression_id, platform_id FROM regression_table \
              WHERE build_id ='$build_id' OR $incrBuild_Id_QString "

        set sel_clause "SELECT regression_id, platform_id FROM regression_table \
              WHERE build_id ='$build_id' OR $incrBuild_Id_QString "
    } else {
        puts "SELECT regression_id, platform_id FROM regression_table \
              WHERE build_id ='$build_id' "
        set sel_clause "SELECT regression_id, platform_id FROM regression_table \
              WHERE build_id ='$build_id' "
    }

    set rslt_lst [mysqlsel $mysql_handler $sel_clause -list]    
    set q 0;
    if {[llength $rslt_lst] == 0} {
        puts "Failed to get regression information"
        return 0;
    }
    foreach regInfoList $rslt_lst {
        set regId   [lindex $regInfoList 0]
        set pId     [lindex $regInfoList 1]
        set RegressionInfo($regId,platform_id) $pId
        set PlatformInfo($pId,regression_id) $regId
        # --------------------------------------------------------
        #  Skip regs with platform IDs in certain skip list
        # --------------------------------------------------------
        if {[lsearch -exact $UniquePIDList(golden) $my_platform_id] >= 0} {
            if {$DebugOn} {puts "!!!!!\n!!!!!\nI AM RUNNING ON A GOLDEN ONLY COMPARE TO GOLDEN $UniquePIDList(golden)\n!!!!!\n!!!!!";  flush stdout; after 50;}
            if {[lsearch -exact $UniquePIDList(golden) $pId]} {
                if {$DebugOn||$DebugOnHi} {puts "REGRESSION RESULTS SKIPPED:  NOT GOLDEN";  flush stdout; after 50;}
                continue;
            }            
        } elseif {[lsearch -exact $UniquePIDList(panther) $my_platform_id] >= 0} {
            if {$DebugOn} {puts "!!!!!\n!!!!!\nI AM RUNNING ON A PANTHER ONLY COMPARE TO PANTHER\n!!!!!\n!!!!!";  flush stdout; after 50;}
            if {[lsearch -exact $UniquePIDList(panther) $pId]} {
                if {$DebugOn||$DebugOnHi} {puts "REGRESSION RESULTS SKIPPED:  NOT Panther";  flush stdout; after 50;}
                continue;
            }            
        } else {
            if {[lsearch -exact $UniquePIDList(panther) $pId] >= 0 || \
                [lsearch -exact $UniquePIDList(golden) $pId] >= 0 } {
                if {$DebugOn||$DebugOnHi} {puts "REGRESSION RESULTS SKIPPED:  \
                        DON'T COMPARE WITH\nGOLDEN RESULTS OR PANTHER RESULTS";  flush stdout; after 50;}
                continue;
            }
        }
        # --------------------------------------------------------
        #  Skip reg ids for different type/subtype pair ie rtr/std
        # --------------------------------------------------------
        if {![info exists PlatformInfo($pId,number_nodes)]} {
           if {$DebugOn} {puts "Platform id $pId PlatformInfo(\$pId,number_nodes) is not set... CONTINUE";  flush stdout; after 50;}
           continue; 
        } elseif {$regSubType == "standard" && $PlatformInfo($pId,number_nodes) > 2 || \
            $regSubType == "standard" && $PlatformInfo($pId,number_nodes) < 2 } {
            # IF the feature is not of the correct type/subtype bail
            if {$DebugOn} {puts "Platform id $pId is not a standard CONTINUE";  flush stdout; after 50;}
            continue;
        } elseif {$regSubType == "routing" && $PlatformInfo($pId,number_nodes) < 5 } {
            if {$DebugOn} {puts "Platform id $pId is not a routing CONTINUE";  flush stdout; after 50;}
            continue;            
        }
        if {$DebugOn} {puts "#------- NEW Regression ID Entry for \
            platform $PlatformInfo($pId,platform_name)-----------\n\
            regId   [lindex $regInfoList 0] \n\
            pId     [lindex $regInfoList 1] \n\
            PlatformInfo($pId,regression_id) $regId \n\
            \n--------------------------------------------------------------";
            flush stdout; after 50;
        }
        # --------------------------------------------------------
        #  Get  C U R R E N T L Y    R U N N I N G   table info
        #    
        # --------------------------------------------------------
        set sel_clause2 "SELECT platform_id, feature_id FROM current_run_table \
                      WHERE regression_id ='$regId'"
        set rslt_lst2 [mysqlsel $mysql_handler $sel_clause2 -flatlist]    
        set running_platform_id   [lindex $rslt_lst2 0]
        set running_feature_id [lindex $rslt_lst2 1]
        if {[llength $rslt_lst2] == 0} {
            puts "REGRESSION ID: $regId is not currently running.";
        } else {
            if {[info exists FeatureIdInfo($running_feature_id,feature_directory)]} {
                set myFName $FeatureIdInfo($running_feature_id,feature_directory)
                if {$DebugOn} {puts "$myFName \
                       is CURRENTLY RUNNING ON $PlatformInfo($running_platform_id,platform_name)";
                       flush stdout; after 50;
                }
                set FeatureInfo($myFName,CR) 1
                set FeatureIdInfo($running_feature_id,CR) 1
                set PlatformInfo($running_platform_id,CR) 1

                set fId $running_feature_id
                # ----------------------------------------------------
                # General finished flag even though it is 
                # ----------------------------------------------------
                lappend Finished($myFName,finished_platform) \
                               $PlatformInfo($running_platform_id,platform_name)
                # ----------------------------------------------------
                # Set up variables for the features that have run. 
                # ----------------------------------------------------
                set FeatureInfo($FeatureIdInfo($fId,feature_directory),AlreadyRunPlatform) $PlatformInfo($pId,platform_name)
                set FeatureIdInfo($fId,AlreadyRunPlatform) $PlatformInfo($running_platform_id,platform_name)
                set FeatureInfo($FeatureIdInfo($fId,feature_directory),AlreadyRunRegPlatform) $PlatformInfo($pId,regplatname)
                set FeatureIdInfo($fId,AlreadyRunRegPlatform) $PlatformInfo($running_platform_id,regplatname)
                if {[lsearch $my_chipset_platforms $FeatureIdInfo($fId,AlreadyRunPlatform)] != -1 } {
                    # ------------------------------------------------
                    # If a finished feature/platform pair is in my chipset
                    #   list mark the feature Already Run Chip DoneWithPhase2
                    # ------------------------------------------------
                    set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase2) 1
                    set FeatureIdInfo($fId,DoneWithPhase2) 1
                    if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase2";  flush stdout; after 50;}
                }
                if {$FeatureIdInfo($fId,AlreadyRunPlatform) == "$my_platform_name"} {
                    # my_platform_name
                    # my_platform_numnodes
                    # ------------------------------------------------
                    # If a finished feature/platform pair is my platform
                    #   mark the feature Already Run Family DoneWithPhase3
                    # ------------------------------------------------
                    set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase3) 1
                    set FeatureIdInfo($fId,DoneWithPhase3) 1
                    if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase3";  flush stdout; after 50;}
                } else {
                    #if {$DebugOn||$DebugOnHi} {puts "Missed $FeatureIdInfo($fId,AlreadyRunPlatform) == $my_platform_name";  flush stdout; after 50;}
                }
                if {$FeatureIdInfo($fId,AlreadyRunRegPlatform) == "$my_regplat_name"} {
                    # ------------------------------------------------
                    # If a finished feature runreg plattype VPE_FUNC_STD pair is my runreg plattype
                    #   mark the feature Already Run Family DoneWithPhase3_5
                    # ------------------------------------------------
                    set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase3_5) 1
                    set FeatureIdInfo($fId,DoneWithPhase3_5) 1
                    if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase3_5";  flush stdout; after 50;}
                }
                if {$pId == $my_platform_id} {
                    # ------------------------------------------------
                    # If a finished platform id is my platform id
                    #   mark the feature Already Run Me ARM
                    # ------------------------------------------------
                    set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase4) 1
                    set FeatureIdInfo($fId,DoneWithPhase4) 1
                    if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase4";  flush stdout; after 50;}
                }
            } else {
                if {$DebugOn} {puts "NO FeatureInfo MATCH FOR feature id $running_feature_id feature_name";  flush stdout; after 50;}
                continue;
            }
        }


        # --------------------------------------------------------
        #  Get  R E P O R T  table info
        #    
        # --------------------------------------------------------
        set sel_clause3 "SELECT report_id, feature_id FROM report_table \
                      WHERE regression_id = '$regId'"
        set rslt_lst3 [mysqlsel $mysql_handler $sel_clause3 -list]    
        set r 0;
        if {$rslt_lst3 == ""} {
            puts "There are not report table entries for regression ID $regId"
        } else {
            if {$DebugOn} {puts "------------------  There are [llength $rslt_lst3] feature reports for RegId $regId ---------------";  flush stdout; after 50;}
            foreach reportInfo $rslt_lst3 {
                set finished_report_id   [lindex $reportInfo 0]
                set finished_feature_id  [lindex $reportInfo 1]
                set fId $finished_feature_id
                if {[info exists FeatureIdInfo($fId,feature_directory)]} {
                    set myFName $FeatureIdInfo($fId,feature_directory)
                    # ----------------------------------------------------
                    # General finished flag
                    # ----------------------------------------------------
                    lappend Finished($myFName,finished_platform) \
                            $PlatformInfo($pId,platform_name)
                    # ----------------------------------------------------
                    # Set up variables for the features that have run. 
                    # ----------------------------------------------------
                    set FeatureInfo($FeatureIdInfo($fId,feature_directory),AlreadyRunPlatform) $PlatformInfo($pId,platform_name)
                    set FeatureIdInfo($fId,AlreadyRunPlatform) $PlatformInfo($pId,platform_name)
                    set FeatureInfo($FeatureIdInfo($fId,feature_directory),AlreadyRunRegPlatform) $PlatformInfo($pId,regplatname)
                    set FeatureIdInfo($fId,AlreadyRunRegPlatform) $PlatformInfo($pId,regplatname)
                    if {[lsearch $my_chipset_platforms $FeatureIdInfo($fId,AlreadyRunPlatform)] != -1}  {
                        # ------------------------------------------------
                        # If a finished feature/platform pair is in my chipset
                        #   list mark the feature Already Run Chip DoneWithPhase2
                        # ------------------------------------------------
                        set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase2) 1
                        set FeatureIdInfo($fId,DoneWithPhase2) 1
                        if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase2";  flush stdout; after 50;}
                    }
                    if {$FeatureIdInfo($fId,AlreadyRunPlatform) == "$my_platform_name"} {
                        # my_platform_name
                        # my_platform_numnodes
                        # ------------------------------------------------
                        # If a finished feature/platform pair is my platform
                        #   mark the feature Already Run Family DoneWithPhase3
                        # ------------------------------------------------
                        set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase3) 1
                        set FeatureIdInfo($fId,DoneWithPhase3) 1
                        if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase3";  flush stdout; after 50;}
                    } else {
                        #if {$DebugOn||$DebugOnHi} {puts "Missed $FeatureIdInfo($fId,AlreadyRunPlatform) == $my_platform_name";  flush stdout; after 50;}
                    }
                    if {$FeatureIdInfo($fId,AlreadyRunRegPlatform) == "$my_regplat_name"} {
                        # ------------------------------------------------
                        # If a finished feature runreg plattype VPE_FUNC_STD pair is my runreg plattype
                        #   mark the feature Already Run Family DoneWithPhase3_5
                        # ------------------------------------------------
                        set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase3_5) 1
                        set FeatureIdInfo($fId,DoneWithPhase3_5) 1
                        if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase3_5";  flush stdout; after 50;}
                    }
                    if {$pId == $my_platform_id} {
                        # ------------------------------------------------
                        # If a finished platform id is my platform id
                        #   mark the feature Already Run Me ARM
                        # ------------------------------------------------
                        set FeatureInfo($FeatureIdInfo($fId,feature_directory),DoneWithPhase4) 1
                        set FeatureIdInfo($fId,DoneWithPhase4) 1
                        if {$DebugOn} {puts "$FeatureIdInfo($fId,feature_directory) DoneWithPhase4";  flush stdout; after 50;}
                    }
                }
                incr r
            }
        }
        incr q
    }
    if {$DebugOn||$DebugOnHi} {puts "=========!!!!!!!!!!!\n========\nFINISHED GATHERING CURRENTLY RUNNING/FINISHED\n=========!!!!!!!!!!!\n=========";  flush stdout; after 50;}
    # ------------------------------------------------------------
    #  Loop through all of my type features in order to get exact
    #    idea of which phase and what test plan to choose.
    #    
    # ------------------------------------------------------------
    set DoneWithPhase2 1
    set DoneWithPhase3 1
    set DoneWithPhase3_5 1
    set DoneWithPhase4 1
    set NotDoneWithPhase1Mods ""
    set NotDoneWithPhase2Mods ""
    set NotDoneWithPhase3Mods ""
    set NotDoneWithPhase3_5Mods ""
    set NotDoneWithPhase4Mods ""
    set finalFeatures ""
    set alldone 1
    foreach chooseFeatureID $myFeaturesIDs {
        if {[info exists FeatureIdInfo($chooseFeatureID,feature_directory)]} {
            set chooseFeature $FeatureIdInfo($chooseFeatureID,feature_directory)
        } else {
            puts "\nFeature Name is not set for featureId\n!!!!!!  $chooseFeatureID    !!!!!\n"
            set FeatureIdInfo($chooseFeatureID,feature_directory) "BAD"
            #return 0
            continue;
        }
        if {$DebugOn} {
            if {[info exist Finished($chooseFeature,finished_platform)]} {
                if {[llength $Finished($chooseFeature,finished_platform)] > 0} {
                    puts "Finished $chooseFeature on platform/s:"
                    foreach fPlat $Finished($chooseFeature,finished_platform) {
                        puts "- $fPlat"
                    }               
                }
            } else {
                puts "NOT Finished $chooseFeature"
            }
            flush stdout; after 50;
        }
        # --------------------------------------------------------
        #  Skip exclude cases
        # --------------------------------------------------------
        if {[lsearch $exclude $chooseFeature]!= -1}  {
            if {$DebugOn} {puts "E X C L U D E    $chooseFeature ";  flush stdout; after 50;}
            continue;
        }
        # --------------------------------------------------------
        #  Skip no supp test plans removed ... just run them last
        # --------------------------------------------------------
        #if {$FeatureInfo($chooseFeature,execTime) == 0} {
        #    if {$DebugOn} {puts "@!@!@!@!@!\nFeature $chooseFeature SKIPPED no previous exec time\n@!@!@!@!@!";}
        #    continue;
        #}
        set hitOnce 0
        # FeatureInfo($feature,feature_id)
        # FeatureIdInfo($fId,feature_directory)
        # FeatureInfo($feature,feature_type) 
        # FeatureIdInfo($fId,feature_type) 
        # FeatureInfo($feature,feature_sub_type) 
        # FeatureIdInfo($fId,feature_sub_type) 
        if {$regType != $FeatureInfo($chooseFeature,feature_type)  || \
                $regSubType != $FeatureInfo($chooseFeature,feature_sub_type) } {
            # IF the feature is not of the correct type/subtype bail
            if {$DebugOn} {puts "Feature $chooseFeature BAD TYPE OR SUBTYPE   CONTINUE";  flush stdout; after 50;}
            continue;
        } else {
            lappend finalFeatures $chooseFeature
            if {![info exists FeatureInfo($chooseFeature,DoneWithPhase4)]} {
                set FeatureInfo($chooseFeature,DoneWithPhase4) 0
                set DoneWithPhase4 0
                set alldone 0
                lappend NotDoneWithPhase4Mods $chooseFeature
                if {$DebugOn} {puts "Feature $chooseFeature is NOT DoneWithPhase4";  flush stdout; after 50;}
            } else {
                set hitOnce 1
            }
            if {![info exists FeatureInfo($chooseFeature,DoneWithPhase3_5)]} {
                set FeatureInfo($chooseFeature,DoneWithPhase3_5) 0
                set DoneWithPhase3_5 0
                set alldone 0
                lappend NotDoneWithPhase3_5Mods $chooseFeature
                if {$DebugOn} {puts "Feature $chooseFeature is NOT DoneWithPhase3_5";  flush stdout; after 50;}
            } else {
                set hitOnce 1
            }
            if {![info exists FeatureInfo($chooseFeature,DoneWithPhase3)]} {
                set FeatureInfo($chooseFeature,DoneWithPhase3) 0
                set DoneWithPhase3 0
                set alldone 0
                lappend NotDoneWithPhase3Mods $chooseFeature
                if {$DebugOn} {puts "Feature $chooseFeature is NOT DoneWithPhase3";  flush stdout; after 50;}
            } else {
                set hitOnce 1
            }
            if {![info exists FeatureInfo($chooseFeature,DoneWithPhase2)]} {
                set FeatureInfo($chooseFeature,DoneWithPhase2) 0
                set DoneWithPhase2 0
                set alldone 0
                lappend NotDoneWithPhase2Mods $chooseFeature
                if {$DebugOn} {puts "Feature $chooseFeature is NOT DoneWithPhase2";  flush stdout; after 50;}
            } else {
                set hitOnce 1
            }
            if {[info exists FeatureInfo($chooseFeature,AlreadyRunPlatform)]} {
                set hitOnce 1
            } else {
                set FeatureInfo($chooseFeature,AlreadyRunPlatform) 0
                set alldone 0
            }
            if {[info exists FeatureInfo($chooseFeature,CR)]} {
                set hitOnce 1
            } else {
                set FeatureInfo($chooseFeature,CR) 0
            }
            if {$hitOnce} {
                set FeatureInfo($chooseFeature,DoneWithPhase1) 1
            } else {
                lappend NotDoneWithPhase1Mods $chooseFeature
                set FeatureInfo($chooseFeature,DoneWithPhase1) 0
                set alldone 0
            }
        }

    }
    set DoneWithPhase1 1
    foreach theFeature $finalFeatures {
        if {![info exists FeatureInfo($theFeature,DoneWithPhase1)] || !$FeatureInfo($theFeature,DoneWithPhase1)} {
            set DoneWithPhase1 0
            set alldone 0
        }
    }
    if {$alldone == 1} {
        return Finished
    }
    # -------------------------------------------------------------------
    # Print out Results
    # -------------------------------------------------------------------
    if {$DoneWithPhase1} {
        if {$DebugOn||$DebugOnHi} {puts "@@@@@@\n@@@@@@\nPlatform $my_platform_name is DoneWithPhase1\n@@@@@@\n@@@@@@";  flush stdout; after 50;}
        if {$stopWithPhase == "1"} {
             return Finished
        }
    } else {
        if {$DebugOn||$DebugOnHi} {puts "!!!!!!\n!!!!!!\nPlatform $my_platform_name is NOT DoneWithPhase1\n!!!!!!\n!!!!!!";  flush stdout; after 50;}
    }
    if {$DoneWithPhase2} {
        if {$DebugOn||$DebugOnHi} {puts "@@@@@@\n@@@@@@\nPlatform $my_platform_name is DoneWithPhase2\n@@@@@@\n@@@@@@";  flush stdout; after 50;}
        if {$stopWithPhase == "2"} {
               return Finished
        }
    } else {
        if {$DebugOn||$DebugOnHi} {puts "!!!!!!\n!!!!!!\nPlatform $my_platform_name is NOT DoneWithPhase2\n$NotDoneWithPhase2Mods\n!!!!!!\n!!!!!!";  flush stdout; after 50;}
        
    }
    if {$DoneWithPhase3} {
        if {$DebugOn||$DebugOnHi} {puts "@@@@@@\n@@@@@@\nPlatform $my_platform_name is DoneWithPhase3\n@@@@@@\n@@@@@@";  flush stdout; after 50;}
        if {$stopWithPhase == "3"} {
               return Finished
        }
    } else {
        if {$DebugOn||$DebugOnHi} {puts "!!!!!!\n!!!!!!\nPlatform $my_platform_name is NOT DoneWithPhase3\n$NotDoneWithPhase3Mods\n!!!!!!\n!!!!!!";  flush stdout; after 50;}
    }
    if {$DoneWithPhase3_5} {
        if {$DebugOn||$DebugOnHi} {puts "@@@@@@\n@@@@@@\nPlatform $my_platform_name is DoneWithPhase3_5\n@@@@@@\n@@@@@@"; flush stdout; after 50;}
        if {$stopWithPhase == "3_5"} {
               return Finished
        }
    } else {
        if {$DebugOn||$DebugOnHi} {puts "!!!!!!\n!!!!!!\nPlatform $my_platform_name is NOT DoneWithPhase3_5\n\
                     $NotDoneWithPhase3_5Mods\n!!!!!!\n!!!!!!";  flush stdout; after 50;}
    }
    if {$DoneWithPhase4} {
        if {$DebugOn||$DebugOnHi} {puts "@@@@@@\n@@@@@@\nPlatform $my_platform_name is DoneWithPhase4\n@@@@@@\n@@@@@@";  flush stdout; after 50;}
    } else {
        if {$DebugOn||$DebugOnHi} {puts "!!!!!!\n!!!!!!\nPlatform $my_platform_name is NOT DoneWithPhase4\n$NotDoneWithPhase4Mods\n!!!!!!\n!!!!!!";  flush stdout; after 50;}
    }
    # --------
    # Note for tomorrow - how to handle skipped -- check Dany table.
    if {$DebugOn||$DebugOnHi} {puts "\n=========\n=========\nF I N I S H E D   D E T E R M I N I N G   P H A S E\n=========\n=========\n";  flush stdout; after 50;}
    foreach theFeature $finalFeatures {
        if {!$DoneWithPhase1 && !$FeatureInfo($theFeature,DoneWithPhase1)} {
            if {$DebugOn||$DebugOnHi} {puts "Feature $theFeature returned in Phase1";  flush stdout; after 50;}
            return $theFeature
        }
        if {$DoneWithPhase1 && !$DoneWithPhase2 && !$FeatureInfo($theFeature,DoneWithPhase2)} {
            if {$DebugOn||$DebugOnHi} {puts "Feature $theFeature returned in Phase2";  flush stdout; after 50;}
            return $theFeature
        }
        if {$DoneWithPhase1 && $DoneWithPhase2 && !$DoneWithPhase3 && \
                   !$FeatureInfo($theFeature,DoneWithPhase3)} {
            if {$DebugOn||$DebugOnHi} {puts "Feature $theFeature returned in Phase3";  flush stdout; after 50;}
            return $theFeature
        }
        if {$DoneWithPhase1 && $DoneWithPhase2 && $DoneWithPhase3 && !$DoneWithPhase3_5 && \
                   !$FeatureInfo($theFeature,DoneWithPhase3_5)} {
            if {$DebugOn||$DebugOnHi} {puts "Feature $theFeature returned in Phase3_5";  flush stdout; after 50;}
            return $theFeature
        }
        if {$DoneWithPhase1 && $DoneWithPhase2 && $DoneWithPhase3 && $DoneWithPhase3_5 && !$DoneWithPhase4 && \
                   !$FeatureInfo($theFeature,DoneWithPhase4)} {
            if {$DebugOn||$DebugOnHi} {puts "Feature $theFeature returned in Phase4";  flush stdout; after 50;}
            return $theFeature
        }
    }
    exit;
}
##################################################################
#
#
#
#
#
##################################################################
proc InsertQueueEntry {args} {
    parse_args InsertQueueEntry $args {
        id_label "NULL"
        build_id ""
        reg_server ""
        user ""
        platform ""
        type ""
        status ""
        branch ""
        tag ""
        comment ""
        robot_guid  ""
        priority "3"
    }
    
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    set d1 [exec date +%Y-%m-%d]
    set d2 [exec date +%k:%M:%S]
    set d [append d $d1]
    set d [append d " "]
    set d [append d $d2]
    
    set insert_clause [append insert_clause "insert into reg_run (id_label, "]
    set insert_clause [append insert_clause "build_id, "]
    set insert_clause [append insert_clause "reg_server, "]
    set insert_clause [append insert_clause "user, "]
    set insert_clause [append insert_clause "platform, "]
    set insert_clause [append insert_clause "type, "]
    set insert_clause [append insert_clause "status, "]
    set insert_clause [append insert_clause "date_run, "]
    set insert_clause [append insert_clause "tag, "]
    set insert_clause [append insert_clause "comment, "]
    set insert_clause [append insert_clause "robot_guid, "]
    set insert_clause [append insert_clause "priority, "]
    set insert_clause [append insert_clause "branch) "]
    
    set insert_clause [append insert_clause "values (\"$id_label\", "]
    set insert_clause [append insert_clause "\"$build_id\", "]
    set insert_clause [append insert_clause "\"$reg_server\", "]
    set insert_clause [append insert_clause "\"$user\", "]
    set insert_clause [append insert_clause "\"$platform\", "]
    set insert_clause [append insert_clause "\"$type\", "]
    set insert_clause [append insert_clause "\"$status\", "]
    set insert_clause [append insert_clause "\"$d\", "]
    set insert_clause [append insert_clause "\"$tag\", "]
    set insert_clause [append insert_clause "\"$comment\", "]
    set insert_clause [append insert_clause "\"$robot_guid\", "]
    set insert_clause [append insert_clause "\"$priority\", "]
    set insert_clause [append insert_clause "\"$branch\")"]
    
    if {[catch {mysqlexec  $DEVREG(mysql,centralhandler) $insert_clause} reason]} {
        #puts stderr $mysqlstatus(message)
        puts "!!!!!\nInsert of new regression $id_label failed\nreason: $reason\n!!!!!"
        #set insert_sync [append insert_sync "insert into sync_table (stored_query) "]
        #set insert_sync [append insert_sync "values (\"$insert_clause\")"]
        #mysqlexec  $DEVREG(mysql,localhandler) $insert_sync
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            return $mysqlstatus(code)
        }
    }
    return $mysqlstatus(code)
}
##################################################################
#
#
#
#
#
##################################################################
proc getRegIdFromQId {id_label} {
    global DEVREG
    global mysqlstatus  mysql_handler

    set reg_id_list ""
    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler
    puts "MYSQL CONNECTION STATUS: centralstatus = $centralstatus"    
    set sel_clause "SELECT reg_id FROM reg_run \
                  WHERE id_label ='$id_label'"
    #
    # EY-03-20-2013: Wrap call to mysqlsel in a catch statement.  This
    # will prevent scripts from aborting due to errors.
    set rc [catch {
        set reg_id_list [mysqlsel $DEVREG(mysql,centralhandler) $sel_clause -flatlist];
    } reason];
    if {$rc != 0} {
        result_debug "getRegIdFromQId: mysqlsel failed with return code $rc.  Error: $reason";
    }
    set the_reg_id [lindex $reg_id_list 0]
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    return $the_reg_id
}
##################################################################
#
#
#
#
#
##################################################################
proc InsertQModuleEntry {args} {
    parse_args InsertQModuleEntry $args {
        reg_id "NULL"
        name "NULL"
        list ""
        status ""
    }
    global DEVREG
    global mysqlstatus mysql_handler
    
    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler
    set insert_clause [append insert_clause "insert into test_module (reg_id, "]
    set insert_clause [append insert_clause "name, "]
    set insert_clause [append insert_clause "status, "]
    set insert_clause [append insert_clause "list) "]
    
    set insert_clause [append insert_clause "values (\"$reg_id\", "]
    set insert_clause [append insert_clause "\"$name\", "]
    set insert_clause [append insert_clause "\"$status\", "]
    set insert_clause [append insert_clause "\"$list\")"]
    
    catch {mysqlexec  $DEVREG(mysql,centralhandler) $insert_clause} reason
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    if {0 && $mysqlstatus(code) !=0} {
        puts stderr $mysqlstatus(message)
        puts "!!!!!\nInsert of new module $name failed\nreason: $reason\n!!!!!"
        set insert_sync [append insert_sync "insert into sync_table (stored_query) "]
        set insert_sync [append insert_sync "values (\"$insert_clause\")"]
        mysqlexec  $DEVREG(mysql,localhandler) $insert_sync
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            return $mysqlstatus(code)
        }
    }
    return $mysqlstatus(code)
}

##################################################################
#
#
#
#
#
##################################################################
proc updateRegTestModule {args} {
    parse_args updateRegTestModule $args {
        reg_id   "null"
        name     "null"
        pass_cnt "null"
        total_cnt "null"
        status "null"
        testbed "null"
        list "null"
        duration "null"
        pass_cnt_1 "null"
        total_cnt_1 "null"
        start_timestamp "null"
        duration_1 "null"
        sqa_revision "null"
        corefiles "null"
        corefiles_1 "null"
    }
    
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    #if {$reg_id == "null" || $reg_id == "" || $name == "null" || $name == ""} {
    #    return -1
    #}
    set argList ""
    if {$pass_cnt != "null"} {
        lappend argList "pass_cnt"
    }
    if {$total_cnt != "null"} {
        lappend argList "total_cnt"
    }
    if {$status != "null"} {
        lappend argList "status"
    }
    if {$testbed != "null"} {
        lappend argList "testbed"
    }
    if {$list != "null"} {
        lappend argList "list"
    }
    if {$duration != "null"} {
        lappend argList "duration"
    }
    if {$pass_cnt_1 != "null"} {
        lappend argList "pass_cnt_1"
    }
    if {$total_cnt_1 != "null"} {
        lappend argList "total_cnt_1"
    }
    if {$duration_1 != "null"} {
        lappend argList "duration_1"
    }
    if {$start_timestamp != "null"} {
        lappend argList "start_timestamp"
    }
    if {$sqa_revision != "null"} {
        lappend argList "sqa_revision"
    }
    if {$corefiles != "null"} {
        lappend argList "corefiles"
    }
    if {$corefiles_1 != "null"} {
        lappend argList "corefiles_1"
    }
    set argCount [llength $argList]
    set a 0
    set update_clause [append update_clause "update test_module "]
    foreach theArg $argList {
        set aLineNum [expr $a + 1];
        if {$a==0 && $aLineNum<$argCount} {
            set update_clause [append update_clause "set $theArg=\'[set $theArg]\', "]
            incr a
            continue;
        } elseif {$a==0 && $aLineNum==$argCount} {
            set update_clause [append update_clause "set $theArg=\'[set $theArg]\' "]
            incr a
            continue;
        }
        if {$aLineNum<$argCount} {
            set update_clause [append update_clause "$theArg=\'[set $theArg]\', "]
        } else {
            set update_clause [append update_clause "$theArg=\'[set $theArg]\' "]
        }
        incr a;
    }
    set update_clause [append update_clause "WHERE reg_id=\'$reg_id\' AND name=\'$name\' "]
    #puts "updateclause: $update_clause"
    if [catch {mysqlexec  $DEVREG(mysql,centralhandler) $update_clause} reason] {
        puts "OOPS $reason"
    }
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    if {0 && $mysqlstatus(code) !=0} {
        puts stderr $mysqlstatus(message)
        puts "!!!!!\nUpdate of module $name failed\nreason: $reason\n!!!!!"
        set insert_sync [append insert_sync "insert into sync_table (stored_query) "]
        set insert_sync [append insert_sync "values (\"$update_clause\")"]
        mysqlexec  $DEVREG(mysql,localhandler) $insert_sync
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            return $mysqlstatus(code)
        }
    }
    return $mysqlstatus(code)
}
##################################################################
#
#
#
#
#
##################################################################
proc updateRegIdStatus {args} {
    parse_args updateRegIdStatus $args {
        reg_id   "null"
        status "null"
        id_label "null"
    }
    
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler
    set ts [clock format [clock seconds] -format "%Y-%m-%d %I:%M:%S"]

    set update_clause [append update_clause "update reg_run "]
    set update_clause [append update_clause "set status=\"$status\" "]
    if {$id_label != "null"} {
        set update_clause [append update_clause "where id_label=\"$id_label\" "]
    } else {
        set update_clause [append update_clause "where reg_id=\"$reg_id\" "]
    }
    #puts "up regid $update_clause"
    catch {mysqlexec  $DEVREG(mysql,centralhandler) $update_clause} reason
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    if {0 && $mysqlstatus(code) !=0} {
        puts stderr $mysqlstatus(message)
        puts "!!!!!\nUpdate of reg_id status failed\nreason: $reason\n!!!!!"
        set insert_sync [append insert_sync "insert into sync_table (stored_query) "]
        set insert_sync [append insert_sync "values (\"$update_clause\")"]
        mysqlexec  $DEVREG(mysql,localhandler) $insert_sync
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            return $mysqlstatus(code)
        }
    }
    return $mysqlstatus(code)
}
##################################################################
#
#
##################################################################
proc updateRegIdEntry {args} {
    parse_args updateRegIdStatus $args {
        reg_id   "null"
        id_label "null"
        status   "null"
        start_timestamp "null"
        priority        "null"
        control         "null"
        version         "null"
    }
    
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    set argList ""
    if {$status != "null"} {
        lappend argList "status"
    }
    if {$start_timestamp != "null"} {
        lappend argList "start_timestamp"
    }
    if {$priority != "null"} {
        lappend argList "priority"
    }
    if {$version != "null"} {
        lappend argList "version"
    }
    if {$control != "null"} {
        lappend argList "control"
    }
    set argCount [llength $argList]
    set a 0
    set update_clause [append update_clause "update reg_run "]
    foreach theArg $argList {
        set aLineNum [expr $a + 1];
        if {$a==0 && $aLineNum<$argCount} {
            set update_clause [append update_clause "set $theArg=\'[set $theArg]\', "]
            incr a
            continue;
        } elseif {$a==0 && $aLineNum==$argCount} {
            set update_clause [append update_clause "set $theArg=\'[set $theArg]\' "]
            incr a
            continue;
        }
        if {$aLineNum<$argCount} {
            set update_clause [append update_clause "$theArg=\'[set $theArg]\', "]
        } else {
            set update_clause [append update_clause "$theArg=\'[set $theArg]\' "]
        }
        incr a;
    }

    if {$id_label != "null"} {
        set where_stmt "id_label=\"$id_label\" "
    } else {
        set where_stmt "reg_id=\"$reg_id\" "
    }    

    set update_clause [append update_clause "WHERE $where_stmt "]
    catch {mysqlexec  $DEVREG(mysql,centralhandler) $update_clause} reason
    return $mysqlstatus(code)
}
##################################################################
#
#
#
#
#
##################################################################
proc updateRegTestModuleWhere {args} {
    parse_args updateRegTestModule $args {
        reg_id   "null"
        name     "null"
        pass_cnt "null"
        total_cnt "null"
        status "null"
        testbed "null"
        list "null"
        duration "null"
        pass_cnt_1 "null"
        total_cnt_1 "null"
        duration_1 "null"
        start_timestamp "null"
        corefiles "null"
        corefiles_1 "null"
        where_stmt "null"
    }
    
    global DEVREG
    global mysqlstatus  mysql_handler


    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    #if {$reg_id == "null" || $reg_id == "" || $name == "null" || $name == ""} {
    #    return -1
    #}
    set argList ""
    if {$pass_cnt != "null"} {
        lappend argList "pass_cnt"
    }
    if {$total_cnt != "null"} {
        lappend argList "total_cnt"
    }
    if {$status != "null"} {
        lappend argList "status"
    }
    if {$testbed != "null"} {
        lappend argList "testbed"
    }
    if {$list != "null"} {
        lappend argList "list"
    }
    if {$duration != "null"} {
        lappend argList "duration"
    }
    if {$pass_cnt_1 != "null"} {
        lappend argList "pass_cnt_1"
    }
    if {$total_cnt_1 != "null"} {
        lappend argList "total_cnt_1"
    }
    if {$duration_1 != "null"} {
        lappend argList "duration_1"
    }
    if {$start_timestamp != "null"} {
        lappend argList "start_timestamp"
    }
    if {$corefiles != "null"} {
        lappend argList "corefiles"
    }
    if {$corefiles_1 != "null"} {
        lappend argList "corefiles_1"
    }

    set argCount [llength $argList]
    set a 0
    set update_clause [append update_clause "update test_module "]
    foreach theArg $argList {
        set aLineNum [expr $a + 1];
        if {$a==0 && $aLineNum<$argCount} {
            set update_clause [append update_clause "set $theArg=\'[set $theArg]\', "]
            incr a
            continue;
        } elseif {$a==0 && $aLineNum==$argCount} {
            set update_clause [append update_clause "set $theArg=\'[set $theArg]\' "]
            incr a
            continue;
        }
        if {$aLineNum<$argCount} {
            set update_clause [append update_clause "$theArg=\'[set $theArg]\', "]
        } else {
            set update_clause [append update_clause "$theArg=\'[set $theArg]\' "]
        }
        incr a;
    }
    set update_clause [append update_clause "WHERE $where_stmt "]
    #puts "updateclause: $update_clause"
    if {[catch {mysqlexec  $DEVREG(mysql,centralhandler) $update_clause} reason]} {
        puts "query error $update_clause"
    }
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    if {0 && $mysqlstatus(code) !=0} {
        puts stderr $mysqlstatus(message)
        puts "!!!!!\nUpdate of module $name failed\nreason: $reason\n!!!!!"
        set insert_sync [append insert_sync "insert into sync_table (stored_query) "]
        set insert_sync [append insert_sync "values (\"$update_clause\")"]
        mysqlexec  $DEVREG(mysql,localhandler) $insert_sync
        if {$mysqlstatus(code) !=0} {
            puts stderr $mysqlstatus(message)
            return $mysqlstatus(code)
        }
    }
    return $mysqlstatus(code)
}
##################################################################
#
#
#
#
#
##################################################################
proc getRegIdModulesWhere {reg_id where} {
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler
    
    set sel_clause "SELECT name FROM test_module \
                   WHERE reg_id ='$reg_id' AND $where"
    set mod_list [mysqlsel $DEVREG(mysql,centralhandler) $sel_clause -flatlist]
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    return $mod_list
}
##################################################################
#
#
#
##################################################################
proc getRunRegTestModuleStatus {reg_id  mod} {
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    set sel_clause "SELECT status, pass_cnt, total_cnt, duration FROM test_module \
                   WHERE reg_id ='$reg_id' AND name = '$mod'"
    set mod_list [mysqlsel $DEVREG(mysql,centralhandler) $sel_clause -flatlist]
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    return $mod_list
}
##################################################################
#
#
#
#
#
##################################################################
proc getValueTestModWhere {get where} {
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    set sel_clause "SELECT $get FROM test_module \
                   WHERE $where"
    set mod_list [mysqlsel $DEVREG(mysql,centralhandler) $sel_clause -flatlist]
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    return $mod_list
}
##################################################################
#
#
#
#
#
##################################################################
proc getFromRegRunWhere {get where} {
    global DEVREG
    global mysqlstatus mysql_handler

    set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    set DEVREG(mysql,centralhandler) $mysql_handler

    set sel_clause "SELECT $get FROM reg_run \
                   WHERE $where"
    set out_list [mysqlsel $DEVREG(mysql,centralhandler) $sel_clause -flatlist]
    #catch {mysqlclose $DEVREG(mysql,centralhandler)} reason
    return $out_list
}
##################################################################
## proc updateJenkinsRegIdStatus
#
#  send an http request to a jenkins url
#
#
###################################################################
proc updateJenkinsRegIdStatus {args} {
    parse_args updateJenkinsRegIdStatus $args {
        reg_id   "null"
        q_id   "null"
        status "null"
        url "null"
    }

    global DEVREG

    catch {
        set j_url [http_formatQuery queue_id $q_id reg_id $reg_id \
                    result $status]
        set out_url [append url "&$j_url"]
        puts "!!\n!!\n!!\nSending $out_url\n!!\n!!\n!!"

        set token [http_get $out_url -timeout 10000 ]
        puts stderr ""

        upvar #0 $token state

        puts "output: $state(body)"
    } httpResult

    if { $httpResult != "" } {
        puts "HTTP CRASH: $httpResult"
    }
    #return $state(body)

}
##################################################################
#
#
#
#
#
##################################################################
proc dbKillReg {queueId} {
    # -----------------------------------------------------------------------------------------
    # mysql server cfg for posting
    # -----------------------------------------------------------------------------------------
    global autoPath
    source $autoPath/Lib/mysqlLib.tcl
    global DEVREG
    global mysql_handler mysql_handler
    if {[info exists DEVREG(mysql,UseDb)] && !$DEVREG(mysql,UseDb)} {
        puts "-----\nSkip update database Use DB is set to $DEVREG(mysql,UseDb)\n-----"
        return;
    }
    # connect to local sync database -- queuries are stored on the sync database while updating
    #                                   the central db.  If central is successful that sync query
    #                                   is deleted.  Else it is saved and purged once link is back
    #                                   up.
    #puts "-----\nConnecting to SYNC database $DEVREG(mysql,localdb) at $DEVREG(mysql,localbackup)\n-----"
    #set localstatus [conn_to_db $DEVREG(mysql,localbackup) $DEVREG(mysql,localdb) regression_user extreme]
    #set DEVREG(mysql,localhandler) $mysql_handler
    #puts "-----\nDatabase $DEVREG(mysql,localdb) at $DEVREG(mysql,localbackup) - \
    #            status $localstatus handler $DEVREG(mysql,localhandler)\n-----"
    # 
    #puts "-----\nConnecting to CENTRAL database $DEVREG(mysql,centraldb) at $DEVREG(mysql,centralserver)\n-----"
    #set centralstatus [conn_to_db $DEVREG(mysql,centralserver) $DEVREG(mysql,centraldb) regression_user extreme]
    #set DEVREG(mysql,centralhandler) $mysql_handler
    #puts "-----\nDatabase $DEVREG(mysql,centraldb) at $DEVREG(mysql,centralserver) - \
    #            status $centralstatus handler $DEVREG(mysql,centralhandler)\n-----"
    
    set rId [getRegIdFromQId $queueId]
    updateRegIdStatus -reg_id $rId -status "Killed"
    set activeMods [getRegIdModulesWhere $rId "(status = 'queued ' OR status = 'running' OR status = 'reRun')"]
    set modQ ""
    if {[llength $activeMods] == 0} {
        return;
    }
    foreach aMod $activeMods {
        lappend modQ "name = \'$aMod\'"
    }
    set modQString [join $modQ " OR "]
    set modQString "(${modQString})"
    updateRegTestModuleWhere -status "killed" -where_stmt "reg_id = \'$rId\' AND $modQString"
}

#########################################################################################################
#Procedure Name: get_db_name_by_build
#Description : queries build table and gets db_name from build_id
#Input args : build_id
#output args : db_name
#Typical Usage : retval [get_db_name_by_build 12.5.0.30]
#Category: Utility
########################################################################################################
proc get_db_name_by_build {build} {
    global mysqlIP
    global my_db
    set conn [conn_to_db $mysqlIP $my_db]
    if {$conn != "0"} {
        puts "Unable to connect to $my_db"
        return -1
     }
    global mysql_handler
    set list_out [convBuild $build]
    set build_minor_release [lindex $list_out 0]
    set build_number [lindex $list_out 1]
    set build_id [string trim [mysqlsel $mysql_handler "SELECT build_id  FROM build_table WHERE build_minor_release = \"$build_minor_release\"  AND build_number = \"$build_number\"" -flatlist] "{}"]
    
    set db [string trim [mysqlsel $mysql_handler "SELECT db_name FROM build_table WHERE build_id = \"$build_id\"" -flatlist] "{}"]
    return $db
}
#################################################################################################3
#Procedure Name : convBuild
#Description : Converts the input build into build number and build minor release
#Input args : build
#output args : output which contains build number and build minor release
#Typical Usage: retval [convBuild 12.5.0.30]
#Category : Utility
######################################################################################################
proc convBuild {build} {
  set output ""
  set build_list [split $build "."]
  set build_minor_release [lindex $build_list 0].[lindex $build_list 1].[lindex $build_list 2]
  lappend output $build_minor_release
  set build_list [lreplace $build_list 0 2 ""]
  set build_number [string trim [join $build_list "."] "."]
  lappend output $build_number
  return $output
 
}

    
###########################################################################################################################
#Procedure Name : mailNewFailures
#Description : Compares the current build results per module with the base line build and mails the new failures  in HTML 
#              format.
#Input args : 
#           cfg - cfg file name
#           build - current build
#           module - feature_directory name
#           baseLine - List of base builds with which the results have to be compared
#Output args : None
#Category : Utility
####################################################################################################################################

proc mailNewFailures {args} {
  parse_args mailNewFailures $args {
     cfg ""
     build ""
     module ""
     baseLine ""
  }
  global mysqlIP
  global my_db
   #########select_db_by_build########################
   set orig_build_db [get_db_name_by_build $build]
  ####connect to Db########################
  set connection [conn_to_db $mysqlIP $orig_build_db]
  if {$connection != "0"} {
      puts "Unable to connect to $orig_build_db"
      return 
  }
  global mysql_handler
  set  platform_id [mysqlsel $mysql_handler "SELECT platform_id FROM platform_table  WHERE platform_cfg_file_name = \"$cfg\"" -flatlist]
  set  feature_id [mysqlsel $mysql_handler "SELECT feature_id FROM feature_table WHERE feature_directory = \"$module\" AND feature_type = 'functional'" -flatlist]


  set build_list [convBuild $build]
  set build_minor_release [lindex $build_list 0]
  set build_number [lindex $build_list 1]

  set build_id [mysqlsel $mysql_handler "SELECT build_id FROM build_table WHERE build_number = \"$build_number\" AND build_minor_release = \"$build_minor_release\"" -flatlist]
  set regression_id [mysqlsel $mysql_handler "SELECT regression_id FROM regression_table WHERE build_id = \"$build_id\" AND platform_id = \"$platform_id\"" -flatlist]
  set report_id [mysqlsel $mysql_handler "SELECT report_id FROM report_table WHERE regression_id = \"$regression_id\" AND feature_id = \"$feature_id\"" -flatlist]
  set run_number [llength $report_id]
  set report_id [mysqlsel $mysql_handler "SELECT report_id FROM report_table WHERE regression_id = \"$regression_id\" AND feature_id = \"$feature_id\" AND run_number = \"$run_number\"" -flatlist]

  set  result_of_orig_build [mysqlsel $mysql_handler "SELECT feature_test_script_name,log_id,status FROM log_table WHERE report_id = \"$report_id\"" -list]

  #puts "list of original build  : $result_of_orig_build"
  global mysql_handler
  set baseLineList [split $baseLine ","]
  #puts "$baseLine"
  set finalResult ""
  foreach element $baseLineList {
      set baseLinedb [get_db_name_by_build $element]
      set conn [conn_to_db $mysqlIP $baseLinedb]
      if {$conn != "0"} {
          puts "unable to connect to $baseLinedb"
          return
       }
      set baseLineBuild_list [convBuild $element]
      set baseLineBuild_number [lindex $baseLineBuild_list 1]
      set baseLineBuild_minor_release [lindex $baseLineBuild_list 0]



     set  baseLineBuild_id [mysqlsel $mysql_handler "SELECT build_id FROM build_table WHERE build_number = \"$baseLineBuild_number\" AND build_minor_release = \"$baseLineBuild_minor_release\"" -flatlist]
     #puts "id :  $baseLineBuild_id"

     set  baseLineRegression_id [mysqlsel $mysql_handler "SELECT regression_id FROM regression_table WHERE build_id = \"$baseLineBuild_id\" AND platform_id = \"$platform_id\"" -flatlist]
     #puts "reg :  $baseLineRegression_id"
     if {$baseLineRegression_id == ""} {
         continue;
     }
     set  baseLineReport_id [mysqlsel $mysql_handler "SELECT report_id FROM report_table WHERE regression_id = \"$baseLineRegression_id\" AND feature_id = \"$feature_id\"" -flatlist]
     #puts "repid : $baseLineReport_id"
     if {$baseLineReport_id  == ""} {
          continue;
     }

    set brunNumber [llength $baseLineReport_id]
    set  baseLineReport_id [mysqlsel $mysql_handler "SELECT report_id FROM report_table WHERE regression_id = \"$baseLineRegression_id\" AND feature_id = \"$feature_id\" AND run_number = \"$brunNumber\"" -flatlist]

    set result_of_baseLine_build [mysqlsel $mysql_handler "SELECT feature_test_script_name,log_id,status FROM log_table WHERE report_id = \"$baseLineReport_id\"" -list]


    #puts "list of base line build : $result_of_baseLine_build"

       set connection [conn_to_db $mysqlIP $my_db]
       global mysql_handler
       foreach ele $result_of_orig_build {

         set script_name [lindex $ele 0]
         set log_id [lindex $ele 1]
         set status [lindex $ele 2]
         set notReq "Aborted Failed CoreDump PowerCycled"
         if {[lsearch $notReq $script_name] != -1} {
              continue;
         }

              foreach bele $result_of_baseLine_build {
                 set bscript_name [lindex $bele 0]
                 set blog_id [lindex $bele 1]
                 set bstatus [lindex $bele 2]
      
                 if {[string compare $script_name $bscript_name] == 0 } {
     
                     if {($status == "failed") && ($bstatus == "passed")} {
                          set fa [string trim [mysqlsel $mysql_handler "SELECT fa_cause FROM aux_log_table WHERE log_id = \"$log_id\"" -flatlist] "{}"]
                          set notReqList "script new_script harness"
                          if {[lsearch $notReqList $fa] == -1} {
                                lappend finalResult "$script_name $log_id  $element"
                          }
                     }
                 }

             }

      }


  }
  if {[llength $finalResult] != 0} {
       puts $finalResult
       mailHtmlFormat -mailInput $finalResult -regression_id $regression_id -feature_id $feature_id -module $module -build $build -baseLine $baseLine -cfg $cfg       

  } else {
       puts " NO_NEW_FAILURES"
  }

}
##################################################################################################################
#Procedure Name : mailHtmlFormat
#Description : Formats the Input passed by proc mailNewFailures in HTML and sends mail
#Input args:
#     mailInput : input that needs to be formatted
#     regression_id : regression id
#     feature_id : feature_id
#     module : module name
#     build : current build
#     baseLine : base line build
#     cfg : cfg file name
#Output args: None
#Category : Utility
#################################################################################################################

proc mailHtmlFormat {args} {
     parse_args mailHtmlFormat $args {
     mailInput ""
     regression_id ""
     feature_id ""
     module ""
     build ""
     baseLine ""
     cfg ""
     }
     global mysqlIP
     global my_db

     set connection [conn_to_db $mysqlIP $my_db]
     global mysql_handler
     set feature_name [mysqlsel $mysql_handler "SELECT feature_name FROM feature_table WHERE feature_id = \"$feature_id\"" -flatlist]
     set aa_id [mysqlsel $mysql_handler "SELECT aa_id FROM feature_table WHERE feature_id = \"$feature_id\"" -flatlist]
     set feature_owner [mysqlsel $mysql_handler "SELECT aa_first_name,aa_last_name FROM aa_table WHERE aa_id = \"$aa_id\"" -flatlist]
     set feature_owner [split $feature_owner ","]
     set aa_mail [mysqlsel $mysql_handler "SELECT aa_email FROM aa_table WHERE aa_id = \"$aa_id\"" -flatlist]
    
     set fp [open "Tmp/tmpMsgFile_[pid].html" "w+"]
     puts $fp "MIME-Version: 1.0"
     puts $fp "Content-type: text/html; charset=iso-8859-1"
     puts $fp "subject: New failures in Module $module on platform $cfg"
     puts $fp "To : $aa_mail"
     puts $fp "Cc : sqaauto@extremenetworks.com"
     puts $fp "<html>"
     puts $fp "<body>"
     puts $fp "<br><b><font size=\"4\" color= \"#000000\"> Module:</font> <font size =\"4\"color = \"#FF0000\"> ${module}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size=\"4\" color =\"#000000\"> Feature Owner:</font><font size = \"4\" color = \"#FF0000\"> [lindex $feature_owner 0] [lindex $feature_owner 1]</font></b>&nbsp;<br/>"
     puts $fp "<br><b><font size = \"4\" color = \"#000000\"> cfg:</font><font size =\"4\" color = \"#FF0000\"> ${cfg}</font></b>&nbsp;<br/>"
     puts $fp "<br><b><font size=\"4\" color= \"#000000\"> Build:</font> <font size =\"4\"color = \"#FF0000\"> ${build}</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size=\"4\" color =\"#000000\"> Base Line Build:</font><font size = \"4\" color = \"#FF0000\"> ${baseLine}</font></b>&nbsp;<br/>"
     puts $fp "&nbsp;<br/>"
     puts $fp "<table border=\"3\" bordercolor=\"black\" cellpadding=\"10\" >"
     puts $fp "<tr>"
     puts $fp "<td> <b><font size = \"4\" color = \"#000000\">New Failures</font></b> </td>"
     puts $fp "<td><b><font size = \"4\" color = \"#000000\"> Base Line</font></b> </td>"
     puts $fp "</tr>"
     foreach ele $mailInput {
         puts $fp "<tr>" 
         puts $fp "<td> <A href=\"http://autowebrdu/phpdb4/displayDoubleLog4.php?regression_id=${regression_id}&feature_id=${feature_id}&feature_test_script_name=[lindex $ele 0]&&log_id_list=[lindex $ele 1]&first_log_id=0&second_log_id=0&feature_name=${feature_name}\"><b><font size = \"3\" color = \"#FF0000\">[lindex $ele 0]</font></b></A></td>"
         puts $fp "<td><b><font size = \"3\" color = \"#000000\">[lindex $ele 2]</font></b> </td></tr>"
     }

     puts $fp "</table>"
     puts $fp "</body>"
     puts $fp "</html>"
     close $fp
 
     exec cat Tmp/tmpMsgFile_[pid].html | /usr/sbin/sendmail -t
     exec rm -f Tmp/tmpMsgFile_[pid].html

}    
        
proc validateBaseLine {build} {
  global mysqlIP
  global my_db


  set connection [conn_to_db $mysqlIP $my_db]
  if {$connection != 0} {
     puts "unable to connect to DB"
     return -1
  }
  global mysql_handler
  set build_ele [split $build ","]
  
  set len [llength $build_ele]
  set val ""
  foreach ele $build_ele {
  set build_list [convBuild $ele]
  set build_minor_release [lindex $build_list 0]
  set build_number [lindex $build_list 1]
  set build_id [mysqlsel $mysql_handler "SELECT build_id FROM build_table WHERE build_minor_release = \"$build_minor_release\" AND build_number = \"$build_number\"" -flatlist]
   if {$build_id != ""} {
       lappend val $build_id
   }
  }
  
  if {[llength $val] != $len} {
      return -1
  } else {
      return 1

  }

}
##########################################################################
#
#
##########################################################################
proc GetNumAvailableIxiaPorts {} {

    set inputargs [http_formatQuery]
    set sdnHostURL "http://otps/sdn/getixiacardcount.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""
    upvar #0 $token state
    puts "\nTotal available: $state(body)";
    return $state(body)
}
##########################################################################
#
#
##########################################################################
proc GetAvailableIxiaPort {available cfg portid} {

    set available 1
    set inputargs [http_formatQuery available $available cfg $cfg portid $portid]
    set sdnHostURL "http://otps/sdn/getixiacard.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""
    
    upvar #0 $token state

    puts "\noutput: $state(body)"
    return $state(body)
}
   
##########################################################################
#
#
##########################################################################
proc InsertSDNLink {ixia_sw_port tor_sw_port vmantag} {

    set inputargs [http_formatQuery ixia_sw_port $ixia_sw_port tor_sw_port $tor_sw_port vmantag $vmantag]
    set sdnHostURL "http://otps/sdn/insert_link.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""

    upvar #0 $token state

    puts "output: $state(body)"
    return $state(body)
    #puts "status $state(status)"
}
##########################################################################
#
#
##########################################################################
proc GetAvailableVmans {} {

    set inputargs [http_formatQuery]
    set sdnHostURL "http://otps/sdn/get_vman_port.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""

    upvar #0 $token state

    #puts "output: $state(body)"
    return $state(body)
    #puts "status $state(status)"
}
##########################################################################
#
#
##########################################################################
proc SetIxiaPortNotAvailable {ixia_switch ixia_switch_port cfg} {
    global IxiaDynPortIdSetup
    set inputargs [http_formatQuery ixia_switch $ixia_switch ixia_switch_port $ixia_switch_port cfg $cfg]
    set sdnHostURL "http://otps/sdn/update_ixia_notavailable.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""

    upvar #0 $token state

    #puts "output: $state(body)"
    return $state(body)
    #puts "status $state(status)"
}
##########################################################################
#
#
##########################################################################
proc SetIxiaPortAvailable {ixia_switch ixia_switch_port} {

    set inputargs [http_formatQuery ixia_switch $ixia_switch ixia_switch_port $ixia_switch_port]
    set sdnHostURL "http://otps/sdn/update_ixia_available.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""

    upvar #0 $token state

    #puts "output: $state(body)"
    return $state(body)
    #puts "status $state(status)"
}
##########################################################################
#
#
##########################################################################
proc TestBedSupportsSDNL1 {cfg} {
    set inputargs [http_formatQuery cfg $cfg]
    set sdnHostURL "http://otps/sdn/check_cfg_available.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""

    upvar #0 $token state

    #puts "output: $state(body)"
    return $state(body)
    #puts "status $state(status)"
}
##########################################################################
proc VerifyNumIxiaPortsRequiredOK {portsNeeded {CHECKLOOPLIMIT 60}} {
    set loop 1
    while {1} {

        set nP [GetNumAvailableIxiaPorts]
        if {$nP >= $portsNeeded} {
            result_debug "We have $portsNeeded ... Continue"
            return $nP
        } else {
            result_debug "Not enough ports: $portsNeeded ... Only $nP"
            exSleep 10
        }
        if {$loop > $CHECKLOOPLIMIT} {
            result_debug "We Could not get enough ports in $CHECKLOOPLIMIT secs DIE"
            global IxiaDynPortIdSetup
            if {[array exists IxiaDynPortIdSetup]} {
                puts "\n@@@\n@@@\nCleaning up using IxiaDynPortIdSetup()"
                for {set u 1} {$u<=12} {incr u} {
                    if {![info exists IxiaDynPortIdSetup($u)]} {
                        continue
                    }
                    puts "---- Cleaning up using $IxiaDynPortIdSetup($u)"
                    if {[info exists IxiaDynPortIdSetup($u)]} {
                        set listIn [split $IxiaDynPortIdSetup($u) "_"]
                        set tagId  [lindex $listIn 0]
                        set ixa [lindex $listIn 1]
                        set tor [lindex $listIn 2]

                        puts "Time to delete a vman TOR switch"
                        LoginSDNL1 "TOR" 1
                        SendACmd "delete vman vman$tagId"
                        puts "Time to delete a vman IXIA switch"
                        LoginSDNL1 "IXIA" 1
                        SendACmd "delete vman vman$tagId"
                        SetIxiaPortAvailable 1 $ixa
                    }
                }
                array unset IxiaDynPortIdSetup
                puts "@@@\n@@@"
            }
            exit;
        }
        incr loop
    }
}
##########################################################################
#
#
#
# Perform all actions required to reserve an Ixia port based on portId
# passed in
#
# ReserveSDNL1PortId $portId 
#
##########################################################################
proc ReserveSDNL1PortId {portId} {
   global DUTPortMappingArray
   global ixiaPortMappingArray ixiaCh1
   global IxiaDynPortIdSetup
   global configurationFile
   global L1

   set myCfgList [split $configurationFile "."]
   set mycfg [lindex $myCfgList 0]
   set newList [split $mycfg "/"]
   set mycfg [lindex $newList 1]
   if {![TestBedSupportsSDNL1 $mycfg]} {
       return
   }
   puts "\nCFG File: $configurationFile  Short = $mycfg"
   if {![info exists IxiaDynPortIdSetup($portId)] && [array exists ixiaPortMappingArray]} {
       if {![acquire_lock $L1]} {
           set s [expr 20 + [random 10]]
           puts "\n!!!\nCould not aquire lock.. Sleeping $s seconds"
           exSleep $s
       } else {
           puts "\n#!#!\nGOT the LOCK .... Configure vman"
       }
       VerifyNumIxiaPortsRequiredOK 1 30
       set res1 [GetAvailableIxiaPort 1 $mycfg $portId]
       set retList [split $res1 ":"]
       puts "\n@@@\nGive Me Ixia portId $portId \
             (ixiaPortMappingArray($portId) OLD $ixiaPortMappingArray($portId)) \
              NEW [lindex $retList 0]"
       #"$chassis $card ${port}:$ixia_switch_port:$tor_sw_port";
       puts "Ixia List: [lindex $retList 0]"
       puts "Ixia_SW Port: [lindex $retList 1]"
       puts "TOR_SW Port: [lindex $retList 2]"
       puts "New ixiaCh1: $ixiaCh1 New list: [lindex $retList 0]"
       puts [SetIxiaPortNotAvailable 1 [lindex $retList 1] $mycfg]
       set tagId [random 4091]
       set IxiaDynPortIdSetup($portId) "${tagId}_[lindex $retList 1]_[lindex $retList 2]"
       puts "HAVE TO SKIP. Setting ixiaPortMappingArray($portId) to \"[lindex $retList 0]\""
       set ixiaPortMappingArray($portId) "[lindex $retList 0]"

       #Test this out to see how it works
       IxiaOnePortInit $portId
#     set retVal1 [port config -MacAddress [GetPortIdMac $portId]]
#     result_debug "Port Mac address config retVal is $retVal1."
#     set retVal2 [port set [lindex $retList 0]]
#     result_debug "Port Mac address set retVal is $retVal2."
#     set retVal3 [port write [lindex $retList 0]]
#     result_debug "Port Mac address write retVal is $retVal3."
       # End test

       puts "Time to create a vman TOR switch"
       LoginSDNL1 "TOR" 1
       SendACmd "create vman vman$tagId"
       SendACmd "configure vman vman$tagId tag $tagId"
       SendACmd "configure vman vman$tagId add port [lindex $retList 2] untag"
       SendACmd "configure vman vman$tagId add port 43 tag"
       puts "Time to create a vman IXIA switch"
       LoginSDNL1 "IXIA" 1
       SendACmd "create vman vman$tagId"
       SendACmd "configure vman vman$tagId tag $tagId"
       SendACmd "configure vman vman$tagId add port [lindex $retList 1] untag"
       SendACmd "configure vman vman$tagId add port 43 tag"
       # Hack to avoid race conditions
       release_lock $L1
       verify_release_lock $L1
       global whichDutNow
       global DUT${whichDutNow}_CONNECT
       Login [set DUT${whichDutNow}_CONNECT]
       #puts [SetIxiaPortNotAvailable 1 [lindex $retList 1] $mycfg]
       #set IxiaDynPortIdSetup($portId) "${tagId}_[lindex $retList 1]_[lindex $retList 2]"
       #puts "HAVE TO SKIP. Setting ixiaPortMappingArray($portId) to \"[lindex $retList 0]\""
       #set ixiaPortMappingArray($portId) "[lindex $retList 0]"
     #  puts "@@@\n@@@"
     #  set getLinkUpdateDB [RequestIxiaCard $portId]
     #  if {$getLinkUpdateDB < 0} {
     #      result_debug "\n\nDid not get an ixia port setup.  What to do now?"
     #  }
   } elseif {[array exists ixiaPortMappingArray]} {
       #puts "\n@@@\n@@@\nDon't need a portId... set already"
       #puts "Port is already set for $portId: $IxiaDynPortIdSetup($portId)"
       #puts "@@@\n@@@"
   }
}
##########################################################################
#
#
##########################################################################
proc GetSDNL1Console {type id} {

    set inputargs [http_formatQuery type $type id $id]
    set sdnHostURL "http://otps/sdn/get_console.php"
    set sdnHostURL [append sdnHostURL "?$inputargs"]
    #puts "sdnHostURL $sdnHostURL"
    set token [http_get $sdnHostURL -timeout 1000000 ]

    puts stderr ""

    upvar #0 $token state

    puts "output: $state(body)"
    return $state(body)
    #puts "status $state(status)"
}
############################################################################
# Proc to save runRegAll commands to the database so they can be relaunched
#
#
############################################################################
proc InsertCommandLineCalls {args} {
    parse_args InsertCommandLineCalls $args {
        script ""
        aVal   ""
    }

    global mysqlIP my_db mysql_handler MAIN
    if {![info exists mysqlIP] || ![info exists my_db] || ![info exists MAIN(STORECMDS)] || !$MAIN(STORECMDS)} {
        return
    }
    if [catch {mysqlconnect -host $mysqlIP -user regression_user -password extreme -db $my_db} myHandle] {
        puts "Could not connect to the db -host $mysqlIP -user regression_user -password extreme -db $my_db"
        return
    }
    puts "Connected to db -host $mysqlIP -user regression_user -password extreme -db $my_db"

    # Replace sql chars with dummies.. can't find tcl add slashes
    set aVal [string map {"\"" "DQDQ"} $aVal]
    set aVal [string map {"'" "SQSQ"} $aVal]
    set aVal [string map {"," "QCQ"} $aVal]
    # fix on output with later tool
    #set inq [string map {"DQDQ" "\""} $inq]
    #set inq [string map {"SQSQ" "'"} $inq]
    #set inq [string map {"QCQ"  ","} $inq]

    set insert_clause [append insert_clause "insert into reg_executions "]
    set insert_clause [append insert_clause "(command) "]

    set insert_clause [append insert_clause "values (\"$script $aVal\")"]

    puts $insert_clause
    if [catch {mysqlexec  $myHandle $insert_clause} oops] {
        puts "Storage of the kickoff command failed: $oops"
    }
    catch {mysqlclose $myHandle} result
}
