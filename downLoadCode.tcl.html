<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>downLoadCode.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#downLoadCode.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>downLoadCode.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="downLoadCode.tcl-annot.html">annotations</a> | <a href="downLoadCode.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckForDownload</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  </span>
<span class="comment-line">#  CheckForDownload sets all switches and NP cards to be downloaded by default</span>
<span class="comment-line">#  This approach is taken because rebooting the switches twice for download situations</span>
<span class="comment-line">#  seems too painful               </span>
<span class="comment-line">#     </span>
<span class="comment-line">#  USED by downLdCode</span>
<span class="comment-line"># Input args: code  (code name without extension... as passed into main.tcl</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: SetupTestTool</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckForDownload_20">proc <a href="downLoadCode.tcl-annot.html#::::CheckForDownload">::::CheckForDownload</a></a></strong> { { image &#34;&#34; } { fd_res &#34;&#34; } } {
    global spawn_id
    <span class="comment-line">#variable to store all the DUTs interested information</span>
    global DUTs_info
    <span class="comment-line">#variable to store all the DUTs Slots interested information</span>
    global DUT
    global numDUT
    global DUT1_CONNECT
    global DUT2_CONNECT
    global DUT3_CONNECT
    global DUT4_CONNECT
    global DUT5_CONNECT

<span class="comment-line">###########################################################################</span>
<span class="comment-line">#  Setup for platform</span>
<span class="comment-line">###########################################################################</span>
        set numDUT 1
        while { [info exists DUT${numDUT}_CONNECT] } {
             puts &#34;***** numDUT=$numDUT ***** &#34;
             incr numDUT 1
        }
        incr numDUT -1
        <span class="comment-line">###################################################################</span>
        <span class="comment-line"># Gather information about the switches because getDUTsinfo hasn't run</span>
        <span class="comment-line">###################################################################</span>
        for {set i 1} {$i &lt;= $numDUT} {incr i 1} {

            puts &#34;Number of slots DUT$i = $DUTs_info(DUT$i,numSlots)&#34;
            set numSlots $DUTs_info(DUT$i,numSlots)
            <span class="comment-line">################################################################</span>
            <span class="comment-line">## Welcome to the migration download check portion of the code</span>
            <span class="comment-line">##</span>
            <span class="comment-line">##   This assumes that getDUTInfo has been run in LoadImage.tcl</span>
            <span class="comment-line">################################################################</span>
            
            <span class="comment-line"># inialize the mList to NULL</span>
            set DUTs_info(DUT$i,mList) &#34;NULL&#34;
            <span class="comment-line"># seperate the download build name and number strip the v</span>
            set iiList   [split $image &#34;\.&#34;]
            set image    [lindex $iiList 0]           ; <span class="comment-line">#drop any file extensions</span>
            set image    [split $image -]             ; <span class="comment-line">#seperate any branch info</span>
            set image    [lindex $image 0]            ; <span class="comment-line">#seperate any branch info</span>
            set image    [string trimleft $image v]   ; <span class="comment-line">#remove any v from the left</span>
            set iList    [split $image b]             ; <span class="comment-line">#split on the b to get build and build number</span>
            set iBuild   [lindex $iList 0]             ; <span class="comment-line">#set build</span>
            set iBNumber [lindex $iList 1]            ; <span class="comment-line">#set build number</span>
            <a name="::DBug(1)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;Going to Image $iBuild Build $iBNumber&#34;


            <span class="comment-line">##################################################################</span>
            <span class="comment-line"># Need to add logic to make sure Image selected = image running</span>
            <span class="comment-line">##################################################################</span>
            set imageSel $DUTs_info(DUT$i,imageSel)   ; <span class="comment-line">#get image currently selected</span>
            set priImage $DUTs_info(DUT$i,priImage)   ; <span class="comment-line">#get image name in pri</span>
            set secImage $DUTs_info(DUT$i,secImage)   ; <span class="comment-line">#get image name in sec</span>
            set cImage     $DUTs_info(DUT$i,version)  ; <span class="comment-line">#get the current DUT version</span>
            set sVVersion  $DUTs_info(DUT$i,sVVersion); <span class="comment-line">#get the version running on sw</span>
            
            if {$sVVersion != $cImage} {
                if {$imageSel == $priImage} {
                    set cImage $secImage
                } else {
                    set cImage $priImage
                }
            }

            <span class="comment-line"># seperate the current build name and number strip the periods and branch</span>
            set cImage     $DUTs_info(DUT$i,version)  ; <span class="comment-line">#get the current DUT version</span>
            <a name="::DBug(2)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;cImage = $cImage&#34;
            set cImageList [split $cImage { }]        ; <span class="comment-line">#split on white space</span>
            
            set cImage     [lindex $cImageList 0]     ; <span class="comment-line">#get image drop branch info</span>
            <a name="::DBug(3)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;cImage = $cImage&#34;
            set cImageList [split $cImage &#34;\.&#34;]       ; <span class="comment-line">#split on \. to remove them</span>
            
            set cImage     &#34;[lindex $cImageList 0][lindex $cImageList 1][lindex $cImageList 2]&#34; ; <span class="comment-line">#reassemble with no dots</span>
            <a name="::DBug(4)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;cImage = $cImage&#34;
            set CIList     [split $cImage b]          ; <span class="comment-line">#split on b seperate name and build number  </span>
            
            set cBuild     [lindex $CIList 0]          ; <span class="comment-line">#use the left as the build</span>
            
            set cBNumber   [lindex $CIList 1]          ; <span class="comment-line">#use the right as the build number</span>
            <a name="::DBug(5)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;From Image $cBuild Build $cBNumber on DUT $i&#34;
            
        }
    <a name="::DBug(6)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;numDUT = $numDUT&#34;

    for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
         <span class="comment-line">#Since the MSM will certainly need code. change its flag immediately</span>
         set DUTs_info(DUT$i,dlReqD) 1
    
         
         set numSlots $DUTs_info(DUT$i,numSlots)
         <a name="::DBug(7)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;Number of Slots for DUT $i = $numSlots&#34;
     }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownloadImageSlot</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Download Image to a Slot</span>
<span class="comment-line">#               </span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: TFTPServerIP filename slot {pri_or_sec &#34;&#34;}</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#        DownloadImageSlot 10.1.1.10 v700b12.oc3 slot 2 primary</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DownloadImageSlot_134">proc <a href="downLoadCode.tcl-annot.html#::::DownloadImageSlot">::::DownloadImageSlot</a></a></strong> {TFTPServerIP filename slot {pri_or_sec &#34;&#34;} } {
   <a name="::ConfigGatewayNetwork(1)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send download image $TFTPServerIP $filename slot $slot&#34;
   send	&#34;download image $TFTPServerIP $filename $pri_or_sec slot $slot\n&#34;
   expect {
      -nocase &#34;(Y/N)&#34; {
         send &#34;y\n&#34;
      }
      timeout {
         <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in download config&#34;
         return &#34;error&#34;
      }
   }
   <a name="::SaveOutputBuffer(1)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
   set timeout 300
   set flag &#34;ok&#34;
   expect {
      timeout {
         <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in download config. Can't get a prompt after download&#34;
         return &#34;error&#34;
      }
      &#34;Error: Access violation&#34; {
         set flag &#34;error&#34;
      }
      &#34;ERROR:&#34; {
         set flag &#34;error&#34;
      }
      &#34;Error:&#34; {
         set flag &#34;error&#34;
      }
      &#34;failed&#34; {
         set flag &#34;error&#34;
      }
      &#34;#&#34; {
      }
   }
   <a name="::SaveOutputBuffer(2)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
   
   
   if { $flag == &#34;ok&#34; } {
      <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Slot $slot Image download successful&#34;
   } elseif { $flag == &#34;error&#34; } {
      <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Slot $slot Image download failed&#34;
   }
   <a name="::UnconfigGatewayNetwork(1)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   return $flag
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownloadBootromSlot</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Download Image to a Slot</span>
<span class="comment-line">#               </span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: TFTPServerIP filename slot {pri_or_sec &#34;&#34;}</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#        DownloadImageSlot 10.1.1.10 v700b12.oc3 slot 2 primary</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DownloadBootromSlot_198">proc <a href="downLoadCode.tcl-annot.html#::::DownloadBootromSlot">::::DownloadBootromSlot</a></a></strong> {TFTPServerIP filename slot  } {
   <a name="::ConfigGatewayNetwork(2)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send download bootrom $TFTPServerIP $filename slot $slot&#34;
   send	&#34;download bootrom $TFTPServerIP $filename slot $slot\n&#34;
   expect {
      -nocase &#34;(Y/N)&#34; {
         send &#34;y\n&#34;
      }
      timeout {
         <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in download slot bootrom&#34;
         return &#34;error&#34;
      }
   }
   <a name="::SaveOutputBuffer(3)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
   set timeout 300
   set flag &#34;ok&#34;
   expect {
      timeout {
         <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in download slot bootrom. Can't get a prompt after download&#34;
         return &#34;error&#34;
      }
      &#34;Error: Access violation&#34; {
         set flag &#34;error&#34;
      }
      &#34;ERROR:&#34; {
         set flag &#34;error&#34;
      }
      &#34;Error:&#34; {
         set flag &#34;error&#34;
      }
      &#34;failed&#34; {
         set flag &#34;error&#34;
      }
      &#34;#&#34; {
      }
   }
   <a name="::SaveOutputBuffer(4)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
   
   
   if { $flag == &#34;ok&#34; } {
      <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Slot $slot Bootrom download successful&#34;
   } elseif { $flag == &#34;error&#34; } {
      <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Slot $slot Bootrom download failed&#34;
   }
   <a name="::UnconfigGatewayNetwork(2)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   return $flag
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownloadConfigSlot</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Download a config to a slot</span>
<span class="comment-line">#               </span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: TFTPServerIP filename slot {pri_or_sec &#34;&#34;}</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#         DownloadConfigSlot 10.1.1.10 v700b12.cfg slot 2 primary</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DownloadConfigSlot_261">proc <a href="downLoadCode.tcl-annot.html#::::DownloadConfigSlot">::::DownloadConfigSlot</a></a></strong> {TFTPServerIP filename slot {pri_or_sec &#34;&#34;} } {
   <a name="::ConfigGatewayNetwork(3)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send download image $TFTPServerIP $filename slot $slot&#34;
   send	&#34;download configuration $TFTPServerIP $filename $pri_or_sec slot $slot\n&#34;
   expect {
      -nocase &#34;(Y/N)&#34; {
         send &#34;y\n&#34;
      }
      timeout {
         <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in download config&#34;
         return &#34;error&#34;
      }
   }
   <a name="::SaveOutputBuffer(5)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
   set timeout 300
   set flag &#34;ok&#34;
   expect {
      timeout {
         <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in download config. Can't get a prompt after download&#34;
         return &#34;error&#34;
      }
      &#34;Error: Access violation&#34; {
         set flag &#34;error&#34;
      }
      &#34;ERROR:&#34; {
         set flag &#34;error&#34;
      }
      &#34;Error:&#34; {
         set flag &#34;error&#34;
      }
      &#34;failed&#34; {
         set flag &#34;error&#34;
      }
      &#34;#&#34; {
      }
   }
   <a name="::SaveOutputBuffer(6)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
   
   
   if { $flag == &#34;ok&#34; } {
      <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Slot $slot Config download successful&#34;
   } elseif { $flag == &#34;error&#34; } {
      <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Slot $slot Config download failed&#34;
   }
   <a name="::UnconfigGatewayNetwork(3)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   return $flag
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownLdCode</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  </span>
<span class="comment-line">#  Download Appropriate image to All slots  (MSM and NP)</span>
<span class="comment-line">#</span>
<span class="comment-line">#  :Download a version of code to all switches in test               </span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: code (code root without the .ext</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<span class="comment-line"># EY-03-06-2007: Added Panther TFTP file to arguments list.</span>
<strong><a name="::::DownLdCode_329">proc <a href="downLoadCode.tcl-annot.html#::::DownLdCode">::::DownLdCode</a></a></strong> { {i386tftpFile &#34;NULL&#34;} {marinerTftpFile &#34;NULL&#34;} {aspenTftpFile &#34;NULL&#34;} {aspennapaTftpFile &#34;NULL&#34;} {cougarTftpFile &#34;NULL&#34;} {viperTftpFile &#34;NULL&#34;} {olympicTftpFile &#34;NULL&#34;} {jaguarTftpFile &#34;NULL&#34;} {pantherTftpFile &#34;NULL&#34;} {voyagerTftpFile &#34;NULL&#34;} {tigerTftpFile &#34;NULL&#34;} {sylvesterTftpFile &#34;NULL&#34;} { bootrom &#34;NULL&#34; } { unc &#34;no&#34; } { fd_res &#34;&#34; } } {

    global spawn_id
    global numDUT
    global tftpServerList
    global DUTs_info
    global DUT
    global defaultRouter
    global switchPort2DefaultRouter
    global DUT1_CONNECT
    global DUT2_CONNECT
    global DUT3_CONNECT
    global DUT4_CONNECT
    global DUT5_CONNECT
    global DUT1_SETUP
    global DUT2_SETUP
    global DUT3_SETUP
    global DUT4_SETUP
    global DUT5_SETUP
    

    set stop 0
    set flagRom Ok
    set flag Ok
    set dlStatus &#34;NULL&#34;
    set dlStatusRom &#34;NULL&#34;
    set dlStatusNP &#34;NULL&#34;


    <span class="comment-line"># use Tclx for fork</span>
    package require Tclx

    for {set i 1} {$i &lt;= $numDUT} {incr i} {
	set DUT_dlStatus($i) 0 ;<span class="comment-line"># 0 as the exit code means all is good</span>
    }

    <span class="comment-line">############################################################################</span>
    <span class="comment-line"># Check download flags to see if image should be downloaded, then download</span>
    <span class="comment-line">#############################################################################</span>
    for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
	
	<span class="comment-line">#These files (one for each dut) will be written to by the fork child processes below</span>
	<span class="comment-line">#and will contain the DUT_dlStatus($i) value -- either 1 or 0 -- for that dut</span>
	set filename($i) &#34;Tmp/deleteme_$i[pid].txt&#34;
	set fileid($i) [open $filename($i) w]
	
	set numTftp [llength $tftpServerList]
	set tCount 0
	<span class="comment-line"># Login to the DUT</span>
	set DUTName [format %s%d DUT $i]
	global ${DUTName}_CONNECT;
	<a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT]
	<span class="comment-line">##################################################################</span>
	<span class="comment-line"># Download the BOOTROM</span>
	<span class="comment-line">##################################################################</span>
	if { $bootrom != &#34;NULL&#34; } {
	    set dlStatusRom [<a name="::DownloadBootrom(1)"><a href="./downLoadCode.tcl.html#::DownloadBootrom_1009">::DownloadBootrom</a></a> $i [lindex $tftpServerList $tCount] bootrom/${bootrom}.bin]
	    while { ($dlStatusRom == &#34;error&#34;) &amp;&amp; ($flagRom == &#34;Ok&#34;) } {
		incr tCount
		if {$tCount == $numTftp} {
		    <span class="comment-line"># if run out of TFTP Servers in the list</span>
		    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------Error Downloading BOOTROM Code file-----#######&#34;
		    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------Error Downloading BOOTROM Code file-----#######&#34;
		    <a name="::DBug(8)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;Error Downloading BOOTROM Code file&#34;
		    set flagRom Error
		}
		set dlStatusRom [<a name="::DownloadBootrom(2)"><a href="./downLoadCode.tcl.html#::DownloadBootrom_1009">::DownloadBootrom</a></a> $i [lindex $tftpServerList $tCount] bootrom/${bootrom}.bin ]
	    }
	}
	
	<span class="comment-line">##################################################################</span>
	<span class="comment-line"># Download the Image</span>
	<span class="comment-line">##################################################################</span>
	global supportedPlatform
	global gnssChassis
	
	<span class="comment-line"># Will be used for parallel download, in case image is not given for a particular DUT</span>
	set image($i) &#34;NULL&#34;
	
	if {([regexp -nocase $gnssChassis $DUTs_info(DUT$i,platform)] || \
        [regexp -nocase $gnssChassis $DUTs_info(DUT$i,sysType)])} {
	    if {([string compare $marinerTftpFile &#34;NULL&#34;]==0) &amp;&amp; ([string compare $olympicTftpFile &#34;NULL&#34;]==0)} {
    		<a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No DUT $i image supplied which is a gnssChassis&#34;
    		<a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image part primary&#34;
    		continue
	    } elseif {[string compare $marinerTftpFile &#34;NULL&#34;]!=0 &amp;&amp; \
               ([regexp -nocase &#34;mariner|10808&#34; $DUTs_info(DUT$i,platform)] \
               || [regexp -nocase &#34;mariner|10808&#34; $DUTs_info(DUT$i,sysType)])} {
    		set image($i) $marinerTftpFile
	    } elseif {[string compare $olympicTftpFile &#34;NULL&#34;]!=0 &amp;&amp; \
              ([regexp -nocase &#34;890|12804|12802&#34; $DUTs_info(DUT$i,platform)] \
               || [regexp -nocase &#34;890|12804|12802&#34; $DUTs_info(DUT$i,sysType)]) } {
    		set image($i) $olympicTftpFile
	    }
	    if {[<a name="::CheckImagePartition(1)"><a href="./downLoadCode.tcl.html#::CheckImagePartition_1311">::CheckImagePartition</a></a>]==1} {
    		return 1
	    }
	}
	global i386Platform
	if {[regexp -nocase $i386Platform $DUTs_info(DUT$i,platform)]} {
	    if {[string compare $i386tftpFile &#34;NULL&#34;]==0} {
		<a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No i386 image supplied for DUT $i which is an i386&#34;
		<span class="comment-line"># SK27Aug04: Not returning error here as developers' regression</span>
		<span class="comment-line"># need to carry on even if NULL image provided for i386.</span>
		<span class="comment-line"># This is only for queuing system, should not affect automated regressions</span>
		<a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image part primary&#34;
		continue
	    } else {
		set image($i) $i386tftpFile
	    }
	    if {[<a name="::CheckImagePartition(2)"><a href="./downLoadCode.tcl.html#::CheckImagePartition_1311">::CheckImagePartition</a></a>]==1} {
		return 1
	    }
	}
	global bcmChassis stacking
	if {([regexp -nocase $bcmChassis $DUTs_info(DUT$i,platform)]  || 
             [regexp -nocase $bcmChassis $DUTs_info(DUT$i,sysType)]) \
             &amp;&amp; ![regexp -nocase $stacking $DUTs_info(DUT$i,platform)]} {
	    if {([string compare $aspenTftpFile &#34;NULL&#34;]==0) &amp;&amp; ([string compare $aspennapaTftpFile &#34;NULL&#34;]==0)} {
		<a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No aspen image supplied for DUT $i which is an aspen&#34;
		<span class="comment-line"># CS27Jan05: Not returning error here as from now it will</span>
		<span class="comment-line"># need to carry on even if NULL image provided for aspen.</span>
		<span class="comment-line"># This is only for queuing system, should not affect automated regressions</span>
		<a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image part primary&#34;
		continue
	    } else {
		if { ([string compare $aspenTftpFile &#34;NULL&#34;]==0) } {
		    set image($i) $aspennapaTftpFile
		} else {
		    set image($i) $aspenTftpFile
		}
	    }
	    if {[<a name="::CheckImagePartition(3)"><a href="./downLoadCode.tcl.html#::CheckImagePartition_1311">::CheckImagePartition</a></a>]==1} {
		return 1
	    }
	}
        <span class="comment-line"># EY-06-19-2007: Added support for Lynx platform.</span>
	global bcmStackable bcmLynx bcmx650 bcmx480 bcmNWI bcmx460 bcmx670 bcmxE4G bcmx440 bcmViper bcmx430 bcmx770;
	if {([regexp -nocase $bcmStackable|$stacking $DUTs_info(DUT$i,platform)] || \
                   [regexp -nocase $bcmStackable|$stacking $DUTs_info(DUT$i,sysType)])} {
	    if {[string compare $cougarTftpFile &#34;NULL&#34;] == 0 &amp;&amp; \
		[string compare $viperTftpFile &#34;NULL&#34;] == 0 &amp;&amp; \
                [string compare $jaguarTftpFile &#34;NULL&#34;] == 0 &amp;&amp; \
                [string compare $tigerTftpFile &#34;NULL&#34;] == 0 &amp;&amp; \
                [string compare $sylvesterTftpFile &#34;NULL&#34;] == 0 &amp;&amp; \
                [string compare $pantherTftpFile &#34;NULL&#34;] == 0} {
		<a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No stackable image supplied for DUT $i which is a stackable &#34;
		<a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image part primary&#34;
		continue
	    } elseif {([string compare $jaguarTftpFile &#34;NULL&#34;]!=0 \
                       || [string compare $cougarTftpFile &#34;NULL&#34;]!=0 \
		       || [string compare $viperTftpFile &#34;NULL&#34;]!=0 \
                       || [string compare $tigerTftpFile &#34;NULL&#34;]!=0 \
                       || [string compare $sylvesterTftpFile &#34;NULL&#34;]!=0 \
                       || [string compare $pantherTftpFile &#34;NULL&#34;]) \
                       &amp;&amp; ([regexp -nocase &#34;(SummitX450|summitx250|SummitX450a|SummitX450e|x450a|x450e|x250|$stacking|$bcmLynx|$bcmx650|$bcmx460|$bcmx480|$bcmNWI|NWI|$bcmx670|$bcmxE4G|$bcmx440|$bcmx770|$bcmViper|$bcmx430)&#34; $DUTs_info(DUT$i,platform)] \
                       ||  [regexp -nocase &#34;(SummitX450|summitx250|SummitX450a|SummitX450e|x450a|x450e|x250|$stacking|$bcmLynx|$bcmx650|$bcmx460|$bcmx480|$bcmNWI|NWI|$bcmx670|$bcmxE4G|$bcmx440|$bcmx770|$bcmViper|$bcmx430)&#34; $DUTs_info(DUT$i,sysType)])} {
                       &amp;&amp; ([regexp -nocase &#34;(SummitX450|summitx250|SummitX450a|SummitX450e|x450a|x450e|x250|$stacking|$bcmLynx|$bcmx650|$bcmx460|$bcmx480|$bcmNWI|NWI|$bcmx670|$bcmxE4G|$bcmx440)|$bcmViper|$bcmx430&#34; $DUTs_info(DUT$i,platform)] \
                       ||  [regexp -nocase &#34;(SummitX450|summitx250|SummitX450a|SummitX450e|x450a|x450e|x250|$stacking|$bcmLynx|$bcmx650|$bcmx460|$bcmx480|$bcmNWI|NWI|$bcmx670|$bcmxE4G|$bcmx440)|$bcmViper|$bcmx430&#34; $DUTs_info(DUT$i,sysType)])} {
            if {[string compare $jaguarTftpFile &#34;NULL&#34;]!=0} {
                set image($i) $jaguarTftpFile
            }
            if {[string compare $cougarTftpFile &#34;NULL&#34;]!=0} {
                set image($i) $cougarTftpFile
            }
            if {[string compare $viperTftpFile &#34;NULL&#34;]!=0} {
                set image($i) $viperTftpFile
            }
            if {[string compare $pantherTftpFile &#34;NULL&#34;]!=0} {
                set image($i) $pantherTftpFile
            }
            if {[string compare $tigerTftpFile &#34;NULL&#34;]!=0} {
                set image($i) $tigerTftpFile
            }
            if {[string compare $sylvesterTftpFile &#34;NULL&#34;]!=0} {
                set image($i) $sylvesterTftpFile
            }
            }
	    if {[<a name="::CheckImagePartition(4)"><a href="./downLoadCode.tcl.html#::CheckImagePartition_1311">::CheckImagePartition</a></a>]==1} {
		return 1
	    }
	}
	global pioneerChassis;
	if {([regexp -nocase $pioneerChassis $DUTs_info(DUT$i,platform)] || \
             [regexp -nocase $pioneerChassis $DUTs_info(DUT$i,sysType)])} {
	    if {[string compare $voyagerTftpFile &#34;NULL&#34;] == 0 } {
		<a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No voyager image supplied for DUT $i&#34;
		<a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image part primary&#34;
		continue
	    } elseif {([string compare $voyagerTftpFile &#34;NULL&#34;]!=0) \
                       &amp;&amp; ([regexp -nocase &#34;$pioneerChassis&#34; $DUTs_info(DUT$i,platform)] \
                       || [regexp -nocase $pioneerChassis $DUTs_info(DUT$i,sysType)])} {
                if {[string compare $voyagerTftpFile &#34;NULL&#34;]!=0} {
		   set image($i) $voyagerTftpFile
                }
            }
	    if {[<a name="::CheckImagePartition(5)"><a href="./downLoadCode.tcl.html#::CheckImagePartition_1311">::CheckImagePartition</a></a>]==1} {
		return 1
	    }
	}
    }

    for {set i 1} {$i &lt;= $numDUT} {incr i 1} {

	set tCount 0
	<span class="comment-line"># Login to the DUT</span>
	set DUTName [format %s%d DUT $i]
	global ${DUTName}_CONNECT;
	<a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT]

	<span class="comment-line">#############################################</span>
	<span class="comment-line"># Putting the fork here because CheckImagePartition above does an unconfig switch all;</span>
	<span class="comment-line"># We dont want that to be part of fork</span>
	<span class="comment-line">#############################################</span>

	lappend childPids [fork]
	after 1000 ;<span class="comment-line"># required to avoid children getting the same tmp file sometimes being too fast</span>
	if {[lindex $childPids [expr $i-1]]} {
	    if {$i==$numDUT} {
		set co 1
		foreach childPid $childPids {
		    <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Parent now waiting for child # $co with pid $childPid&#34;
		    wait $childPid    ;<span class="comment-line"># parent waits here for child to complete</span>
		    <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Now child returned with pid $childPid&#34;
		    incr co
		}
	    }
	} else {
	    <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;child # $i enters with pid [pid]&#34;

	    if { $image($i) != &#34;NULL&#34; } {
		<a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Downloading image $image($i) from [lindex $tftpServerList $tCount]&#34;
		set tCount 0
		<span class="comment-line"># dlStatus is either &#34;error&#34; or &#34;ok&#34;</span>
		set dlStatus [<a name="::CheckDownloadImage(1)"><a href="./downLoadCode.tcl.html#::CheckDownloadImage_943">::CheckDownloadImage</a></a> $tftpServerList $image($i)]
		<span class="comment-line"># Reset the download flags to 0 if the download happened successfully</span>
		if {$dlStatus != &#34;error&#34;} {
		    set DUTs_info(DUT$i,dlReqD) 0
		} else {
		    set DUT_dlStatus($i) 1
		}
		if {[<a name="::CheckMSMsCompatibility(1)"><a href="./downLoadCode.tcl.html#::CheckMSMsCompatibility_1251">::CheckMSMsCompatibility</a></a>]==1} {
		    set DUT_dlStatus($i) 1
		}
	    }

	    puts $fileid($i) $DUT_dlStatus($i)
	    exit  ;<span class="comment-line"># Child exits here, returns back to the waiting parent</span>
	    <span class="comment-line"># end of fork construct</span>
	}
	close $fileid($i)
    }

    <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2

    for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
	if {[catch { set fileid($i) [open $filename($i) r] } result] } {
            <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not open fork download file&#34;
            return 1
        } else {
            set DUT(dlStatus) [gets $fileid($i)]
            close $fileid($i)

            catch { [file delete $filename($i)] } result
            if { ($result == 1) || ($DUT(dlStatus) == 1) } {
                return 1
            }
        }
	<span class="comment-line">#if { $result == 1 } {</span>
	<span class="comment-line">#    return 1</span>
	<span class="comment-line">#}</span>

	<span class="comment-line">#set DUT(dlStatus) [gets $fileid($i)]</span>
	<span class="comment-line">#close $fileid($i)</span>
	
	<span class="comment-line">#catch { [file delete $filename($i)] } result</span>
	<span class="comment-line">#if { ($result == 1) || ($DUT(dlStatus) == 1) } {</span>
	<span class="comment-line">#    return 1</span>
	<span class="comment-line">#}</span>
    }

    return 0
    
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetNpExtension</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Match Hardware type with file extension</span>
<span class="comment-line">#               The extension is used to pick the file to be</span>
<span class="comment-line">#               download to a slot.  XXXX.ext</span>
<span class="comment-line">#               XXXX is passed into main. &#34;ext&#34; decided based on hardwaretype</span>
<span class="comment-line"># Input args: hardwaretype</span>
<span class="comment-line"># Output args: extension</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#        GetNpExtension a3ci</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetNpExtension_630">proc <a href="downLoadCode.tcl-annot.html#::::GetNpExtension">::::GetNpExtension</a></a></strong> {hardwareType} {

          set hardwareType [string tolower $hardwareType]
          switch $hardwareType {
                  &#34;a3ci&#34;    {set flavor atm3}
                  &#34;p3ci&#34;    {set flavor oc3}
                  &#34;p12ci&#34;   {set flavor oc12}
                  &#34;arm&#34;     {set flavor arm}
                  &#34;asmgm2x&#34; {set flavor mpls}
                  &#34;mpls&#34;    {set flavor mpls}
                  &#34;sma&#34;     {set flavor sma}
          }
          return $flavor
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: TftpImagesToSwitches</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  </span>
<span class="comment-line">#  Download images and/or bootrom to switches of a test bed</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: platform array and platform image pa</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::TftpImagesToSwitches_660">proc <a href="downLoadCode.tcl-annot.html#::::TftpImagesToSwitches">::::TftpImagesToSwitches</a></a></strong> { tftpfiles { bootrom &#34;NULL&#34; } { unc &#34;no&#34; } { fd_res &#34;&#34; } {partition &#34;primary&#34;}} {

    global spawn_id
    global tftpServerList
    global DUTs_info MAIN
    global DEVREG; <span class="comment-line"># Queuing system global variables array</span>
    global whichDutNow
    global at
    global xmod; <span class="comment-line"># A list of xmods names loaded along with the main image</span>
    global xmodDUT
    global xmodPairs


    set at download
    set stop 0
    set flagRom Ok
    set flag Ok
    set dlStatus &#34;NULL&#34;
    set dlStatusRom &#34;NULL&#34;
    set dlStatusNP &#34;NULL&#34;

    array set TftpFile $tftpfiles

    <span class="comment-line"># use Tclx for fork</span>
    package require Tclx

    <span class="comment-line"># Get the partition to download to</span>
    if {[regexp -nocase &#34;pri&#34; $partition]} {
        set targetPartition &#34;secondary&#34;
    } elseif {[regexp -nocase &#34;sec&#34; $partition]} {
        set targetPartition &#34;primary&#34;
    }

    for {set i 1} {$i &lt;= $MAIN(NODECOUNT)} {incr i} {
        global DUT${i}_CONNECT
        global DUT${i}_Stacking_msma_slot
        set DUT_dlStatus($i) 0 ;<span class="comment-line"># 0 as the exit code means all is good</span>
    }

    <span class="comment-line">############################################################################</span>
    <span class="comment-line"># Check download flags to see if image should be downloaded, then download</span>
    <span class="comment-line">#############################################################################</span>
    for {set i 1} {$i &lt;= $MAIN(NODECOUNT)} {incr i 1} {
        
        <span class="comment-line">#These files (one for each dut) will be written to by the fork child processes below</span>
        <span class="comment-line">#and will contain the DUT_dlStatus($i) value -- either 1 or 0 -- for that dut</span>
        set filename($i) &#34;Tmp/deleteme_$i[pid].txt&#34;
        set fileid($i) [open $filename($i) w]
        
        set numTftp [llength $tftpServerList]
        set tCount 0
        <span class="comment-line"># Login to the DUT</span>
        <a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${i}_CONNECT]
        <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear log&#34;
        <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear log static&#34;
        <a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable log display&#34;
        <span class="comment-line">##################################################################</span>
        <span class="comment-line"># Download the BOOTROM</span>
        <span class="comment-line">##################################################################</span>
        if { $bootrom != &#34;NULL&#34; } {
            set dlStatusRom [<a name="::DownloadBootrom(3)"><a href="./downLoadCode.tcl.html#::DownloadBootrom_1009">::DownloadBootrom</a></a> $i [lindex $tftpServerList $tCount] bootrom/${bootrom}.bin]
            while { ($dlStatusRom == &#34;error&#34;) &amp;&amp; ($flagRom == &#34;Ok&#34;) } {
                incr tCount
                if {$tCount == $numTftp} {
                    <span class="comment-line"># if run out of TFTP Servers in the list</span>
                    <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------Error Downloading BOOTROM Code file-----#######&#34;
                    <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------Error Downloading BOOTROM Code file-----#######&#34;
                    <a name="::DBug(9)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;Error Downloading BOOTROM Code file&#34;
                    set flagRom Error
                }
                set dlStatusRom [<a name="::DownloadBootrom(4)"><a href="./downLoadCode.tcl.html#::DownloadBootrom_1009">::DownloadBootrom</a></a> $i [lindex $tftpServerList $tCount] bootrom/${bootrom}.bin ]
            }
        }
        
        <span class="comment-line">##################################################################</span>
        <span class="comment-line"># Set the image to be downloaded</span>
        <span class="comment-line">##################################################################</span>
        
        set image($i) &#34;NULL&#34;
        set dutImageFamily [<a name="::GetImageFamilyFromSysType(1)"><a href="./platform.tcl.html#::GetImageFamilyFromSysType_580">::GetImageFamilyFromSysType</a></a> $DUTs_info(DUT$i,sysType)]
        <span class="comment-line"># ----------------------------------------------------------------</span>
        <span class="comment-line"># 3 flavors to be downloaded as of 03/01/2018</span>
        <span class="comment-line">#   - Stack, OnieStack, Normal platform</span>
        <span class="comment-line">#</span>
        <span class="comment-line"># ----------------------------------------------------------------</span>
        if {[info exists DUT${i}_Stacking_msma_slot] &amp;&amp; [set DUT${i}_Stacking_msma_slot] &gt; 0} {
            if {[regexp -nocase &#34;480&#34; $DUTs_info(DUT$i,hwList)]} {
                set dutImageFamily summitx480
            }
        }
        <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n#####--------! ! ! ! ! ! ! ! ! ! ! ! ! -------#######\n\
                          Platform for DUT$i is $DUTs_info(DUT$i,platform) -- $DUTs_info(DUT$i,sysType)&#34;
        <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n#####------------------------------------------#######\n\
                          Assigning DUT$i image to $dutImageFamily :\n\
                          $TftpFile($dutImageFamily)&#34;
        <a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------------------------------------------#######&#34;
        set image($i) $TftpFile(everest)
        set DUTs_info(DUT$i,filetodownload) $image($i) 

        if {$xmodDUT($i)} {
            <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n#####------------------------------------------#######&#34;
            set xosFile [string trimright $image($i) &#34;.xos&#34;]
            foreach xmPart $xmodPairs {
                <span class="comment-line"># if index 0 is not equal to this dut continue</span>
                if {[lindex $xmPart 0] != $i} {continue;}
                set xm [lindex $xmPart 1]
                set xmodFile ${xosFile}-${xm}.xmod
                set DUTs_info(DUT$i,${xm}_imagename) $xmodFile
                <a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34; XMOD $DUTs_info(DUT$i,${xm}_imagename)&#34;
            }
            <a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------------------------------------------#######&#34;
        }
    }

    for {set i 1} {$i &lt;= $MAIN(NODECOUNT)} {incr i 1} {

        set tCount 0
        <span class="comment-line"># Login to the DUT</span>
        <a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT]

        <span class="comment-line">#############################################</span>
        <span class="comment-line"># Putting the fork here because CheckImagePartition above does an unconfig switch all;</span>
        <span class="comment-line"># We dont want that to be part of fork</span>
        <span class="comment-line">#############################################</span>

        lappend childPids [fork]
        after 1000 ;<span class="comment-line"># required to avoid children getting the same tmp file sometimes being too fast</span>
        if {[lindex $childPids [expr $i-1]]} {
            if {$i==$numDUT} {
                set co 1
                foreach childPid $childPids {
                    <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Parent now waiting for child # $co with pid $childPid&#34;
                    wait $childPid    ;<span class="comment-line"># parent waits here for child to complete</span>
                    <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Now child returned with pid $childPid&#34;
                    incr co
                }
            }
        } else {
            <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nchild # $i enters with pid [pid]\n--&#34;

            if { $image($i) != &#34;NULL&#34; } {
                <a name="::result_debug(27)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nDownloading image $image($i) from [lindex $tftpServerList $tCount]\n--&#34;
                set tCount 0
                <span class="comment-line"># dlStatus is either &#34;error&#34; or &#34;ok&#34;</span>
                set dlStatus [<a name="::CheckDownloadImage(2)"><a href="./downLoadCode.tcl.html#::CheckDownloadImage_943">::CheckDownloadImage</a></a> $tftpServerList $image($i)]
                <span class="comment-line"># Reset the download flags to 0 if the download happened successfully</span>
                if {$dlStatus != &#34;error&#34;} {
                    set DUTs_info(DUT$i,dlReqD) 0
                } else {
                    set DUT_dlStatus($i) 1
                }
                if {[<a name="::CheckMSMsCompatibility(2)"><a href="./downLoadCode.tcl.html#::CheckMSMsCompatibility_1251">::CheckMSMsCompatibility</a></a>]==1} {
                    set DUT_dlStatus($i) 1
                }
                <span class="comment-line"># If there are xmods to download... do it</span>
                if {$xmodDUT($i)} {
                    global whichDutNow
                    foreach xmPart $xmodPairs {
                        <span class="comment-line"># if index 0 is not equal to this dut break</span>
                        if {[lindex $xmPart 0] != $i} {continue;}
                        set xm [lindex $xmPart 1]
                        set xmodFile $DUTs_info(DUT$i,${xm}_imagename)
                        <a name="::result_debug(28)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nDownloading xmod $xmodFile from [lindex $tftpServerList $tCount]\n--&#34;
                        set dlXStatus [<a name="::CheckDownloadImage(3)"><a href="./downLoadCode.tcl.html#::CheckDownloadImage_943">::CheckDownloadImage</a></a> $tftpServerList $xmodFile $targetPartition]
                        if {$dlXStatus == &#34;error&#34;} {
                            <a name="::result_debug(29)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error downloading $DUTs_info(DUT$i,${xm}_imagename)&#34;
                        }
                    }
                }
            } else {
                <a name="::result_debug(30)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nImage $image($i) - Use primary image because set to NULL \
                      - plat $DUTs_info(DUT$i,platform)\n--&#34;;
                <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image primary&#34;;
            }
            puts &#34;WRITING TO FILEID $fileid($i) STATUS $DUT_dlStatus($i)&#34;
            puts $fileid($i) $DUT_dlStatus($i)
            puts &#34;SENDING EXIT TO DOWNLOAD CODE&#34;
            exit  ;<span class="comment-line"># Child exits here, returns back to the waiting parent</span>
            <span class="comment-line"># end of fork construct</span>
        }
        close $fileid($i)
    }

    <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
    puts &#34;MADE IT PAST FORK&#34;
    for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
        puts &#34;DOING DOWNLOAD CLEANUP&#34;
	catch { set fileid($i) [open $filename($i) r] } result
	if { $result == 1 } {
	    return 1
	}

	set DUT(dlStatus) [gets $fileid($i)]
	close $fileid($i)
	
	catch { [file delete $filename($i)] } result
	if { ($result == 1) || ($DUT(dlStatus) == 1) } {
	    return 1
	}
    }
    puts &#34;RETURNING FROM DOWNLOAD PROC&#34;
    return 0
    
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure _qloadSingleDut</span>
<span class="comment-line">#</span>
<span class="comment-line">#   - This procedure is meant to be run from within multiTask</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_qloadSingleDut_873">proc <a href="downLoadCode.tcl-annot.html#::::_qloadSingleDut">::::_qloadSingleDut</a></a></strong> {args} {
    global tftpServerList
    global DUTs_info MAIN
    global DEVREG; <span class="comment-line"># Queuing system global variables array</span>
    global whichDutNow
    global xmod; <span class="comment-line"># A list of xmods names loaded along with the main image</span>
    global xmodDUT
    global xmodPairs
    set tCount 0

    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _qloadSingleDut $args {
        dut    &#34;1&#34;
    }

    global DUT${dut}_CONNECT
    <a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0

    if {$DUTs_info(DUT${dut},filetodownload)  != &#34;NULL&#34; } {
        <a name="::result_debug(31)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nDownloading image $DUTs_info(DUT${dut},filetodownload) from [lindex $tftpServerList $tCount]\n--&#34;
        <span class="comment-line"># dlStatus is either &#34;error&#34; or &#34;ok&#34;</span>
        set dlStatus [<a name="::CheckDownloadImage(4)"><a href="./downLoadCode.tcl.html#::CheckDownloadImage_943">::CheckDownloadImage</a></a> $tftpServerList $DUTs_info(DUT${dut},filetodownload)]
        <span class="comment-line"># Reset the download flags to 0 if the download happened successfully</span>
        if {$dlStatus != &#34;error&#34;} {
            <a name="::_setMultiTaskVar(1)"><a href="./multiTask.tcl.html#::_setMultiTaskVar_167">::_setMultiTaskVar</a></a> DUTs_info(DUT$dut,dlReqD) 0
            <a name="::_setMultiTaskVar(2)"><a href="./multiTask.tcl.html#::_setMultiTaskVar_167">::_setMultiTaskVar</a></a> DUTs_info(DUT$dut,qloadStatus) 1
            set DUTs_info(DUT$dut,dlReqD) 0
        } else {
            <a name="::_setMultiTaskVar(3)"><a href="./multiTask.tcl.html#::_setMultiTaskVar_167">::_setMultiTaskVar</a></a> DUT_dlStatus($dut) 1
            <a name="::_setMultiTaskVar(4)"><a href="./multiTask.tcl.html#::_setMultiTaskVar_167">::_setMultiTaskVar</a></a> DUTs_info(DUT$dut,qloadStatus) 0
            set DUT_dlStatus($dut) 1
        }
        <span class="comment-line"># If there are xmods to download... do it</span>
        if {$xmodDUT($dut)} {
            foreach xmPart $xmodPairs {
                <span class="comment-line"># if index 0 is not equal to this dut break</span>
                if {[lindex $xmPart 0] != $dut} {continue;}
                set xm [lindex $xmPart 1]
                set xmodFile $DUTs_info(DUT$dut,${xm}_imagename)
                <a name="::result_debug(32)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nDownloading xmod $xmodFile from [lindex $tftpServerList $tCount]\n--&#34;
                set dlXStatus [<a name="::CheckDownloadImage(5)"><a href="./downLoadCode.tcl.html#::CheckDownloadImage_943">::CheckDownloadImage</a></a> $tftpServerList $xmodFile $MAIN(targetPart)]
                if {$dlXStatus == &#34;error&#34;} {
                    <a name="::result_debug(33)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error downloading $DUTs_info(DUT$dut,${xm}_imagename)&#34;
                }
            }
        } else {
            <a name="::result_debug(34)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not an xmodDUT - set to $xmodDUT($dut)&#34;
        }
        return 1
    } else {
        <a name="::result_debug(35)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n--\nImage $DUTs_info(DUT${dut},filetodownload) - Use primary image because set to NULL \
              - plat $DUTs_info(DUT$dut,platform)\n--&#34;;
        <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image $MAIN(bootPart)&#34;;
        return 1
    }
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckDownloadImage</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that checks the downloaded image success from the lift of tftp servers provided in</span>
<span class="comment-line">#              tftpServerList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: tftpServerList, filename</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         set status [CheckDownloadImage $TFTPServerIP $filename]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckDownloadImage_943">proc <a href="downLoadCode.tcl-annot.html#::::CheckDownloadImage">::::CheckDownloadImage</a></a></strong> {downloadsource filename {partition &#34;&#34;} {slotId &#34;&#34;} {install &#34;y&#34;} {confgateway &#34;1&#34;}} {

    global ImageForInstall
    if {$slotId != &#34;&#34;} {set slotId &#34;msm $slotId&#34;}

    set downloadsource [<a name="::GetRandomTFTPList(1)"><a href="./downLoadCode.tcl.html#::GetRandomTFTPList_1151">::GetRandomTFTPList</a></a> $downloadsource]

    foreach downloadfrom $downloadsource {
        <a name="::result_debug(36)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Start downloading image $filename from $downloadfrom&#34;

        global stacking
        global DUTs_info
        if {[regexp -nocase $stacking [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]] &amp;&amp; ![regexp -nocase &#34;xmod&#34; $filename]} {
            <span class="comment-line">#set partition $DUTs_info(DUT1,imageBooted)</span>
            lappend showSwitchOutput &#34;{Image Booted:} 1&#34;
            set partition [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $showSwitchOutput]
            unset showSwitchOutput
            if {$partition == &#34;primary&#34;} {
                set alt &#34;secondary&#34;
            } else {
                set alt &#34;primary&#34;
            }
            set status [<a name="::DownloadImage(1)"><a href="./downLoadCode.tcl.html#::DownloadImage_1058">::DownloadImage</a></a> $downloadfrom $filename $alt $slotId $install $confgateway]
        } else {

            set status [<a name="::DownloadImage(2)"><a href="./downLoadCode.tcl.html#::DownloadImage_1058">::DownloadImage</a></a> $downloadfrom $filename $partition $slotId $install $confgateway]
        }
        if {$status == &#34;ok&#34;} {break }
        flush stdout

    }

    <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Downloading image $filename from $downloadsource&#34;
    if {$status == &#34;error&#34;} {
        global whichDutNow
        <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to download image from $downloadsource DUT $whichDutNow&#34;
        <a name="::EnableDebugMode(1)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
        <a name="::result_debug(37)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;enabling debug ems show trace devmgr all logto file&#34;
        <a name="::SendACmd(11)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug ems show trace devmgr all logto file&#34;
        <a name="::SendACmd(12)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug ems show trace nodemgr all logto file&#34;
        <a name="::SendACmd(13)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug ems show trace epm all logto file&#34;
        <a name="::DisableDebugMode(1)"><a href="./misc.tcl.html#::DisableDebugMode_2957">::DisableDebugMode</a></a>
        <a name="::SendACmd(14)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;&#34;
        <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
        return $status
    } else {
        <a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Image successfully downloaded from $downloadsource&#34;
        <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
        return $status
    }
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownloadBootrom</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that downloads the bootrom supplied in filename from the tftp server TFTPServerIP</span>
<span class="comment-line">#              reboots after bootrom successfully downloaded</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: connect, TFTPServerIP, filename</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [DownloadImage $TFTPServerIP $filename ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DownloadBootrom_1009">proc <a href="downLoadCode.tcl-annot.html#::::DownloadBootrom">::::DownloadBootrom</a></a></strong> {{dut &#34;&#34;} TFTPServerIP filename} {

   global switchPort2DefaultRouter
   if {$dut!=&#34;&#34;} {
       set DUTName [format %s%d DUT $dut]
       global ${DUTName}_CONNECT;
       <a name="::Login(6)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT];
   }

   if { [llength $TFTPServerIP] &gt; 0 } {
       set TFTPServerIP [lindex [<a name="::GetRandomTFTPList(2)"><a href="./downLoadCode.tcl.html#::GetRandomTFTPList_1151">::GetRandomTFTPList</a></a> $TFTPServerIP] 0]
   }

   <a name="::ConfigGatewayNetwork(4)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   if {[regexp -nocase $switchPort2DefaultRouter mgmt]} {
      set uplink &#34;Mgmt&#34;
   } else {
      set uplink &#34;Default&#34;
   }

   set flag &#34;ok&#34;
   <a name="::result_debug(38)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send download bootrom $TFTPServerIP $filename&#34;
   set rtValue [<a name="::CheckCmdLegal(1)"><a href="./checkCmdLegality.tcl.html#::CheckCmdLegal_58">::CheckCmdLegal</a></a> &#34;download bootrom $TFTPServerIP $filename vr vr-$uplink&#34;]
   <a name="::UnconfigGatewayNetwork(4)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   if { $rtValue == &#34;illegal&#34; } {
       <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;bootrom download failed&#34;
       set flag &#34;error&#34;
   } else {
       <a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;bootrom download pass rebooting switch&#34;
       <a name="::CheckReboot(1)"><a href="./SendSwCmd.tcl.html#::CheckReboot_1202">::CheckReboot</a></a> $dut
    }
   <span class="comment-line">#   puts &#34;flag: $flag&#34;</span>
   return $flag
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownloadImage</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal proc that downloads the image provided in filename to the current DUT from tftp server </span>
<span class="comment-line">#              provided in TFTPServerIP.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: TFTPServerIP, filename</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [DownloadImage $TFTPServerIP $filename ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DownloadImage_1058">proc <a href="downLoadCode.tcl-annot.html#::::DownloadImage">::::DownloadImage</a></a></strong> {downloadsource filename {partition &#34;&#34;} {slotId &#34;&#34;} {install &#34;y&#34;} {confgateway &#34;1&#34;}} {

    if { !($confgateway!=1 || $downloadsource==&#34;memorycard&#34;) } {<a name="::ConfigGatewayNetwork(5)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>}

    after 5000 ;<span class="comment-line"># Required as it might be a timing issue to reach network</span>
    global whichDutNow
    global DUTs_info
    global env

    <a name="::result_debug(39)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send download image $downloadsource $filename $partition $slotId&#34;
    set rtValue &#34;legal&#34;
    set buf &#34;&#34;
    if { [<a name="::::isExosPlatform(1)"><a href="./SystemSetup.tcl.html#::::isExosPlatform_970">::::isExosPlatform</a></a> DUT$whichDutNow ] == 1 } {
        global switchPort2DefaultRouter
        global connectionTimeout
        set origConnectionTimeout $connectionTimeout
        set connectionTimeout 1000
        set pid [pid]
        set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;w&#34;]

        set downloadAttempt 1

        while { ($downloadAttempt &lt;= 3) } {
            if { $downloadsource == &#34;memorycard&#34; } {
                set buf [<a name="::SendACmd(15)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;download image memorycard $filename $partition $slotId&#34; &#34;NULL&#34; $fd_in true 3 $install]
            } elseif {[regexp -nocase &#34;mgmt&#34; $switchPort2DefaultRouter]} {
                after 800
                set buf [<a name="::SendACmd(16)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;download image $downloadsource $filename $partition $slotId&#34; &#34;NULL&#34; $fd_in true 3 $install]
            } else {
                set virtualRouter [<a name="::GetVrString(1)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow]
                set buf [<a name="::SendACmd(17)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;download image $downloadsource $filename vr $virtualRouter $partition $slotId&#34; &#34;NULL&#34; $fd_in true 3 $install]
            }
            <span class="comment-line"># &#34;tftp.*timeout&#34;</span>
            <span class="comment-line"># &#34;Network is unreachable&#34;</span>
            if { [regexp -nocase &#34;tftp.*timeout&#34; $buf] } {
                <a name="::result_debug(40)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- DUT $whichDutNow Image download failed attempt # $downloadAttempt because of TFTP timeout. Retrying...&#34;
                close $fd_in
                <a name="::_saveOutputIfMultiTasked(1)"><a href="./multiTask.tcl.html#::_saveOutputIfMultiTasked_198">::_saveOutputIfMultiTasked</a></a> &#34;Tmp/temp_$pid&#34;
                file delete &#34;Tmp/temp_$pid&#34;
                set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;w&#34;]
                incr downloadAttempt
            } else {
                break
            }
        }

        set connectionTimeout $origConnectionTimeout
        close $fd_in
        set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;r&#34;]

        global validstring
        set validstring(1) &#34;only&#34;
        set validstring(20) &#34;recommended&#34;
        set validstring(21) &#34;capable&#34;
        set validstring(2) &#34;Please&#34;
        set validstring(22) &#34;Signature&#34;
        set validstring(23) &#34;digitally&#34;
        set rtValue [<a name="::check_illegality(1)"><a href="./checkCmdLegality.tcl.html#::check_illegality_139">::check_illegality</a></a> $fd_in]

        if { $downloadAttempt &gt; 3 } {
            <a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;DUT$whichDutNow Image download failed 3 attempts because of TFTP timeout. Will not retry...&#34;
            set rtValue &#34;illegal&#34;
        }


        close $fd_in
        <span class="comment-line"># If this happens to be multitasked, save the output for print</span>
        <a name="::_saveOutputIfMultiTasked(2)"><a href="./multiTask.tcl.html#::_saveOutputIfMultiTasked_198">::_saveOutputIfMultiTasked</a></a> &#34;Tmp/temp_$pid&#34;

        file delete &#34;Tmp/temp_$pid&#34;
        <a name="::result_debug(41)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the rtValue $rtValue&#34;
        if {$rtValue==&#34;legal&#34;} {
            set buf &#34;ok&#34;
        } else {
            set buf &#34;error&#34;
        }
    }
    if { !($confgateway!=1 || $downloadsource==&#34;memorycard&#34;) } {<a name="::UnconfigGatewayNetwork(5)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>}
    return $buf
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetRandomTFTPList</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that randomizes the order of the elements in tftpServerList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: tftpServerList</span>
<span class="comment-line"># Output args: new list with different order</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#         set downloadsource [GetRandomTFTPList $downloadsource]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Utility)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetRandomTFTPList_1151">proc <a href="downLoadCode.tcl-annot.html#::::GetRandomTFTPList">::::GetRandomTFTPList</a></a></strong> { oldtftplist } {

    <span class="comment-line"># More random based on clock ticks and pid, since that is different for each forked task...</span>
    set seed [expr rand()*[clock clicks]/[pid]]
    set afterdec &#34;.[lindex [split $seed &#34;.&#34;] 1]&#34;
    set tftpserverIdx [expr int($afterdec*[llength $oldtftplist])]
    <a name="::result_debug(42)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;tftpserverIdx is $tftpserverIdx&#34;

    if {$tftpserverIdx &gt; [expr [llength $oldtftplist] - 1]} {
      set tftpserverIdx 0
    }

    set tftpserver [lindex $oldtftplist $tftpserverIdx]
    lappend newList $tftpserver

    if { [llength $oldtftplist] &gt; 1 } {
    set otherservers [<a name="::ldelete(1)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $oldtftplist $tftpserver]
    lappend newList $otherservers
    }

    return [split [join $newList]]
}

<span class="comment-line">##################################################################          </span>
<strong><a name="::::FindNumSlots_1175">proc <a href="downLoadCode.tcl-annot.html#::::FindNumSlots">::::FindNumSlots</a></a></strong> {Ip} {
    global DUT
    set numSlots 0
    
    <a name="::Login(7)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $Ip

    set fd_in [open &#34;Tmp/tmp_slots&#34; &#34;w&#34;]
    <a name="::SendACmd(18)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;sh ver&#34; NULL $fd_in
    close $fd_in

    set fd_in [open &#34;Tmp/tmp_slots&#34; &#34;r&#34;]
    while {[gets $fd_in line] != -1} {
       set cookedLine [<a name="::cookString(1)"><a href="./misc.tcl.html#::cookString_22">::cookString</a></a> $line]
       set aList [split $cookedLine]

       <span class="comment-line">###########################################################</span>
       <span class="comment-line">#  Logic to find the number of slots</span>
       <span class="comment-line">###########################################################</span>
       if { ([string tolower [lindex $aList 0]] == &#34;slot&#34;) } {
         set numSlots [lindex $aList 1]
       }
    }
   catch {file delete &#34;Tmp/tmp_slots&#34;}
       if {$numSlots==3} {set numSlots 0}  ;<span class="comment-line"># S7i wrongly shows slot1,2,3</span>
              return $numSlots
}
<span class="comment-line">##################################################################          </span>
<strong><a name="::::FindChassisType_1202">proc <a href="downLoadCode.tcl-annot.html#::::FindChassisType">::::FindChassisType</a></a></strong> {Ip} {

    set chassis 0
    

    <a name="::Login(8)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $Ip

    set fd_in [open &#34;Tmp/tmp_chassis&#34; &#34;w&#34;]
    <a name="::SendACmd(19)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;sh ver&#34; $fd_res $fd_in
    close $fd_in

    set fd_in [open &#34;Tmp/tmp_chassis&#34; &#34;r&#34;]
    while {[gets $fd_in line] != -1} {
       set cookedLine [<a name="::cookString(2)"><a href="./misc.tcl.html#::cookString_22">::cookString</a></a> $line]
       set aList [split $cookedLine]

       if { ([string tolower [lindex $aList 0]] == &#34;msm&#34;) } {
         set fabric msm
       }
       if { ([string tolower [lindex $aList 0]] == &#34;baseboard:&#34;) } {
         set fabric alpine
       }
    }
    set numSlots [<a name="::FindNumSlots(1)"><a href="./downLoadCode.tcl.html#::FindNumSlots_1175">::FindNumSlots</a></a> $Ip]
    if {($numSlots == 16) &amp;&amp; ($fabric == msm)} {
        set chassis GD
    }
    elseif {($numSlots == 8) &amp;&amp; ($fabric == msm)} {
        set chassis BD
    }
    elseif {($numSlots == 4) &amp;&amp; ($fabric == msm)} {
        set chassis BT
    }
    elseif {($numSlots == 8) &amp;&amp; ($fabric == alpine)} {
        set chassis Alpine3808
    }
    elseif {($numSlots == 4) &amp;&amp; ($fabric == alpine)} {
        set chassis Alpine3804
    }
    elseif {($numSlots == 2) &amp;&amp; ($fabric == alpine)} {
        set chassis Alpine3802
    }
    else {
        set chassis Summit
    }
    catch {file delete &#34;Tmp/tmp_chassis&#34;}
    return $chassis
}

<strong><a name="::::CheckMSMsCompatibility_1251">proc <a href="downLoadCode.tcl-annot.html#::::CheckMSMsCompatibility">::::CheckMSMsCompatibility</a></a></strong> {} {

            lappend getKeyList &#34;{Image Selected:} 1&#34;
            lappend getKeyList &#34;{Image Selected:} 2&#34;
            lappend getKeyList &#34;{Primary ver:} 1&#34;
            lappend getKeyList &#34;{Primary ver:} 2&#34;
            lappend getKeyList &#34;{Secondary ver:} 1&#34;
            lappend getKeyList &#34;{Secondary ver:} 2&#34;
            set origPart [<a name="::GetKeyValue(2)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $getKeyList]
            <a name="::result_debug(43)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the MSMs state: $origPart&#34;
            set bankUsed [lindex $origPart 0]
            set primaryBuilds [lindex $origPart 1]
            set secondaryBuilds [lindex $origPart 2]
            if {[string compare -nocase [lindex $bankUsed 0] &#34;primary&#34;]==0} {
               <a name="::SendACmd(20)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>	&#34;use image partition secondary&#34;
<span class="comment-line">#               CheckReboot</span>
<span class="comment-line">#               set origPart [GetKeyValue &#34;show switch&#34; $getKeyList]</span>
<span class="comment-line">#               result_debug &#34;the MSMs state: $origPart&#34;</span>
<span class="comment-line">#               set bankUsed [lindex $origPart 0]</span>
<span class="comment-line">#               set primaryBuilds [lindex $origPart 1]</span>
<span class="comment-line">#               set secondaryBuilds [lindex $origPart 2]</span>
            }
            <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verifying Master/Backup compatibility...&#34;
            if {[lindex $bankUsed 1]!=&#34;&#34;} {   ;<span class="comment-line"># if MSM-B present</span>
               if {[lindex $bankUsed 0]==[lindex $bankUsed 1]} {
                 <a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Master:[lindex $bankUsed 0] and Backup:[lindex $bankUsed 1] are on same banks&#34;
                 if {[string compare -nocase [lindex $bankUsed 0] &#34;primary&#34;]==0} {
                    if {[lindex $primaryBuilds 0]==[lindex $primaryBuilds 1]} {
                       <a name="::result_ok(7)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Master:[lindex $primaryBuilds 0] and Backup:[lindex $primaryBuilds 1] use same primary image&#34;
                    } else {
                       <a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Master:[lindex $primaryBuilds 0] and Backup:[lindex $primaryBuilds 1] do not use same primary image&#34;
                       return 1
                    }
                 } elseif {[string compare -nocase [lindex $bankUsed 1] &#34;secondary&#34;]==0} {
                    if {[lindex $secondaryBuilds 0]==[lindex $secondaryBuilds 1]} {
                       <a name="::result_ok(8)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Master:[lindex $secondaryBuilds 0] and Backup:[lindex $secondaryBuilds 1] use same secondary image&#34;
                    } else {
                       <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Master:[lindex $secondaryBuilds 0] and Backup:[lindex $secondaryBuilds 1] do not use same secondary image&#34;
                       return 1
                    }
                 }
               } else {
                  <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Master:[lindex $bankUsed 0] and Backup:[lindex $bankUsed 1] are not on same banks&#34;
                  return 1
               }
            }
            
            <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
            set timeout 300
<span class="comment-line">#            if {[string compare -nocase [lindex $bankUsed 0] &#34;primary&#34;]==0} {</span>
<span class="comment-line">#               SendACmd	&#34;use image partition secondary&#34;</span>
<span class="comment-line">#               CheckReboot</span>
<span class="comment-line">#               if {[CheckMSMsCompatibility]==1} {</span>
<span class="comment-line">#                  return 1</span>
<span class="comment-line">#               }</span>
<span class="comment-line">#            }</span>
            unset getKeyList
            return 0
}

<strong><a name="::::CheckImagePartition_1311">proc <a href="downLoadCode.tcl-annot.html#::::CheckImagePartition">::::CheckImagePartition</a></a></strong> {{partition &#34;primary&#34;}} {

   global whichDutNow
   global DUTs_info
   global i386Platform
   if {[regexp -nocase &#34;$i386Platform&#34; $DUTs_info(DUT$whichDutNow,platform)] &amp;&amp; ([<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4] &lt; &#34;11.1.0&#34; \
       || ([<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4] == &#34;11.1.0&#34; &amp;&amp; [<a name="::GetVersion(3)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 3] &lt;= 6))} {
      <a name="::EnableDebugMode(2)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
      <a name="::result_debug(44)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Remove hal_syslog*.nvram to avoid licensing incompatibility&#34;
      <a name="::SendACmd(21)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!rm /root/config/hal_syslog*.nvram&#34;
   }
   global DUTs_info
   if {![regexp -nocase &#34;$partition&#34; $DUTs_info(DUT$whichDutNow,imageBooted)]} {
   set buf [<a name="::SendACmd(22)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image partition $partition&#34;]
   set backupStr &#34;Error: This command can only be executed on Master&#34;
   global DUT1_CONNECTB
   global DUT2_CONNECTB
   global DUT3_CONNECTB
   global DUT4_CONNECTB
   global DUT5_CONNECTB
   if {[regexp -nocase $backupStr $buf]} {
      <a name="::result_debug(45)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Backup MSM encountered&#34;
      set xos_version [<a name="::GetVersion(4)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4]
      if {$xos_version &lt; &#34;11.2.0&#34;} {
         <a name="::EnableDebugMode(3)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>  ;<span class="comment-line"># needed as 11.1.1.3 requires debug-mode</span>
         if { $xos_version &gt;= &#34;10.2.0&#34; } {
            set virtualRouter VR-Control
         } else {
            set virtualRouter VR-1
         }
         global bcmChassis
         if {[regexp -nocase $bcmChassis $buf]} {
            <a name="::SendACmd(23)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.12.2&#34;
         } else {
            <a name="::SendACmd(24)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.10.2&#34;
         }
      } else {
         if {[info exists DUT${whichDutNow}_CONNECTB]} {
            <span class="comment-line">#SendACmd &#34;telnet msm b&#34;</span>
            <a name="::Login(9)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECTB] -CheckOperational 0
         }
      }
      <a name="::SendACmd(25)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image part $partition&#34;
      <a name="::logout(1)"><a href="./logout.tcl.html#::logout_21">::logout</a></a>
      <a name="::Login(10)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT$whichDutNow,connect) -CheckOperational 0
   }
   <a name="::UnconfigSwAll(1)"><a href="./SendSwCmd.tcl.html#::UnconfigSwAll_1628">::UnconfigSwAll</a></a> -at &#34;download&#34;
   global supportedPlatform
   if {([regexp -nocase &#34;$supportedPlatform&#34; $DUTs_info(DUT$whichDutNow,platform)]  || \
            [regexp -nocase &#34;$supportedPlatform&#34; [<a name="::GetSysType(1)"><a href="./misc.tcl.html#::GetSysType_453">::GetSysType</a></a> DUT${whichDutNow}]]) &amp;&amp; \
       [info exists DUT${whichDutNow}_CONNECTB]} {
<span class="comment-line">#puts &#34;the whichDutNow $whichDutNow and [parray DUTs_info] and $DUT1_CONNECTB&#34;</span>
      set showSwitchOutput &#34;&#34;
      global pioneerPlatform
      global everestChassis
      if {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)] || \
          [regexp -nocase $everestChassis $DUTs_info(DUT$whichDutNow,platform)]} {
          lappend showSwitchOutput &#34;{MM-A *\\*} exist&#34;
      } else {
          lappend showSwitchOutput &#34;{MSM-A *\\*} exist&#34;
      }
      lappend showSwitchOutput &#34;{Current State:} {MASTER *BACKUP .*In *Sync} inLine exists&#34;
      if {[<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show switch&#34; $showSwitchOutput -time {s: 1 i: 5 d: 150 f: 150 r} -comment &#34;check both MSMs up in sh switch output&#34;]==&#34;error&#34;} {
         return 1
      }
   }
   }
   <a name="::SendACmd(26)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use ima part secondary&#34;
   return 0
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: Load_THT_CFG</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Load THT base configs</span>
<span class="comment-line">#</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#      </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,</span>
<span class="comment-line">#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)</span>
<span class="comment-line"># Category: SetupSwitch</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::Load_THT_CFG_1396">proc <a href="downLoadCode.tcl-annot.html#::::Load_THT_CFG">::::Load_THT_CFG</a></a></strong> {} {
    global DUTs_info
    global MaxLoopCount
    global cfg



    <span class="comment-line">#First check the cfg. If cfg has tht then run otherwise return</span>

    if {![regexp -nocase &#34;tht&#34; $cfg]} {
        <a name="::result_debug(46)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No need to run. Not a tht test bed. This is $cfg&#34;
        return -code return testSkipped
       
    }
    <span class="comment-line"># ---------------------------------------------------</span>
    <span class="comment-line">#   Set up a global variable to turn on log checking</span>
    <span class="comment-line">#      It would have been better to have a single</span>
    <span class="comment-line">#      check log procedure, but oh well.</span>
    <span class="comment-line"># ---------------------------------------------------</span>
    if {[info exists DUTs_info(DUT1,BaseConfigLoaded)] &amp;&amp; $DUTs_info(DUT1,BaseConfigLoaded)} {
        <a name="::result_debug(47)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;THT Base is already loaded continue&#34;
        return;
    }
    
    set MaxLoopCount 40000
    <span class="comment-line"># download to all 5 dut files tht_dut$dut.xsf</span>
    <span class="comment-line">#   sleep 600 secs after kicking of load script</span>
    set myDutList {1 2 3 4 5}
    set fullDutList {}
    set noFullDutList {}
    set haveBaseDutList {}
    set nadaDutList {}
    set thtXsfList &#34;&#34;
    set o2XsfList &#34;&#34;
    set o5XsfList &#34;&#34;
    
    foreach theDut $myDutList {
        <span class="comment-line"># Check to see if the full module configuration is available on the </span>
        <a name="::Login(11)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT$theDut,connect)
        set parameter &#34;&#34;
        lappend parameter &#34;{[file tail [pwd]]_DUT${theDut}_THT.cfg} exist&#34;
        set haveFull [<a name="::CheckKeyValue(2)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;ls&#34; $parameter -comment &#34;Check to see if the full module config is present&#34; -reportResults 0 ]
        if {$haveFull != &#34;ok&#34;} {
            <a name="::result_debug(48)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not Found: [file tail [pwd]]_DUT${theDut}_THT.cfg&#34;
            lappend noFullDutList $theDut
        } else {
            <a name="::result_debug(49)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND: [file tail [pwd]]_DUT${theDut}_THT.cfg&#34;
            lappend fullDutList $theDut
            <a name="::SendACmd(27)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;cp [file tail [pwd]]_DUT${theDut}_THT.cfg tht_base.cfg&#34;
            <a name="::SendACmd(28)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use config tht_base&#34;
        }
        unset parameter
    }
    if {[llength $noFullDutList] &gt; 0} {
        foreach theDut $noFullDutList {
            <span class="comment-line"># Check to see if the module BASE configuration is available on the </span>
            <a name="::Login(12)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT$theDut,connect)
            set parameter &#34;&#34;
            lappend parameter &#34;{THT_DUT${theDut}_Base.cfg} exist&#34;
            set haveBase [<a name="::CheckKeyValue(3)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;ls&#34; $parameter -comment &#34;Check to see if the THT Base config is present&#34; -reportResults 0 ]
            if {$haveBase != &#34;ok&#34;} {
                <a name="::result_debug(50)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NOT Found: THT_DUT${theDut}_Base.cfg&#34;
                lappend nadaDutList $theDut
            } else {
                <a name="::result_debug(51)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found: THT_DUT${theDut}_Base.cfg&#34;
                lappend haveBaseDutList $theDut
                <a name="::SendACmd(29)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;cp THT_DUT${theDut}_Base.cfg tht_base.cfg&#34;
                <a name="::SendACmd(30)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use config tht_base&#34;
            }
            unset parameter
        }
    }
    if {[llength $nadaDutList] &gt; 0} {
        <span class="comment-line"># This is a list of duts with no base or full config.  Build a list of xsf filenames.</span>
        foreach theDut $nadaDutList {
            <a name="::result_debug(52)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $theDut found no configs.  PULL clean .xsf&#34;
            lappend thtXsfList tht_dut${theDut}
            lappend o2XsfList  tht_o2_dut${theDut}
            lappend o5XsfList  tht_o5_dut${theDut}
        }
    }
    
    <span class="comment-line"># -------------------------------------------------------------</span>
    <span class="comment-line">#  All of the lists are present. Do the first action.</span>
    <span class="comment-line">#    - do you think you can multitask within a multitask??</span>
    <span class="comment-line">#    - We will find out.</span>
    <span class="comment-line"># -------------------------------------------------------------</span>
    set procList &#34;&#34;
    if {[llength $fullDutList] &gt; 0 || [llength $haveBaseDutList] &gt; 0} {
        <span class="comment-line"># Create the , delimited string</span>
        if {[llength $fullDutList] &gt; 0} {
            set commaDutA [join $fullDutList ,]
            set commaDut ${commaDutA}
        }
        if {[llength $haveBaseDutList] &gt; 0} {
            set commaDutB [join $haveBaseDutList ,]
            set commaDut $commaDutB
        }
        if {[llength $haveBaseDutList] &gt; 0 &amp;&amp; [llength $fullDutList] &gt; 0} {
            set commaDut ${commaDutA},$commaDutB
        }
        <a name="::result_debug(53)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;CheckReboot $commaDut -save no -waitforloadcfg yes&#34;
        lappend procList &#34;CheckReboot $commaDut -save no -waitforloadcfg yes&#34;
    }
    if {[llength $nadaDutList] &gt; 0} {
        if {$cfg == &#34;p4_voy_ipr_tht.cfg&#34;} {
            <a name="::result_debug(54)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;lappend procList checkDownloadConfigParallel [list $nadaDutList] [list $thtXsfList] -wait 90 .... &#34;
            lappend procList &#34;checkDownloadConfigParallel [list $nadaDutList] [list $thtXsfList] -wait 90 \
                -timeout 3000 -incremental 0&#34;
        } elseif {$cfg == &#34;p2_oly_ipr.cfg&#34;} {
            <a name="::result_debug(55)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;lappend procList checkDownloadConfigParallel [list $nadaDutList] [list $o2XsfList] -wait 90 .... &#34;
            lappend procList &#34;checkDownloadConfigParallel [list $nadaDutList] [list $o2XsfList]  -wait 90 \
                -timeout 800 -incremental 0&#34;
        } elseif {$cfg == &#34;p5_oly_ipr.cfg&#34;} {
            <a name="::result_debug(56)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;lappend procList checkDownloadConfigParallel [list $nadaDutList] [list $o5XsfList] -wait 90 .... &#34;
            lappend procList &#34;checkDownloadConfigParallel [list $nadaDutList] [list $o5XsfList]  -wait 90 \
                -timeout 800 -incremental 0&#34;
        } 
    }
    <span class="comment-line"># The first list of tasks is created.</span>
    <a name="::result_debug(57)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n------------------------------------------------------------&#34;
    <a name="::result_debug(58)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MultiTask is getting ready to run with these procs:&#34;
    foreach aProc $procList {
        <a name="::result_debug(59)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  - $aProc&#34;
    }
    <a name="::result_debug(60)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;------------------------------------------------------------&#34;
    <a name="::MultiTask(1)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $procList
    set DUTs_info(DUT1,BaseConfigLoaded) 1
    if {0} {
    <a name="::result_debug(61)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n-------------------------------------\nFirst Load/Reboot is Done\n-------------------------------------&#34;
    if {[llength $fullDutList] &gt; 0} {
        foreach fDut $fullDutList {
            <a name="::result_debug(62)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $fDut had the full config.  Not more work needed.&#34;
        }
    }
    set thtXsfList &#34;&#34;
    set o2XsfList &#34;&#34;
    set o5XsfList &#34;&#34;
    set incrDutList &#34;&#34;
    if {[llength $haveBaseDutList] &gt; 0} {
        foreach bDut $haveBaseDutList {
            <a name="::result_debug(63)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $bDut only had the base config.  Try to download rest.&#34;
            lappend incrDutList $bDut
            lappend thtXsfList &#34;[file tail [pwd]]_tht_dut${theDut}&#34;
            lappend o2XsfList  &#34;[file tail [pwd]]_tht_o2_dut${theDut}&#34;
            lappend o5XsfList  &#34;[file tail [pwd]]_tht_o5_dut${theDut}&#34;
        }
    }
    if {[llength $nadaDutList] &gt; 0} {
        foreach nDut $nadaDutList {
            <a name="::result_debug(64)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $nDut just downloaded xsf base.  Try to download rest.&#34;
            lappend incrDutList $nDut
            lappend thtXsfList &#34;[file tail [pwd]]_tht_dut${theDut}&#34;
            lappend o2XsfList  &#34;[file tail [pwd]]_tht_o2_dut${theDut}&#34;
            lappend o5XsfList  &#34;[file tail [pwd]]_tht_o5_dut${theDut}&#34;
        }    
    }
    if {[llength $incrDutList] &gt; 0} {
        $q=0;
        if {$cfg == &#34;p4_voy_ipr_tht.cfg&#34;} {
            foreach iDut $incrDutList {
                <a name="::result_debug(65)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $nDut is a base. Incr load DUT: $iDut XSFFile: [lindex $thtXsfList $q].&#34;
                incr q
            }
            <span class="comment-line">#checkDownloadConfigParallel $incrDutList $thtXsfList -wait 90 -timeout 600 -incremental 1</span>
        } elseif {$cfg == &#34;p2_oly_ipr.cfg&#34;} {
            foreach iDut $incrDutList {
                <a name="::result_debug(66)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $nDut is a base. Incr load DUT: $iDut XSFFile: [lindex $o2XsfList $q].&#34;
                incr q
            }
            <span class="comment-line">#checkDownloadConfigParallel $incrDutList $o2XsfList  -wait 90 -timeout 600 -incremental 1</span>
        } elseif {$cfg == &#34;p5_oly_ipr.cfg&#34;} {
            foreach iDut $incrDutList {
                <a name="::result_debug(67)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $nDut is a base. Incr load DUT: $iDut XSFFile: [lindex $o5XsfList $q].&#34;
                incr q
            }
            <span class="comment-line">#checkDownloadConfigParallel $incrDutList $o5XsfList  -wait 90 -timeout 600 -incremental 1</span>
        }
    }
    }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
