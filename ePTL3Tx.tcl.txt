#################################################################
# $RCSfile: ixiaL3Tx.tcl,v $ - 
#
# Copyright (c) 1999 by Extreme Networks Inc.
# 
# Revision control history
# ------------------------
# $Header: /export/cvsroot/automation/Lib/ixiaL3Tx.tcl,v 2.36.6.29 2010/08/24 01:39:52 ghundertmark Exp $
# Extreme Networks modification history
# -------------------------------------
# $Log: ixiaL3Tx.tcl,v $
# Revision 2.36.6.29  2010/08/24 01:39:52  ghundertmark
# Merge branch 12_4 to trunk
#
# Revision 2.36.6.29  2010/08/24 01:39:52  ghundertmark
# Merge branch 12_4 to trunk
#
# Revision 2.36.6.28  2009/07/07 22:39:02  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.36.6.27.2.1  2009/07/07 22:37:04  lagrawal
# removed extra empty line causing issue in some procs
#
# Revision 2.36.6.27  2009/07/01 10:55:41  nellinivasu
# Merged From Branch 'branch-dev_v12-1-rel4'
#
# Revision 2.36.6.26  2009/06/05 00:25:09  jramarao
# Merged from DEV after May 26 2009
#
# Revision 2.36.6.25  2009/05/15 17:03:04  lagrawal
# Add protocol tag id
#
# Revision 2.36.6.24  2009/04/15 13:26:19  nellinivasu
# Merged From Branch 'branch-dev_v12-1-rel4'
#
# Revision 2.36.6.23  2009/03/18 21:48:28  jramarao
# From branch-dev_v12-1-rel4
#
# Revision 2.36.6.21.18.2  2009/02/24 12:12:23  nellinivasu
# Merged From Branch 'branch-pioneer2_dev-v12-1-rel4'
#
# Revision 2.36.6.21.18.4  2009/04/15 13:18:29  nellinivasu
# With non default ipTotalLength, Set lengthOverride to false for XMV ixia card type in function ixiaConf_2Ports_ip,if not it is treated as bad packet.
#
# Revision 2.36.6.21.18.3  2009/04/03 09:29:29  lagrawal
# merge from branch-pioneer2_dev-v12-1-rel4 to branch-dev_v12-1-rel4
#
# Revision 2.36.6.21.18.1.4.2  2009/02/24 12:05:06  nellinivasu
# With non default ipTotalLength, Set lengthOverride to false for XMS ixia card type in function ixiaConf_2Ports_ip,if not it is treated as bad packet.
#
# Revision 2.36.6.21.18.1.4.1  2009/02/17 21:49:14  ghundertmark
# add protocolTag to enable 88a8 in the ethertype offset
#
# Revision 2.36.6.21.18.1  2008/10/20 20:00:57  lagrawal
# added lengthOverride to function ixiaConf_2Ports_ip use can set the value true/false to overide length/keep it same when sending packet , override packet simetime is treated as bad packet
#
# Revision 2.36.6.21.18.4  2009/04/15 13:18:29  nellinivasu
# With non default ipTotalLength, Set lengthOverride to false for XMV ixia card type in function ixiaConf_2Ports_ip,if not it is treated as bad packet.
#
# Revision 2.36.6.21.18.3  2009/04/03 09:29:29  lagrawal
# merge from branch-pioneer2_dev-v12-1-rel4 to branch-dev_v12-1-rel4
#
# Revision 2.36.6.21.18.1.4.2  2009/02/24 12:05:06  nellinivasu
# With non default ipTotalLength, Set lengthOverride to false for XMS ixia card type in function ixiaConf_2Ports_ip,if not it is treated as bad packet.
#
# Revision 2.36.6.21.18.1.4.1  2009/02/17 21:49:14  ghundertmark
# add protocolTag to enable 88a8 in the ethertype offset
#
# Revision 2.36.6.21.18.1  2008/10/20 20:00:57  lagrawal
# added lengthOverride to function ixiaConf_2Ports_ip use can set the value true/false to overide length/keep it same when sending packet , override packet simetime is treated as bad packet
#
# Revision 2.36.6.21  2007/04/30 12:23:19  ghundertmark
# Add txperc to frameformat for L3
#
# Revision 2.36.6.20  2007/03/02 10:22:19  nellinivasu
# Modified proc ixiaConf_2Ports_arp to support destHwAddr in ARP payload.
#
# Revision 2.36.6.19  2007/02/21 01:42:46  achilukuri
# Merging  Q3FY07-11.6-Phase-2
#
# Revision 2.36.6.18  2007/01/25 19:26:09  achilukuri
# Release  Q3FY07_11.6 Phase 1 commit
#
# Revision 2.36.6.17.2.1  2007/01/24 13:14:10  aprakasham
# Added UDF options in Proc ixiaConf_2Ports_arp
#
# Revision 2.36.6.17  2006/11/14 04:53:15  dsuk
# Q2FY07 11.5 Phase 2 Merge
#
# Revision 2.36.6.16  2006/11/11 00:06:42  skumar
# Justs' DHCP specific commit
#
# Revision 2.36.6.15.2.1  2006/11/01 22:33:07  dsuk
# added frameSizeMIN and frameSizeMAX arguments
#
# Revision 2.36.6.15  2006/09/29 22:38:16  djain
# Commit for Release Q1FY07-Rel11.4
#
# Revision 2.36.6.14.2.1  2006/09/19 19:37:53  smohanty
# Added Mac address for default src or dest mac in the debug info
#
# Revision 2.36.6.14  2006/06/30 22:35:34  ghundertmark
# Q4FY06 Release commit
#
# Revision 2.36.6.13  2006/06/09 06:12:28  nellinivasu
# Changes made to debug ixia transmission problem.
#
# Revision 2.36.6.12  2006/05/30 05:41:02  nellinivasu
# Changes made to debug ixia transmission problem.
#
# Revision 2.36.6.11  2006/05/29 13:19:30  nellinivasu
# Changes made to debug ixia transmission problem.
#
# Revision 2.36.6.10  2006/05/18 21:12:48  skumar
# Support multiple udfs in _ip
#
# Revision 2.36.6.9  2006/04/15 00:25:08  skumar
# Use lsort based on dictio
#
# Revision 2.36.6.8.4.2  2006/05/12 02:14:54  smohanty
# Supported Generation of QinQ (double tag) packets from ixia
#
# Revision 2.36.6.8.4.1  2006/04/17 22:56:36  smohanty
# Added display of the Tx packet component for ip, mac and dhcp packets
#
# Revision 2.36.6.8  2005/12/21 22:24:18  smohanty
# Commit for Release 12
#
# Revision 2.36.6.7  2005/11/30 02:27:23  skumar
# updates for srcHwAddr, decideLoopCount for ORT long tests
#
# Revision 2.36.6.6.4.2  2005/10/12 01:51:38  skumar
# Fix wrong spelling in couint
#
# Revision 2.36.6.6.4.1  2005/10/12 00:43:57  skumar
# Added workaround for > 16Mil pkt count
#
# Revision 2.36.6.6.4.3  2005/11/08 01:52:33  dsuk
# added tag parameter to ixiaConf_2Ports_Dhcp
#
# Revision 2.36.6.6.4.2  2005/10/12 01:51:38  skumar
# Fix wrong spelling in couint
#
# Revision 2.36.6.6.4.1  2005/10/12 00:43:57  skumar
# Added workaround for > 16Mil pkt count
#
# Revision 2.36.6.6  2005/09/16 02:05:10  skumar
# Added dontTx arg. Default 0. Used for ONLY stream config
#
# Revision 2.36.6.5  2005/06/29 16:57:55  cshaw
# Release exos-br-10
#
# Revision 2.36.6.4  2004/09/30 00:59:26  mverma
# Exos Rel7 check in.
#
# Revision 2.36.6.3.2.1  2004/09/08 00:31:17  skumar
# Added more args for ACL support
#
# Revision 2.36.6.3  2004/07/28 19:44:43  skumar
# Use udf definitions
#
# Revision 2.36.6.2  2004/05/03 23:41:02  skumar
# Changes w.r.t. incremental igmp reports
#
# Revision 2.36.6.1  2003/08/20 03:20:05  cshaw
# trunk-exos release
#
# Revision 2.36.4.2  2003/08/14 00:35:42  cshaw
# Merged in trunk for 3.65 related changes
#
# Revision 2.46  2003/07/25 18:02:58  cshaw
# Merged from br-1-6
#
# Revision 2.45.6.1  2003/07/19 21:37:56  skumar
# Added support for ix 3.65, removed deprecated calls.
#
# Revision 2.36.4.1  2003/06/23 21:28:45  cshaw
# Merged in EW trunk
#
# Revision 2.45  2003/04/18 19:34:47  autotest
# Changes as taken from br-1-3.
#
# Revision 2.44.6.1  2003/04/14 19:41:42  autotest
# Add arp repeat options
#
# Revision 2.44  2003/02/06 03:19:50  tquach
# add more option on dhcp frame
#
# Revision 2.43  2002/09/03 23:36:43  swang
# undid the previous change
#
# Revision 2.42  2002/08/30 01:26:11  swang
# change 'arp config -destHardwareAddr' from '00 00 00 00 00 00' to 'FF FF FF FF FF FF'
#
# Revision 2.41  2002/08/27 21:33:29  eyoung
# Enhanced ixia_Conf_2Ports_ip to allow address counts to be specified when doing MAC or IP address incrementing.
#
# Revision 2.40  2002/08/21 22:45:10  tquach
# Need to clear the port stat before sending the packets else ixiachecktxdone will not work correctly
#
# Revision 2.39  2002/08/09 01:29:54  skumar
# Optimize ixStartCapture per EY suggestion.
#
# Revision 2.38  2002/07/26 22:59:53  aleu
# add description header for each proc
#
# Revision 2.37  2002/07/19 00:33:54  skumar
# Chnage ixStartPortCapture to ixStartCapture.
#
# Revision 2.36  2002/07/10 18:34:08  aleu
# comment out  lines of "ixiaConf_clearStat $c"
#
# Revision 2.35  2002/05/06 21:25:36  aleu
# remove all cardSpeed global var
#
# Revision 2.34  2002/03/28 21:25:22  aleu
# enable tcpConfig{} to set seqNum, syn/fin/ack/rst flags
#
# Revision 2.33  2002/03/28 18:25:20  skumar
# Fix dependency on startCardNum.
#
# Revision 2.32  2002/03/25 19:01:48  aleu
# change ixiaConf_2Ports_arp{}'s default percentage to be 0.01 from 100
#
# Revision 2.31  2002/01/22 00:05:26  tquach
# Add arp increment
#
# Revision 2.30  2001/12/06 19:49:48  tnguyen
# Add some options needed in new performance module
#
# Revision 2.29  2001/10/25 23:46:55  skumar
# Make sure right igmp ver1 for v1 join.
#
# Revision 2.28  2001/09/12 23:21:14  tquach
# Add UDF feature
#
# Revision 2.27  2001/06/08 00:54:04  Autotest
# More checks to avoid error condition-sk.
#
# Revision 2.26  2001/06/07 00:49:53  skumar
# Put filter to Rx if applyFilter set else not in IP forwarding.
#
# Revision 2.25  2001/06/01 02:15:47  skumar
# Changes to take care bi-directional frames send.
#
# Revision 2.24  2001/04/25 01:00:55  skumar
# Added few lines to support udf for pim-dm.
#
# Revision 2.23  2001/04/19 22:54:07  aleu
# minor change
#
# Revision 2.22  2001/03/21 18:30:52  aleu
# add rip & ripRoute ixia commands
#
# Revision 2.21  2001/03/21 01:41:02  aleu
# add frameSizeType stream option in ixiaConf_2Ports_ip
#
# Revision 2.20  2001/02/18 21:41:55  sphomsakha
# Add dontFragment variable
#
# Revision 2.19  2001/01/23 04:02:03  tnguyen
# Change to support ixia 3.1 for udf
#
# Revision 2.18  2001/01/18 03:57:50  tnguyen
# Add ipTotalLength and fix pattern configuration for 3.1
#
# Revision 2.17  2001/01/14 02:20:27  tquach
# Add DHCP procedure
#
# Revision 2.16  2000/11/06 16:41:08  jfan
# Fix a bug for ipSaMode and merge for conflict
#
# Revision 2.15  2000/11/02 23:55:12  skumar
# Put length check on ipOptions field to avoid bug in ixia 3.1 ver.
#
# Revision 2.14  2000/09/25 18:28:31  tnguyen
# Remove 2portsNum_adjust,
# call capturing only on Tx and Rx ports instead of all cards
#
# Revision 2.13  2000/09/12 22:57:19  tnguyen
# Remove function to print data out to file, will print out at another place
#
# Revision 2.12  2000/08/12 02:20:25  skumar
# Added ipOptions, Fixed Tag problem in 2Way IP forwarding.
#
# Revision 2.11  2000/08/04 18:28:09  jfan
# Fix a bug: Do ixiaCheckTxDone only if the streamType is "stopStream"
#
# Revision 2.10  2000/06/06 21:38:08  tnguyen
# Add TOS and Vlan priority
#
# Revision 2.9  2000/05/25 16:18:19  tnguyen
# Default value for -ipSaMode or -ipDaMode "ipIdle" not "idle"
#
# Revision 2.8  2000/05/17 00:41:51  tnguyen
# Add option to return data frames instead writing to a file
#
# Revision 2.7  2000/05/08 22:22:36  jfan
# Solve the conflict after updating for 2.6
#
# Revision 2.6  2000/04/28 17:25:38  jlequang
# Fist stage of incorporating old BD-extension to Thanh's
# new enhancement.
#
# Revision 2.5  2000/04/07 00:23:48  tnguyen
# Various modifications to the whole project in Lib, L2 and L3.  Commit changes for all these folders at the same time.
#
# Revision 2.3  2000/02/07 23:50:13  jfan
# Add for udp, tcp & icmp
#
# Revision 2.2  1999/10/27 21:58:59  jfan
# Modify IxiaTx functions as interface changed.  Replace "Input" dir to "Exp" dir.  Replace "Tmp\in_xxx" to "Tmp_tmp_xxx"
#
# Revision 2.1  1999/09/27 22:32:33  jfan
# no message
#
#
##################################################################

################################################################## 
# Procedure Name: ixiaConf_2Ports_Dhcp   
# Description: 
#	Set up an ixia port to send DHCP packets based on given
#	opCode and optionCodeList parameters		     
# Input args: args
# Output args: none
# Typical usage: 
#	set frameSent [ixiaConf_2Ports_Dhcp -numIxiaCd $numIxiaCd \
#              -txChas $chasisId -txCard $card -txPort $port -startCardNum $startCardNum \
#              -rxChas $chasisId -rxCard $card -rxPort $rxPo \
#              -sMacAddr $sourceMac -dMacAddr $destMac \
#	       -numFrames $numFrames -streamType $streamType -fcsError $fcsError \
#	       -saMode $saMode -daMode $daMode -opCode $opCode \
#	       -optionCodeList $optionCodeList -clientHwAddr $clientHwAddr ]    
# Category: SendTraffic
##################################################################
proc ixiaConf_2Ports_Dhcp {args} {
   parse_args ixiaConf_2Ports_Dhcp $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "1"
      txCard "1"
      txPort "1"
      rxChas "1"
      rxCard "1"
      rxPort "2"
      sMacAddr "00 00 86 52 55 CB"
      dMacAddr "FF FF FF FF FF FF"
      sIpAddr "0.0.0.0"
      dIpAddr "255.255.255.255"
      srcPort "68"
      dstPort "67"
      numFrames "1"
      dataPattern "0000"
      streamType "stopStream"
      fcsError "good"
      saMode "idle"
      daMode "idle"
      chid "1"
      clientHwAddr "00 00 86 52 55 CB"
      clientIpAddr "0.0.0.0"
      frameSize "342"
      yourIpAddr "0.0.0.0"
      opCode "dhcpBootRequest"
      optionCodeList "{dhcpMessageType dhcpDiscover}"
      dontTx "0"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
   }
                       
   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
#   globalSetDefault
#   protocolStackSetDefault

   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
#   result_debug "\n*** date=$date"
   set time1 [clock seconds]

   set streamType				stopStream
   set patternOffset				32
   set macBroadcast				{FF FF FF FF FF FF}
   set preambleSize				8

   # Create mapping
#   map new -type				one2one
#   map config -type 				one2one

   if { $direction == "2Way" } {
#puts "--------------------- ll3 -----------------"
      map add $txChas $txCard $txPort $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort $txChas $txCard $txPort
#puts "--------------------- ll4 -----------------"
   } else  {
      map add $txChas $txCard $txPort $rxChas $rxCard $rxPort
   }
   #-----------------------------------------------------------------
   # Config streams for validation traffic
#   foreach txMap [lsort -dictionary [array names one2oneArray]] {
#     scan $txMap				"%d,%d,%d" chid c p
#     port get					$chid $c $p
#      set txSpeed				[port cget -speed]
      set txSpeed				100
      ## configure streams
#      stream setDefault
      stream config -rateMode                   usePercentRate
      stream config -asyncIntEnable             true
      stream config -percentPacketRate          50
      stream config -numFrames			$numFrames
#      stream config -name 			S_${c}_${p}
      stream config -framesize			$frameSize
      stream config -frameSizeType              sizeFixed
      decideLoopCount $numFrames $streamType
      port get					$txChas $txCard $txPort
      set srcAddr				[port cget -MacAddress]
      after 200
#      set rxMap					$one2oneArray($txMap)
#      scan [join $rxMap]			"%d %d %d" rxch rxc rxp
      port get					$rxChas $rxCard $rxPort
      set destAddr				[port cget -MacAddress]
       after 200   
      stream config -saRepeatCounter $saMode 
      stream config -daRepeatCounter $daMode 
      if { $saMode != "idle" } { stream config -numSA $numFrames }
      if { $daMode != "idle" } { stream config -numDA $numFrames }
      if { $sMacAddr == "default" } {
          set sTmpMacAddr $srcAddr
      } else { 
          set sTmpMacAddr $sMacAddr
      }				    
      stream config -sa 		       $sTmpMacAddr
      stream config -da 	               $dMacAddr
      
      ## ip header
      #ip setDefault
      ip config -ipProtocol                     udp
      # other ip info
      ip config -destIpAddr                     $dIpAddr
      ip config -destIpAddrMode                 ipIdle
      ip config -sourceIpAddr                   $sIpAddr
      ip config -sourceIpAddrMode               ipIdle
#      ip set                                    $chid $c $p


      udp config -sourcePort	[format %04x $srcPort]
      udp config -destPort	[format %04x $dstPort]
#      udp set $chid $c $p


      ## set up protocol
#      protocol setDefault
      protocol config -ethernetType		ethernetII
      protocol config -name			ip
      protocol config -appName			Dhcp

      ## DHCP packet format
#      dhcp setDefault
      dhcp config -opCode                         $opCode
#      dhcp config -hwType                         dhcpEthernet10Mb
      dhcp config -hwType                         01
      dhcp config -transactionID                  "8a9ab8e8"
      dhcp config -seconds                        7680
#      dhcp config -flags                          dhcpNoBroadcast
      dhcp config -flags                          0000
      dhcp config -clientIpAddr                   $clientIpAddr
      dhcp config -yourIpAddr                     $yourIpAddr
      dhcp config -serverIpAddr                   0.0.0.0
      dhcp config -relayAgentIpAddr               0.0.0.0
      dhcp config -clientHwAddr                   $clientHwAddr
#      dhcp config -optionCodeList                 $optionCodeList
      lappend optionCodeList dhcpIPAddrLeaseTime 1200
      lappend optionCodeList dhcpEnd ff
#      dhcp config -optionData                     {{dhcpIPAddrLeaseTime 1200}}
      dhcp config -optionData                     $optionCodeList
#      dhcp set $chid $c $p
      # dhcp options 
#      puts "DHCP OPTIONS : $optionCodeList"  
      setDhcpOptions optionCodeList
      ## set DHCP config
#      if [dhcp set $chid $c $p] {
#          result_debug "Error setting dhcp configuration!"
#      }
      
      ## set up vlan
      protocol config -enable802dot1qTag                $wTag
      vlan config -cfi                                  $tagCfi
      vlan config -mode                                 $tagMode
      vlan config -repeat                               $tagRepeat
      vlan config -vlanID                               $tagNo
#      vlan set                                          $chid $c $p

#      stream set				$chid $c $p 1
#     stream write                              $chid $c $p 1
      # Define filter & capture

      filter config -captureFilterEnable		true
      filter config -captureTriggerEnable		true
      filter config -userDefinedStat1Enable		false
      filter config -userDefinedStat1DA			addr1
      filter config -captureFilterPattern		anyPattern
      filter config -captureTriggerPattern		anyPattern
      filter config -captureTriggerDA			anyAddr
      filter config -captureFilterDA			anyAddr
#     filter set					$rxch $rxc $rxp

      filterPallette config -DA1 			$destAddr
      filterPallette config -pattern1			$dataPattern
      filterPallette config -patternOffset1 		$patternOffset
#     filterPallette set				$rxch $rxc $rxp
#   }
   set portList "$txChas:$txCard:$txPort" 
   writeConfigToHardware $portList
   zeroPortStats $txChas $txCard $txPort
   #for {set c $startCardNum} {$c<=[expr $startCardNum + $numIxiaCd - 1]} {incr c 1} { ixiaConf_clearStat $c }
   #just in case some previous function stop capture on these ports
   set pList ""
   lappend pList "$txChas $txCard $txPort"
   lappend pList "$rxChas $rxCard $rxPort"
   ixStartCapture $pList
   if {!$dontTx} {
#      startTx one2oneArray
      startTx $portList
      set time2 [clock seconds]
      stream get $txChas $txCard $txPort 1
      set streamSent [stream cget -packetView]
      #result_debug "*** Frame sent from ($txChas $txCard $txPort) = $streamSent"
#      result_debug "*** Time for Ixia TX setup = [expr $time2-$time1] secs"
      # Make sure TX done
      if { $streamType == "stopStream" } {
         if { ($saMode != "contIncrement") && ($saMode != "contDecrement") &&   \
              ($daMode != "contIncrement") && ($daMode != "contDecrement") } {
            ixiaCheckTxDone $txChas $txCard $txPort $numFrames $txPort
            if { $direction == "2Way" } {
               ixiaCheckTxDone $rxChas $rxCard $rxPort $numFrames $txPort
            }
         }
      }
     after 1000
      set time3 [clock seconds]
      #result_debug "*** Time for Ixia TX done = [expr $time3-$time2] secs\n"
      result_debug "*** Ixia port config time [expr $time2-$time1] secs and TX time [expr $time3-$time2] secs\n"
      if {$sMacAddr == "default"} {
         set sMacAddr $srcAddr
      }
      set txPortId [MapIxiaCardnPort $txChas $txCard $txPort]
      set rxPortId [MapIxiaCardnPort $rxChas $rxCard $rxPort]
      displayDhcpPacketFormat -txPortId $txPortId -rxPortId $rxPortId \
        -destMac $dMacAddr -srcMac $sMacAddr -srcIp $sIpAddr -destIp $dIpAddr \
        -saMode $saMode -daMode $daMode -clientHwAddr $clientHwAddr \
        -clientIpAddr $clientIpAddr -opCode $opCode -direction $direction \
        -optionCodeList $optionCodeList -wTag $wTag -tagNo $tagNo \
        -frameSent $streamSent
      return $streamSent
   } else {
      return ""
   }
}

################################################################## 
# Procedure Name: ixiaConf_2Ports_arp   
# Description: 
#	Set up an ixia port to send ARP packets (request or reply)		     
# Input args: args
# Output args: none
# Typical usage: 
#	set frameSent [ixiaConf_2Ports_arp -numIxiaCd $numIxiaCd \
#             -txChas $chasisId -txCard $card -txPort $port -startCardNum $startCardNum \
#             -rxChas $chasisId -rxCard $card -rxPort $rxPo \
#             -operation $type -sMacAddr $sourceMac -dMacAddr $destMac \
#             -sIpAddr $sourceIp -dIpAddr $destIp -numFrames $numFrames \
#	      -wTag $wTag -tagNo $tag -frameSize $frameSize -streamType $streamType \
#	      -arpSaMode $arpSaMode -arpDaMode $arpDaMode -percentage $percentage \
#	      -arpSaRepeat $arpSaRepeat -arpDaRepeat $arpDaRepeat]   
# Category: SendTraffic
##################################################################
proc ixiaConf_2Ports_arp {args} {
   parse_args ixiaConf_2Ports_arp $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "1"
      txCard "1"
      txPort "1"
      rxChas "1"
      rxCard "1"
      rxPort "2"
      sMacAddr "default"
      dMacAddr "FF FF FF FF FF FF"
      sIpAddr "127.0.0.1"
      dIpAddr "127.0.0.1"
      arpSaMode "arpIdle"
      arpDaMode "arpIdle"
      operation "arpRequest"
      goodChecksum "true"
      numFrames "1"
      frameSize "64"
      frameRate "default"
      dataPattern "0000"
      streamType "stopStream"
      fcsError "good"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
      percentage "0.01"
      saMode "idle"
      daMode "idle"
      chid "1"
      arpSaRepeat "1"
      arpDaRepeat "1"
      srcHwAddr "default"
      srcHwAddrMode "arpIdle"
      srcHwAddrRepeat "1"
      destHwAddr "default"
      destHwAddrMode "arpIdle"
      destHwAddrRepeat "1"   
      udfEnable "false"
      udfInitval "00"
      udfOffset "0"
      udfCountertype "c8"
      udfContinuousCount "false"
      dontTx "0"
   }
   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
#   globalSetDefault
#  protocolStackSetDefault

   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   #result_debug "\n*** date=$date"
   set time1 [clock seconds]
   set streamType					$streamType
   set patternOffset				32
   set macBroadcast					{FF FF FF FF FF FF}
   set preambleSize					8

   # Create mapping
#   map new -type					one2one
#   map config -type 				one2one
   if { $direction == "2Way" } {
#puts "--------------------- ll3 -----------------"
      map add $txChas $txCard $txPort $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort $txChas $txCard $txPort
#puts "--------------------- ll4 -----------------"
   } else  {
      map add $txChas $txCard $txPort $rxChas $rxCard $rxPort
   }
   #-----------------------------------------------------------------
   # Config streams for validation traffic
#   foreach txMap [lsort -dictionary [array names one2oneArray]] {
#      scan $txMap					"%d,%d,%d" chid c p
#      port get						$chid $c $p
#      set txSpeed					[port cget -speed]
       set txSpeed 100
      stream config -numFrames		$numFrames
#      stream config -name 			S_${c}_${p}
      stream config -framesize		$frameSize
      decideLoopCount $numFrames $streamType

      if { $frameRate == "default" } {
         set frameRate [decideFrameRate $txSpeed $frameSize $percentage]
      } else {
         set percentage [decidePercentage $txSpeed $frameSize $frameRate]
      }
      stream config -rateMode usePercentRate
      stream config -percentPacketRate $percentage

#      set ifg [calculateGap $frameRate $frameSize $preambleSize $txSpeed]

      # Now we configure the stream
      stream config -fcs                       $fcsError
#      stream config -ifg                       $ifg
#      stream config -isg                       $ifg
#      stream config -ibg                       $ifg
      stream config -fir                       false           ;# for timestamp
      stream config -patternType nonRepeat  ;#needed for version 3.1
#      stream config -dataPattern	userpattern -pattern $dataPattern
      stream config -dataPattern $dataPattern
      port get						$txChas $txCard $txPort
    set srcAddr					[port cget -MacAddress]
       after 200   
#    set rxMap						$one2oneArray($txMap)
#     scan [join $rxMap]			"%d %d %d" rxch rxc rxp
     port get						$rxChas $rxCard $rxPort
     set destAddr					[port cget -MacAddress]
       after 200   

      stream config -saRepeatCounter $saMode 
      stream config -daRepeatCounter $daMode 
      if { $saMode != "idle" } { stream config -numSA $numFrames }
      if { $daMode != "idle" } { stream config -numDA $numFrames }

      if { $sMacAddr == "default" } { 
         set sTmpMacAddr $srcAddr
      } else {
         set sTmpMacAddr $sMacAddr
      }

      if { $dMacAddr == "FF FF FF FF FF FF" } {
         set dTmpMacAddr "FF FF FF FF FF FF"
      } else {
         set dTmpMacAddr $dMacAddr
      }


	  stream config -sa 					$sTmpMacAddr
          stream config -da 					$dTmpMacAddr

	  protocol config -ethernetType 		ethernetII
	  protocol config -name					ip
	  protocol config -appName				Arp
	  protocol config -enable802dot1qTag	$wTag

     arp config -sourceProtocolAddr		 $sIpAddr
     arp config -destProtocolAddr		 $dIpAddr
     arp config -sourceProtocolAddrMode          $arpSaMode
     arp config -destProtocolAddrMode            $arpDaMode
  
     if {$srcHwAddr=="default"} {
        arp config -sourceHardwareAddr	         $sTmpMacAddr
     } else {
        arp config -sourceHardwareAddr	         $srcHwAddr
     }

     if {$destHwAddr=="default"} {
        arp config -destHardwareAddr             $dTmpMacAddr
     } else {
        arp config -destHardwareAddr             $destHwAddr
     }

#    arp config -destHardwareAddr	         "00 00 00 00 00 00"
     arp config -sourceProtocolAddrRepeatCount   $arpSaRepeat
     arp config -destProtocolAddrRepeatCount     $arpDaRepeat
     arp config -operation		         $operation
     arp config -sourceHardwareAddrMode	         $srcHwAddrMode
     arp config -sourceHardwareAddrRepeatCount   $srcHwAddrRepeat
     arp config -destHardwareAddrMode            $destHwAddrMode
     arp config -destHardwareAddrRepeatCount     $destHwAddrRepeat

#     arp set								    $chid $c $p
      
 # Define UDF package
      if {$udfEnable == "true"} {
          set inter 0
          foreach udfOffs $udfOffset {
          udf config -enable "true"
          udf config -continuousCount [lindex $udfContinuousCount $inter]
          udf config -initval [lindex $udfInitval $inter]
          udf config -offset [lindex $udfOffset $inter]
          udf config -countertype [lindex $udfCountertype $inter]
          incr inter
#          udf set $inter
          }
      }
          udf config -enable $udfEnable
      vlan config -cfi						$tagCfi
      vlan config -mode						$tagMode
      vlan config -repeat					$tagRepeat
         if {$wTag == "true"} {
	  vlan config -vlanID					$tagNo
          } else {
           vlan config -vlanID					none
          }
#      vlan set								$chid $c $p
      
#      vlan set								$chid $c $p
#      stream set							$chid $c $p 1

	  # Define filter & capture
      filter config -captureFilterEnable		true
      filter config -captureTriggerEnable		true
      filter config -userDefinedStat1Enable		false
      filter config -userDefinedStat1DA			addr1
      filter config -captureFilterPattern		anyPattern
      filter config -captureTriggerPattern		anyPattern
      filter config -captureTriggerDA			anyAddr
      filter config -captureFilterDA			anyAddr
#      filter set								$rxch $rxc $rxp

      filterPallette config -DA1 				$destAddr
      filterPallette config -pattern1			$dataPattern
      filterPallette config -patternOffset1 	$patternOffset
#      filterPallette set						$rxch $rxc $rxp
# }
   set portList "$txChas:$txCard:$txPort"
#   writeConfigToHardware one2oneArray
   writeConfigToHardware $portList
   zeroPortStats $txChas $txCard $txPort
   #for {set c $startCardNum} {$c<=[expr $startCardNum + $numIxiaCd - 1]} {incr c 1} { ixiaConf_clearStat $c }
   #just in case some previous function stop capture on these ports
      stream get $txChas $txCard $txPort 1
      set streamSent [stream cget -packetView]
   set pList ""
   lappend pList "$txChas $txCard $txPort"
   lappend pList "$rxChas $rxCard $rxPort"
   ixStartCapture $pList
   if {!$dontTx} {
#      startTx one2oneArray
      startTx $portList
      set time2 [clock seconds]
      #result_debug "*** Frame sent from ($txChas $txCard $txPort) = $streamSent"
#      result_debug "*** Time for Ixia TX setup = [expr $time2-$time1] secs"

      # Make sure TX done
      if { $streamType == "stopStream" } {
         if { ($saMode != "contIncrement") && ($saMode != "contDecrement") &&   \
              ($daMode != "contIncrement") && ($daMode != "contDecrement") } {
            ixiaCheckTxDone $txChas $txCard $txPort $numFrames $txPort
            if { $direction == "2Way" } {
               ixiaCheckTxDone $rxChas $rxCard $rxPort $numFrames $txPort
            }
         }
      }
      after 500
      set time3 [clock seconds]
#     result_debug "*** Time for Ixia TX done = [expr $time3-$time2] secs\n"
      result_debug "*** Ixia port config time [expr $time2-$time1] secs and TX time [expr $time3-$time2] secs\n"
      if {$sMacAddr == "default"} {
         set sMacAddr $srcAddr
      }
      set txPortId [MapIxiaCardnPort $txChas $txCard $txPort]
      set rxPortId [MapIxiaCardnPort $rxChas $rxCard $rxPort]
      displayArpPacketFormat -txPortId $txPortId -rxPortId $rxPortId \
        -direction $direction -destMac $dMacAddr -srcMac $sMacAddr \
        -srcIp $sIpAddr -destIp $dIpAddr -operation $operation \
        -wTag $wTag -tagNo $tagNo -frameSent $streamSent
      return $streamSent
   } else {
      return ""
   }
}

################################################################## 
# Procedure Name: ixiaConf_2Ports_ip   
# Description: 
#	Set up an ixia port to send IP packets (tcp/udp/icmp/igmp)		     
# Input args: args
# Output args: none
# Typical usage: 
#	 set frameSent [ixiaConf_2Ports_ip -numIxiaCd $numIxiaCd \
#             -txChas $chasisId -txCard $card -txPort $port -startCardNum $startCardNum \
#             -rxChas $ch -rxCard $c -rxPort $rxPort \
#             -ipProtocol $protocol -sMacAddr $sourceMac -dMacAddr $destMac \
#             -sIpAddr $sourceIp -dIpAddr $destIp -dDutIpAddr $gatewayIp -ttl $ttl \
#             -pSrcPort $sourcePort -pDstPort $destPort \
#             -frameSizeType $frameSizeType -frameSizeMIN $frameSizeMIN  -frameSizeMAX $frameSizeMAX \
#	      -goodChecksum $goodChecksum -numFrames $numFrames -frameSize $frameSize \
#	      -frameRate $frameRate -dataPattern $dataPattern -streamType $streamType \
#	      -fcsError $fcsError -wTag $wTag -tagNo $tag -TOS $TOS -userPriority $userPriority \
#	      -percentage $percentage -priority $priority -ipOptions $ipOptions -direction $direction \
#             -saMode $saMode -daMode $daMode -ipSaMode $ipSaMode -ipDaMode $ipDaMode -dIpMask $dIpMask sIpMask $sIpMask \
#             -dontFrag $dontFrag -tcpSeqNum $tcpSeqNum -tcpSynFlag $tcpSynFlag -tcpFinFlag $tcpFinFlag \
#             -tcpRstFlag $tcpRstFlag -tcpAckFlag $tcpAckFlag -sequence $sequence -type $type -code $code \
#             -id $id -applyFilter $applyFilter -maxResponseTime $maxResponseTime -groupAddr $groupAddr \
#             -udfEnable $udfEnable -udfInitval $udfInitval -udfOffset $udfOffset -udfCountertype $udfCountertype ]   
# Category: SendTraffic
##################################################################
proc ixiaConf_2Ports_ip {args} {
   parse_args ixiaConf_2Ports_ip $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "1"
      txCard "1"
      txPort "1"
      rxChas "1"
      rxCard "1"
      rxPort "2"
	   ipProtocol "ip"
      pSrcPort "00"
	   pDstPort "00"
	   sMacAddr "default"
	   dMacAddr "00 e0 2b 00 00 01"
	   sIpAddr "127.0.0.1"
	   dIpAddr "127.0.0.1"
      dDutIpAddr "127.0.0.1"
	   sIpMask "255.255.255.0"
	   dIpMask "255.255.255.0"
	   sClass "classC"
      dClass "classC"
	   ttl "64"
	   goodChecksum "true"
	   ipOptions ""
	   ipTotalLength "20"
	   TOS "default"
      numFrames "1"
      frameSize "64"
      frameSizeType "sizeFixed"
      frameSizeMAX "1518"
      frameSizeMIN "64"
      frameRate "default"
      dataPattern "0000"
      frameType "08 00"
      streamType "stopStream"
      fcsError "good"
      wTag "false"
	   tagNo "002"
	   tagCfi "resetCFI"
      	tagMode "vIdle"
	tagRepeat "1"
        protocolTagId "null"
	userPriority "0"
	applyFilter "0"
      	percentage "100"
      	priority "0"
      	sendArp "false"
      	numArpFrames "2"
      	saMode "idle"
      	daMode "idle"
        saCount ""
        daCount ""
      	ipSaMode "ipIdle"
      	ipDaMode "ipIdle"
        ipSaCount ""
        ipDaCount ""
      	dontFrag "true" 
      	tcpSynFlag "false"
      	tcpFinFlag "false"
      	tcpRstFlag "false"
      	tcpAckFlag "false"
        tcpPushFlag "false"
        tcpUrgFlag "false"
      	tcpSeqNum "000000000"
      	type "8"
	code "0"
	id "0"
	sequence "0"
	maxResponseTime "100"
        igmpMode "Fixed"
        igmpRepeatCount ""
	groupAddr "224.0.0.1"
      	chid "1"
      	ipApplication "ip"
     	ripCommand "ripRequest"
     	ripVersion "2"
     	ripAuthen ""
     	ripAuthenType "2"
     	ripNumRoute "1"
     	ripRouteFamilyId {2}
     	ripRouteIp {0.0.0.0}
     	ripRouteTag {00}
     	ripRouteMask {0.0.0.0} 
     	ripRouteNextHop {0.0.0.0}
     	ripRouteMetric {16}
     	udfEnable "false"
        udfInitval "00"
        udfOffset "0"
        udfCountertype "c8"
        udfContinuousCount "false"
        protoOffsetEnable "false"
        protoOffset "14"
        userDefTag ""
        clearStats "yes"
        dontTx "0"
        lengthOverride ""
    }
   
         
#result_debug "@@@ ixiaConf_2Ports_ip: numFrames=$numFrames, ipDaMode=$ipDaMode, sIpAddr=$sIpAddr"
#      puts "-dataPattern $dataPattern \
#        -streamType $streamType -percentage $percentage -TOS $TOS   \
#        -ipProtocol $ipProtocol -pDstPort $pDstPort -pSrcPort $pSrcPort \
#        -dMacAddr $dMacAddr  -sIpAddr $sIpAddr  -dIpAddr $dIpAddr"

#puts "frameSize$frameSize percentage$percentage"
        
   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
#  globalSetDefault
#  protocolStackSetDefault

   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   #result_debug "\n*** date=$date"
   set time1 [clock seconds]
   
   set enableUDF4DVMRP 0
   # a hack to set dvmrp message
   if {$ipProtocol == "dvmrp" } { 
      set ipProtocol "ip"
      set enableUDF4DVMRP 1
   }
   
   set enablepimdm 0
   if {$ipProtocol == "pim-dm" } { 
      set ipProtocol "ip"
      set enablepimdm 1
   }
   
   set patternOffset          30    ;# offset1 for filterPallette pattern1
   set macBroadcast           {FF FF FF FF FF FF}
   set preambleSize           8

   # Create mapping
#   map new -type              one2one
#   map config -type           one2one
   if { $direction == "2Way" } {
#puts "--------------------- ll3 -----------------"
      map add $txChas $txCard $txPort $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort $txChas $txCard $txPort
#puts "--------------------- ll4 -----------------"
   } else  {
      map add $txChas $txCard $txPort $rxChas $rxCard $rxPort
   }
   if { $sendArp == "true" } {
      set numLearnFrames 2
#     learn config -numframes $numLearnFrames
#     send_arp_frames one2oneArray
   }

   #-----------------------------------------------------------------
   # Config streams for validation traffic
   set counter 0
    set chid $txChas
    set c $txCard
    set p $txPort
#   foreach txMap [lsort -dictionary [array names one2oneArray]] { 
#      scan $txMap					   "%d,%d,%d" chid c p
#      set txSpeed					   [port cget -speed]
      set txSpeed					   100
#      stream setDefault
      stream config -numFrames   $numFrames
#      stream config -name        S_${c}_${p}
      stream config -frameSizeType	  $frameSizeType
      stream config -framesize   $frameSize
      #random size
      if {$frameSizeType == "sizeRandom"} {
         stream config -frameSizeType	  $frameSizeType
         stream config -frameSizeMAX      $frameSizeMAX
         stream config -frameSizeMIN      $frameSizeMIN
      }
      decideLoopCount $numFrames $streamType
      if { $frameRate == "default" } {
         set frameRate [decideFrameRate $txSpeed $frameSize $percentage]
      } else {
         set percentage [decidePercentage $txSpeed $frameSize $frameRate]
      }

      stream config -rateMode usePercentRate
      stream config -percentPacketRate $percentage

#result_debug "@@@ frameRate=$frameRate"
#      set ifg [calculateGap $frameRate $frameSize $preambleSize $txSpeed]
      stream config -fcs                       $fcsError
#      stream config -ifg                       $ifg
#      stream config -isg                       $ifg
#      stream config -ibg                       $ifg
      stream config -fir                       false           ;# for timestamp
      stream config -patternType nonRepeat  ;#needed for version 3.1
      stream config -dataPattern $dataPattern
#      stream config -dataPattern	userpattern -pattern $dataPattern
      stream config -frameType $frameType
#     port get						   $chid $c $p
      port get $txChas $txCard $txPort
      set srcAddr					   [port cget -MacAddress]
      after 200   
#      set rxMap						$one2oneArray($txMap)
#     scan [join $rxMap]			"%d %d %d" rxch rxc rxp
   
#      port get						   $rxch $rxc $rxp
      port get						   $rxChas $rxCard $rxPort
      set destAddr					[port cget -MacAddress]
       after 200  
      stream config -saRepeatCounter $saMode 
      stream config -daRepeatCounter $daMode 
      if {$saMode != "idle"} {
          if {$saCount == ""} {
              stream config -numSA $numFrames
          } else {
              stream config -numSA $saCount
          }
      }
      if {$daMode != "idle"} {
          if {$daCount == ""} {
              stream config -numDA $numFrames
          } else {
              stream config -numDA $daCount
          }
      }

      if { $sMacAddr == "default" } { stream config -sa $srcAddr
      } else {                        stream config -sa $sMacAddr }
      
      #Kludge to get the first mac address      
      if {[llength $dMacAddr]>2} {
         set dMacAdd $dMacAddr
      } else {
         set dMacAdd [lindex $dMacAddr $counter]
      }
      if {$counter==0} {
         if {[llength $dMacAddr]>2} {set dMacAddToFilter $dMacAddr} else {set dMacAddToFilter [lindex $dMacAddr 1]}
      } else {
         set dMacAddToFilter [lindex $dMacAddr 0]
      }

      # if IP packet is to multicast fwded, set the DAMAC to be multicast and SA mac to be port mac
      if {[regexp -nocase "01 00 5e" $dMacAddr]} {
         #set dMacAddToFilter $srcAddr   ;# can not figure out for now as maybe L2 or L3 mcast fwding.
         set destAddr $dMacAdd         
      }

      stream config -da 						   $dMacAdd
#      protocol setDefault
	   protocol config -ethernetType  		ethernetII
	   protocol config -name			ip
	   protocol config -enable802dot1qTag		[lindex $wTag $counter]


      switch $ipApplication {
	"rip"  	{ protocol config -appName Rip }
	"ip" -
	default { protocol config -appName ip }
      }	   

#     ip setDefault
      set myDestIpAddr ""
      if { ($chid == $txChas) && ($c == $txCard) && ($p == $txPort) } {
	      ip config -sourceClass					$sClass
         ip config -sourceIpAddr				   $sIpAddr
	      ip config -sourceIpMask				   $sIpMask
         ip config -destClass					   $dClass
	      ip config -destIpAddr					$dIpAddr
	      ip config -destIpMask					$dIpMask
  	      set myDestIpAddr $dIpAddr
	  } else {
	      ip config -sourceClass					$dClass
         ip config -sourceIpAddr				   $dIpAddr
	      ip config -sourceIpMask				   $dIpMask
         ip config -destClass					   $sClass
	      ip config -destIpAddr					$sIpAddr
	      ip config -destIpMask					$sIpMask
  	      set myDestIpAddr $sIpAddr
	  }

     ip config -sourceIpAddrMode 				$ipSaMode 
     ip config -sourceIpAddrRepeatCount		1
     ip config -destIpAddrMode					$ipDaMode 
	  ip config -destIpAddrRepeatCount			1
	  ip config -destMacAddr					   $dMacAddr
     ip config -destDutIpAddr					   $dDutIpAddr
	
     if {$ipSaMode != "ipIdle"} {
         if {$ipSaCount == ""} {
             ip config -sourceIpAddrRepeatCount $numFrames
         } else {
             ip config -sourceIpAddrRepeatCount $ipSaCount
         }
     }
     if {$ipDaMode != "ipIdle"} {
         if {$ipDaCount == ""} {
             ip config -destIpAddrRepeatCount $numFrames
         } else {
             ip config -destIpAddrRepeatCount $ipDaCount
         }
     }

	  ip config -ipProtocol                   $ipProtocol
	  ip config -ttl                          $ttl
	  ip config -useValidChecksum             $goodChecksum
      
     if {$dontFrag == "true" } {
        ip config -fragment                     1
     } else {
        ip config -fragment                     0
     }

     if {[string length $ipOptions]} {
         ip config -options						$ipOptions
     }

	  if {$TOS != "default" } {
#	  	   puts "TOS |$TOS|"
	      set precedence [expr [expr $TOS&0x80]==0x80][expr [expr $TOS&0x40]==0x40][expr [expr $TOS&0x20]==0x20]b
#	      puts "Precedence |$precedence|"
	      set key(000b) routine
	      set key(001b) priority
	      set key(010b) immediate
	      set key(011b) flash
	      set key(100b) flashOverride
	      set key(101b) criticEcp
	      set key(110b) internetControl
	      set key(111b) networkControl
   	  if {([expr $TOS & 0x10] == 0x10)} {
   	      ip config -delay                 1
   	   } else { ip config -delay           0 }
   	  if {([expr $TOS & 0x08] == 0x08)} {
            ip config -throughput            1
   	   } else { ip config -throughput      0 }
   	  if {([expr $TOS & 0x04] == 0x04)} {
   	      ip config -reliability					   1
   	   } else { ip config -reliability				0 }
   	  ip config -precedence						$key($precedence)
   	  ip config -tos						$TOS
      } else { 
          set TOS "00"
   	  ip config -tos						$TOS
      }
#      card get                                             $chid $c
#      set ixiaCardType                                     [card cget -typeName]
#      set flag [regexp -nocase "XMS|XMV" $ixiaCardType]
       set flag 0
      if {$ipTotalLength != "default" } {

        if {$lengthOverride != "" } {
         ip config -lengthOverride $lengthOverride
        } else {

        # For XMS or XMV ixia card type when ipTotalLength is not equal to default,lengthOverride must be false
        # If not it will be treated as bad packet Hence added the below code
          if !{$flag} {
             ip config -lengthOverride "true"
          }
        }                  
         ip config -totalLength  $ipTotalLength
         ip config -identifier 6558 ;#14700      
      }
      if {$lengthOverride != "" } {
         ip config -lengthOverride $lengthOverride
      }
 #     ip set                                  $chid $c $p

      switch $ipProtocol {
	"tcp"  { tcpConfig $chid $c $p $pSrcPort $pDstPort $tcpSeqNum $tcpSynFlag $tcpFinFlag $tcpRstFlag $tcpAckFlag $tcpPushFlag $tcpUrgFlag}
	"udp"  { udpConfig $chid $c $p $pSrcPort $pDstPort }
	"icmp" { icmpConfig $chid $c $p $type $code $id $sequence}
	"igmp" { igmpConfig $chid $c $p $groupAddr $type $maxResponseTime $igmpMode $igmpRepeatCount
	         if {$type==18} {
               igmp config -version 1
               igmp config -maxResponseTime 00
#               igmp set $chid $c $p
	         }
	       }
      }
      if  { $ipApplication == "rip" } {
#        rip setDefault
        rip config -command 	$ripCommand
        rip config -version	$ripVersion 
        
#        ripRoute setDefault
#        for {set index 0} {$index < $ripNumRoute } {incr index} {
#          set routeID [expr $index + 1]
#    	  result_debug "Setting route $routeID to [lindex $ripRouteIp $index]"
#          ripRoute set $routeID
#        }  
#        rip set 	$chid $c $p
#    	  ripRoute config -familyId [lindex $ripRouteFamilyId $index ]
#    	  ripRoute config -routeTag [lindex $ripRouteTag $index ]
#          ripRoute config -ipAddress [lindex $ripRouteIp $index ]
#          ripRoute config -subnetMask [lindex $ripRouteMask $index ]
#          ripRoute config -nextHop [lindex $ripRouteNextHop $index ]
#          ripRoute config -metric [lindex $ripRouteMetric $index ]
    	  ripRoute config -familyId $ripRouteFamilyId
    	  ripRoute config -routeTag $ripRouteTag
          ripRoute config -ipAddress $ripRouteIp
          ripRoute config -subnetMask $ripRouteMask
          ripRoute config -nextHop $ripRouteNextHop
          ripRoute config -metric $ripRouteMetric
      }
      if {$protocolTagId != "null"} {
          set decProtoTagId [expr $protocolTagId]
          vlan config -protocolTagId                            $decProtoTagId
      }
            
      vlan config -cfi							   $tagCfi
      vlan config -mode							   $tagMode
      vlan config -repeat						   $tagRepeat
      vlan config -userPriority			      $userPriority
      if {$protocolTagId != "null"} {
          set decProtoTagId [expr $protocolTagId]
          vlan config -protocolTagId                            $decProtoTagId
      }      
      if {[lindex $wTag $counter]=="true"} {
         vlan config -vlanID						[lindex $tagNo $counter]
#         vlan set									   $chid $c $p
      }
      incr counter

      #overwrite the ip protocol into igmp protocol, so the datapattern can go right
      #after the ip header and not after igmp header is used igmp directly
      if { $enableUDF4DVMRP } {
#         udf setDefault
         udf config -enable "true"
         udf config -initval "02"
         udf config -offset 23
         udf config -countertype "c8"
#         udf set 1
      }
      
      if {$enablepimdm} {
#         udf setDefault
       udf config -enable "true"
         udf config -initval "67"
         udf config -offset 23
         udf config -countertype "c8"
#         udf set 1
      }
#      stream set                             $chid $c $p 1

      #set packet group to default, otherwise will cause ICMP bad CRC
##      packetGroup setDefault						
#      packetGroup setTx                      $chid $c $p 1

      # Define UDF package 
      if {$udfEnable == "true"} {
          set inter 0
          foreach udfOffs $udfOffset {
          udf config -enable "true"
          udf config -continuousCount [lindex $udfContinuousCount $inter]
          udf config -initval [lindex $udfInitval $inter]
          udf config -offset [lindex $udfOffset $inter]
          udf config -countertype [lindex $udfCountertype $inter]
          incr inter
#          udf set $inter
          }
      }
          udf config -enable $udfEnable
      # define protocolOffset
      if {$protoOffsetEnable == "true"} {
#         protocolOffset setDefault
         protocolOffset config -enable true
         protocolOffset config -offset $protoOffset
         protocolOffset config -userDefinedTag $userDefTag
#         if [protocolOffset set $txChas $txCard $txPort] {
#            result_debug "Error in protocolOffset set for \
#                          $txChas $txCard $txPort"
#         }
      } else {
#         protocolOffset setDefault
         protocolOffset config -enable false
#        protocolOffset set $txChas $txCard $txPort
      }
#      stream set                             $chid $c $p 1
          
      # Define filter & capture

      filter config -captureFilterEnable		true
      filter config -captureTriggerEnable		true
      if {$applyFilter} {
         filter config -userDefinedStat1Enable  true
         # In case of mcast fwding, dont care of SA1 value
         if {[regexp -nocase "01 00 5e" $dMacAddr]} {
            filter config -userDefinedStat1SA      anyPattern
         } else {
            filter config -userDefinedStat1SA      addr1
         }
      } else {
         filter config -userDefinedStat1Enable  false
      }
      filter config -userDefinedStat1DA      addr1
      
      filter config -captureFilterPattern		anyPattern
      filter config -captureTriggerPattern   anyPattern
      filter config -captureTriggerDA			anyAddr
      filter config -captureFilterDA			anyAddr
      filter config -userDefinedStat1Pattern      pattern1
#      filter set                             $rxch $rxc $rxp

      filterPallette config -DA1 				$destAddr
      filterPallette config -matchType1   matchIpDAEthernetII
      set fir ""
      set sec ""
      set thi ""
      set fou ""
#      scan $myDestIpAddr %d.%d.%d.%d fir sec thi fou
      if {($fir!="")&&($sec!="")&&($thi!="")&&($fou!="")} {
         set pattern1 [string toupper [format "%02x %02x %02x %02x" $fir $sec $thi $fou]]
      } else {
         set pattern1 ""
      }
      filterPallette config -pattern1     $pattern1
      filterPallette config -SA1          $dMacAddToFilter

      filterPallette config -patternOffset1 	$patternOffset
#     filterPallette set                     $rxch $rxc $rxp
#      puts "the set is $rxch, $rxc, $rxp with DA1 $destAddr, Pattern1 $myDestIpAddr, SA1 $dMacAddToFilter"
#   }
#   writeConfigToHardware one2oneArray
   set portList "$txChas:$txCard:$txPort"
    if {[ixWriteConfigToHardware $portList -noProtocolServer]} {
	ixPuts "failed to do ixWritePortsToHardware.\n$::ixErrorInfo"
    }
#   writeConfigToHardware $portList
   if {$clearStats == "yes" } {
       zeroPortStats $txChas $txCard $txPort
   }
   #for {set c $startCardNum} {$c<=[expr $startCardNum + $numIxiaCd - 1]} {incr c 1} { ixiaConf_clearStat $c }
   #just in case some previous function stop capture on these ports
      stream get $txChas $txCard $txPort 1
      set streamSent [stream cget -packetView]
   set pList ""
   lappend pList "$txChas $txCard $txPort"
   lappend pList "$rxChas $rxCard $rxPort"
   ixStartCapture $pList
   if {!$dontTx} {
#      startTx one2oneArray
      startTx $portList
      set time2 [clock seconds]
      #result_debug "*** Frame sent from ($txChas $txCard $txPort) = $streamSent"
#      result_debug "*** Time for Ixia TX setup = [expr $time2-$time1] secs"
      # Make sure TX done
      if { $streamType == "stopStream" } {
         if { ($saMode != "contIncrement") && ($saMode != "contDecrement") &&  
              ($daMode != "contIncrement") && ($daMode != "contDecrement") } {
            ixiaCheckTxDone $txChas $txCard $txPort $numFrames $txPort
            #Reset the filter
            if { $direction == "2Way" } {
               ixiaCheckTxDone $rxChas $rxCard $rxPort $numFrames $txPort
            }
         # Reset the filters
         if {$applyFilter} {
            result_debug "resetting the UDS1 settings"
#            foreach txMap [lsort -dictionary [array names one2oneArray]] {
#              scan $txMap					   "%d,%d,%d" chid c p
#              set rxMap						$one2oneArray($txMap)
#              scan [join $rxMap]			"%d %d %d" rxch rxc rxp
               filter config -userDefinedStat1Enable  false
               filter config -userDefinedStat2Enable  false
#              filter set $rxch $rxc $rxp
#              filterPallette setDefault
#              filterPallette set $rxch $rxc $rxp
#            }
#           writeConfigToHardware one2oneArray
           writeConfigToHardware $portList
         }
      }
      }
   after 1000
      set time3 [clock seconds]
#      result_debug "*** Time for Ixia TX done = [expr $time3-$time2] secs\n"
      result_debug "*** Ixia port config time [expr $time2-$time1] secs and TX time [expr $time3-$time2] secs\n"
      if {$sMacAddr == "default"} {
         set sMacAddr $srcAddr
      }
      set txPortId [MapIxiaCardnPort $txChas $txCard $txPort]
      set rxPortId [MapIxiaCardnPort $rxChas $rxCard $rxPort]
      displayIpPacketFormat -txPortId $txPortId  -rxPortId $rxPortId \
                    -direction $direction -frameSent $streamSent \
                    -streamType $streamType -destMac $dMacAddr \
                    -srcMac $sMacAddr -srcIp $sIpAddr -destIp $dIpAddr \
                    -numFrames $numFrames -protocol $ipProtocol \
                    -tcpSynFlag $tcpSynFlag -tcpFinFlag $tcpFinFlag \
                    -tcpRstFlag $tcpRstFlag -tcpAckFlag $tcpAckFlag \
                    -tcpPushFlag $tcpPushFlag -tcpUrgFlag $tcpUrgFlag \
                    -tcpSeqNum $tcpSeqNum -tcpPushFlag $tcpPushFlag \
                    -sourcePort $pSrcPort -destPort $pDstPort -tag $tagNo \
                    -userPriority $userPriority -saMode $saMode \
                    -saCount $saCount -daMode $daMode -daCount $daCount \
                    -ipSaMode $ipSaMode -ipSaCount $ipSaCount \
                    -ipDaMode $ipDaMode -ipDaCount $ipDaCount \
                    -percentage "$percentage"
      return $streamSent
   } else {
      return ""
   }
}

##################################################################    
# Procedure Name: tcpConfig
# Description:
#     	This proc is used to configure TCP header fields on an ixia port
#	before sending IP/TCP packets. 
# Input args: chid c p pSrcPort pDstPort {seqNum} {synFlag} {finFlag} {rstFlag} {ackFlag}
# Output args: None
# Typical usage:
#	tcpConfig $chid $c $p $pSrcPort $pDstPort $tcpSeqNum $tcpSynFlag $tcpFinFlag $tcpRstFlag $tcpAckFlag
# Category: SetupTestTool
##################################################################
proc tcpConfig {chid c p pSrcPort pDstPort {seqNum "0"} {synFlag "false"} {finFlag "flase"} {rstFlag "false"} {ackFlag "false"} {pushFlag "false"} {urgFlag "false"}} {
   set len [string length $pSrcPort]
   if {$len == 4 && [string index $pSrcPort 0] == "0"} {
   append pSrcPort1 [string index $pSrcPort 1] [string index $pSrcPort 2] [string index $pSrcPort 3]
   tcp config -sourcePort	[format %04x $pSrcPort1]
   } else {
   tcp config -sourcePort	[format %04x $pSrcPort]
   }
   tcp config -destPort		[format %04x $pDstPort]
   tcp config -sequenceNumber	[format %08x $seqNum]
   tcp config -synchronize      $synFlag
   tcp config -finished		$finFlag
   tcp config -resetConnection	$rstFlag
   tcp config -acknowledgeValid	$ackFlag
   tcp config -pushFunctionValid $pushFlag
   tcp config -urgentPointerValid $urgFlag
#   tcp set $chid $c $p
}

##################################################################    
# Procedure Name: udpConfig
# Description:
#     	This proc is used to configure UDP header fields on an ixia port
#	before sending IP/UDP packets. 
# Input args: chid c p pSrcPort pDstPort
# Output args: None
# Typical usage:
#	udpConfig $chid $c $p $pSrcPort $pDstPort
# Category: SetupTestTool
##################################################################
proc udpConfig { chid c p pSrcPort pDstPort {ckSum 0} } {
   udp config -sourcePort	[format %04x $pSrcPort]
   udp config -destPort		[format %04x $pDstPort]
   udp config -checksumMode $ckSum
#  udp set $chid $c $p
}

##################################################################    
# Procedure Name: icmpConfig
# Description:
#     	This proc is used to configure ICMP header fields on an ixia port
#	before sending IP/ICMP packets. 
# Input args: chid c p type code id sequence
# Output args: None
# Typical usage:
#	icmpConfig $chid $c $p $type $code $id $sequence
# Category: SetupTestTool
##################################################################
proc icmpConfig { chid c p type code id sequence } {
   icmp config -type		$type
   icmp config -code		$code
   icmp config -id			$id
   icmp config -sequence	$sequence
#   icmp set $chid $c $p
}

##################################################################    
# Procedure Name: igmpConfig
# Description:
#     	This proc is used to configure IGMP header fields on an ixia port
#	before sending IP/IGMP packets. 
# Input args: chid c p groupIp type maxResponseTime
# Output args: None
# Typical usage:
#	igmpConfig $chid $c $p $groupAddr $type $maxResponseTime
# Category: SetupTestTool
##################################################################
proc igmpConfig { chid c p groupIp type maxResponseTime igmpMode igmpCount} {
   igmp config -type		$type
   igmp config -groupIpAddress		$groupIp
   igmp config -maxResponseTime     $maxResponseTime
   igmp config -mode $igmpMode
   igmp config -repeatCount $igmpCount
#  igmp set $chid $c $p
}

##################################################################    
# Procedure Name: setDhcpOptions
# Description:
#     	This proc is used to set the ixia DHCP options specified in the 
#	optionCodeList. 
# Input args: OptionCodeList
# Output args: None
# Typical usage:
#	setDhcpOptions $optionCodeList
# Category: SetupTestTool
##################################################################
proc setDhcpOptions {OptionCodeList} {

    upvar $OptionCodeList optionCodeList
    set retCode 0

    # make sure there's an 'end' at the back end of each set of options
    lappend optionCodeList dhcpEnd ff

    foreach {option data} $optionCodeList {
        #ixPuts "option: $option"
        #ixPuts "  data:   $data\n"
#        dhcp config -optionData       $data
#        if [dhcp setOption $option] {
#            #ixPuts "Error setting DHCP option <$option>"
#            result_debug "Error setting DHCP option <$option>"
#            set retCode 1
#            continue
#        }
    }
    return $retCode
}
