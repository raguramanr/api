<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>result.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#result.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>result.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="result.tcl-annot.html">annotations</a> | <a href="result.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line"># Utilities for result file manipulation</span>
global LIB_PATH

<span class="comment-line"># Various Internal Variables</span>
set EX_RESULT_LEVEL 2
set EX_DEBUG 1

<span class="comment-line"># The output_level definitiions</span>

set EX_RESULT_LEVEL_INFO(0) {debug log print}
set EX_RESULT_LEVEL_INFO(1) {warning error debug log print}
set EX_RESULT_LEVEL_INFO(2) {warning error h1 h2 h3 p ok skip debug perfData log print}
set EX_RESULT_LEVEL_INFO(3) {warning error h1 h2 h3 p ok skip pre debug perfData log print}
set EX_RESULT_LEVEL_INFO(4) {warning error h1 h2 h3 p ok skip pre debug perfData log print}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: fmt_add</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: internal lib command to define result_* commands</span>
<span class="comment-line">#              Adds the selected format to the formatting commands.</span>
<span class="comment-line">#              uses result_format.tcl file to define the procs</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: fmt, defs</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line"># fmt_add h3 {</span>
<span class="comment-line"># 	color &#34;blue&#34;</span>
<span class="comment-line"># 	htmlstart &#34;&lt;h3&gt;&#34;</span>
<span class="comment-line"># 	start &#34;&#34;</span>
<span class="comment-line"># 	line &#34;** %% **&#34;</span>
<span class="comment-line"># 	end &#34;&#34;</span>
<span class="comment-line"># 	htmlend &#34;&lt;/h3&gt;&#34;</span>
<span class="comment-line"># }</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::show_text_date_42">proc <a href="result.tcl-annot.html#::::show_text_date">::::show_text_date</a></a></strong> { txt {extended no}} {
    global whichDutNow
    if {$extended == &#34;yes&#34;} {
        set tm [exec date &#34;+%m/%d/%y %H:%M:%S&#34;]
    } else {
        set tm [exec date &#34;+%H:%M:%S&#34;]
    }
    append txt &#34; - &#34;
    append txt $tm
    return $txt
}

<strong><a name="::::show_text_date_dut_54">proc <a href="result.tcl-annot.html#::::show_text_date_dut">::::show_text_date_dut</a></a></strong> { txt {extended no}} {
    global whichDutNow
    if {$extended == &#34;yes&#34;} {
        set tm [exec date &#34;+%m/%d/%y %H:%M:%S&#34;]
    } else {
        set tm [exec date &#34;+%H:%M:%S&#34;]
    }
    if {[info exists whichDutNow]} {
        append txt &#34; - DUT${whichDutNow} - &#34;
    } else {
        append txt &#34; - &#34;
    }
    append txt $tm
    return $txt
}

<strong><a name="::::fmt_add_70">proc <a href="result.tcl-annot.html#::::fmt_add">::::fmt_add</a></a></strong> {fmt defs {newColor &#34;null&#34;}} {
    global EX_RESULT_FORMAT erf

    set cmd &#34;&#34;

    <span class="comment-line"># Set the defaults</span>
    set erf($fmt,color) &#34;white&#34;
    set erf($fmt,htmlstart) &#34;&#34;
    set erf($fmt,start) &#34;&#34;
    set erf($fmt,line) &#34;%%&#34;
    set erf($fmt,end) &#34;&#34;
    set erf($fmt,htmlend) &#34;&#34;

    <span class="comment-line"># Search through the format list and add each key to the</span>
    <span class="comment-line"># EX_RESULT_FORMAT array.</span>
    foreach {key value} $defs {
        if {$key == &#34;cmd&#34;} {
            <span class="comment-line"># if the key is cmd, then we need to store it</span>
            set cmd $value
        } else {
            if {$key == &#34;color&#34; &amp;&amp; $newColor != &#34;null&#34;} {
                set erf($fmt,$key) $newColor
            } else {
                set erf($fmt,$key) $value
            }
        }
    }

    <span class="comment-line"># If we got cmd (and it's not NULL)</span>
    if {$cmd != &#34;&#34;} {
        <span class="comment-line"># We need ot make a new procedure that executs cmd as well</span>
        <span class="comment-line"># as the normal result_fmt command.</span>
        if {($fmt == &#34;perfData&#34;) || ($fmt == &#34;log&#34;)} {
               <strong><a name="::::"result_$fmt"_103">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;$cmd \$text;\nresult_fmt $fmt \[show_text_date_dut \$text\]&#34;
            } elseif { ($fmt == &#34;debug&#34;) || ($fmt == &#34;error&#34;)} {
               if  { ($fmt == &#34;debug&#34;)} {
                 <strong><a name="::::"result_$fmt"_106">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;$cmd;\nresult_fmt $fmt \$text;\nshowDebugInfo $fmt&#34;
               } else {
                 <strong><a name="::::"result_$fmt"_108">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;$cmd;\nresult_fmt $fmt \[show_text_date_dut \$text\];\
                            \nshowDebugInfo $fmt;\n_analyzeFailure \$text;&#34;
               }
            } elseif {$fmt == &#34;h1&#34;} {
               <strong><a name="::::"result_$fmt"_112">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;$cmd;\nresult_fmt $fmt \[show_text_date \$text yes\]&#34;
            } else {
               <strong><a name="::::"result_$fmt"_114">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;$cmd;\nresult_fmt $fmt \[show_text_date_dut \$text\]&#34;
            }
    } else {
        <span class="comment-line"># Otherwise, we just call the result_fmt command</span>
        switch -exact -- $fmt {
           &#34;h1&#34; {
                <strong><a name="::::"result_$fmt"_120">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;puts \&#34;\&#34;; result_fmt $fmt \[show_text_date \$text yes\]&#34;
           }
           &#34;h2&#34; {
                <strong><a name="::::"result_$fmt"_123">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;puts \&#34;\&#34;; result_fmt $fmt \[show_text_date \$text\]&#34;
           }
           &#34;p&#34; {
                <strong><a name="::::"result_$fmt"_126">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;puts \&#34;\&#34;; result_fmt $fmt \[show_text_date_dut \$text\]&#34;
           }
           &#34;print&#34; {
                <strong><a name="::::"result_$fmt"_129">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;puts \&#34;\&#34;; result_fmt $fmt \[show_text_date_dut \$text\]&#34;
           }
           default {
                <strong><a name="::::"result_$fmt"_132">proc <a href="result.tcl-annot.html#::::"result_$fmt"">::::"result_$fmt"</a></a></strong> &#34;text&#34; &#34;puts \&#34;\&#34;; result_fmt $fmt \[show_text_date \$text\]&#34;
           }
        }
    }
}

<span class="comment-line"># Load the format definitions</span>
<span class="comment-line"># Don't move this line - It have to be here !!!</span>
<span class="comment-line">#source &#34;../../Lib/result_format.tcl&#34;</span>
source &#34;$LIB_PATH/result_format.tcl&#34;
source &#34;$LIB_PATH/pdList.tcl&#34;

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: ex_cat</span>
<span class="comment-line">#   </span>
                   <span class="comment-line">#proc &#34;result_$fmt&#34; &#34;text&#34; &#34;$cmd;\nshowDebugInfo $fmt;\nresult_fmt $fmt \$text&#34;</span>
<span class="comment-line"># Description: internal lib command to read and return the data from a file</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: file</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: string read from file</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#	set data [ex_cat $report]</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::ex_cat_161">proc <a href="result.tcl-annot.html#::::ex_cat">::::ex_cat</a></a></strong> {file} {
	if {![file exists $file]} {
		return &#34;&#34;
	}
	
	set fid [open $file]
	set data [read $fid]
	close $fid
	
	return $data
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: get_result_dir</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Returns the result directory. If it does not exist, it will be created.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none  </span>
<span class="comment-line">#  </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># </span>
<span class="comment-line"># Return value: String value of result directory</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              get_result_dir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::get_result_dir_189">proc <a href="result.tcl-annot.html#::::get_result_dir">::::get_result_dir</a></a></strong> {{randomIndex &#34;unknown&#34;}} {
   <span class="comment-line"># Need to understand before change this global variable! </span>
   global resultDir MAIN

   if {$resultDir == &#34;NULL&#34;} {
     set resultDir [<a name="::find_new_result_dir(1)"><a href="./result.tcl.html#::find_new_result_dir_228">::find_new_result_dir</a></a> $randomIndex]
     set MAIN(RESULTDIR) $resultDir
     <span class="comment-line">#</span>
     <span class="comment-line"># EY-03-22-2013: Instead of just checking for permission denied errors,</span>
     <span class="comment-line"># check for any abnormal return code and print out the error.</span>
     if {[catch {eval [file mkdir $resultDir]} reason]} {
         puts stderr &#34;get_result_dir: Couldn't create $resultDir directory: $reason&#34;;
         flush stderr;
         return &#34;&#34;;
     }
<span class="comment-line">#     if [regexp -nocase &#34;permission denied&#34; $reason] {</span>
<span class="comment-line">#             puts stderr &#34;$reason&#34;</span>
<span class="comment-line">#             return &#34;&#34;</span>
<span class="comment-line">#     }</span>
   }

   return $resultDir
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: find_new_result_dir</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Uses the current date to find a new result directory.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none  </span>
<span class="comment-line">#  </span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#             result directory        </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#             find_new_result_dir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::find_new_result_dir_228">proc <a href="result.tcl-annot.html#::::find_new_result_dir">::::find_new_result_dir</a></a></strong> { randomIndex } {
    global tStartDateString MAIN

    if {![info exists tStartDateString]} {
        set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]
    }
    
    if {![info exists MAIN(RESULTPATH)]} {
        set MAIN(RESULTPATH) &#34;Result&#34;
        set tmp &#34;Result&#34;
    } else {
        set tmp $MAIN(RESULTPATH)
    }
    <span class="comment-line"># Make sure that the result directory does not exist.</span>
    <span class="comment-line">#puts &#34;find_new_result_dir startDate: $tStartDateString&#34;</span>
    set pwd [pwd]
    if {[regexp -nocase &#34;clitest&#34; $pwd]} {
       global resultPath
       set tmp $resultPath
    }
    
    if { $randomIndex == &#34;unknown&#34;} {
      set range 1000000
      set randomIndex [expr {int(rand()*$range)}]
    }
    set dname [format %s_%s $tStartDateString $randomIndex]
    set dir &#34;$tmp/$dname&#34;

    return $dir
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: open_result_file</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Opens result file</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#              test name - test case name  </span>
<span class="comment-line">#              mode - read/write</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:.. </span>
<span class="comment-line">#             file descriptor        </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#             open_result_file $test $mode</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::open_result_file_276">proc <a href="result.tcl-annot.html#::::open_result_file">::::open_result_file</a></a></strong> {test {mode &#34;a&#34;}} {
	global EX_RESULT_FILE EX_RESULT_FILE_HTML MAIN

    set MAIN(APPROXTIME1) [clock seconds]
    set MAIN(CURRENTTESTCASE) $test

    <span class="comment-line">#Code to FAKE run test cases just to get their testNo</span>
    if {[info exists MAIN(GETTESTNUMS)] &amp;&amp; $MAIN(GETTESTNUMS)} {
        return -code return $test
    }

	<span class="comment-line"># set the result files</span>
	set EX_RESULT_FILE [open &#34;[<a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$test.txt&#34; &#34;$mode&#34;]

    <span class="comment-line"># Update the file that holds all test case mappings</span>
    set r [catch {info level [expr [info level] - 1]} e]
    if {$r} {
        <span class="comment-line">#puts &#34;Called directly by the interpreter (e.g.: .tcl on the partyline).&#34;</span>
    } else {
        <a name="::map_proc_to_result_file(1)"><a href="./result.tcl.html#::map_proc_to_result_file_321">::map_proc_to_result_file</a></a> $e $test
    }

    <span class="comment-line"># SKIP FEATURE SECTION STILL HAS SMALL RESULT TEXT FILES SO UPLOAD WORKS</span>
    if {[info exists MAIN(MAKESKIPRESULTFILE)] &amp;&amp; $MAIN(MAKESKIPRESULTFILE)} {
        global title fd_res
        set fd_res $EX_RESULT_FILE
        <span class="comment-line">#_setShowOutput -screen off -log on -res_fmt on</span>
        if {[info exists title]} {
            result_h1 &#34;$title&#34;;
            <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$title&#34;;
        } else {
            result_h1 &#34;$test will be skipped. No Feature support on platform&#34;;
            <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;$test will be skipped. No Feature support on platform&#34;;
        }
        result_skip &#34;$test Skipped due to platform Support&#34;
        <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>;
        <span class="comment-line">#_setShowOutput -screen on -log on -res_fmt on</span>
        close $fd_res
        set EX_RESULT_FILE &#34;&#34;
        return -code return $test
    }
	<span class="comment-line"># !! WARNING !!</span>
	<span class="comment-line"># DO NOT USE THIS DISCRIPTOR, IT MAY BE GONE IN FUTURE VERSIONS</span>
	return $EX_RESULT_FILE
}
<strong><a name="::::map_proc_to_result_file_321">proc <a href="result.tcl-annot.html#::::map_proc_to_result_file">::::map_proc_to_result_file</a></a></strong> {testproc resultfile} {
    global LISTINFO PHPLSTCOUNT

    if {![info exists LISTINFO(&#34;any&#34;)]} {
        return; <span class="comment-line">#Variable has not been set yet</span>
    }
    if {[lsearch $LISTINFO(&#34;any&#34;) $testproc] &lt; 0} {
        return; <span class="comment-line">#This is not a proc in the completetests.lst</span>
    }
    if {[info exists LISTINFO($testproc)]} {
        set l $LISTINFO($testproc)
    } else {
        set l &#34;not_set&#34;
    }

    set fd_me [open &#34;[<a name="::get_result_dir(2)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/testfile_map.txt&#34; &#34;a&#34;]
    puts $fd_me &#34;#proc: $testproc file: $resultfile.txt list: $l&#34;
    puts $fd_me &#34;lappend procs_executed \&#34;$testproc\&#34;&#34;
    puts $fd_me &#34;set procFile(\&#34;$testproc\&#34;) \&#34;$resultfile.txt\&#34;&#34;
    close $fd_me

    if {[info exists PHPLSTCOUNT]} {incr PHPLSTCOUNT;} else {set PHPLSTCOUNT 0}
    set fd_php [open &#34;[<a name="::get_result_dir(3)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/testfile_php_map.txt&#34; &#34;a&#34;]
    puts $fd_php &#34;\$tcllists\[\&#34;$l\&#34;]\[$PHPLSTCOUNT] = \&#34;$testproc\&#34;; \$testlist\[\&#34;$testproc\&#34;] = \&#34;$l\&#34;;&#34;
    close $fd_php

}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: close_result_file</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: closes the current result file. </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#              none        </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#             close_result_file $fid</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::close_result_file_363">proc <a href="result.tcl-annot.html#::::close_result_file">::::close_result_file</a></a></strong> {{fid &#34;&#34;}} {
<span class="comment-line">#	global EX_RESULT_FILE EX_RESULT_FILE_HTML</span>
	global EX_RESULT_FILE
	
	set fid $EX_RESULT_FILE
        <span class="comment-line">#regex is just to make sure fid is a valid fid</span>
        <span class="comment-line">#if {[regexp -nocase {[0-9a-zA-Z]} $fid]} {</span>
        <span class="comment-line">#   dumpStackUtilizationInfo</span>
        <span class="comment-line">#}</span>
	if {$fid != &#34;&#34;} {
		close $fid
	}

	set EX_RESULT_FILE &#34;&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: iswhite</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Returns true if char is a white space (space, tab, new line, or</span>
<span class="comment-line"># carriage return), fales if it isn't.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: char</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: 1 or 0</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#	set result [iswhite &#34;abc&#34;]</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::iswhite_396">proc <a href="result.tcl-annot.html#::::iswhite">::::iswhite</a></a></strong> {char} {
	return [regexp {[ \t\n\r]} $char]
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: get_next_char</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Returns the next character in string relative to index. We also</span>
<span class="comment-line"># incriment index so successive calls to get_next_char will always</span>
<span class="comment-line"># return the next character.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: str</span>
<span class="comment-line"># Output args: index</span>
<span class="comment-line"># Return value: integer</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#     set char [get_next_char $str i]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::get_next_char_417">proc <a href="result.tcl-annot.html#::::get_next_char">::::get_next_char</a></a></strong> {str index} {
	upvar $index i
	incr i
	return [string index $str [expr {$i - 1}]]
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: clip_string_with_wrap</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Changes a string (str) into a list of lines. Wrapps the lines</span>
<span class="comment-line"># at col. This function should work on a single line, or two hundered</span>
<span class="comment-line"># lines. It is horribly inefficient and should be re-written in C.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: str,col</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: string</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#  set para [clip_string_with_wrap $p [expr {78 - [string length $erf($style,line)] + 2}]]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::clip_string_with_wrap_440">proc <a href="result.tcl-annot.html#::::clip_string_with_wrap">::::clip_string_with_wrap</a></a></strong> {str col} {
	<span class="comment-line"># Initialize our variables</span>
	set ret {}
	set pos 0
	set line &#34;&#34;
        set strLength [string length $str]

	<span class="comment-line"># Loop until we are done with the string</span>
	for {set i 0} {$i &lt; $strLength } {incr i} {
		<span class="comment-line"># Get the nex character</span>
		set char [string index  $str $i]
		
		<span class="comment-line"># Test to see if we are past the column limit</span>
		if {($pos) &gt;= $col} {
			<span class="comment-line"># If we are, append the current line to the return list</span>
			lappend ret $line
			<span class="comment-line"># Re-initialize the line</span>
			set line &#34;&#34;
			<span class="comment-line"># Append the character to the line</span>
			append line $char
			<span class="comment-line"># Set the position to 1 (we already have 1 character)</span>
			set pos 1
		} else {
			<span class="comment-line"># Oterwise, append the character to the line</span>
			append line $char
			<span class="comment-line"># Incriment the position</span>
			incr pos
		}
	}

	<span class="comment-line"># Figure out how long the line was, and subtract that from our</span>
	<span class="comment-line"># column limit. The purpose of this is to padd the last line</span>
	<span class="comment-line"># with spaces so that any surrounding formatting appears as it should.</span>
        <span class="comment-line"># commented out. Creates problems. Seems unncessary</span>

	<span class="comment-line">#set i [expr {$col - [string length $line]}]</span>
	<span class="comment-line">#while {$i &gt; 0} {</span>
	<span class="comment-line">#	#append line &#34; &#34;</span>
	<span class="comment-line">#	incr i -1</span>
	<span class="comment-line">#}</span>

	<span class="comment-line"># Append the last line to ret.</span>
	lappend ret $line

	<span class="comment-line"># Return the list of lines.</span>
	return $ret
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: mputs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line"># Put multiple argumets to multiple file descriptors. The first argument</span>
<span class="comment-line"># fdl is a list of file descriptors. All remaining arguments are then</span>
<span class="comment-line"># put to the file descriptors WITH OUT NEW LINES. So, the following</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: fd, args</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#   mputs {stdout stderr} &#34;Testing, &#34; &#34;the&#34; &#34; system\n&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># puts &#34;Testing, the system\n&#34; to standard out. (The \n is a literal new</span>
<span class="comment-line"># line).</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::mputs_508">proc <a href="result.tcl-annot.html#::::mputs">::::mputs</a></a></strong> {fdl args} {
	foreach fd $fdl {
		foreach str $args {
			puts -nonewline $fd $str
		}
	}
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: put_ansi_out</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line"># Puts a string of text to a file descriptor with ANSI escaped colors.</span>
<span class="comment-line"># &#34;style&#34; </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: fd, stype, str</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#  put_ansi_out &#34;stdout&#34; $style $text</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::put_ansi_out_533">proc <a href="result.tcl-annot.html#::::put_ansi_out">::::put_ansi_out</a></a></strong> {fd style str} {
    global MAIN EX_RESULT_FORMAT erf
    <span class="comment-line">#upvar #0 EX_RESULT_FORMAT erf</span>

    if {![info exists MAIN(REPORT_COLS)]} {set MAIN(REPORT_COLS) 138}

	<span class="comment-line"># We want to break the string at the new lines into paragraphs.</span>
	set plist [split $str &#34;\n&#34;]

	<span class="comment-line"># We then operate on each paragraph.</span>
	foreach p $plist {
		<span class="comment-line"># Put the color escape sequence to the file descriptors</span>
		<a name="::mputs(1)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd [<a name="::get_color_from_name(1)"><a href="./result.tcl.html#::get_color_from_name_628">::get_color_from_name</a></a> $erf($style,color)]

		<span class="comment-line"># If the start is non-NULL, then put it to the file</span>
		if {$erf($style,start) != &#34;&#34;} {
			<a name="::mputs(2)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd $erf($style,start) &#34;\n&#34;
		}

		<span class="comment-line"># Break the paragraph into lines</span>
		<span class="comment-line"># Init wrap at 78 replaced with $MAIN(REPORT_COLS) from common.cfg</span>
		set para [<a name="::clip_string_with_wrap(1)"><a href="./result.tcl.html#::clip_string_with_wrap_440">::clip_string_with_wrap</a></a> $p [expr {$MAIN(REPORT_COLS) - [string length $erf($style,line)] + 2}]]

		<span class="comment-line"># Then, operate on each line and put it to the file.</span>
		foreach l $para {
			regsub {%%} $erf($style,line) $l line
			<a name="::mputs(3)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd $line &#34;\n&#34;
		}

		<span class="comment-line"># If the end sequence is non-NULL, put it to the file.</span>
		if {$erf($style,end) != &#34;&#34;} {
			<a name="::mputs(4)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd $erf($style,end) &#34;\n&#34;
		}

		<span class="comment-line"># Now, end the output by putting &#34;normal&#34; escape sequence (and</span>
		<span class="comment-line"># a new line character)</span>
		<a name="::mputs(5)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd [<a name="::get_color_from_name(2)"><a href="./result.tcl.html#::get_color_from_name_628">::get_color_from_name</a></a> &#34;none&#34;]
	}
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: put_ascii_out</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line"># Same as above, but without ANSI escape sequences</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: fd, style, str</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line"># put_ascii_out $EX_RESULT_FILE $style $text</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::put_ascii_out_589">proc <a href="result.tcl-annot.html#::::put_ascii_out">::::put_ascii_out</a></a></strong> {fd style str} {
    global MAIN EX_RESULT_FORMAT erf
    <span class="comment-line">#upvar #0 EX_RESULT_FORMAT erf</span>
    
    if {![info exists MAIN(REPORT_COLS)]} {set MAIN(REPORT_COLS) 138}

    set plist [split $str &#34;\n&#34;]

	foreach p $plist {
		if {$erf($style,start) != &#34;&#34;} {
			<a name="::mputs(6)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd $erf($style,start) &#34;\n&#34;
		}
        <span class="comment-line"># Original wrapping of 78 chars replaced with $MAIN(REPORT_COLS) from common.cfg </span>
		set para [<a name="::clip_string_with_wrap(2)"><a href="./result.tcl.html#::clip_string_with_wrap_440">::clip_string_with_wrap</a></a> $p [expr {$MAIN(REPORT_COLS) - [string length $erf($style,line)] + 2}]]
		foreach l $para {
			regsub {%%} $erf($style,line) $l line
			<a name="::mputs(7)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd $line &#34;\n&#34;
		}
		if {$erf($style,end) != &#34;&#34;} {
			<a name="::mputs(8)"><a href="./result.tcl.html#::mputs_508">::mputs</a></a> $fd $erf($style,end) &#34;\n&#34;
		}
	}
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: get_color_from_name</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Returns the ANSI escape sequence for color &#34;name&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: name</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: integer</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line"># mputs $fd [get_color_from_name &#34;none&#34;]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::get_color_from_name_628">proc <a href="result.tcl-annot.html#::::get_color_from_name">::::get_color_from_name</a></a></strong> {name} {
	global tcl_platform

	if {$tcl_platform(platform) != &#34;unix&#34;} {
		return &#34;&#34;
	}
	set b 0
	set c 7
	switch -- [string tolower $name] {
		&#34;black&#34; {
			set c 0
		} &#34;darkred&#34; {
			set c 1
		} &#34;darkgreen&#34; {
			set c 2
		} &#34;brown&#34; {
			set c 3
		} &#34;darkblue&#34; {
			set c 4
		} &#34;darkmagenta&#34; {
			set c 5
		} &#34;darkcyan&#34; {
			set c 6
		} &#34;gray&#34; {
			set c 7
		} &#34;none&#34; {
			return &#34;\033\[0m&#34;
		} &#34;darkgray&#34; {
			set c 0
			set b 1
		} &#34;blue&#34; {
			set c 4
			set b 1
		} &#34;green&#34; {
			set c 2
			set b 1
		} &#34;cyan&#34; {
			set c 6
			set b 1
		} &#34;red&#34; {
			set c 1
			set b 1
		} &#34;magneta&#34; {
			set c 5
			set b 1
		} &#34;yellow&#34; {
			set c 3
			set b 1
		} &#34;white&#34; {
			set c 7
			set b 1
		}
		default {
			set c 0
		}
	}

	if {$b} {
		return &#34;\033\[1;3${c}m&#34;
	} else {
		return &#34;\033\[3${c}m&#34;
	}
}

<span class="comment-line">################################################################################### </span>
<span class="comment-line"># Procedure Name: result_fmt</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Puts text to all result files formatted by style</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: style, text</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line"># proc &#34;result_$fmt&#34; &#34;text&#34; &#34;$cmd;\nresult_fmt $fmt \$text&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">###################################################################################</span>
<strong><a name="::::result_fmt_707">proc <a href="result.tcl-annot.html#::::result_fmt">::::result_fmt</a></a></strong> {style text} {
	global EX_RESULT_FILE EX_RESULT_LEVEL EX_RESULT_LEVEL_INFO MAIN

    <a name="::_initOutputOptions(1)"><a href="./SendSwCmd.tcl.html#::_initOutputOptions_3161">::_initOutputOptions</a></a>
    if {$MAIN(SHOWRESULT_FMT)} {
        if {[lsearch $EX_RESULT_LEVEL_INFO($EX_RESULT_LEVEL) $style] &gt; -1} {
            <a name="::put_ansi_out(1)"><a href="./result.tcl.html#::put_ansi_out_533">::put_ansi_out</a></a> &#34;stdout&#34; $style $text
        } 
    }
    if {$MAIN(PRINTTOLOG)} {
        <a name="::put_ascii_out(1)"><a href="./result.tcl.html#::put_ascii_out_589">::put_ascii_out</a></a> $EX_RESULT_FILE $style $text
    }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: ex_output</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal proc, sets the output level</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: level</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#     ex_output 2</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::ex_output_736">proc <a href="result.tcl-annot.html#::::ex_output">::::ex_output</a></a></strong> {{level -1}} {
	global EX_RESULT_LEVEL

	if {$level &gt; 4} {
		error &#34;Bad level $level&#34;
	}

	if {$level &lt; 0} {
		return $EX_RESULT_LEVEL
	} else {
		set EX_RESULT_LEVEL $level
	}
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: ex_debug</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Turns on or off debugging. Internal proc only</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: debug</span>
<span class="comment-line"># Output args:  none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line"># cmd {if {![ex_debug]} {return}}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::::ex_debug_765">proc <a href="result.tcl-annot.html#::::ex_debug">::::ex_debug</a></a></strong> {{debug &#34;&#34;}} {
	global EX_DEBUG

	if {$debug == &#34;&#34;} {
		return $EX_DEBUG
	} else {
		set EX_DEBUG $debug
	}
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetLatestResultDir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: gets the latest result directory for the module</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              module name, regType, home of the automation tree`</span>
<span class="comment-line">#              version</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value: result directory name</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#              GetLatestResultDir $modulename $regType &#34;&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::GetLatestResultDir_793">proc <a href="result.tcl-annot.html#::::GetLatestResultDir">::::GetLatestResultDir</a></a></strong> {testModule regType {home &#34;/auto/branch/automation&#34;}} {

   set lt 0
   set ctimeList &#34;&#34;


   set regType [ string tolower $regType ]
   switch  -regexp $regType {
     &#34;func*&#34; { set resultDir &#34;$home/Functionaltest&#34; }
     &#34;perf*&#34; { set resultDir &#34;$home/PerformanceTest&#34; }
     &#34;scala*&#34; { set resultDir &#34;$home/Scalabilitytest&#34; }
     &#34;bench*&#34; { set resultDir &#34;$home/Benchmarktest&#34; }
     &#34;cli&#34; { set resultDir &#34;$home/CLItest/uploadanddownload&#34; }
     default { set resultDir &#34; &#34; }
   }
   set resultDir &#34;$resultDir/$testModule/Result&#34;
   <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Result dir = $resultDir&#34;
   set dirList [glob -nocomplain -- &#34;$resultDir/*&#34;]
   foreach di $dirList {
      file lstat $di damn
      <span class="comment-line">#puts &#34;ctime $damn(ctime)&#34;</span>
      lappend ctimeList [set damn(ctime)]    ;<span class="comment-line"># NOTE: ctime changed to ino attribute of file.</span>
   }
   set latestcTime [lindex [lsort -integer $ctimeList] [expr [llength $ctimeList]-1]]
   set finalIndex [lsearch -exact $ctimeList $latestcTime]
   set finalDirectory [file tail [lindex $dirList $finalIndex]]
   set latestResultDirectory &#34;$resultDir/$finalDirectory&#34;
   <span class="comment-line">#puts &#34;latestResultDirectory $latestResultDirectory&#34;</span>
   return $latestResultDirectory
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: GetMainResultDir</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: gets the result directory for the module created by main.tcl</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              module name, regType, randomIndex home of the automation tree`</span>
<span class="comment-line">#              version</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value: result directory name</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#              GetLatestResultDir $modulename $regType &#34;&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::GetMainResultDir_841">proc <a href="result.tcl-annot.html#::::GetMainResultDir">::::GetMainResultDir</a></a></strong> {testModule regType randomIndex {home &#34;/auto/branch/automation&#34;}} {

   set regType [ string tolower $regType ]
   switch  -regexp $regType {
     &#34;func*&#34; { set resultDir &#34;$home/Functionaltest&#34; }
     &#34;perf*&#34; { set resultDir &#34;$home/PerformanceTest&#34; }
     &#34;scala*&#34; { set resultDir &#34;$home/Scalabilitytest&#34; }
     &#34;bench*&#34; { set resultDir &#34;$home/Benchmarktest&#34; }
     &#34;cli&#34; { set resultDir &#34;$home/CLItest/uploadanddownload&#34; }
     default { set resultDir &#34; &#34; }
   }
   set resultDir &#34;$resultDir/$testModule/Result&#34;
   <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Result dir = $resultDir&#34;
   puts &#34;Result dir = $resultDir&#34;
   set dirList [glob -nocomplain -- &#34;$resultDir/*&#34;]
   foreach di $dirList {

      if {[regexp -nocase $randomIndex $di]} {
        <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;mainResultDir $di&#34;
        set mainResultDir $di
        puts &#34;mainResultDir $mainResultDir&#34;
        return $mainResultDir
      }

   }
   <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;did not find the Result directory&#34;
   puts &#34;did not find the Result directory&#34;
   return error
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: create_report_directory</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: creates report directory</span>
<span class="comment-line">#              with a more informative name</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              create -if yes create the direcory otherwise create reportdir.tct file</span>
<span class="comment-line">#              module name</span>
<span class="comment-line">#              version</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value: report directory name</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#              create_report_directory yes $modulename $version</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::create_report_directory_890">proc <a href="result.tcl-annot.html#::::create_report_directory">::::create_report_directory</a></a></strong> { {sourceFile &#34;null&#34;} {create &#34;yes&#34;} {modulename &#34;&#34;} {<a name="::version(1)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> &#34;&#34;} {subversion &#34;&#34;} {qId &#34;&#34;}} {
global DUTs_info
   global env
   global tcl_platform
   global reportDir 

   set tmp &#34;Report&#34;
   set pwd [pwd]

   set sourceFile [file tail $sourceFile]
   set sourceFileList [split $sourceFile .]
   set sourceFile [lindex $sourceFileList 0]

   if {[regexp -nocase &#34;clitest&#34; $pwd]} {
       global reportPath
       set tmp $reportPath
   }

   set bladeType [<a name="::getModule(1)"><a href="./result.tcl.html#::getModule_1100">::getModule</a></a>]
   set date  [clock format [clock seconds] -format &#34;%Y-%m-%d&#34;]
   set Platform $DUTs_info(DUT1,platform)

   global NEWBUILD
   global OLDBUILD
   if {[regexp -nocase &#34;upgradedowngrade&#34; $pwd]} {
<span class="comment-line">#      set ImageVer [format %s_%s $DUTs_info(DUT1,priImage) $DUTs_info(DUT1,secImage)]</span>
      set ImageVer [format %s:%s $NEWBUILD $OLDBUILD]
   } else {
     if {$version != &#34;&#34;} {
        set ImageVer $version
     } else {
        set ImageVer $DUTs_info(DUT1,version)
     }
   }
   set ImageVer [string tolower $ImageVer]
   if {($subversion != &#34;&#34;) &amp;&amp; ($subversion != &#34;NULL&#34;) } {
      set ImageVer $ImageVer-$subversion
   } 
   puts &#34;ImageVer :: $ImageVer&#34;

   set index 0
   set goOn 1
   while {$goOn == 1} {
     set reportDirList [glob -nocomplain -- &#34;$tmp/*$sourceFile*$Platform*$bladeType*$modulename*$ImageVer*$qId $index&#34;]
     if {[llength $reportDirList] &gt; 0} {
       incr index
     } else {
       set goOn 0
     }
   }
   set reportDir &#34;$tmp/$date $sourceFile $Platform $bladeType $modulename $ImageVer $qId $index&#34;
   puts &#34;reportDir $reportDir&#34;
   ;<span class="comment-line"># create report directory</span>
   if {$create == &#34;yes&#34;} {
     if {![file exists $reportDir]} {
         puts &#34;Creating report directory &lt;$reportDir&gt;.&#34;
         catch {exec mkdir $reportDir} output
     }
   }
   if {$create != &#34;yes&#34;} {
     set resultDir [<a name="::get_result_dir(4)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]
     puts &#34;create_report_dir - resultDir = $resultDir&#34;
     <span class="comment-line"># lets write the new report directory string into a file: reportdir.txt</span>
     set fdRD [open &#34;$resultDir/reportdir.txt&#34; &#34;w&#34;]
     puts $fdRD &#34;$reportDir\n&#34;
     close $fdRD;
   }
   return $reportDir
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: move_file_result_directory</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: moves ta single file in theresult directory to report directory</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#              file name</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value:</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#              move_file_result_directory $fileName </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################</span>

<strong><a name="::::move_file_result_directory_977">proc <a href="result.tcl-annot.html#::::move_file_result_directory">::::move_file_result_directory</a></a></strong> {fileName} {

   global reportDir

   ;<span class="comment-line"># Move fileName File if it exists.</span>
   if [file exists [<a name="::get_result_dir(5)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$fileName] {
       puts &#34;Moving file [<a name="::get_result_dir(6)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$fileName to report directory &lt;$reportDir&gt;.&#34;
       catch {exec mv [<a name="::get_result_dir(7)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$fileName $reportDir} output
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: move_result_directory</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: move the complete result directory to report directory</span>
<span class="comment-line">#              with a more informative name</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  </span>
<span class="comment-line">#              module name</span>
<span class="comment-line">#              version</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Output args: none        </span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value: </span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              move_result_directory $modulename $version</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::move_result_directory_1006">proc <a href="result.tcl-annot.html#::::move_result_directory">::::move_result_directory</a></a></strong> { {modulename &#34;&#34;} {<a name="::version(2)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> &#34;&#34;} {execTimeFile &#34;&#34;} } {
   global DUTs_info MAIN
   global env
   global tcl_platform
   global reportDir
       
   set tmp &#34;Report&#34;
   set pwd [pwd]
   if {[regexp -nocase &#34;clitest&#34; $pwd]} {
       global reportPath
       set tmp $reportPath
   }
   
   set bladeType [<a name="::getModule(2)"><a href="./result.tcl.html#::getModule_1100">::getModule</a></a>]
   set date  [clock format [clock seconds] -format &#34;%Y-%m-%d&#34;]
   set Platform $DUTs_info(DUT1,platform)
   
   global NEWBUILD
   global OLDBUILD
   if {[regexp -nocase &#34;upgradedowngrade&#34; $pwd]} {
<span class="comment-line">#      set ImageVer [format %s_%s $DUTs_info(DUT1,priImage) $DUTs_info(DUT1,secImage)]</span>
      set ImageVer [format %s:%s $NEWBUILD $OLDBUILD]
   } else {
     if {$version != &#34;&#34;} {
        set ImageVer $version
     } else {       
        set ImageVer $DUTs_info(DUT1,version)
     }
   }
   set ImageVer [string tolower $ImageVer]

<span class="comment-line"># adding e-mail-report-to-tester feature</span>
   if {[info exist MAIN(feature_directory)] &amp;&amp; [info exist env(mailto)] &amp;&amp; 
       ![regexp -nocase &#34;windows&#34; $tcl_platform(platform)]} {
       set subj &#34;Test summary: $ImageVer $Platform $bladeType $modulename $MAIN(feature_directory)&#34;
       exec /bin/cat &#34;[<a name="::get_result_dir(8)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.txt&#34; | /bin/mail -s $subj $env(mailto)
   }
   
   <span class="comment-line">#Remove the report.exr from original result dir</span>
   set exrFile &#34;[<a name="::get_result_dir(9)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34;
   if {[file exists $exrFile]==1} {
      file delete $exrFile
   }
   <span class="comment-line">#Remove the reportdir.txt file</span>
   set reportdirFile &#34;[<a name="::get_result_dir(10)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/reportdir.txt&#34;
   if {[file exists $reportdirFile]==1} {
     file delete $reportdirFile
   }

   <span class="comment-line">#puts &#34;Directory contents are:\n[glob -directory [get_result_dir] *]&#34;</span>
   set fileList [glob -directory [<a name="::get_result_dir(11)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>] *]

   foreach fileThis [glob -directory [<a name="::get_result_dir(12)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>] *] {
     if { [file rename -force  $fileThis $reportDir] != &#34;&#34; } {
       puts &#34;Failed to move results file $fileThis to report directory.&#34;
       puts &#34;Make sure all opened files are closed.&#34;
     }
   }
   if [file isdirectory [<a name="::get_result_dir(13)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]] {
     file delete [<a name="::get_result_dir(14)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]
   }

   ;<span class="comment-line"># Move executionTime File if it exists.</span>
   if [file exists [<a name="::get_result_dir(15)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$execTimeFile] {
       puts &#34;Moving execution time file [<a name="::get_result_dir(16)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/$execTimeFile to report directory &lt;$reportDir&gt;.&#34;
       catch {exec mv $execTimeFile $reportDir} output
   }
   
   <span class="comment-line"># Move core file if any to Report directory</span>
   <a name="::moveCoreDumpsToReportDir(1)"><a href="./cleanup.tcl.html#::moveCoreDumpsToReportDir_754">::moveCoreDumpsToReportDir</a></a>
   <a name="::moveConfigDiffToReportDir(1)"><a href="./cleanup.tcl.html#::moveConfigDiffToReportDir_856">::moveConfigDiffToReportDir</a></a>

   <span class="comment-line"># Change report permissions to wide open</span>
   catch {exec chmod 777 $reportDir -R } output

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: getModule</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Get blade type - HW module type</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  none</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#              module name             </span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value: string</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              getModule </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################</span>
<strong><a name="::::getModule_1100">proc <a href="result.tcl-annot.html#::::getModule">::::getModule</a></a></strong> {} {
 global sourceFile
 set module &#34;&#34;
 global stackable i386Stackable
 global DUTs_info

 set cfgFile [file tail $sourceFile]
 set Platform $DUTs_info(DUT1,platform)

 if {[regexp -nocase &#34;$stackable|$i386Stackable&#34; $Platform]} {
    return $module
 }
 if { [file exists ../../main/runReg.cfg] } {
    set module [<a name="::get_platform_blade(1)"><a href="./misc.tcl.html#::get_platform_blade_3987">::get_platform_blade</a></a> $cfgFile]
    if {$module == &#34;not_found&#34;} {
      set module [<a name="::getModuleNoRunRegCfg(1)"><a href="./result.tcl.html#::getModuleNoRunRegCfg_1124">::getModuleNoRunRegCfg</a></a>]
    }
  } else {
    set module [<a name="::getModuleNoRunRegCfg(2)"><a href="./result.tcl.html#::getModuleNoRunRegCfg_1124">::getModuleNoRunRegCfg</a></a>]
  }
 return $module
}


<strong><a name="::::getModuleNoRunRegCfg_1124">proc <a href="result.tcl-annot.html#::::getModuleNoRunRegCfg">::::getModuleNoRunRegCfg</a></a></strong> {} {
   global portMappingList
   global DUTs_info
  set module &#34;&#34;
  set dut DUT
  set connect _CONNECT
   
  set Platform $DUTs_info(DUT1,platform)
  global stackable i386Stackable
  if {[regexp -nocase &#34;$stackable|$i386Stackable&#34; $Platform]} {
     return $module
  }
  
  lappend parameterList &#34;{HW Module Type:} 1&#34;
if { 0 } {
  if {![info exists portMappingList]} {
     global DUT1_CONNECT
     <a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT1_CONNECT
     set hwTypes [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot&#34; $parameterList]
     unset parameterList
     lappend parameterList &#34;{State:} 1&#34;
     set states [<a name="::GetKeyValue(2)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot&#34; $parameterList]
     for {set i 0} {$i&lt;[llength $states]} {incr i} {
        if {[lindex $states $i]==&#34;Operational&#34;} {
           unset parameterList
           return [lindex $hwTypes $i]
           break
        }
     }
  }
} else {
  if {![info exists portMappingList]} {
     global DUT1_CONNECT
     <a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT1_CONNECT
     lappend parameter1List &#34;{State:} 1&#34;
     for {set i 1} {$i&lt;=8} {incr i} {
        set state [<a name="::GetKeyValue(3)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot $i&#34; $parameter1List]
	if {$state == &#34;Operational&#34;} {
	   unset parameter1List
	   set hwType [<a name="::GetKeyValue(4)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot $i&#34; $parameterList]
	   unset parameterList
	   return $hwType
	}
     }
  }
}

  if {[info exists DUTs_info(DUT1,bladeType)]} {
     return $DUTs_info(DUT1,bladeType)
  }

  set slotList &#34;&#34;
  set dutList &#34;&#34;
  foreach portId $portMappingList {
     if {[lsearch -regexp $portId :]!=-1} {
        set slot [lindex [split [lindex $portId 1] :] 0]
        set temp [lindex $portId 2]
        
        set index [lsearch $slotList $slot]
        set flag 0
        if {($index!=-1)} {
           if {[lindex $dutList $index]==$temp} {
              set flag 1
           }
        }
        
        if {($index==-1) &amp;&amp; ($flag==0)} {
           global $dut$temp$connect
           <a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [expr $$dut$temp$connect]
           set hwType [<a name="::GetKeyValue(5)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot $slot&#34; $parameterList]
           if {[lsearch -regexp $module $hwType]==-1} {
              append module $hwType
           }
        }
        lappend slotList $slot
        lappend dutList $temp
     }
  }
  return $module 
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetLastTestRun</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal proc to get ctime based latest test run from</span>
<span class="comment-line">#              resultDir location. Mainly meant to be used to </span>
<span class="comment-line">#              continue remaining tests after prev aborted.</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: Since ctime is messes up lastTestRun in case 0 sec taken by many tests,</span>
<span class="comment-line">#       reply on largest value of ino.</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#              resultDir</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return value: Returns the value of latest test that was run based on ctime of a file.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              set lastTest [GetLastTestRun &#34;[get_result_dir]&#34;]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################## </span>
<strong><a name="::::GetLastTestRun_1226">proc <a href="result.tcl-annot.html#::::GetLastTestRun">::::GetLastTestRun</a></a></strong> {resultDir} {
   
   set lt 0
   set ctimeList &#34;&#34;
   set dirList [glob -nocomplain -- &#34;$resultDir/*&#34;]
   foreach di $dirList {
      file lstat $di damn
      lappend ctimeList [set damn(ino)]    ;<span class="comment-line"># NOTE: ctime changed to ino attribute of file.</span>
   }
   set latestcTime [lindex [lsort -integer $ctimeList] [expr [llength $ctimeList]-1]]
   set finalIndex [lsearch -exact $ctimeList $latestcTime]
   set finalFile [file tail [lindex $dirList $finalIndex]]
   regsub -nocase &#34;.txt&#34; $finalFile &#34;&#34; lt
   <span class="comment-line">#result_debug &#34;the last test run was $lt&#34;</span>
   return $lt
}

<strong><a name="::::result_step_1243">proc <a href="result.tcl-annot.html#::::result_step">::::result_step</a></a></strong> { step } {
   <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n&lt;STEP&gt; $step &lt;STEP&gt;\n&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: showDebugInfo</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Calls the showDebugInfo proc of individual modules as per the debug level</span>
<span class="comment-line">#              This information is then added onto log-file and stdout </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#            reason : tells from where the proc is called, from result_debug or from result_error</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># return Value: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#              showDebugInfo &#34;debug&#34;</span>
<span class="comment-line">#              showDebugInfo &#34;error&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: setup</span>
<span class="comment-line">################################################################## </span>

<strong><a name="::::showDebugInfo_1266">proc <a href="result.tcl-annot.html#::::showDebugInfo">::::showDebugInfo</a></a></strong> {fmt} {
    
    global showErrorData EX_RESULT_FORMAT erf
    global debugStart
    global debugLevel
    
    if {![info exists debugStart]} {
        set debugStart 0
    }
    if { $debugStart == 1 } {
        set module [lindex [split [pwd] /] end]
        if { [llength [info procs showDebugInfo$module]] == 1  } {
            set printColor $erf(print,color)
            if {[string compare $fmt &#34;error&#34;] == 0} {
                set erf(print,color) &#34;darkmagenta&#34;
                if {$showErrorData &gt; 0 } {
                    <a name="::result_print(1)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;***  START_DEBUG_INFO, REASON=$fmt , iLevel [info level] debugLevel=$showErrorData *****&#34; 
                    showDebugInfo$module $showErrorData 
                    <a name="::result_print(2)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;***  END_DEBUG_INFO, REASON=$fmt , debugLevel=$showErrorData *****&#34; 
                }
            }
            if {[string compare $fmt &#34;debug&#34;] == 0} {
                set erf(print,color) &#34;darkmagenta&#34;
        
                set level 0
                if {[info exists debugLevel] } { 
                    if {$debugLevel &gt; 0} {
                        set level $debugLevel
                        if {$showErrorData &gt; 0} {
                            set level $showErrorData
                        }
                    }

                    if {$level &gt; 0} {
                        <a name="::result_print(3)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;***  START_DEBUG_INFO, REASON=$fmt , iLevel [info level] debugLevel=$level *****&#34; 
                        showDebugInfo$module $level
                        <a name="::result_print(4)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;***  END_DEBUG_INFO, REASON=$fmt , debugLevel=$level *****&#34; 
                    }
                }
            }
            set erf(print,color) $printColor
        }
    }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
