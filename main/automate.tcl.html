<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>automate.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#automate.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>automate.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="automate.tcl-annot.html">annotations</a> | <a href="automate.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

source ../Lib/mainLib.tcl;
source ../Lib/queueLib.tcl;

set modulesToBeSummarizedPath &#34;../Autoweb/cgi-bin/cgiScripts/modulesToBeSummarized.cfg&#34;;
set execSummaryFilename &#34;execSummary.txt&#34;;

;<span class="comment-line"># Used in regexp to look for summit matches</span>
<span class="comment-line"># EY-06-16-2006: Added new Jaguar-2 platform names: X450a-24x, X450a-24xdc, and X450e-48p.</span>
set summitList &#34;SummitX450|Summit-PC|SummitX406|SummitX450e-24p|SummitX450a-48t|X450a-24t|X450e-24p|X450e-24t|X450a-48t|X450a-24tdc|X450a-24x|X450a-24xdc|X450e-48p|X450e-48t&#34;;
set alpineList &#34;Aspen&#34;;
<span class="comment-line">#set bladeList  &#34;10G|10G4X|G60T|G60X|G48T|G48P|G24X|pcsimc2|G20XT|G20XTR|10G2X|10G2XR&#34;;</span>

set bladeList  &#34;10G|10G4X|G60T|G60X|G48T|G48P|G24X|pcsimc2|GM-20XT|GM-20XTR|10G2X|10G2XR|G48Te|G48Pe|G48Ta|G48Xa&#34;;

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [print_usage]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Prints the usage of utility in case any of the args are incorrect or insufficient</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - none</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#     print_usage</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::print_usage_34">proc <a href="automate.tcl-annot.html#::print_usage">::print_usage</a></a></strong><a name="::print_usage"></a> {} {
    puts &#34;\r&#34;
    puts {USAGE: automate.tcl -regType &lt;regType&gt; -regSubType &lt;regSubType&gt; \
	    -build &lt;imageName&gt; [-platform &lt;platform&gt;] [-blade &lt;bladeType&gt;] \
	    [-modules &lt;moduleList] \
	    [-noconfig] [-cliFlag &lt;cliFlag&gt;] [-help]}
    puts {      -regType: Type of Regression to be run (functional|cli|performance)}
    puts {      -regSubType: Test Subtype (standard|ipRoute1|ipRoute2|ipRoute3|uploadanddownload|upgradedowngrade)}
    puts {      -build:    Name of image e.g. 10.2.0.16/11.0.0.27/11.1.0.2}
    puts {      -platform: Name of the platform.  BD-10808/Aspen/SummitX450/Summit-PC/\
	    BD-PC}
    puts {      -blade:    Type of the blade.  G60T/G60X/G48T/10G4X}
    puts {      -modules: Specific list of modules to run against. }
    puts {      -noconfig: DO NOT create the short config and batch re-run file}
    puts {      -cliFlag&gt;: cliFlag (NO_REBOOT|NO_REBOOT_NO_DOWNLOAD, optional with regPath clitest)}
    puts {      -help:     Prints usage}
    puts &#34;\r&#34;
    puts { * Summit platforms DO NOT require blade type.} 
    puts { * ipRoute regSubTypes DO NOT require platform/blade} 
    puts &#34;\r&#34;
}


<span class="comment-line">###################################################################</span>
<span class="comment-line"># Get the performance data from previuos build.</span>
<span class="comment-line"># Currently not used..</span>
<span class="comment-line">###################################################################</span>
<strong><a name="::getPerfDataFromPrevBuild_61">proc <a href="automate.tcl-annot.html#::getPerfDataFromPrevBuild">::getPerfDataFromPrevBuild</a></a></strong><a name="::getPerfDataFromPrevBuild"></a> {module plat blade build testNumber subtest}  {
   global webServerDirName
   global newPlatforms
      
   set flag 0;
   set curDir [pwd]
   cd &#34;$webServerDirName&#34;

   <span class="comment-line"># newPlatform summit24e3</span>
   if {[regexp -nocase $newPlatforms $plat]} {
      set relName $plat
   } else {
      set relName [string range $build 0 3]
   }

   set number 0
   set ver 0
   set b b
   set flg [regexp -nocase {^([0-9]+.[0-9a-z]+.[0-9]+).(.*)} $build match ver number]

   set i 1
   set dataListToReturn &#34;&#34;
   while {$i&lt;4} {
      set prevBuild $ver$b[expr $number-$i]
      set thisDir [<a name="::getDirName(1)"><a href="./automate.tcl.html#::getDirName_1648">::getDirName</a></a> $plat $blade $module $prevBuild &#34;Performance&#34; &#34;&#34;]
      set fname &#34;$thisDir/$module&#34;
      append fname &#34;_perfData.txt&#34;;

      if {[catch {open $fname r} fd_in]} {
       <span class="comment-line"># File does not already exists, check the next prev build.</span>
         incr i
      } else {
         break
      }
   }

   if {$i &gt;= 4} {    ;<span class="comment-line"># No earlier build found for this module</span>
      cd $curDir
      return $dataListToReturn
   }
   set data &#34;&#34;
   while {[gets $fd_in line] != -1} {
      if {[regexp $testNumber $line]} {
         if {[regexp -nocase $subtest $line]} {
            if {([regexp -nocase {\[ *[0-9.]+ *\]} $line match ]==1) \
               || ([regexp -nocase {\[ *[0-9.]+% *\]} $line match ]==1)} {
               set data $match
               break
            } 
         } else {
            while {[gets $fd_in line] != -1} {
               if {[regexp {[0-9].[0-9]|Using file .*} $line] == 1} {
                  if {[regexp -nocase $subtest $line]} {
                     if {([regexp -nocase {\[ *[0-9.]+ *\]} $line match ]==1) \
                        || ([regexp -nocase {\[ *[0-9.]+% *\]} $line match ]==1)} {
                        set data $match
                        break
                     } 
                  } else {
                     continue
                  }
               } else {
                  if {[regexp -nocase $subtest $line]} {
                     if {([regexp -nocase {\[ *[0-9.]+ *\]} $line match ]==1) \
                        || ([regexp -nocase {\[ *[0-9.]+% *\]} $line match ]==1)} {
                        set data $match
                     }
                  }
               }
            }
         }
      }
   }
   close $fd_in
   if {$data == &#34;&#34;} {
      set retData &#34;&#34;
   } else {
      set retData $prevBuild
   }
   append retData &#34; $data&#34;
   return $retData
}




<strong><a name="::putPerfTestResult_147">proc <a href="automate.tcl-annot.html#::putPerfTestResult">::putPerfTestResult</a></a></strong><a name="::putPerfTestResult"></a> {module webFileName perfFileName platform bladeType buildName} {

    global webServerDirName
    
    set curDir [pwd]
    cd $curDir

    set moduleDirName [file dirname $webFileName]
    set relName [string range $buildName 0 3]
    
    set destFile $module
    append destFile &#34;_perfData.txt&#34;
    set perfdata ./$perfFileName 

    puts &#34;DEBUG: Opening $perfdata&#34;
    if {[catch {open $perfdata r} fd_in]} {
	cd $curDir
	puts &#34; !!!!  NO performance data found : $fd_in  !!!!&#34;
	return 1;
    }
    
    if {[file exists $webServerDirName/$moduleDirName/$destFile]} {
	puts &#34;Deleting $webServerDirName/$moduleDirName/$destFile&#34;
	if [catch {file delete $webServerDirName/$moduleDirName/$destFile} fd_out] {
	    return 1
	}
	
    }
    
    if {[catch {open &#34;$webServerDirName/$moduleDirName/$destFile&#34; w 0777} fd_out]} {
	cd $curDir
	puts &#34; !!!! ERROR : $fd_out    !!!!&#34;
	return 1;
    }
    
    puts &#34;$webServerDirName/$moduleDirName/$destFile opened&#34;

    while {[gets $fd_in line] != -1} {
	if {[regexp {[0-9].[0-9]|Using file .*} $line] == 1} {
	    set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} $line match testNumber];
	    set flg [regexp -nocase {Using file .*/(.*.cli)} $line match testNumber];
	}

	if {([regexp -indices {\[ *[0-9.]+ *\]} $line match ]==1) \
		|| ([regexp -indices {\[ *[0-9.]+% *\]} $line match ]==1)} {
	    scan $match {%[0-9]} endIndex
	    set subtestStr  [string range  $line 0 [incr endIndex -1]]
	    <span class="comment-line"># We are not going to get the previous build date for now</span>
	    <span class="comment-line">#            set prevData [getPerfDataFromPrevBuild $module $platform $bladeType $buildName $testNumber $subtestStr] </span>
	    <span class="comment-line">#            append line $prevData</span>
	}

	puts &#34;WRITING: $line to $fd_out&#34;
	puts $fd_out $line
    }
    
    puts &#34;Closing $fd_in and $fd_out&#34;
    close $fd_in
    close $fd_out
    
    return 0
}




<span class="comment-line">################################################################</span>
<span class="comment-line">#  [SummarizeAllFailures]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Procedure to summarize all the Failures from report.txt files to a common summary file.</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                buildName</span>
<span class="comment-line">#                platform</span>
<span class="comment-line">#                bladeType</span>
<span class="comment-line">#                regType</span>
<span class="comment-line">#                regSubType</span>
<span class="comment-line">#                fd - file descriptor of the output file to write to</span>
<span class="comment-line">#                perfFileName</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns 0 on failure or 1 on success</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line"># SummarizeAllFailures $build $platform $blade $regType $regSubType $fd</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::SummarizeAllFailures_236">proc <a href="automate.tcl-annot.html#::SummarizeAllFailures">::SummarizeAllFailures</a></a></strong><a name="::SummarizeAllFailures"></a> {buildName platform bladeType regType regSubType \
	regressionModules fd {perfFileName &#34;&#34;}} {

    global runflag;
    global moduleNeedToRerun;
    global regPath

    global performanceRegressionModules
    
    set key &#34;FAILED&#34;
    set origBladeType $bladeType
    
    <span class="comment-line"># modulesToBeSummarized.cfg defines modules for each test, </span>
    <span class="comment-line"># namely standard, cli, iprouting</span>
    foreach testModule $regressionModules {
	puts &#34;\n&#34;
	set testCaseListFailed &#34;&#34;;
	set testCaseListPassed &#34;&#34;;
	set testCaseListAll &#34;&#34;;
	set testCaseListPerf &#34;&#34;;
	set testCaseListNotFound &#34;&#34;;      
        set testsFromCfgFile &#34;&#34;;
        set pdList &#34;&#34;
        set runOrRerun 1
	
	<span class="comment-line"># Get the first report dir from a list of many dirs for bladeType and buildName</span>
	puts $fd &#34;###############################################&#34;
	puts $fd &#34;           Module:$testModule                  &#34;
	puts $fd &#34;###############################################&#34;

	puts &#34;###############################################&#34;
	puts &#34;           Module:$testModule                  &#34;
	puts &#34;###############################################&#34;

	<span class="comment-line"># Get the directory listing under module/Report for all directories </span>
	<span class="comment-line"># matching this platform_blade_build.  For summit just use </span>
	<span class="comment-line"># platform_build.  These are the directories that we search for </span>
	<span class="comment-line"># the &#34;report.txt&#34; file to get the regression test result summary.</span>
	if {[regexp -nocase &#34;summit&#34; $platform] &amp;&amp; \
		[regexp -nocase &#34;standard&#34; $regSubType]} {

	    <span class="comment-line"># Since bladeType is &#34;&#34; in summit, check the right dir based on </span>
	    <span class="comment-line"># the platform itself.</span>
	    set summitPlatform [string range $platform 0 end]
<span class="comment-line">#	    set temp [string tolower [string range $summitPlatform 1 end]]</span>
<span class="comment-line">#	    set thisPlatform [string index &#34;$platform&#34; 0]</span>
	    set thisPlatform $summitPlatform
<span class="comment-line">#	    append thisPlatform $temp</span>
	    puts &#34;DEBUG: Looking for $regPath/$testModule/Report/\
		    *$thisPlatform*$buildName *&#34;
	    set dirList [glob -nocomplain -- \
		    &#34;$regPath/$testModule/Report/*$thisPlatform*$buildName *&#34;]
	    if {[regexp -nocase $platform &#34;summit48i&#34;]} {
		set tempDirList &#34;&#34;
		foreach dirName $dirList {
		    if {[regexp -nocase &#34;summit48si&#34; $dirName]!=1} {
			lappend tempDirList $dirName
		    }
		}
		set dirList $tempDirList
	    }

	} elseif {[regexp -nocase &#34;ipr&#34; $regSubType]} {
	    puts &#34;DEBUG: Routing   $regType  $regSubType&#34;
<span class="comment-line">#	    puts &#34;DEBUG: looking for $regPath/$testModule/Report/*$buildName *&#34;</span>
	    puts &#34;DEBUG: looking for $regPath/$testModule/Report/*$platform*$bladeType*$buildName *&#34;	;<span class="comment-line"># my</span>
<span class="comment-line">#	    set dirList [glob -nocomplain -- \</span>
<span class="comment-line">#		    &#34;$regPath/$testModule/Report/*$buildName *&#34;]</span>
	    set dirList [glob -nocomplain -- \
		    &#34;$regPath/$testModule/Report/*$platform*$bladeType*$buildName *&#34;]
	    
	} elseif {[regexp -nocase &#34;performance&#34; $regType]} {
	    puts &#34;DEBUG: Perf   $regType  $regSubType&#34;
	    puts &#34;DEBUG: looking for *regPath/$testModule/Report/*$buildName *&#34;
	    set dirList [glob -nocomplain -- \
		    &#34;$regPath/$testModule/Report/*$buildName *&#34;]

	} elseif {[regexp -nocase &#34;cli&#34; $regType]} {
	    puts &#34;DEBUG: CLI   $regType  $regSubType&#34;
	    set testModule [string tolower $testModule]
	    puts &#34;DEBUG: looking for $regPath/$testModule/Report/*$platform*$bladeType*$buildName*&#34;
	    set dirList [glob -nocomplain -- \
		    &#34;$regPath/$testModule/Report/*$platform*$bladeType*$buildName*&#34;]
	    
      } else {
	  puts &#34;DEBUG: DEFAULT&#34;
	  puts &#34;DEBUG: looking for $regPath/$testModule/Report/\
		  *$platform*$bladeType*$buildName *&#34;
	  set dirList [glob -nocomplain -- \
		  &#34;$regPath/$testModule/Report/*$platform*$bladeType*$buildName *&#34;]
      }

      <span class="comment-line"># dirList contains all Report/xxx directories for all runs </span>
      <span class="comment-line"># of platform_blade_build</span>
      <span class="comment-line">#set dirList [lsort -decreasing $dirList];</span>
      <span class="comment-line">#set rightDirList [lrange $dirList 0 0]    ;# 1 dir for everything else</span>

      <span class="comment-line"># Dany - sort based on the index of the directory and not lsort command</span>
      set rightDirList &#34;&#34;
      foreach tdir $dirList {
        <span class="comment-line">#get directory index</span>
        set splitDir [split $tdir &#34; &#34;]
        <span class="comment-line"># get the last element</span>
        set indx [lindex $splitDir end]
        if {$rightDirList == &#34;&#34;} {
          set rightDirList $tdir
          set highestIndx $indx
        } else {
          if {$indx &gt; $highestIndx} {
            set highestIndx $indx
            set rightDirList $tdir
          }
        }
      }

      if {$rightDirList != &#34;&#34;} {
        set rightDirList [list $rightDirList]
      }

      puts &#34;DEBUG: dirList       $dirList&#34;
      puts &#34;DEBUG: rightDirList  $rightDirList&#34;


      <span class="comment-line"># Check if platform_blade_build directory even exists.  Won't exist </span>
      <span class="comment-line"># if this module was not tested with this build on this platform_blade.</span>

      if {[regexp -nocase &#34;cli&#34; $regType]} {
	  if {$rightDirList==&#34;&#34;} {
	      puts &#34;!!! Error: NO report.txt file for $testModule !!!\n&#34;
	      puts $fd &#34;!!! Error: NO report.txt for module:$testModule for \
		      $bladeType and $buildName !!!&#34;
	      puts $fd &#34;###############################################\n&#34;
	      <span class="comment-line"># --- need to create the config file here</span>
	      continue
	  } else {
	      puts $fd &#34;           Report Dir: &#34;
	      puts &#34;Found report.txt for $testModule in Dir:&#34;
	      foreach rd $rightDirList {
		  puts $fd &#34;               $rd.&#34;
		  puts &#34;$rd.&#34;
	      }
	  }
      } else {
	  if {$rightDirList==&#34;&#34;} {
	      puts &#34;!!! Error: NO report.txt for module:$testModule for \
		      $bladeType and $buildName !!!&#34;
	      puts $fd &#34;!!! Error: NO report.txt for module:$testModule for \
		      $bladeType and $buildName !!!&#34;
	      puts $fd &#34;###############################################\n&#34;
	      
	      <span class="comment-line"># --- need to create the config file here</span>
	      continue
	  } else {
	      puts $fd &#34;           Report Dir: &#34;
	      puts &#34;Found report.txt for $testModule in Dir:&#34;
	      foreach rd $rightDirList {
		  puts $fd &#34;               $rd.&#34;
		  puts &#34;$rd.&#34;
	      }
	  }
      }
           
      <span class="comment-line"># There should only be 1 rightDirList...and it should be the </span>
      <span class="comment-line"># from the latest run</span>
      puts &#34;DEBUG: Looping through rightDirList $rightDirList&#34;
      
      set moduleAborted &#34;No&#34;
      foreach rightDir $rightDirList {

	  set count 0
	  <span class="comment-line"># unset the paragraph for earlier module if exists</span>
	  if {[info exists paragraph]} {
	      unset paragraph
	  }
	  
	  set fsize [file size $rightDir/report.txt]
	  if {$fsize &gt; 200000} {
	      puts &#34;Big file ($fsize) - Please wait ...&#34;;
	  }

	  ;<span class="comment-line"># Open execSummary.txt and return time to execute ALL for this module</span>
	  ;<span class="comment-line">#----- Execution Time Summary For ../Functionaltest/Dot1X -----</span>
	  ;<span class="comment-line">#    SETUP: 316   (0 hours, 5 minutes, 16 seconds)</span>
	  ;<span class="comment-line"># CHK_CONN: 63    (0 hours, 1 minutes, 3 seconds)</span>
	  ;<span class="comment-line">#    QUICK: 360   (0 hours, 6 minutes, 0 seconds)</span>
	  ;<span class="comment-line">#     PASS: 722   (0 hours, 12 minutes, 2 seconds)</span>
	  ;<span class="comment-line">#      ALL: 993   (0 hours, 16 minutes, 33 seconds)</span>
	  ;<span class="comment-line">#</span>
	  ;<span class="comment-line"># TOTAL CURRENT RUN:  1372  (0 hours, 22 minutes, 19 seconds)</span>
	  global execSummaryFilename
	  set execSummaryPath &#34;$rightDir/$execSummaryFilename&#34;
	  set execAllTime &#34;&#34;
	  
	  if [file exists $execSummaryPath] {
	      set execAllTime [exec cat $execSummaryPath]
	  } else {
	      puts &#34;**************************************************&#34;
	      puts &#34;\nWARNING: Execution Time File:$execSummaryFilename \
		      does NOT exist\n&#34;
	      puts &#34;**************************************************&#34;
	  }

	  <span class="comment-line"># Parse report.txt and put each line in array paragraph(x)</span>
	  if {[catch {open &#34;$rightDir/report.txt&#34; r} fd_in]} {
	      puts &#34;ERROR: Unable to open $rightDir/report.txt for reading&#34;
	      return &#34;&#34;;
	  }
	  while {[gets $fd_in line] != -1} {
               if {[regexp -nocase &#34;MODULE_ABORTED&#34; $line]} {
                   set moduleAborted &#34;Yes&#34;
	           set testCaseListFailed &#34;&#34;;
		   lappend testCaseListFailed &#34;ALL&#34;;
                   set testsFromCfgFile &#34;&#34;;
                   set pdList &#34;&#34;
	           close $fd_in
                   break;
               }
	  }
          if { $moduleAborted == &#34;Yes&#34; } {
             continue;
          } else {
             seek $fd_in 0 start
          }
 
	  while {[gets $fd_in line] != -1} {
	      set paragraph($count) $line
	      incr count
	  }
	  close $fd_in

	  puts &#34;DEBUG paragraph count: $count&#34;
	  
	  set thisPara &#34;&#34;
	  set prevFailed 0
	  set relFlag 0
	  
	  <span class="comment-line"># Proc to create thisPara and pass it to VerifyResult.  Essentially </span>
	  <span class="comment-line"># group each line into thisPara until we hit a blank line.  Sections </span>
	  <span class="comment-line"># separated by a blank line constitute paragraphs.</span>
	  
	  for {set i 0} {$i&lt;=[array size paragraph]} {incr i} {
	      
	      if {$i != [array size paragraph]} {
		  set line $paragraph($i)                      
	      } 
	      
	      <span class="comment-line"># tn: MAJOR Test Number. i.e. 2.1.1 or 3.4 etc. This gets set</span>
	      <span class="comment-line">#     in verifyResult call.</span>
	      <span class="comment-line"># fl: Failure.. verifyResult returns -1 for passing test case</span>
	      <span class="comment-line">#</span>
	      <span class="comment-line"># We continue to append to $thisPara until we get a blank line.</span>
	      <span class="comment-line"># As soon as we get a blank line, we pass that paragraph to verifyResult</span>
	      if { ($line==&#34;&#34;) || ($i == [array size paragraph]) } {
		  
		  <span class="comment-line"># We hit a blank line or the end of the report.txt file</span>
		  set tn &#34;none&#34;

		  if {[regexp -nocase &#34;perf&#34; $regType]} {
		      set fl [<a name="::verifyPerfResult(1)"><a href="./automate.tcl.html#::verifyPerfResult_984">::verifyPerfResult</a></a> $thisPara $fd tn]
		  } else {
		      set fl [<a name="::verifyResult(1)"><a href="./automate.tcl.html#::verifyResult_922">::verifyResult</a></a> $thisPara $fd tn]	 
		  }
		  
		  
		  if {[regexp -nocase &#34;System setup&#34; $tn]&amp;&amp;$relFlag==0} {
		      puts &#34;DEBUG: writeReleaseMasterFile  $buildName   $platform&#34;
		      <a name="::writeReleaseMasterFile(1)"><a href="./automate.tcl.html#::writeReleaseMasterFile_1061">::writeReleaseMasterFile</a></a> $buildName $platform
		      set tn &#34;none&#34;
		      set relFlag 1
		  }
		  
		  if {[regexp -nocase &#34;perf&#34; $regType]} {
		      <span class="comment-line"># Performance</span>

		      if {$tn!=&#34;none&#34;&amp;&amp;$fl!=-1} {
			  lappend testCaseListPerf $tn;
		      } 
		  } else {
		      <span class="comment-line"># Standard/Routing/CLI</span>

		      if {$tn != &#34;none&#34; &amp;&amp; $fl != -1} {
			  lappend testCaseListFailed $tn;
		      } elseif {$tn != &#34;none&#34; &amp;&amp; $fl == -1} {
			  lappend testCaseListPassed $tn
		      }
		  }
		  
		  if {$fl!=&#34;-1&#34;} {
		      set prevFailed 1
		  }
		  set thisPara &#34;&#34;
		  continue
		  
	      } else {

		  <span class="comment-line"># Append each line to $thisPara until we hit a blank line.</span>
		  lappend thisPara $line
		  ;<span class="comment-line"># Get config file name from report.txt</span>
		  set flag [regexp -nocase {^Using config file: (.*)} $line match cfgFile]
		  set flag [regexp -nocase {^Using lst: (.*)} $line match lstName]
	      }
	      
	  } ;<span class="comment-line"># for {set i 0} {$i&lt;=[array size paragraph]} {incr i} </span>

	  if {($fl==-1)&amp;&amp;($prevFailed==0)} {
	      if [regexp -nocase &#34;perf&#34; $regType] {
		  puts &#34;No performance data for $testModule in dir $rightDir )))&#34;
		  puts $fd &#34;No performance data for $testModule in dir $rightDir )))&#34;
	      } else {
		  puts &#34;OK: No Test case failed for $testModule in dir $rightDir )))&#34;
		  puts $fd &#34;OK: No Test case failed for $testModule in dir $rightDir )))&#34;
	      }
	  }
	  
	  if {$testModule == &#34;cli&#34;} {
	      if {($runflag == &#34;config&#34;) &amp;&amp; ($prevFailed == 1)} {
		  lappend moduleNeedToRerun $testModule;
	      }   
	  }
	  
	  puts $fd &#34;\n&#34;

	  ;<span class="comment-line"># Config read from report.txt earlier</span>
	  puts &#34;Config file name : $cfgFile&#34;
	  puts $fd &#34;Config file name : $cfgFile&#34;

          <span class="comment-line"># ADD CODE</span>
          <span class="comment-line"># If test_to_run in config file don't do anything</span>
          <span class="comment-line"># pass in like before</span>
          <span class="comment-line"># If not process the list file from the config file</span>
          <span class="comment-line"># and append it to the end of the cfg file and pass in new</span>
          <span class="comment-line"># config file to the TestsFromCfgFile proc below</span>

          if {[set tmpCfgFile [preProcessCfgFile $testModule $cfgFile $regPath $lstName $platform]]==0} {
             return $tmpCfgFile
          }
          puts &#34;tmpCfgFile =  $tmpCfgFile&#34; 
          set saveCfgFile $cfgFile
          set cfgFile $tmpCfgFile

          <span class="comment-line"># --- compare and get the left out test cases</span>
          set testsFromCfgFile [<a name="::TestsFromCfgFile(1)"><a href="./automate.tcl.html#::TestsFromCfgFile_1770">::TestsFromCfgFile</a></a> $testModule $cfgFile $buildName $fd $regPath];
	  puts &#34;DEBUG: testsFromCfgFile: $testsFromCfgFile&#34;
	  puts &#34;DEBUG: module:           $testModule        cfgFile: $cfgFile&#34;    
	  puts &#34;DEBUG: buildName:        $buildName         fd:      $fd&#34;
	  
	  
	  if [regexp -nocase &#34;perf&#34; $regType] {
	      set runOrRerun 1
	      puts &#34;Test cases with performance data      : $testCaseListPerf&#34;;
	  } else {
	      <span class="comment-line"># set the runOrRerun flag to 2 if cfg is pt a file, 1 otherwise</span>
	      if {[regexp -nocase &#34;short/pt.*$buildName&#34; $saveCfgFile]} {
		  puts &#34;DEBUG: This was a re-run based on CONFIG FILE: $cfgFile&#34;;
		  set runOrRerun 2
	      } else {
		  puts &#34;DEBUG: This was an initial run based on CONFIG FILE: $cfgFile&#34;;
		  set runOrRerun 1
	      }
	 
	     puts &#34;Test cases failed      : $testCaseListFailed&#34;;
	     puts &#34;Test cases passed      : $testCaseListPassed&#34;;
	     puts $fd &#34;Test cases failed      : $testCaseListFailed&#34;;
	     puts $fd &#34;Test cases passed      : $testCaseListPassed&#34;;
	     
	     <span class="comment-line"># Compare passed/failed tests with testFromCfgFile and compute testCaseListFailed</span>
	     foreach testFromCfgFile $testsFromCfgFile {
		 if {[regexp -nocase $testFromCfgFile $testCaseListFailed] != 1 &amp;&amp; \
			 [regexp -nocase $testFromCfgFile $testCaseListPassed] != 1 &amp;&amp; \
			 $testFromCfgFile != 0} {
		     lappend testCaseListFailed $testFromCfgFile
		 }
	     }
	 
	     <span class="comment-line"># Check OLD PDs for non-performance runs</span>
	     <span class="comment-line"># check for the PD of the failed tests from prev build</span>
	     set buildHead &#34;&#34;
	     if [regexp -nocase {([0-9].[0-9].[0-9]b[0-9]+)_[a-z]+} \
		     $buildName match buildHead] {

	     } else {

		 set buildHead $buildName

	     }
	     
	     puts &#34;DEBUG: Get PD lists from previous build&#34;
             if {$regSubType == &#34;upgradedowngrade&#34;} {
                 set pdList &#34;&#34;
             } else {
	         set pdList [<a name="::getPDListFromPrevBuild(1)"><a href="./automate.tcl.html#::getPDListFromPrevBuild_770">::getPDListFromPrevBuild</a></a> testCaseListFailed \
                         $testModule $platform $bladeType $buildHead \
                         $regType $regSubType]
             }
	     puts &#34;DEBUG: pdList: $pdList&#34;
	     
	     <span class="comment-line"># if -noconfig option is NOT supplied, append moduleNeedToRerun </span>
	     <span class="comment-line"># list with module</span>
	     if { ($testCaseListFailed != &#34;&#34;) &amp;&amp; ($runflag==&#34;config&#34;) } {
		 
puts &#34;Now going to $testCaseListFailed and $runflag&#34;
		 if {$testModule!=&#34;cli&#34;} {
		     lappend moduleNeedToRerun $testModule;
		 }
		 ; <span class="comment-line"># Create a consistent pt file across runs! (APL)</span>
		 set rval [<a name="::createShortConfig(1)"><a href="./automate.tcl.html#::createShortConfig_1967">::createShortConfig</a></a> $cfgFile $testModule \
			 $testCaseListFailed &#34;$platform$bladeType&#34; \
			 $buildName $regPath];

		 if {$rval == 0} {
		     puts &#34;WARNING: WE HAVE PROBLEM CREATING THE SHORT CONFIG FILE !!!&#34;
		     puts $fd &#34;WARNING: WE HAVE PROBLEM CREATING THE SHORT CONFIG FILE !!!&#34;    
		 }
	     } 
	 }
         catch {file delete $cfgFile}
     }
     
   
     <span class="comment-line"># --------------- WEB POSTING ---------------</span>
     
     <span class="comment-line"># Han: we want to update the web server with the performance data......</span>
     <span class="comment-line"># Put the test case number : performance data as log file</span>
     if {[regexp -nocase &#34;perf&#34; $regType]} {
	 
	 <span class="comment-line"># Update webserver database files on autoweb</span>
	 set webFileName [<a name="::updatePerfWebDataFile(1)"><a href="./automate.tcl.html#::updatePerfWebDataFile_1098">::updatePerfWebDataFile</a></a> $regType $buildName $platform \
		 $bladeType $testModule $testCaseListPerf $testsFromCfgFile]      
	 
	 set err [<a name="::putPerfTestResult(1)"><a href="./automate.tcl.html#::putPerfTestResult_147">::putPerfTestResult</a></a> $testModule $webFileName $perfFileName \
		 $platform $bladeType $buildName]
	 if {$err != 0} {
	     puts &#34; Failed to update performance data&#34;
	 }

     } else {

     
	 <span class="comment-line"># Update webserver database files on autoweb</span>
	 <span class="comment-line"># NOTE: If runOrRerun=1, testsFromCfgFile indicates the tests that </span>
	 <span class="comment-line">#       are not run from cfg file.</span>
	 set webFileName [<a name="::updateWebDataFile(1)"><a href="./automate.tcl.html#::updateWebDataFile_1199">::updateWebDataFile</a></a> $regType $regSubType $buildName \
		 $platform $bladeType $testModule $testCaseListFailed $pdList \
		 $testsFromCfgFile $runOrRerun $execAllTime]
	 <span class="comment-line">#run=1,rerun=2</span>
	 
	 <span class="comment-line"># if rerun, put failed test log on webserver</span>
	 puts &#34;DEBUG: runOrRerun = $runOrRerun webFileName:$webFileName&#34;
	 if {$runOrRerun==2} {

	     puts &#34;DEBUG: Saw Failed Test&#34;

	     set curDir [pwd]
	     global webServerDirName
	     cd &#34;$webServerDirName&#34;

	     puts &#34;DEBUG: Opening $webFileName to write failed case log&#34;

	     if {[catch {open $webFileName r} fd_in]} {
		 cd $curDir
		 puts &#34;** ERROR: Unable to open $webFileName.&#34;
		 continue
	     } else {
		 set count 0
		 while {[gets $fd_in line] != -1} {
		     set para($count) $line
		     incr count
		 }
		 close $fd_in
		 set logList &#34;&#34;
		 for {set ind 0} {$ind&lt;[array size para]} {incr ind} {
		     set status &#34;&#34;
		     set test &#34;&#34;
		     regexp {([0-9]+[.][0-9a-z_.-]*)([a-zA-Z]+)} $para($ind) match test status
		     <span class="comment-line"># check if status is RF, D or FW</span>
		     global rfTag
		     if {$status==$rfTag||$status==&#34;D&#34;||$status==&#34;FW&#34;} {
			 lappend logList $test
		     }
		 }
	     }
	     puts &#34;DEBUG: logList $logList&#34;
	     cd $curDir
	     foreach log $logList {
		 set log [string trimright $log -]
		 set moduleDirName [file dirname $webFileName]
		 set destFile $testModule$log.txt
		 set rightDi [lindex $rightDirList 0]
		 append rightDi &#34;/$log.txt&#34;
		 puts &#34;DEBUG: $webServerDirName/$moduleDirName/$destFile &#34;;
		 
		 if {[file exists $webServerDirName/$moduleDirName/$destFile]} {
		     if [catch {file delete $webServerDirName/$moduleDirName/$destFile} reason] {
			 puts &#34;ERROR: $reason&#34;
			 continue
		     }
		 }
		 catch {file copy $rightDi $webServerDirName/$moduleDirName/$destFile} reason
	     }
	     if [info exists para] {
		 unset para
	     }
	 }
     } 

     puts $fd &#34;###############################################\n&#34;

 } ;<span class="comment-line"># END foreach testModule $regressionModules</span>

 return 1
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [getPDListFromPrevBuild]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Procedure to capture PDlist from 3 consecutive builds based on the testsList, module, plat, blade and regType.</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                testsList</span>
<span class="comment-line">#                module</span>
<span class="comment-line">#                plat</span>
<span class="comment-line">#                blade</span>
<span class="comment-line">#                build</span>
<span class="comment-line">#                regType</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns list of PDs for above criteria</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#       set pdList [getPDListFromPrevBuild testCaseListFailed $module $platform $bladeType $buildHead $regType]</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::getPDListFromPrevBuild_770">proc <a href="automate.tcl-annot.html#::getPDListFromPrevBuild">::getPDListFromPrevBuild</a></a></strong><a name="::getPDListFromPrevBuild"></a> {testsList module plat blade build \
	regType regSubType} {

    global webServerDirName
    global newPlatforms
    global rerunTag
    global rfTag
    global rpTag
      
    set flag 0;
    set curDir [pwd]
    upvar $testsList testCaseList
    if {![file isdir $webServerDirName]} {
       file mkdir $webServerDirName
    }
    cd &#34;$webServerDirName&#34;
    if {[regexp -nocase $newPlatforms $plat]} {
	set relName $plat
    } else {
	set relName [string range $build 0 3]
    }
    
    set number 0
    set ver 0
    set b .
    set flg [regexp -nocase {^([0-9]+.[0-9a-z]+.[0-9]+).([0-9]+).*} $build match ver number]
    
    set i 1
    set pdListToReturn &#34;&#34;
    
    <span class="comment-line"># check upto 3 build</span>
    while {$i&lt;4} {
	set prevBuild $ver$b[expr $number-$i]
	if {[regexp -nocase &#34;^cli&#34; $module]} {
	    set bl [split $blade]
	    switch -- $plat {
		&#34;BD&#34; {
		    set pl &#34;BD&#34;
		} &#34;Alpine&#34; {
		    set pl $plat
		} &#34;BT&#34; {
		    set pl &#34;BT&#34;
		} &#34;GODZILLA&#34; {
		    set pl &#34;GZ&#34;
		} &#34;Summit24e3&#34; {
		    set pl &#34;S24e3&#34;
		} default {
		    set pl $plat
		}
	    }
	    set prevDir &#34;$relName/$prevBuild/$module$pl[lindex $bl 0]&#34;
	    set fname &#34;$prevDir/[lindex $bl 1].txt&#34;
	} else {
	    switch -- $plat \
		    &#34;BD&#34; {
		set pl &#34;BD&#34;
	    } &#34;Alpine&#34; {
		set pl $plat
	    } &#34;BT&#34; {
		set pl &#34;BT&#34;
	    } &#34;GODZILLA&#34; {
		set pl &#34;GZ&#34;
	    } &#34;Summit24e3&#34; {
		set pl &#34;S24e3&#34;
	    } default {
		set pl $plat
	    }
	    
	    if [regexp -nocase &#34;ipr&#34; $regSubType] {
		global Iproute
<span class="comment-line">#		set prevDir &#34;$relName/$prevBuild/[lindex $Iproute 0]&#34;	;# my</span>
		set prevDir &#34;$relName/$prevBuild/RoutingRegressionSummary/$pl$blade&#34;	;<span class="comment-line"># my</span>
	    } else {
		set prevDir &#34;$relName/$prevBuild/$pl$blade&#34;
	    }
	    set fname &#34;$prevDir/$module.txt&#34;;
	}
	
	puts &#34;prevBuildDir-----&gt; $fname&#34;
	
	if {[catch {open $fname r} fd_in]} {
	    <span class="comment-line"># File does not already exists, check the next prev build.</span>
	    incr i
	} else {
	    incr i 10
	    break
	}
    }

    ;<span class="comment-line"># No earlier build found for this module</span>
    if {$i&lt;10} {    
	cd $curDir
	return $pdListToReturn
    }
    set count 0
    while {[gets $fd_in line] != -1} {
	set paragraph($count) $line
	incr count
    }
    close $fd_in
    set tList $testCaseList
    set testCaseList &#34;&#34;
    set status &#34;&#34;
    foreach t $tList {
	for {set i 0} {$i&lt;[array size paragraph]} {incr i} {
	    set status &#34;&#34;
	    set test &#34;&#34;
	    if {[regexp -nocase &#34;$t-&#34; $paragraph($i)]} {
		regexp {([0-9]+[.][0-9a-z_.-]*)([a-zA-Z]+)} $paragraph($i) match test status

		if {[regexp -nocase &#34;^PD&#34; $status] &amp;&amp; $test==&#34;$t-&#34;} {    
		    ;<span class="comment-line"># check if the test has a PD</span>
		    lappend pdListToReturn $paragraph($i)
		    break
		} else {   ;<span class="comment-line"># test does not have a PD</span>
		    if {[lsearch $testCaseList $t]==-1} {
			lappend testCaseList $t
		    }
		    break
		}
	    }
	}
	if {$status==&#34;&#34;} {
	    if {[lsearch $testCaseList $t]==-1} {
		lappend testCaseList $t
	    }
	}
    }
    cd $curDir

    return $pdListToReturn
}


<span class="comment-line">################################################################</span>
<span class="comment-line">#  [verifyResult]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Procedure to check the para for testcase and supplies the caller return value in out variable testN</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                para</span>
<span class="comment-line">#                fd</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                testN</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns -1 on error or the failed test line on sucess</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#            set fl [verifyResult $thisPara $fd tn]</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::verifyResult_922">proc <a href="automate.tcl-annot.html#::verifyResult">::verifyResult</a></a></strong><a name="::verifyResult"></a> {para fd testN} {

    upvar $testN testNumber
    set match &#34;&#34;

    <span class="comment-line"># Separately put the time consumption inside the heading</span>
    set timeValueKay &#34;Total test time|hours.*minutes.*seconds&#34;

    for {set i 0} {$i&lt;[llength $para]} {incr i} {
	if { [regexp $timeValueKay [lindex $para $i]] == 1 } {
	    puts $fd [lindex $para $i]
	}
    }

    set key &#34;FAILED&#34;
    set flag -1

    <span class="comment-line"># Search for FAILED keyword in the paragraph, and mark paragraph number</span>
    for {set i 0} {$i&lt;[llength $para]} {incr i} {

	if {[regexp $key [lindex $para $i]]==1} {
	    set flag $i

	}
    }

    if {$flag != &#34;-1&#34;} {
	<span class="comment-line"># Found keyword FAILED</span>
	for {set j 0} {$j&lt;=$flag} {incr j} {

	    if {(([regexp &#34;OK&#34; [lindex $para $j]]!=1)&amp;&amp; \
		    ([regexp {[0-9].[0-9]|Using file .*} \
		    [lindex $para $j]]==1)) ||  ([regexp -nocase \
		    &#34;System Setup|Total test time|hours.*minutes.*seconds&#34; \
		    [lindex $para $j]]) || ([regexp $key [lindex $para $j]])} {
		
		puts $fd [lindex $para $j]

		if {$j==0} {
		    set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} \
			    [lindex $para $j] match testNumber];
		    set flg [regexp -nocase {Using file .*/(.*.cli)} \
			    [lindex $para $j] match testNumber];
		} else {
		    if {[regexp -nocase &#34;Show Release_Master .*FAILED&#34; \
			    [lindex $para $j]]} {
			set testNumber &#34;System Setup&#34;
		    }
		}
	    }
	}
    } else {
	set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} [lindex $para 0] \
		match testNumber];
	set flg [regexp -nocase {Using file .*/(.*.cli)} [lindex $para 0] \
		match testNumber];

    }
    return $flag
}

<span class="comment-line"># Specifically used for performance</span>
<strong><a name="::verifyPerfResult_984">proc <a href="automate.tcl-annot.html#::verifyPerfResult">::verifyPerfResult</a></a></strong><a name="::verifyPerfResult"></a> {para fd testN} {
    upvar $testN testNumber
    set flag -1
    set perfdata1 &#34;&#34;
    set perfdata2 &#34;&#34;

    for {set i 0} {$i&lt;[llength $para]} {incr i} {
	if {([regexp -indices {\[ *[0-9.]+ *\]} [lindex $para $i] \
		match perfdata1]==1) \
		|| ([regexp -indices {\[ *[0-9.]+% *\]} [lindex $para $i] \
		match perfdata2]==1)} {

	    set flag $i
	}
   }

   if {$flag!=&#34;-1&#34;} {
      for {set j 0} {$j&lt;= $flag} {incr j} {
         set strBuf [lindex $para $j]
         if {($j==0) &amp;&amp; ([regexp {[0-9].[0-9]|Using file .*} $strBuf] == 1)} {
            set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} \
		    $strBuf match testNumber];
            set flg [regexp -nocase {Using file .*/(.*.cli)} \
		    $strBuf match testNumber];
         } 
         if {([regexp {[0-9].[0-9]|Using file .*} $strBuf] == 1) \
            || ([regexp -nocase \
	    &#34;System Setup|Total test time|hours.*minutes.*seconds&#34; $strBuf]) \
            || ([regexp {\[ *[0-9.]+ *\]} $strBuf]==1) \
            || ([regexp {\[ *[0-9.]+% *\]} $strBuf]==1)} {
	
            if {([regexp -indices {\[ *[0-9.]+ *\]} $strBuf match ]==1) \
               || ([regexp -indices {\[ *[0-9.]+% *\]} $strBuf match ]==1)} {
               scan $match {%[0-9]} endIndex
               set subtestStr  [string range  $strBuf 0 [incr endIndex -1]]
            }
            if {$j==0} {
               set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} \
		       $strBuf match testNumber];
               set flg [regexp -nocase {Using file .*/(.*.cli)} \
		       $strBuf match testNumber];
            } else {
               if {[regexp -nocase &#34;Show Release_Master .*FAILED&#34; $strBuf]} {
                  set testNumber &#34;System Setup&#34;
               }
            }
            puts $fd $strBuf
         } 
      } 
   } else {
      set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} [lindex $para 0] \
	      match testNumber];
      set flg [regexp -nocase {Using file .*/(.*.cli)} [lindex $para 0] \
	      match testNumber];
   }
   return $flag
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [writeReleaseMasterFile]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  Procedure that writes to autoweb about the release master check flag. The file is</span>
<span class="comment-line">#  empty if check passes, or contains FAILED if check fails</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                build</span>
<span class="comment-line">#                plat</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns 0 in case of error of not able to create a dir</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#      writeReleaseMasterFile $buildName $platform</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::writeReleaseMasterFile_1061">proc <a href="automate.tcl-annot.html#::writeReleaseMasterFile">::writeReleaseMasterFile</a></a></strong><a name="::writeReleaseMasterFile"></a> {build plat} {

    global webServerDirName
    global newPlatforms

   set curDir [pwd]

   if {[regexp -nocase $newPlatforms $plat]} {
      set relName $plat
   } else {
      set relName [string range $build 0 3]
   }
   cd &#34;$webServerDirName&#34;
   set thisDir &#34;$relName/$build&#34;
   set fname &#34;$thisDir/relMasterCheck&#34;
   if {[catch {open $fname r} fd_in]} {
      if {![file isdirectory $thisDir]} {
	  file mkdir $thisDir
      }
      if {[catch {open $fname w 0777} fd_out]} {
         cd $curDir
         return 0;
      } else {
         puts $fd_out &#34;FAILED&#34;
      }
      close $fd_out
   }
   cd $curDir
}




<span class="comment-line">#</span>
<span class="comment-line"># QAD to support performance reports.  Integrate better with </span>
<span class="comment-line"># proc updatePerfWebDataFile later. (APL)</span>
<span class="comment-line">#</span>
<strong><a name="::updatePerfWebDataFile_1098">proc <a href="automate.tcl-annot.html#::updatePerfWebDataFile">::updatePerfWebDataFile</a></a></strong><a name="::updatePerfWebDataFile"></a> {{regType &#34;&#34;} build platform blade module tList testsRan} {

    global webServerDirName
    global newPlatforms
    global rfTag
    global rpTag
    
    set flag 0;
    set curDir [pwd]
    cd &#34;$webServerDirName&#34;

    puts &#34;DEBUG: updatePerfWebDataFile{} platform: $platform: blade:$blade \
	    module:$module build:$build regType:$regType&#34;

    set thisDir [<a name="::getDirName(2)"><a href="./automate.tcl.html#::getDirName_1648">::getDirName</a></a> $platform $blade $module $build $regType $regSubType]
    set fname &#34;$thisDir/$module.txt&#34;;


    <span class="comment-line"># To show there is report for this module</span>
    <span class="comment-line"># If file exists, delete it, since we are generating a report</span>
    set reportFile &#34;$thisDir/../$module.txt&#34;
    if {[file exists $reportFile]} {
	puts &#34; We are deleting the report file $reportFile&#34;
	if [catch {file delete $reportFile} result] {
	    puts &#34;ERROR: $result&#34;
	    return 0
	}
    }

    if {[file exists $fname]} {
	if [catch {file delete $fname} result] {
	    puts &#34;ERROR: $result&#34;
	    return 0
	}
    }

    set testsInBugList &#34;&#34;
    
    if {![file isdirectory $thisDir]} {
	file mkdir $thisDir
    }
    
    if {[catch {open $reportFile w 0777} fd_out]} {
	puts &#34;** ERROR: Cannot open $reportFile for writing&#34;
	cd $curDir
	return 0;
    } else {
	puts $fd_out &#34;PERFORMANCE DATA&#34;
    }

    if {[catch {open $fname w 0777} fd_out]} {
	puts &#34;** ERROR: Cannot open $fname for writing&#34;
	cd $curDir
	return 0;
    } else {
	foreach t $tList {
	    puts $fd_out &#34;$t&#34;
	}
    }

    close $fd_out
    cd $curDir
    return $fname
}


<span class="comment-line">################################################################</span>
<span class="comment-line">#  [updateWebDataFile]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  This is most crucial proc that writes result data to autoweb data files.</span>
<span class="comment-line">#  controls multiple runs of automate.tcl by not updating appropriate flags, </span>
<span class="comment-line">#  maintaining up to date information. It supports this mechanism for any </span>
<span class="comment-line">#  number of runs of regression</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                regType</span>
<span class="comment-line">#                build</span>
<span class="comment-line">#                platform</span>
<span class="comment-line">#                blade</span>
<span class="comment-line">#                module</span>
<span class="comment-line">#                tList - tests list that failed</span>
<span class="comment-line">#                bugList - bugs that were carried over from previous builds</span>
<span class="comment-line">#                testsRan - tests that were run in a given file</span>
<span class="comment-line">#                runOrRerun - flag that indicates if the regression was first </span>
<span class="comment-line">#                             run or rerun</span>
<span class="comment-line">#                execAllTime - Time to execute all tests.  If &#34;all&#34; not run</span>
<span class="comment-line">#                              this value is set to 0 </span>
<span class="comment-line">#</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns 0 on error or </span>
<span class="comment-line">#                  webFileName to which the data was written in success</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#     set webFileName [updateWebDataFile $regType $buildName $platform $bladeType \</span>
<span class="comment-line">#                       $module $testCaseListFailed $pdList $testsFromCfgFile \</span>
<span class="comment-line">#                       $runOrRerun]   ;#run=1,rerun=2</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::updateWebDataFile_1199">proc <a href="automate.tcl-annot.html#::updateWebDataFile">::updateWebDataFile</a></a></strong><a name="::updateWebDataFile"></a> {{regType &#34;&#34;} regSubType build platform blade module \
	tList bugList testsRan runOrRerun {execAllTime 0}} {
    
    ;<span class="comment-line"># tList are the failed test cases</span>
    ;<span class="comment-line"># bugList is the list of PDs from previous builds.</span>
    ;<span class="comment-line"># NOTE: A failed test case can be in either tList or bugList, but not both.</span>

    global webServerDirName
    global newPlatforms
    global rerunTag
    global rfTag
    global rpTag
    global abortTag
      
    if {[regexp -nocase &#34;perf&#34; $regType]} {
	<a name="::updatePerfWebDataFile(2)"><a href="./automate.tcl.html#::updatePerfWebDataFile_1098">::updatePerfWebDataFile</a></a> $regType $build $platform $blade \
		$module $tList $testsRan
	return
    }


    puts &#34;DEBUG: updateWebDataFile{} platform:$platform: blade:$blade \
	    module:$module build:$build regType:$regType $regSubType&#34;

  set webSuffix &#34;&#34;
    if {[string compare &#34;root&#34; [id user]]==0} {  ;<span class="comment-line"># check env AUTOMATE_GID in case of root </span>
       global env
       if {[info exists env(AUTOMATE_GID)]} {
          set gid &#34;software&#34;   ;<span class="comment-line"># dont want to assign the env itself which may</span>
                               <span class="comment-line"># potentially write other builds than _dev suffixes</span>
       } else {
          set gid &#34;sqa&#34;
       }
    } else {  ;<span class="comment-line"># else get effective gid</span>
       set gid [id effective group]
    }
   if {$gid == &#34;software&#34;} {
      append build &#34;_dev&#34;  
      set webSuffix &#34;_dev&#34;
   }

    set flag 0;
    puts &#34;***** [pwd]   **** $webServerDirName&#34;   
    set curDir [pwd]
   
    cd &#34;$webServerDirName&#34;

if { 0 } {
    if {[regexp -nocase $newPlatforms $platform]} {
	set relName $platform
    } else {
	set relName [string range $build 0 3]
    }
}

    set relName [string range $build 0 3]

    switch -- $platform \
    &#34;BD-10808&#34; {
	set pl $platform
    } &#34;BD-8904&#34; {
	set pl $platform
    } &#34;BD-12804&#34; {
	set pl $platform
    } &#34;BD-16808&#34; {
	set pl $platform
    } &#34;BD-PC&#34; {
	set pl $platform
    } &#34;Summit-PC&#34; {
	set pl $platform
    } &#34;BD&#34; {
	set pl &#34;BD&#34;
    } &#34;Aspen&#34; {
	set pl $platform
    } &#34;SummitX450&#34; {
	set pl $platform
    } &#34;SummitX406&#34; {
	set pl $platform
    } &#34;GODZILLA&#34; {
	set pl &#34;GZ&#34;
    } &#34;Summit24e3&#34; {
	set pl &#34;S24e3&#34;
    } default {
	set pl $platform
    }
    
    if [regexp -nocase &#34;ipr&#34; $regSubType] {
	global Iproute
	set thisDir &#34;$relName/$build/RoutingRegressionSummary/$pl$blade&#34;
	
    } elseif {[regexp -nocase &#34;cli&#34; $regType]} {
        if {[regexp -nocase &#34;upload&#34; $regSubType]} {
	    set thisDir &#34;$relName/$build/cli$pl$blade&#34;
        } else {
            set buildList [split $build :]
	    set build1 [lindex $buildList 0]$webSuffix
	    set build2 [lindex $buildList 1]
	    regsub -all &#34;$webSuffix&#34; $build2 {} build2x
	    set thisDir &#34;$relName/$build1/upgradedowngrade/$build2x/cli$pl$blade&#34;
        }
	
    } else {
	set thisDir &#34;$relName/$build/$pl$blade&#34;
    }
    
    set fname &#34;$thisDir/$module.txt&#34;;
    set fnameTime &#34;$thisDir/$module.time.txt&#34;;

   puts &#34;Update Web Data File -----&gt;  $fname&#34;
   
   <span class="comment-line"># Web results should be written in /autoweb/Http/cgi-bin/cgi.tcl/data/$fname</span>
   <span class="comment-line"># Samples...</span>
   <span class="comment-line"># $fname for standard...6.2/6.2.2b131/BDF96Ti/jumbo.txt</span>
   <span class="comment-line"># $fname for CLI...6.2/6.2.2b131/cliBDF96Ti/jumbo.txt</span>
   <span class="comment-line"># $fname for routing...6.2/6.2.2b131/RoutingRegressionSummary/aspen/jumbo.txt</span>
   <span class="comment-line"># $fname for performance...6.2/6.2.2b131/PerformanceSummary/BDF96Ti/EAPS_PerfData.txt</span>
 
   set testsInBugList &#34;&#34;
   foreach b $bugList {

       set test &#34;&#34;
       regexp {([0-9]+[.][0-9a-z_.]*)-([a-zA-Z]+)} $b match test status
       lappend testsInBugList $test
   }

   if {$runOrRerun==1} {
       puts &#34;UpdateWebDataFile ---&gt; FIRST RUN&#34;
       if {[catch {open $fname r} fd_in]} {

	   ;<span class="comment-line"># If we can't read it, then create it.</span>
	   if {![file isdirectory $thisDir]} {
	       file mkdir $thisDir
	   }

	   if {[catch {open $fname w 0777} fd_out]} {
	       puts &#34;** ERROR: Can't open $fname for writing&#34;
	       cd $curDir
               puts &#34;RETURNING 0 (1)&#34;
	       return 0;
	   } else {
	       <span class="comment-line"># Write all PDs to txt file</span>
	       foreach bug $bugList {
		   puts &#34;DEBUG:     bug:$bug&#34;
		   puts $fd_out $bug
	       }
	       foreach t $tList {
                   if { ( $t == &#34;ALL&#34; ) &amp;&amp; ( [file size $fname]==0 ) } { <span class="comment-line">#Module aborted</span>
		       puts &#34;DEBUG: All test cases failed as module got aborted&#34;
		       puts $fd_out &#34;$abortTag&#34;
                       break
                   }
		   puts &#34;DEBUG:     TAG:$t-$rerunTag&#34;
		   puts $fd_out &#34;$t-$rerunTag&#34;
	       }
	   }

	   close $fd_out

	   if {[regexp -nocase &#34;^cli&#34; $module]!=1} {
	       if {[file size $fname]==0&amp;&amp;($testsRan!=&#34;&#34;)} {
		   catch {open $fname w 0777} fd_out
		   puts $fd_out &#34;PASSED&#34;
		   close $fd_out
	       }
	       if {[file size $fname]==0&amp;&amp;($testsRan==&#34;&#34;)} {
		   catch {open $fname w 0777} fd_out
		   puts $fd_out &#34;N/A&#34;
		   close $fd_out
	       }
	   } else {
	       if {[file size $fname]==0} {
		   catch {open $fname w 0777} fd_out
		   puts $fd_out &#34;PASSED&#34;
		   close $fd_out
	       }
	   }

       } else {

	   <span class="comment-line"># File already exists, read it and update it with R </span>
	   <span class="comment-line"># or same as what is read</span>
	   if {[catch {open temp[pid] w 0777} fd_out]} {
	       cd $curDir
	       puts &#34;RETURNING 0 (2)&#34;
	       return 0
	   } else {
	       set count 0
	       while {[gets $fd_in line] != -1} {
		   set paragraph($count) $line
		   incr count
	       }
	       close $fd_in
	       
	       <span class="comment-line"># Write all PDs to txt file</span>
	       foreach bug $bugList {
		   puts $fd_out $bug
	       }
	       foreach t $tList {
                   if { $t == &#34;ALL&#34; } { <span class="comment-line">#Module aborted</span>
		       puts $fd_out &#34;$abortTag&#34;
                       break
                   }
		   for {set i 0} {$i&lt;[array size paragraph]} {incr i} {
		       
		       set flag &#34;notDone&#34;
		       if {[regexp -nocase &#34;^$t&#34; $paragraph($i)]} {
			   set status &#34;&#34;
			   set test &#34;&#34;
			   set flag &#34;done&#34;
			   if {[regexp -nocase &#34;^cli&#34; $module]!=1} {
			       regexp {([0-9]+[.][0-9a-z_.-]*)([a-zA-Z]+)} \
				       $paragraph($i) match test status
			   } else {
			       regexp {([0-9a-zA-Z_.]*)-([a-zA-Z]+)} \
				       $paragraph($i) match test status
			       set test [format %s%s $test -]
			   }

			   <span class="comment-line"># check if status is rerun, if yes keep it </span>
			   <span class="comment-line"># rerun else do not change</span>
			   if {$status==$rerunTag &amp;&amp; $test==&#34;$t-&#34;} {    
			       <span class="comment-line"># test is in R state</span>
			       puts $fd_out &#34;$t-$rerunTag&#34;
			       break
		           }  else {   
			       ;<span class="comment-line"># test is in other state</span>
			       puts $fd_out $paragraph($i)
			       break
			   }
		       }
		   }
		   if {$flag!=&#34;done&#34;} {
		       puts $fd_out &#34;$t-$rerunTag&#34;
		   }
	       }
	       
	       close $fd_out
	       if {[regexp -nocase &#34;^cli&#34; $module]!=1} {
		   if {[file size temp[pid]]==0&amp;&amp;($testsRan!=&#34;&#34;)} {
		       catch {open temp[pid] w 0777} fd_out
		       puts $fd_out &#34;PASSED&#34;
		       close $fd_out
		   }
		   if {[file size temp[pid]]==0&amp;&amp;($testsRan==&#34;&#34;)} {
		       catch {open temp[pid] w 0777} fd_out
		       puts $fd_out &#34;N/A&#34;
		       close $fd_out
		   }
	       } else {
		   if {[file size temp[pid]]==0} {
		       catch {open temp[pid] w 0777} fd_out
		       puts $fd_out &#34;PASSED&#34;
		       close $fd_out
		   }
	       }
	   }
	   catch {file delete $fname} result
	   catch {file rename temp[pid] $fname} result
       }
       ;<span class="comment-line"># Create execution time summary for first pass</span>
       if {[catch {open &#34;$fnameTime&#34; w 0777} fd_out_time]} {
	   puts &#34;WARNING: Unable to open $fnameTime for writing.  $fd_out_time&#34;
       } else {
	   puts $fd_out_time &#34;$execAllTime&#34;
	   close $fd_out_time
       }
   }

   if {$runOrRerun==2} {
       puts &#34;UpdateWebDataFile ---&gt; RE-RUN&#34;
       if {[catch {open $fname r} fd_in]} {
	   puts &#34;DEBUG: Creating new file&#34;
	   <span class="comment-line"># File does not already exists, prudently put the RP,or RF </span>
	   <span class="comment-line"># and do not touch any other flag</span>
	   if {![file isdirectory $thisDir]} {
	       file mkdir $thisDir
	   }
	   if {[catch {open $fname w  0777} fd_out]} {
	       cd $curDir
	       puts &#34;RETURNING 0 (3)&#34;
	       return 0;
	   } else {

	       <span class="comment-line"># Write all PDs to txt file</span>
	       foreach bug $bugList {
		   puts &#34;DEBUG: Writing out bug $bug&#34;
		   puts $fd_out $bug
	       }
	       
	       foreach testRan $testsRan {
		   puts &#34;DEBUG: testRan: $testRan&#34;
		   if {$testRan!=0} {   
		       ;<span class="comment-line"># in case short cfg file not read</span>
		       if {[regexp -nocase $testRan $tList]} {   
			   ;<span class="comment-line"># Test failed</span>
			   puts &#34;DEBUG: testFailed: $testRan&#34;
			   puts $fd_out &#34;$testRan-$rfTag&#34;
		       } elseif {[lsearch $testsInBugList $testRan]==-1} {
			   puts &#34;DEBUG: testPass: $testRan&#34;
			   puts $fd_out &#34;$testRan-$rpTag&#34;         
			   ;<span class="comment-line"># Test passed</span>
		       }
		   } else {
		       close $fd_out
		       catch {file delete $fname} result
		       cd $curDir
	               puts &#34;RETURNING 0 (4)&#34;
		       return 0
		   }
	       }
	   }
	   close $fd_out
       } else {

	   puts &#34;DEBUG: Opened existing file $fname&#34;
	   <span class="comment-line"># File already exists, read it and update it with RF, RP flags</span>
	   if {[catch {open temp[pid] w 0777} fd_out]} {
	       cd $curDir
	               puts &#34;RETURNING 0 (5)&#34;
	       return 0
	   } else {
	       set count 0
	       while {[gets $fd_in line] != -1} {
		   set paragraph($count) $line
		   incr count
	       }
	       close $fd_in
	       
	       <span class="comment-line"># Write all PDs to txt file</span>
<span class="comment-line">#	       foreach bug $bugList {</span>
<span class="comment-line">#		   puts &#34;DEBUG: Writing PD $bug to file&#34;</span>
<span class="comment-line">#		   puts $fd_out $bug</span>
<span class="comment-line">#	       }</span>
	       
	       ;<span class="comment-line"># Look at current Web File and search for instances of the failed test </span>
	       ;<span class="comment-line"># cases ($tList) from this run.  Mark them as RF.  If, for some reason,</span>
	       ;<span class="comment-line"># a failed test case was not found on the Web File, mark it RF as well.</span>
	       foreach t $tList {
		   puts &#34;DEBUG: Looking at $t&#34;
		   set status &#34;&#34;
		   set test &#34;&#34;
		   for {set i 0} {$i&lt;[array size paragraph]} {incr i} {

		       if {[regexp -nocase &#34;^$t-&#34; $paragraph($i)]} {

			   puts &#34;DEBUG: ******* FOUND $t  ***********&#34;
			   regexp {([0-9]+[.][0-9a-z_.-]*)([a-zA-Z]+)} $paragraph($i) match test status
			   if [info exist match] {
			       puts &#34;DEBUG match:$match test:$test status:$status&#34;
			       <span class="comment-line"># set test [format %s%s $test -]</span>
			       <span class="comment-line"># check if status is rerun, if yes change it to </span>
			       <span class="comment-line"># fail else do not change</span>
			       puts &#34;DEBUG: status:$status==rerunTag:$rerunTag    test:$test==t:$t&#34;
			       
			       if {$status==$rerunTag &amp;&amp; $test==&#34;$t-&#34;} {
				   ;<span class="comment-line"># test is in R state</span>
				   puts $fd_out &#34;$t-$rfTag&#34;
				   <span class="comment-line"># CLI  set outp [format %s%s%s $t - $rfTag]</span>
				   <span class="comment-line"># CLI  puts $fd_out $outp</span>
				   <span class="comment-line"># CLI  set paragraph($i) $outp</span>
				   break
				   
			       } elseif {[lsearch $testsInBugList $t]==-1} {
				   <span class="comment-line"># test is in other state</span>
				   puts $fd_out $paragraph($i)
				   break
			       }
			   } else {
			       puts &#34;DEBUG: No existing match for $t in Autoweb.\
				       Add as new $t-$rfTag&#34;
			       puts $fd_out &#34;$t-$rfTag&#34;
			   }
		       } else {
			   continue
		       }
		   }

		   if {$test == &#34;&#34;} {
		       puts &#34;DEBUG: TEST $t not found:&#34;
		       ;<span class="comment-line"># Test wasn't found in web file.</span>
		       ;<span class="comment-line"># Since we know this is a re-run, and this case failed, </span>
		       ;<span class="comment-line"># mark RF</span>
		       puts $fd_out &#34;$t-$rfTag&#34;
		   }
	       }
	       
	       ;<span class="comment-line"># Now go through Web File and examine ALL test cases again.  </span>
	       ;<span class="comment-line"># Any testcases found that PASSED this second run should be </span>
	       ;<span class="comment-line"># marked RP.  We look at each testcase found and check if it's </span>
	       ;<span class="comment-line"># on the failed list.  If it's not on the failed list we can </span>
	       ;<span class="comment-line"># mark it RP.</span>
	       for {set i 0} {$i&lt;[array size paragraph]} {incr i} {
		   set test &#34;&#34;
		   set status &#34;&#34;
		   if {[regexp -nocase &#34;^cli&#34; $module]!=1} {
		       puts &#34;DEBUG: Module was $module&#34;
		       regexp {([0-9]+[.][0-9a-z_.-]*)([a-zA-Z]+)} \
			       $paragraph($i) match test status
		   } else {
		       regexp {([0-9a-zA-Z_.]*)-([a-zA-Z]+)} $paragraph($i) \
			       match test status
		       set test [format %s%s $test -]
		   }

		   if [info exist match] {

		       puts &#34;DEBUG match:$match test:$test status:$status&#34;
		       set test [string trimright $test &#34;-&#34;]
		       
		       ;<span class="comment-line"># Look to see if this test was in the bug list</span>
		       puts &#34;DEBUG: testsInBugList: $testsInBugList&#34;
		       if {[lsearch $testsInBugList $test]==-1} {
			   puts &#34;DEBUG: status:$status &#34;
			   ;<span class="comment-line"># If the previous state was R/RP/RF and it's not on the</span>
			   ;<span class="comment-line"># failed list (tList), mark it RP</span>
			   if {$status==&#34;$rerunTag&#34; || $status==&#34;$rpTag&#34; || \
				   $status==&#34;$rfTag&#34;} {
			       
			       if {[lsearch -exact $tList $test]==-1} {
				   puts $fd_out &#34;$test-$rpTag&#34;
			       }
			   } elseif {$status == &#34;PD&#34;} {
			       puts &#34;DEBUG: PD status...do nothing&#34;
			       if {[lsearch -exact $tList $test]==-1} {
				   puts $fd_out $paragraph($i)
			       }
			       ;<span class="comment-line"># DO NOTHING</span>
			   } else {
			       if {[lsearch -exact $tList $test]==-1} {
				   puts $fd_out $paragraph($i)
			       }
			   }
		       }
		   } else {
		       puts &#34;WARNING: Bad format for entry $paragraph($i)&#34;
		   }
	       }
	       close $fd_out
	   }
	   catch {file delete $fname} result
	   catch {file rename temp[pid] $fname} result
       }
   }
   cd $curDir
   puts &#34;returning **************** $fname *************&#34;
   return $fname
}


<strong><a name="::getDirName_1648">proc <a href="automate.tcl-annot.html#::getDirName">::getDirName</a></a></strong><a name="::getDirName"></a>  {platform blade module build regType regSubType} {

    global newPlatforms

    set fname &#34;Wrong file Name&#34;
    
    puts &#34;In getDirName the regType: $regType  regSubType: $regSubType&#34;
    
    if {[regexp -nocase $newPlatforms $platform]} {
	set relName $platform
    } else {
	set relName [string range $build 0 2]
    }
    if {[regexp -nocase &#34;^cli&#34; $module]} {
	switch -- $platform {
	    &#34;BD&#34; {
		set pl &#34;BD&#34;
	    } &#34;Alpine&#34; {
		set pl $platform
	    } &#34;BT&#34; {
		set pl &#34;BT&#34;
	    } &#34;GODZILLA&#34; {
		set pl &#34;GZ&#34;
	    } &#34;Summit24e3&#34; {
		set pl &#34;S24e3&#34;
	    } default {
		set pl $platform
	    }
	}
	set thisDir &#34;$relName/$build/$module$pl[lindex $bl 0]&#34;
    } else {
	switch -- $platform \
		&#34;BD&#34; {
            set pl &#34;BD&#34;
	} &#34;Alpine&#34; {
            set pl $platform
	} &#34;BT&#34; {
            set pl &#34;BT&#34;
	} &#34;GODZILLA&#34; {
            set pl &#34;GZ&#34;
	} &#34;Summit24e3&#34; {
            set pl &#34;S24e3&#34;
	} default {
            set pl $platform
	}
	if {[regexp -nocase &#34;ipr&#34; $regSubType]} {
	    global Iproute
<span class="comment-line">#	    set thisDir &#34;$relName/$build/[lindex $Iproute 0]&#34;	;# exos</span>
  	    set thisDir &#34;$relName/$build/RoutingRegressionSummary/$pl$blade&#34;	;<span class="comment-line"># my</span>
	} else {
	    if {[regexp -nocase &#34;perf&#34; $regType]} {
		global Performance 

		set thisDir &#34;$relName/$build/PerformanceSummary/$platform$blade&#34;
	    } else {
		set thisDir &#34;$relName/$build/$pl$blade&#34;
	    }
	}
    }
    return $thisDir
}


<span class="comment-line">################################################################</span>
<span class="comment-line">#  [getTestCaseNumber]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  This proc reads a para and returns a testcase number from its line.</span>
<span class="comment-line">#  a test number may start with a digit followed by any char.</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                para</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns test number from the para or</span>
<span class="comment-line">#                none in case of no test found</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#            set tn [getTestCaseNumber $thisPara];</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::getTestCaseNumber_1731">proc <a href="automate.tcl-annot.html#::getTestCaseNumber">::getTestCaseNumber</a></a></strong><a name="::getTestCaseNumber"></a> {para} {

   set count 0;
   set match &#34;&#34;;
   set testn &#34;none&#34;;
   <span class="comment-line">#puts &#34;para =&gt; $para&#34;;</span>
   foreach line $para {
      set flg [regexp -nocase {([0-9]+[.][0-9a-z_.-]*) .*$} $line match testn];
      if {$flg == 1} {
        puts &#34; =++++=&gt; $testn &lt;=========&#34;;
      }
   }
   return $testn;
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [TestsFromCfgFile]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  This proc reads a complete config file and returns the list of</span>
<span class="comment-line">#  tests from tests_to_run variable. This variable may be read</span>
<span class="comment-line"># directly from the config file or via a sourced file</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                mdule</span>
<span class="comment-line">#                fname</span>
<span class="comment-line">#                build</span>
<span class="comment-line">#                fd</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns tests list found in tests_to_run variable </span>
<span class="comment-line">#                0 in case of error</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#      set testsFromCfgFile [TestsFromCfgFile $module $cfgFile $buildName $fd];</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::TestsFromCfgFile_1770">proc <a href="automate.tcl-annot.html#::TestsFromCfgFile">::TestsFromCfgFile</a></a></strong><a name="::TestsFromCfgFile"></a> {mdule fname build fd regPath} {
   
    <span class="comment-line"># --- Get the test number from the running config file</span>
    set flag 0;
    set tList &#34;&#34;;
    set rootDir &#34;&#34;

    set rootDir &#34;$regPath&#34;

    <span class="comment-line"># Not needed in new format.  </span>
    <span class="comment-line"># set fname &#34;$rootDir/$fname&#34;</span>

<span class="comment-line">#    set buildRel [string range $build 0 3]</span>

    if {[catch {open $fname r} fd_in ]} {
	puts &#34;ERROR: proc TestsFromCfgFile{1} Cannot open $fname for r&#34;
	return 0;
    }
   
    set source &#34;&#34;
    while {[gets $fd_in line] != -1} {
	if {[regexp -nocase &#34;source .*&#34; $line]} {
	    if {$tList==&#34;&#34;} {
		set source $line
	    } else {
		set source &#34;_$line&#34;
	    }
	}
	
	if {[regexp -nocase &#34;tests_to_run&#34; $line] &amp;&amp; $flag == 1} {
	    set flag 0
	}
	set testStr &#34;&#34;
	set bld 0
	set flg 0
	if {[regexp {.* tests_to_run\((.*)\)} $line match bld]} {
	    if {[regexp -nocase {[a-z]+} $bld]} {
		set bld 0
	    }
	    if {[CompareRelease $build $bld] &gt;= 0} {
		set flg 1
	    } else {
		set flg 0
	    }
<span class="comment-line">#	    if {$bld&lt;$buildRel||$bld==$buildRel} {</span>
<span class="comment-line">#		set flg 1</span>
<span class="comment-line">#	    } else {</span>
<span class="comment-line">#		set flg 0</span>
<span class="comment-line">#	    }</span>
	}

	if {[regexp {.* tests_to_run\(all\)} $line] || \
		[regexp &#34;.* tests_to_run &#34; $line]||$flg}  {
	    regexp -nocase {.* tests_to_run([0-9a-z(.)]*)} $line match testStr
	    if {[regexp -nocase &#34;6.2e&#34; $testStr]} {
		continue
	    }
	    set flg 0
	    set flag 1;
	    continue;
	} elseif {[regexp {cleanup*} $line]} {
	    continue;
	}

	if {$flag == 1} {
	    set testn &#34;&#34;;
	    set x &#34;&#34;;
	    if {[regexp -nocase &#34;^cli&#34; $mdule]} {
		set fg ![regexp -nocase {(cliCheck)} $line match testn];
	    } else {
		if {[regexp -nocase &#34;tests_to_run&#34; $line]!=1} {
		    set fg [regexp -nocase \
			    {^([^0-9^#]*)([0-9]+[.][0-9a-qs-z_.-]+)} $line match x testn];
		}
	    }
	    if {$fg == 1} {
		if {(![regexp -nocase {^.+init} $testn]) &amp;&amp; \
			(![regexp -nocase {^.+end} $testn])} {
		    lappend tList $testn;
		}
	    }
	}

    }

    close $fd_in;

    if {[regexp -nocase &#34;^_&#34; $source]||($source!=&#34;&#34;&amp;&amp;$tList==&#34;&#34;)} {
	set fg [regexp -nocase &#34;source *(.*)&#34; $source match filename]
	set fileName [string trimright $filename]
        if {[regexp -nocase &#34;env\(.*\)&#34; $fileName]} {
           global env
           puts &#34;fileNamei:$fileName&#34;
           set fileName [expr $fileName]
        }
	set fileName &#34;$rootDir/$mdule/$fileName&#34;
	if {[catch {open $fileName r} fd_in ]} {
	    puts &#34;ERROR: proc TestsFromCfgFile{2} Cannot open $fileName for r&#34;
	    return 0;
	}
	
	while {[gets $fd_in line] != -1} {
	    if {[regexp -nocase &#34;tests_to_run&#34; $line]&amp;&amp;$flag==1} {
		set flag 0
	    }
	    set testStr &#34;&#34;
	    set bld 0
	    set flg 0

	    if {[regexp {.* tests_to_run\((.*)\)} $line match bld]} {

		if {[regexp -nocase {[a-z]+} $bld]} {
		    set bld 0
		}

		if {[CompareRelease $build $bld] &gt;= 0} {
		    set flg 1
		} else {
		    set flg 0
		}
<span class="comment-line">#		if {$bld&lt;$buildRel||$bld==$buildRel} {</span>
<span class="comment-line">#		    set flg 1</span>
<span class="comment-line">#		} else {</span>
<span class="comment-line">#		    set flg 0</span>
<span class="comment-line">#		}</span>

	    }

	    if {[regexp {.* tests_to_run\(all\)} $line] || \
		    [regexp &#34;.* tests_to_run &#34; $line]||$flg}  {
		
		regexp -nocase {.* tests_to_run([0-9a-z(.)]*)} $line match testStr
		
		if {[regexp -nocase &#34;6.2e&#34; $testStr]} {
		    continue
		}

		set flg 0
		set flag 1;
		continue;
	    } elseif {[regexp {cleanup*} $line]} {
		continue;
	    }
	    
	    if {$flag == 1} {
		set testn &#34;&#34;;
		set x &#34;&#34;;
		if {[regexp -nocase &#34;^cli&#34; $mdule]} {
		    set fg ![regexp -nocase {(cliCheck)} $line match testn];
		} else {
		    if {[regexp -nocase &#34;tests_to_run&#34; $line]!=1} {
			set fg [regexp -nocase \
				{^([^0-9^#]*)([0-9]+[.][0-9a-qs-z_.-]+)} $line match x testn];
		    }
		}
		<span class="comment-line">##puts &#34;====&gt; $line ($fg) == $testn &#34;        </span>
		if {$fg == 1} {
		    if {(![regexp -nocase {^.+init} $testn]) &amp;&amp; \
			    (![regexp -nocase {^.+end} $testn])} {
			lappend tList $testn;
		    }
		}
	    }
	}
	close $fd_in;
    }
    
    puts &#34;Test cases in cfg file : $tList&#34;;      
    puts $fd &#34;Test cases in cfg file : $tList&#34;;   
    
    return $tList;
}

<span class="comment-line">################################################################</span>
<span class="comment-line">#  [createShortConfig]</span>
<span class="comment-line"># </span>
<span class="comment-line">#  This proc as name implies creates the pt file on the fly</span>
<span class="comment-line">#   </span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                fname</span>
<span class="comment-line">#                mdule</span>
<span class="comment-line">#                testCaseList</span>
<span class="comment-line">#                btype - bladeType</span>
<span class="comment-line">#                build</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - returns 1 if pt short file is already created or is now created</span>
<span class="comment-line">#                0 in case of error</span>
<span class="comment-line">#      </span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#            set rval [createShortConfig $cfgFile $module $testCaseListFailed </span>
<span class="comment-line">#                       $bladeType $buildName];</span>
<span class="comment-line">#</span>
<span class="comment-line">################################################################</span>
<strong><a name="::createShortConfig_1967">proc <a href="automate.tcl-annot.html#::createShortConfig">::createShortConfig</a></a></strong><a name="::createShortConfig"></a> {fname mdule testCaseList btype build regPath} {

    <span class="comment-line"># Find Test Subdirectory</span>
    set rootSubDir &#34;$regPath&#34;

    global env
    if {[info exists env(WEBSERVERDIR)]} {
       set WebserverDir $env(WEBSERVERDIR)
       <span class="comment-line"># Extract the qId from above dir</span>
<span class="comment-line">#       set qId [string range [file tail $WebserverDir] 0 12]</span>
       set tmpLst [split [file tail $WebserverDir] &#34;_&#34;]
       set qId &#34;&#34;
       for {set count 0} {$count &lt; [llength $tmpLst]} {incr count} {
          append qId &#34;_[lindex $tmpLst $count]&#34;
       }
       set name $btype$qId$build;
    } else {
       set name $btype$build;
    }
    append name &#34;.cfg&#34;;

    if {[regexp -nocase &#34;^pt.*$build&#34; [file tail $fname]]} {
	return 1
    }
    
    ;<span class="comment-line"># Create short directory if it doesn't exist</span>
    if {![file isdirectory &#34;$rootSubDir/$mdule/short&#34;]} {
	file mkdir  &#34;$rootSubDir/$mdule/short&#34;
    }
    
    ;<span class="comment-line"># Open the cfg file to write to </span>
    puts &#34;DEBUG: createShortConfig{} Opening $rootSubDir/$mdule/short/pt$name to write short file&#34;
    if {[catch {open &#34;$rootSubDir/$mdule/short/pt$name&#34; w  0777} fd_out]} {
	close $fd_out;
	return 0;
    }
    
    set flag 0;
    set sourceFile &#34;&#34;
    set fname &#34;$fname&#34;
    
    puts &#34;DEBUG: createShortConfig{}  Open fd_in fname:$fname for reading&#34;
    
    if [catch {open &#34;$fname&#34; &#34;r&#34;} fd_in] {
	if [catch {open &#34;cfg/$fname&#34; &#34;r&#34;} fd_in] {
	    puts &#34;ERROR: createShortConfig{} Unable to open $fname&#34;
	    return 0
	}
    }
    
    while {[gets $fd_in line] != -1} {
	if {$flag == 1} {
	    set testn &#34;&#34;;
	    set x &#34;&#34;;
	    if {[regexp {.* tests_to_run} $line]} {
		puts $fd_out $line;
		continue;
	    }
	    set fg [regexp -nocase {^([0-9]+[.][0-9a-z_.-]*)} \
		    [string trimleft $line] match testn];
<span class="comment-line">#	    puts &#34;DEBUG: createShortConfig{}  fg: $fg&#34;</span>
	    if {$fg == 1} {
		if {(![regexp -nocase {^.+init} $testn]) &amp;&amp; \
			(![regexp -nocase {^.+end} $testn])} {
		    
		    foreach tc $testCaseList {
<span class="comment-line">#			puts &#34;DEBUG: createShortConfig{}  tc: $tc&#34;</span>
			if {$testn == $tc} {
			    puts $fd_out $line;
			    break;
			}
		    }
		} else {
		    puts $fd_out $line;
		}
	    } else {
		puts $fd_out $line;
	    }
	} else {
	    if {[regexp {.* tests_to_run} $line]} {
		set flag 1;
	    }
	    if {[regexp {source *(.*)} $line]} {
		regexp -nocase &#34;source *(.*)&#34; $line match sourceFile
		set sourceFile [string trimright $sourceFile]
		set sourceFile [string trimleft $sourceFile]
                if {[regexp -nocase &#34;env\(.*\)&#34; $sourceFile]} {
                   global env
                   set sourceFile [expr $sourceFile]
                }
	    } else {
		puts $fd_out $line;             
	    }
	}
    }
    
    close $fd_in;       
    
    if {$sourceFile!=&#34;&#34;} {
	puts &#34;DEBUG: createShortConfig{}  sourceFile: \
		$rootSubDir/$mdule/$sourceFile&#34;
	set sourceFile &#34;$rootSubDir/$mdule/$sourceFile&#34;

	if {[catch {open &#34;$sourceFile&#34; r} fd_in]} {
	    return &#34;&#34;;
	}

	while {[gets $fd_in line] != -1} {
	    set testn &#34;&#34;;
	    set x &#34;&#34;;
	    if {[regexp {.* tests_to_run} $line]} {
		puts $fd_out $line;
		continue;
	    }
	    
	    set fg [regexp -nocase {^([0-9]+[.][0-9a-z_.-]*)} \
		    [string trimleft $line] match testn];
	    if {$fg == 1} {
		if {(![regexp -nocase {^.+init} $testn]) &amp;&amp; \
			(![regexp -nocase {^.+end} $testn])} {
		    foreach tc $testCaseList {
			puts &#34;DEBUG: createShortConfig{}  tc2: $tc  testn: \
				$testn&#34;
			if {[string compare $testn $tc] == 0} {
			    puts &#34;DEBUG: createShortConfig{}  writing $line to \
				    $fd_out&#34;
			    puts $fd_out $line;
			    break;
			}
		    }
		} else {
		    puts $fd_out $line;
		}
	    } else {
		puts $fd_out $line;
	    }
	}
	close $fd_in
    }
    close $fd_out;
    
    return 1;
    
}


;<span class="comment-line"># Generates the automate.tcl line for the rerun BAT file.      </span>
<strong><a name="::genAutomateLine_2114">proc <a href="automate.tcl-annot.html#::genAutomateLine">::genAutomateLine</a></a></strong><a name="::genAutomateLine"></a> {regType regSubType build platform blade cliFlag} {
    
    set automateLine &#34;./automate.tcl&#34;

    append automateLine &#34; -regType $regType -regSubType $regSubType -build $build&#34;

    if {$platform != &#34;&#34;} {
	append automateLine &#34; -platform $platform&#34;
    }
    if {$blade != &#34;&#34;} {
	append automateLine &#34; -blade $blade&#34;
    }

    if {$regType == &#34;cli&#34; &amp;&amp; $cliFlag != &#34;&#34;} {
	append automateLine &#34; -cliFlag $cliFlag&#34;
    }

    append automateLine &#34; -noconfig&#34;

    puts &#34;DEBUG: genAutomateLine: $automateLine&#34;

    return $automateLine
}



<strong><a name="::createRerunScript_2140">proc <a href="automate.tcl-annot.html#::createRerunScript">::createRerunScript</a></a></strong><a name="::createRerunScript"></a> {moduleNeedToRerun regType regSubType build platform blade cliFlag} {

    <span class="comment-line"># --- create the bat file or shell script whichever applicable</span>
    global tcl_platform
    global regPath

    puts &#34;\n&#34;;
    puts &#34;ModuleNeedToRerun == $moduleNeedToRerun&#34;;
    set rerunBatFile &#34;&#34;

    ;<span class="comment-line"># Generate the name for BAT file</span>
    set rerunBatFile [genRerunBatFileName $regType $regSubType $platform $blade]

    if {$moduleNeedToRerun == &#34;&#34;} {
	if {[catch {open $rerunBatFile w 0777} fd_out]} {
	    close $fd_out;
	    return &#34;&#34;;
	}

	puts $fd_out &#34;#!/bin/bash&#34;
	puts $fd_out &#34;echo NO MODULES TO RERUN&#34;
	return $rerunBatFile
    }

    set rootFilePath         $regPath
    set rerunBatFileFullPath &#34;&#34;

    puts &#34; ****************************&#34;
    puts &#34;   Creating RERUN BAT FILE   &#34;
    puts &#34; ****************************&#34;


    if [regexp -nocase &#34;cli&#34; $regType] {

	set rerunBatFileFullPath &#34;$rerunBatFile&#34;
	if {[catch {open $rerunBatFileFullPath w 0777} fd_out]} {
	    close $fd_out;
	    return &#34;&#34;;
	}

	set oldModule &#34;&#34;
	if {$tcl_platform(platform) != &#34;windows&#34;} {
	    puts $fd_out &#34;#!/bin/bash&#34;
	}

	;<span class="comment-line"># Write failed modules to bat file</span>
	foreach module $moduleNeedToRerun {
	    if {$oldModule!=$module} {
		set i 0
	    }
	    puts &#34;DEBUG: $rootFilePath/$module/short/pt*$platform$blade*$build.cfg&#34;
	    catch {glob -- &#34;$rootFilePath/$module/short/pt*$platform$blade*$build.cfg&#34;} dirs
	    puts &#34;DEBUG: $dirs&#34;
	    set fileName [lindex $dirs $i]
	    puts &#34;DEBUG: fileName: $fileName&#34;
	    set fileN [file tail $fileName]
	    puts &#34;DEBUG: 1 fileN: $fileN&#34;
	    set fileN [format %s/%s short $fileN]
	    puts &#34;DEBUG: 2 fileN: $fileN&#34;
	    incr i
	    set oldModule $module
	    if {$regSubType == &#34;upgradedowngrade&#34;} {
	        set builds [split $build &#34;:&#34;]
	        set build1 [lindex $builds 0]
	        set build2 [lindex $builds 1]
    	        puts &#34;DEBUG: writing: ./main.tcl -mode auto -regPath $regPath \
		    -module $module -cfg \&#34;$fileN\&#34; -build $build1 -obuild $build2&#34;
	        puts $fd_out &#34;./main.tcl -mode auto -regPath $regPath -module \
		    $module -cfg \&#34;$fileN\&#34; -build $build1 -obuild $build2&#34;

            } else {
	        if { $cliFlag == &#34;&#34; } {
	    	    puts &#34;DEBUG: writing: ./main.tcl -mode auto -regPath $regPath \
		        -module $module -cfg \&#34;$fileN\&#34; &#34;
	    	    puts $fd_out &#34;./main.tcl -mode auto -regPath $regPath -module \
		        $module -cfg \&#34;$fileN\&#34; &#34;
	        } else {
	    	    puts &#34;DEBUG: writing: ./main.tcl -mode auto -regPath $regPath \
		        -module $module -cfg \&#34;$fileN\&#34; -cliFlag \&#34;$cliFlag\&#34; &#34;
	    	    puts $fd_out &#34;./main.tcl -mode auto -regPath $regPath -module \
		        $module -cfg \&#34;$fileN\&#34; -cliFlag \&#34;$cliFlag\&#34; &#34;
	        }
            }
	    puts $fd_out &#34;sleep 10&#34;
        } 
	if {$tcl_platform(platform) != &#34;windows&#34;} {
	    set ret [exec -- chmod +x &#34;$rerunBatFile&#34;]
	}
	
    }  elseif [regexp -nocase &#34;func&#34; $regType] {

	;<span class="comment-line"># Standard and Routing are the same</span>
	set rerunBatFileFullPath &#34;$rerunBatFile&#34;
	if {[catch {open $rerunBatFileFullPath w 0777} fd_out]} {
	    close $fd_out;
	    return &#34;&#34;;
	}

	set oldModule &#34;&#34;
	if {$tcl_platform(platform) != &#34;windows&#34;} {
	    puts $fd_out &#34;#!/bin/bash&#34;
	}
	
	;<span class="comment-line"># Write failed modules to bat file</span>
	foreach module $moduleNeedToRerun {
	    if {$oldModule != $module} {
		set i 0
	    }
	    catch {glob -- &#34;$rootFilePath/$module/short/pt*$platform$blade*$build.cfg&#34;} dirs
	    if [regexp -nocase &#34;no files matched&#34; $dirs] {
		puts &#34;ERROR: $dirs&#34;
		puts $fd_out &#34;## Unable to generate partial cfg## \
			./main.tcl -mode auto -regPath $regPath \
			-module \&#34;$module\&#34; -cfg ERROR&#34;
		continue
	    }
            puts &#34;DEBUG: dirs $dirs&#34;
	    set fileName [lindex $dirs $i]
	    set fileN [file tail $fileName]
	    set fileN [format %s/%s short $fileN]
	    incr i
	    set oldModule $module
	    puts $fd_out &#34;./main.tcl -mode auto -regPath $regPath \
		    -module \&#34;$module\&#34; -cfg \&#34;$fileN\&#34;&#34;
	    puts $fd_out &#34;sleep 4&#34;
	}
	
	
    }  elseif [regexp -nocase &#34;perf&#34; $regType] {
	puts &#34;*************** PERFORMANCE NOT SUPPORTED YET ****************&#34;	    
	set rerunBatFile &#34;&#34;
    }
    
    puts $fd_out &#34;cd ../main&#34;
    puts $fd_out [<a name="::genAutomateLine(1)"><a href="./automate.tcl.html#::genAutomateLine_2114">::genAutomateLine</a></a> $regType $regSubType $build $platform $blade $cliFlag]

    close $fd_out

    if {$tcl_platform(platform) != &#34;windows&#34;} {
	set ret [exec -- chmod +x &#34;$rerunBatFile&#34;]
    }

    return $rerunBatFileFullPath
}



<strong><a name="::validateArgsAutomate_2287">proc <a href="automate.tcl-annot.html#::validateArgsAutomate">::validateArgsAutomate</a></a></strong><a name="::validateArgsAutomate"></a> {argv p_regType p_regSubType p_build p_platform p_blade \
	p_modules p_noconfig p_cliFlag} {
    
    upvar $p_build       build
    upvar $p_platform    platform
    upvar $p_regType     regType
    upvar $p_regSubType  regSubType
    upvar $p_regSubType  regSubType
    upvar $p_blade	 blade
    upvar $p_cliFlag     cliFlag

    global runflag

    if {[lsearch $argv &#34;-help&#34;]  &gt; -1} {
	return 0
    }

    if {$regType == &#34;&#34;} {
	set regType &#34;functional&#34;
	set regSubType &#34;standard&#34;
	puts &#34;-regType not specified. Defaulting to regType:$regType regSubType:$regSubType)&#34;
    }

    if {$build==&#34;&#34;} {
	puts &#34;ERROR: Required Parameters: -build $build invalid or missing&#34;
	return 0
    }

    if {[lsearch $argv &#34;-noconfig&#34;]  &gt; -1} {
	set runflag &#34;noconfig&#34;
    } else {
	set runflag &#34;config&#34;
    }

    <span class="comment-line"># Check the build name</span>
    <span class="comment-line"># these conditions simplifies the version name</span>
    <span class="comment-line"># the direct argument could not be used as report files differ from </span>
    <span class="comment-line"># that of the image name</span>

    set build [ getBuildNumber $build ]
    
    global summitList
    global alpineList
    global bladeList

    <span class="comment-line"># Check the platform name</span>
    if {[regexp -nocase &#34;BD-10808&#34; $platform]} {
	set platform &#34;BD-10808&#34;
    } elseif {[regexp -nocase &#34;BD-8904|BD-12804&#34; $platform]} {
	set platform $platform
    } elseif {[regexp -nocase &#34;BD-16808&#34; $platform]} {
	set platform &#34;BD-16808&#34; 
    } elseif {[regexp -nocase &#34;BD-8810&#34; $platform]} {
	set platform &#34;BD-8810&#34;
    } elseif {[regexp -nocase &#34;BD-PC&#34; $platform]} {
	set platform &#34;BD-PC&#34;
    } elseif {[regexp -nocase &#34;Summit-PC&#34; $platform]} {
	set platform &#34;Summit-PC&#34;
    } elseif {[regexp -nocase &#34;BD&#34; $platform]} {
	set platform &#34;BD&#34;
    } elseif {[regexp -nocase &#34;Aspen&#34; $platform]} {
	set platform &#34;Aspen&#34;
    } elseif {[regexp -nocase &#34;SummitX450&#34; $platform]} {
	set platform $platform
    } elseif {[regexp -nocase &#34;SummitX406&#34; $platform]} {
	set platform &#34;SummitX406&#34;
    } elseif {[regexp -nocase &#34;Godzilla&#34; $platform]} {
	set platform &#34;GODZILLA&#34;
    } elseif {[regexp -nocase &#34;$summitList|Jaguar|x480|NWI&#34; $platform]} {
        <span class="comment-line"># EY-06-16-2006: Added &#34;Jaguar&#34; to regular expression.</span>
	<span class="comment-line"># since glob is case sensitive, make the right string here </span>
	<span class="comment-line"># for glob to work later on</span>
	set fir [string toupper [string index $platform 0]]
	set temp [string tolower [string range $platform 1 5]]
	set last [string tolower [string range $platform 6 end]]
	set platform [format %s%s%s $fir $temp $last]
	puts &#34;DEBUG: validate:  fir:$fir temp:$temp last:$last platform:$platform&#34;
    } elseif { [regexp -nocase &#34;null&#34; $platform] || ($platform == &#34;&#34;)} {
	;<span class="comment-line"># This is okay as not all regressions require this.</span>
    } else {
	puts &#34;ERROR: Invalid Platform: $platform&#34;
	return 0
    }
 
    
    <span class="comment-line"># check the blade name</span>
    if {[regexp -nocase $bladeList $blade]} {
	set bl [string toupper $blade]
	regsub -all &#34;I$&#34; $bl &#34;i&#34; blade
	regsub -all &#34;E$&#34; $bl &#34;e&#34; blade
	regsub -all &#34;A$&#34; $bl &#34;a&#34; blade
	if {[regexp -nocase &#34;10gig&#34; $blade]} {
	    regsub -all &#34;GIG&#34; $blade &#34;Gig&#34; blade
	}
    } elseif {[regexp -nocase $summitList $platform]} {
	set blade &#34;&#34;
    } elseif {[regexp -nocase $alpineList $blade]} {
	set fir [string toupper [string index $blade 0]]
	set temp [string tolower [string range $blade 1 end]]
	set blade [format %s%s $fir $temp]
    } elseif {[regexp -nocase &#34;BD&#34; $blade]} {
	set fir [string toupper [string index $blade 0 2]]
	set temp [string tolower [string range $blade 3 end]]
	set blade [format %s%s $fir $temp]
    } elseif {[regexp -nocase &#34;null&#34; $blade] || ($blade == &#34;&#34;)} {
	;<span class="comment-line"># This is okay as not all regressions require this.</span>
    } else {
	puts &#34;ERROR: Invalid blade name :$blade&#34;
	return 0
    }    

    if {$cliFlag == &#34;&#34; || $cliFlag == &#34;NO_DOWNLOAD&#34; 
	|| $cliFlag == &#34;NO_REBOOT&#34; || $cliFlag == &#34;NO_DOWNLOAD_NO_REBOOT&#34; \
	|| $cliFlag == &#34;NO_REBOOT_NO_DOWNLOAD&#34; } {
     
        return 1
    } else {
	puts &#34;ERROR: Invalid cliFlag :$cliFlag&#34;
	return 0
    }
}




<span class="comment-line"># ==============================================================================</span>
<span class="comment-line"># =================================== MAIN =====================================</span>
<span class="comment-line"># ==============================================================================</span>
puts &#34;######################################################################&#34;
puts &#34;                        AUTOMATE.TCL STARTED &#34;
puts &#34;######################################################################&#34;

set build             &#34;&#34;
set regType           &#34;&#34;
set regSubType           &#34;&#34;
set platform          &#34;&#34;
set blade             &#34;&#34;
set build             &#34;INVALID&#34;
set cfgfile           &#34;template.cfg&#34;
set noconfig          &#34;&#34;
set runflag           &#34;&#34;
set moduleNeedToRerun &#34;&#34;

set LIB_PATH &#34;../Lib&#34;
lappend auto_path $LIB_PATH

source ../Lib/parse_args.tcl
package require Tclx

set sourceFile &#34;&#34;
<span class="comment-line"># backtracked path needed for other utilties outside main to work</span>
if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
   puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
   puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
   exit -1
}

catch { parse_args automate.tcl $argv {
    regType &#34;&#34;
    regSubType &#34;&#34;
    build &#34;&#34;
    platform &#34;&#34;
    blade &#34;&#34;
    modules &#34;&#34;
    noconfig &#34;&#34;
    cliFlag &#34;&#34;
   }   
} result

puts &#34;regType:  $regType   build: $build    platform: $platform  blade: $blade&#34;
puts &#34;noconfig: $noconfig&#34;
puts &#34;----------------------------------------------------------------------&#34;

if { $result != &#34;&#34; } {
    puts &#34;ERROR: $result&#34;
    <a name="::print_usage(1)"><a href="./automate.tcl.html#::print_usage_34">::print_usage</a></a>
    exit
}


if {[<a name="::validateArgsAutomate(1)"><a href="./automate.tcl.html#::validateArgsAutomate_2287">::validateArgsAutomate</a></a> $argv regType regSubType build \
	platform blade modules noconfig cliFlag] == 0 } {
    <a name="::print_usage(2)"><a href="./automate.tcl.html#::print_usage_34">::print_usage</a></a>
    exit
}

gen_index ./
gen_index ../Lib


<span class="comment-line"># This is necessary to get an absolute path for logging</span>
set REG_PATH [pwd]

if {$tcl_platform(platform) == &#34;windows&#34;} {
    load &#34;expect52.dll&#34;
} else {
    load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
}

if {$tcl_platform(platform) == &#34;windows&#34;} {
	lappend auto_path &#34;C:/Program Files/Ixia/TclScripts/Lib/ixTcl1.0&#34;
} else {
  lappend auto_path [file join $env(HOME) &#34;ixia/lib/ixTcl1.0&#34;]
  lappend auto_path [file join $env(HOME) &#34;ixia/lib/dp4.0&#34;]
}

log_user 0

set auto_path [linsert $auto_path 0 . ]

set resultDir &#34;NULL&#34;
set tStartDate [clock format [clock seconds] -format &#34;%m-%d-%Y&#34;];

<span class="comment-line">#append filename $tStartDate &#34;v&#34; $build-$blade-summary;</span>
if {$blade == &#34;&#34; } {
    append filename $tStartDate &#34;v&#34; $build-$platform-summary;
} else {
    append filename $tStartDate &#34;v&#34; $build-$platform-$blade-summary;
}
set bladeName $blade

set orgname $filename;

;<span class="comment-line"># Create Temporary directories</span>
;<span class="comment-line"># TODO: Fix performance to use Summary directory (APL)</span>
if [regexp -nocase &#34;perf&#34; $regType] {
    if {![file isdirectory Performance]} {
	file mkdir Performance
    }
    set summaryFilePath &#34;Performance/&#34;
} else {
    if {![file isdirectory Summary]} {
	file mkdir Summary
    }
    set summaryFilePath &#34;Summary/&#34;
}

;<span class="comment-line"># Generate unique summary file name</span>
set summaryFile $orgname
set i 0
while {[file exists &#34;$summaryFilePath$summaryFile&#34;]} {
    set summaryFile $orgname
    append summaryFile $i &#34;.txt&#34;;
    incr i;
}

<span class="comment-line"># Get all the modules to be summarized</span>
<span class="comment-line"># as this this called from Util as well</span>
set sourceFile $modulesToBeSummarizedPath
if {[file exists $sourceFile] == 0} {
   puts &#34;ERROR: Cannot find config file: $sourceFile, please contact admin\n&#34;
   puts $fd &#34;SETUP ERROR: Cannot find the config file $sourceFile, \
	   please contact the admin.&#34;
   return -1
}
source $sourceFile

puts &#34;REGTYPE:  $regType   REGSUBTYPE: $regSubType   BUILD: $build&#34;
puts &#34;PLATFORM: $platform  BLADE: $blade          GENERATE: $runflag&#34;
puts &#34;&#34;
puts &#34;SUMMARY FILE: $summaryFilePath$summaryFile&#34;

global webServerDirName

<span class="comment-line">#Change the webserver directory name if the SNMP testing is carried out</span>
global env
if {![info exists env(WEBSERVERDIR)]} {
if {$regType == &#34;snmp&#34;} {   
   set webServerDirName $webServerDirName/snmpData
} elseif {$regType == &#34;scal&#34;} {
   set webServerDirName $webServerDirName/scalData
} elseif {[regexp -nocase &#34;functional&#34; $regType]} {
   set webServerDirName $webServerDirName/functionalData
} elseif {[regexp -nocase &#34;cli&#34; $regType]} {
   set webServerDirName $webServerDirName/functionalData
} elseif {[regexp -nocase &#34;performance&#34; $regType]} {
   set webServerDirName $webServerDirName/perfData
} else {
   set webServerDirName $webServerDirName/data
}
}

set fd [open &#34;$summaryFilePath$summaryFile&#34; w 0777]

set regressionModules &#34;&#34;
<span class="comment-line"># The regressionModules are defined in modulesToBeSummarized.cfg.  The list</span>
<span class="comment-line"># is accessed as $regType($regSubType)</span>
set regressionModules [getRegressionModuleList $regType $regSubType]
if {$regressionModules == &#34;&#34; } {
    return &#34;Module List was empty!&#34;
}


;<span class="comment-line"># First element of $regType($regSubType) should be a path to location</span>
;<span class="comment-line"># of modules.  Even though a user specifies a list of modules to run</span>
;<span class="comment-line"># against, we still need to retrieve the regPath based on the regType</span>
;<span class="comment-line"># and regSubType</span>
set relativePath &#34;..&#34;
set regPath &#34;$relativePath/[lindex $regressionModules 0]&#34;
puts &#34;regPath: $regPath&#34;

if {$modules == &#34;&#34;} {
    ;<span class="comment-line"># Remove regPath param from $regressionModules</span>
    set regressionModules [lrange $regressionModules 1 [expr [llength \
	    $regressionModules] - 1] ]
} else {
    puts &#34;Using regression module list passed from command line&#34;
    set regressionModules $modules
}

puts &#34;regressionModules to post: $regressionModules&#34;

<a name="::SummarizeAllFailures(1)"><a href="./automate.tcl.html#::SummarizeAllFailures_236">::SummarizeAllFailures</a></a> $build $platform $blade $regType $regSubType \
	$regressionModules $fd &#34;$summaryFilePath$summaryFile&#34;

close $fd
if [catch {file delete &#34;$summaryFilePath$summaryFile&#34;} result] {
    puts &#34;ERROR: $result&#34;
    return &#34;Unable to delete $summaryFilePath$summaryFile&#34;
}


if {$runflag == &#34;config&#34;} {

    ;<span class="comment-line"># Create batch file for rerun</span>
    if [regexp -nocase &#34;func|cli&#34; $regType] {
	
	set rerunBatchFile [<a name="::createRerunScript(1)"><a href="./automate.tcl.html#::createRerunScript_2140">::createRerunScript</a></a> $moduleNeedToRerun $regType \
		$regSubType $build $platform $blade $cliFlag]
    }
    
    if {$rerunBatchFile != &#34;&#34;} {
	puts &#34;CONFIG_FILE CREATED: $rerunBatchFile&#34;
	<span class="comment-line"># Make sure it's executable</span>
	catch {exec chmod 777 $rerunBatchFile}
	<span class="comment-line"># Dump out the contents</span>
	catch {exec cat &#34;$rerunBatchFile&#34;} result
	puts $result
    }
} 
puts &#34;Regression Modules Processed: (as defined in modulesToBeConfigured.cfg)&#34;
puts &#34;  $regressionModules&#34;
puts &#34;######################################################################&#34;
puts &#34;                      AUTOMATE.TCL FINISHED!&#34;
puts &#34;######################################################################&#34;
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
