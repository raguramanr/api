<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>loadConsoles.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#loadConsoles.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>loadConsoles.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="loadConsoles.tcl-annot.html">annotations</a> | <a href="loadConsoles.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

<strong><a name="::result_debug_3">proc <a href="loadConsoles.tcl-annot.html#::result_debug">::result_debug</a></a></strong><a name="::result_debug"></a> {out} {
    puts &#34;$out&#34;
}
<strong><a name="::result_error_6">proc <a href="loadConsoles.tcl-annot.html#::result_error">::result_error</a></a></strong><a name="::result_error"></a> {out} {
    puts &#34;$out&#34;
}
<strong><a name="::result_ok_9">proc <a href="loadConsoles.tcl-annot.html#::result_ok">::result_ok</a></a></strong><a name="::result_ok"></a> {out} {
    puts &#34;$out&#34;
}
<strong><a name="::result_print_12">proc <a href="loadConsoles.tcl-annot.html#::result_print">::result_print</a></a></strong><a name="::result_print"></a> {out} {
    puts &#34;$out&#34;
}
<strong><a name="::result_pre_15">proc <a href="loadConsoles.tcl-annot.html#::result_pre">::result_pre</a></a></strong><a name="::result_pre"></a> {out} {
    puts &#34;$out&#34;
}
global curAutoRoot
global DUTs_info whichDutNow

source ../Lib/mainLib.tcl
package require Tclx

load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]

set curLocation [pwd]
set curDirList [split [string trim [string trim $curLocation &#34;..&#34;] &#34;/&#34;] &#34;/&#34;]
set v 0;
set pathList &#34;&#34;
set curAutoRoot &#34;&#34;
set skipCC 0
foreach cd $curDirList {
    if {$cd == &#34;main&#34; || $cd == &#34;Lib&#34; || $cd == &#34;Util&#34;} {
        for {set x 0} {$x&lt;$v} {incr x} {
            lappend pathList [lindex $curDirList $x]
        }
        set curAutoRoot &#34;/[join $pathList &#34;/&#34;]&#34;
    } else {
        incr v;
    }
}
puts &#34;CURRENT PATH: $curAutoRoot&#34;
set cDir [file tail [pwd]]
set LIB_PATH &#34;./../Lib&#34;
lappend auto_path $LIB_PATH
puts &#34;DEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;

gen_index &#34;./../Lib&#34;
<span class="comment-line">#source &#34;./../Util/fs.tcl&#34;</span>
set resultDir &#34;NULL&#34;
set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]

set testDuration 0
set testHour 0
set testMin 0
set testSec 0
set resultDir &#34;NULL&#34;

set fd_res [open_result_file &#34;load&#34;]

<strong><a name="::print_usage_63">proc <a href="loadConsoles.tcl-annot.html#::print_usage">::print_usage</a></a></strong><a name="::print_usage"></a> {} {
    puts &#34;\r&#34;
    puts {}
    puts {NOTE!!!!!!!!!  THIS CAN ONLY BE RUN FROM A VNC SESSION !!!!!!!!!!!!!!!}
    puts {}
    puts {Usage: lconsoles.tcl -cfg &lt;config file&gt; }
    puts {   &lt;cfg&gt;: Path of the config file name }
    puts {   &lt;d&gt;: Enable debug mode}
    puts {   &lt;m&gt;: Configure GW Network}
    puts {   &lt;n&gt;: Number of duts}
    puts {   &lt;stc&gt;: 'setup trunk cfg' sysName and edp for manual trunkPortList verify}
    puts {   &lt;ib&gt; sysname to cfg setup inband net}
    puts {   &lt;power|p&gt;: 1|0|2 1=poweron 2=poweroff-poweron}
    puts {   &lt;clear|c&gt;: 1|0 Clear the consoles if locked}
    puts &#34;\r&#34;
}

<span class="comment-line"># checking command parameters</span>
if {$argc&lt;1} {
      puts &#34;Not enough parameters&#34;
      <a name="::print_usage(1)"><a href="./loadConsoles.tcl.html#::print_usage_63">::print_usage</a></a>
      return
}

parse_args lconsoles $argv {
    cfg    &#34;null&#34;
    d &#34;0&#34;
    power 0
    clear 0
    stc 0
    ib 0
    p 0
    c 0
    m 0
    n 2
    f 0
}
if {$p == 0} {
   set power 0
} elseif {$p == 1} {
   set power 1
} elseif {$p == 2} {
   set power 2
} else {
   set power 0
}
if {$c!=0} {
   set clear 1
}

set cfgFile &#34;&#34;

if {$cfg != &#34;null&#34;} {
      if {![regexp -nocase &#34;^cfg&#34; $cfg] } {
            set cfgFile [format %s/%s cfg $cfg]
            set cfgFile [string trim $cfgFile];
            set com common.cfg
      } else {
          set cfgFile $cfg
          set com cfg/common.cfg
      }
}

puts &#34;Using config file: ($cfgFile)&#34;

if {[file exists $cfgFile] == 0} {
    puts &#34;Cannot find config file: $cfgFile\n&#34;
    puts stderr &#34;Cannot find config file: $cfgFile&#34;
    return
}

puts &#34;************** ABOUT TO source $cfgFile and $com *****************&#34;
catch {source $cfgFile } reason
catch {source $com } reason
set initFileId $DUT1_CONNECT
set initFile &#34;${curAutoRoot}/main/Tmp/DUTINFO_$initFileId&#34;
set initFile2 &#34;${curAutoRoot}/main/Tmp2/DUTINFO_$initFileId&#34;
set fn [file tail $cfg]
set smallCfgList [split $fn &#34;.&#34;]
set smallCfg [lindex $smallCfgList 0]
set fn [string trim $fn]
set fn [file rootname $fn]
append initFile &#34;_&#34;
append initFile $fn
append initFile &#34;.txt&#34;

if {[catch {source $initFile}]} {
    if {[file exists initFile2]} {
        if {[catch {source $initFile2}]} {
            puts &#34;No Good Init File&#34;
        }
        set initFile $initFile2
    }
} else {
    set initFile $initFile
}

if {$power==1} {
    for {set i 1} {$i&lt;11} {incr i} {
        if {[info exists POWERCYCLE_DUT($i)]} {
            puts &#34;Powering on DUT DUT$i&#34;
            PowerOffDUT $i &#34;on&#34;
        }
    }
}

if {$clear} {
    set sList &#34;B C D E F G H&#34;
    for {set i 1} {$i&lt;11} {incr i} {
        set whichDutNow $i
        if {[info exists DUT${i}_CONNECT]} {
            ClearConsoleDUT &#34;[set DUT${i}_CONNECT]&#34;
            foreach s $sList {
                if {[info exists DUT${i}_CONNECTB] &amp;&amp; \
                    ![regexp &#34;stack&#34; $cfg]} {
                    continue
                } elseif {[info exists DUT${i}_CONNECT${s}]} {
                    ClearConsoleDUT &#34;[set DUT${i}_CONNECT${s}]&#34;   
                }
            }
        }
    }
}
puts &#34;$initFile&#34;
if {$f} {
    catch {source $initFile} bob
    set TRYFAILSAFE true
    if {![info exists numDUT]} {
        if {$n &lt; 1} {
            puts &#34;Use the -n arg to set the number of DUT&#34;
            exit
        }
        puts &#34;Info required for ConfigGWNetwork not available from initFile&#34;
        set numDUT $n
        set supportedPlatform &#34;&#34;
    }
    set MGMT_REG(telnetNeedsConfig) 1
    set MGMT_REG(forceConsole) 1
    set MGMT_REG(currentConnectionType) &#34;console&#34;
    set MGMT_REG(useTelnetGlobalFlag) 0
    set MGMT_REG(useTelnetLocalFlag) 0
    global whichDutNow connectionTimeout
    set slotList &#34;{} B C D E F&#34;
    for {set i 1} {$i&lt;11} {incr i} {
        set DUTs_info(DUT${i},version) &#34;15.1.1.1&#34;
        foreach s $slotList {
            if {[info exists DUT${i}_CONNECT$s]} {
                set whichDutNow $i
                set cmd &#34;spawn telnet [set DUT${i}_CONNECT${s}]&#34;
                if [catch &#34;$cmd&#34; reason] {
                    <a name="::result_debug(1)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;failed to spawn program: $reason\n&#34;
                    <a name="::result_error(1)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;failed to spawn program: $reason\n&#34;
                }

                set ptimeout $connectionTimeout
                set timeout 3
                <span class="comment-line">#wait for connection</span>
                expect {
                    &#34;?onnection refused&#34; {
                        <a name="::result_debug(2)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;refused&#34;
                        continue;
                    }
                    &#34;?nable to ?onnect&#34; {
                        <a name="::result_debug(3)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;unable to connect&#34;
                        continue;
                    }
                    &#34;?onnected to&#34; {
                        <a name="::result_debug(4)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Successful Connection&#34;
                    }
                }
                <span class="comment-line">#run the failsafe</span>
                FailSafeForceful
                close -i $spawn_id
                wait
            }
        }
    }
    if {[info exists spawn_id] &amp;&amp; $spawn_id != &#34;&#34;} {
        <span class="comment-line">#close -i $spawn_id</span>
    }
    if [info exists connectionTimeout] {
        set timeout $connectionTimeout
    }
}
if {$stc} {
    catch {source $initFile} bob
    if {![info exists numDUT]} {
        if {$n &lt; 1} {
            puts &#34;Use the -n arg to set the number of DUT&#34;
            exit
        }
        puts &#34;Info required for ConfigGWNetwork not available from initFile&#34;
        set numDUT $n
        set supportedPlatform &#34;&#34;
    }
    for {set i 1} {$i&lt;11} {incr i} {
        set whichDutNow $i
        set DUTs_info(DUT${i},version) &#34;15.1.1.1&#34;
        if {[info exists DUT${i}_CONNECT]} {
            Login &#34;[set DUT${i}_CONNECT]&#34; -CheckOperational 0 -masterCheck 0
            SendACmd &#34;configure snmp sysName DUT$i&#34;
            SendACmd &#34;enable edp port all&#34;
            _ClearExpectSession
        }
    }
}
puts &#34;PRE D&#34;
if {$d } {
    if {[file exists $initFile]} {
        catch {source $initFile} bob
    }
    if {![info exists numDUT]} {
        puts &#34;Info required for enable debug mode not available from initFile&#34;
        set numDUT $n
        set supportedPlatform &#34;&#34;
    }
    puts &#34;In D&#34;
    catch {source $initFile} bob
    if {![info exists numDUT]} {
        puts &#34;Info required for EnableDebugMode not available from initFile&#34;
        set numDUT $n
    }
    set MGMT_REG(telnetNeedsConfig) 1
    set MGMT_REG(forceConsole) 1
    set MGMT_REG(currentConnectionType) &#34;console&#34;
    set MGMT_REG(useTelnetGlobalFlag) 0
    set MGMT_REG(useTelnetLocalFlag) 0
    for {set i 1} {$i&lt;11} {incr i} {
        set whichDutNow $i 
        if {[info exists DUT${i}_CONNECT]} {
            EnableDebugModeConsole &#34;[set DUT${i}_CONNECT]&#34;
            _ClearExpectSession
        }
        if {[info exists DUT${i}_CONNECTB]} {
            EnableDebugModeConsole &#34;[set DUT${i}_CONNECTB]&#34;
            _ClearExpectSession
        }
        if {[info exists DUT${i}_CONNECTC]} {
            EnableDebugModeConsole &#34;[set DUT${i}_CONNECTC]&#34;
            _ClearExpectSession
        }
        if {[info exists DUT${i}_CONNECTD]} {
            EnableDebugModeConsole &#34;[set DUT${i}_CONNECTD]&#34;
            _ClearExpectSession
        }
        if {[info exists DUT${i}_CONNECTE]} {
            EnableDebugModeConsole &#34;[set DUT${i}_CONNECTE]&#34;
            _ClearExpectSession
        }
        if {[info exists DUT${i}_CONNECTF]} {
            EnableDebugModeConsole &#34;[set DUT${i}_CONNECTF]&#34;
            _ClearExpectSession
        }
    }
    after 1500
}
if {$m} {
    catch {source $initFile} bob
    if {![info exists numDUT]} {
        puts &#34;Info required for ConfigGWNetwork not available from initFile&#34;
        set numDUT $n
        set supportedPlatform &#34;&#34;
    }
    set MGMT_REG(telnetNeedsConfig) 1
    set MGMT_REG(forceConsole) 1
    set MGMT_REG(currentConnectionType) &#34;console&#34;
    set MGMT_REG(useTelnetGlobalFlag) 0
    set MGMT_REG(useTelnetLocalFlag) 0
    for {set i 1} {$i&lt;11} {incr i} {
        set whichDutNow $i
        set DUTs_info(DUT${i},version) &#34;15.1.1.1&#34;
        if {[info exists DUT${i}_CONNECT]} {
            Login &#34;[set DUT${i}_CONNECT]&#34; -CheckOperational 0 -masterCheck 0
            ConfigGatewayNetwork
            _ClearExpectSession
        }
    }
}
if {$ib} {
    catch {source $initFile} bob
    if {![info exists numDUT]} {
        puts &#34;Info required for ConfigGWNetwork not available from initFile&#34;
        set numDUT $n
        set supportedPlatform &#34;&#34;
    }
    set MGMT_REG(telnetNeedsConfig) 1
    set MGMT_REG(forceConsole) 1
    set MGMT_REG(currentConnectionType) &#34;console&#34;
    set MGMT_REG(useTelnetGlobalFlag) 0
    set MGMT_REG(useTelnetLocalFlag) 0
    for {set i 1} {$i&lt;11} {incr i} {
        set whichDutNow $i
        set DUTs_info(DUT${i},version) &#34;15.1.1.1&#34;
        if {[info exists DUT${i}_CONNECT]} {
            Login &#34;[set DUT${i}_CONNECT]&#34; -CheckOperational 0 -masterCheck 0
            SendACmd &#34;config snmp sysN $smallCfg${i}&#34;
            SendACmd &#34;enable edp port all&#34;
            ConfigGatewayNetwork
            ConfigInBandNetwork
            _ClearExpectSession
        }
    }
}
if {$f} {
    after 2000
}
for {set i 1} {$i&lt;11} {incr i} {
    set whichDutNow $i
    if {$power==2} {
        if {[info exists POWERCYCLE_DUT($i)]} {
            puts &#34;Powering off DUT DUT$i&#34;
            PowerOffDUT $i &#34;off&#34;
            exSleep 1
            puts &#34;Powering on DUT DUT$i&#34;
            PowerOffDUT $i &#34;on&#34;
        }
    }
    if {[info exists DUT${i}_CONNECT]} {
        puts &#34;Sending /usr/kerberos/bin/telnet \&#34;[set DUT${i}_CONNECT]\&#34;&#34;
        if {[catch {exec /usr/bin/xterm -e \
                 &#34;../Util/bash_lc ${cfgFile}_DUT$i \&#34;[set DUT${i}_CONNECT]\&#34;&#34; &amp;} reason]} {
            puts &#34;OOOPPPSSSSS&#34;
        }
    }
    if {[info exists DUT${i}_CONNECTB]} {
        puts &#34;Sending /usr/kerberos/bin/telnet \&#34;[set DUT${i}_CONNECTB]\&#34;&#34;
        if {[catch {exec /usr/bin/xterm -e \
                 &#34;../Util/bash_lc ${cfgFile}_DUT${i}B \&#34;[set DUT${i}_CONNECTB]\&#34;&#34; &amp;} reason]} {
            puts &#34;OOOPPPSSSSS&#34;
        }
    }
    if {[info exists DUT${i}_CONNECTC]} {
        puts &#34;Sending /usr/kerberos/bin/telnet \&#34;[set DUT${i}_CONNECTC]\&#34;&#34;
        if {[catch {exec /usr/bin/xterm -e \
                 &#34;../Util/bash_lc ${cfgFile}_DUT${i}C \&#34;[set DUT${i}_CONNECTC]\&#34;&#34; &amp;} reason]} {
            puts &#34;OOOPPPSSSSS&#34;
        }
    }
    if {[info exists DUT${i}_CONNECTD]} {
        puts &#34;Sending /usr/kerberos/bin/telnet \&#34;[set DUT${i}_CONNECTD]\&#34;&#34;
        if {[catch {exec /usr/bin/xterm -e \
                 &#34;../Util/bash_lc ${cfgFile}_DUT${i}D \&#34;[set DUT${i}_CONNECTD]\&#34;&#34; &amp;} reason]} {
            puts &#34;OOOPPPSSSSS&#34;
        }
    }
    if {[info exists DUT${i}_CONNECTE]} {
        puts &#34;Sending /usr/kerberos/bin/telnet \&#34;[set DUT${i}_CONNECTE]\&#34;&#34;
        if {[catch {exec /usr/bin/xterm -e \
                 &#34;../Util/bash_lc ${cfgFile}_DUT${i}E \&#34;[set DUT${i}_CONNECTE]\&#34;&#34; &amp;} reason]} {
            puts &#34;OOOPPPSSSSS&#34;
        }
    }
    if {[info exists DUT${i}_CONNECTF]} {
        puts &#34;Sending /usr/kerberos/bin/telnet \&#34;[set DUT${i}_CONNECTF]\&#34;&#34;
        if {[catch {exec /usr/bin/xterm -e \
                 &#34;../Util/bash_lc ${cfgFile}_DUT${i}F \&#34;[set DUT${i}_CONNECTF]\&#34;&#34; &amp;} reason]} {
            puts &#34;OOOPPPSSSSS&#34;
        }
    }
}
close_result_file
exit;
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
