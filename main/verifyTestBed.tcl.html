<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>verifyTestBed.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#verifyTestBed.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>verifyTestBed.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="verifyTestBed.tcl-annot.html">annotations</a> | <a href="verifyTestBed.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

<strong><a name="::CheckShowSwitchAfterLogin_3">proc <a href="verifyTestBed.tcl-annot.html#::CheckShowSwitchAfterLogin">::CheckShowSwitchAfterLogin</a></a></strong><a name="::CheckShowSwitchAfterLogin"></a> {i} {
    global DUT[set i]\_CONNECT
    Login [set DUT[set i]\_CONNECT]
    SendACmd &#34;show switch&#34;
}


<span class="comment-line"># ---- MAIN ----</span>
global curAutoRoot
global DUTs_info

source ../Lib/mainLib.tcl
package require Tclx

if {$tcl_platform(platform) == &#34;windows&#34;} {
  load &#34;expect52.dll&#34;
} else {
  load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
}

set curLocation [pwd]
set curDirList [split [string trim [string trim $curLocation &#34;..&#34;] &#34;/&#34;] &#34;/&#34;]
set v 0;
set pathList &#34;&#34;
set curAutoRoot &#34;&#34;
set skipCC 0
foreach cd $curDirList {
    if {$cd == &#34;main&#34; || $cd == &#34;Lib&#34; || $cd == &#34;Util&#34;} {
        for {set x 0} {$x&lt;$v} {incr x} {
            lappend pathList [lindex $curDirList $x]
        }
        set curAutoRoot &#34;/[join $pathList &#34;/&#34;]&#34;
    } else {
        incr v;
    }
}

set LIB_PATH &#34;./../Lib&#34;
lappend auto_path $LIB_PATH
puts &#34;DEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;

gen_index &#34;./../Lib&#34;


<strong><a name="::print_usage_47">proc <a href="verifyTestBed.tcl-annot.html#::print_usage">::print_usage</a></a></strong><a name="::print_usage"></a> {} {
   puts &#34;\r&#34;
   puts {Usage: verifyTestBed.tcl -cfg &lt;config file&gt; [-clean &lt;yes|no&gt;] }
   puts {   &lt;cfg&gt;: Path of the config file name }
   puts {   [&lt;clean&gt;]: Do unconfig before running check connection. Default: yes}
   puts {   [&lt;rescue&gt;]: Go to bootrom and install good image to primary. Default: no}
   puts {   [&lt;userImagePath&gt;]: Get a user defined image not one from release-manager. Default \&#34;\&#34;}
   puts {   [&lt;mtc&gt;]: yes/no Set the sysNames to DUT# for manual EDP trunk port setup Default: no }
   puts {   [&lt;show&gt;]: List license info for cut and paste to cfg file Default: no }
   puts {   [&lt;setLic&gt;]: Set the licenses on the switches. Default: no}
   puts {   [&lt;skipCC&gt;]: skip ixia traffic. Default: 0}
   puts {   [&lt;note&gt;]: Just text}
   puts {   [&lt;target&gt;]: version location}
   puts {   [&lt;vv&gt;]: version to verify}
   puts {   [&lt;quick&gt;]: No state verification}
   puts {   [&lt;bank&gt;]: Just reboot to a specific bank}
   puts &#34;\r&#34;
}

<span class="comment-line"># checking command parameters</span>
if {$argc&lt;1} {
      puts &#34;Not enough parameters&#34;
      <a name="::print_usage(1)"><a href="./verifyTestBed.tcl.html#::print_usage_47">::print_usage</a></a>
      return
}

parse_args main $argv {
      cfg &#34;null&#34;
      clean &#34;no&#34;
      rescue &#34;no&#34;
      userImagePath &#34;&#34;
      TrafficGen &#34;ixia&#34;
      show &#34;no&#34;
      setLic &#34;no&#34;
      skipCC &#34;0&#34;
      note &#34;&#34;
      target   &#34;NULL&#34;
      vv &#34;NULL&#34;
      quick &#34;no&#34;
      bank &#34;null&#34;
      mtc &#34;null&#34;
}

set cfgFile &#34;&#34;
set passCount 0
set failCount 0
set skipCount 0

if [catch {source &#34;cfg/common.cfg&#34;} rea] {
      puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
      puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
      exit -1
}

if {$cfg != &#34;null&#34;} {
      if {![regexp -nocase &#34;^cfg&#34; $cfg] } {
      	    set cfgFile [format %s/%s cfg $cfg]
      	    set cfgFile [string trim $cfgFile];
      } else {
          set cfgFile $cfg
      }
}

puts &#34;Using config file: ($cfgFile)&#34;

if {[file exists $cfgFile] == 0} {
      puts &#34;Cannot find config file: $cfgFile\n&#34;
      puts stderr &#34;Cannot find config file: $cfgFile&#34;
      return
}

puts &#34;************** ABOUT TO source $cfgFile *****************&#34;

catch {source $cfgFile } reason

if {[info exists ixiaPath($ixiaCh1)]} {
   SetIxiaEnv &#34;$ixiaPath($ixiaCh1)&#34;
}

lappend auto_path [file join $env(HOME) &#34;ixia/lib/mpexpr-1.0&#34;]
lappend auto_path [file join $env(HOME) &#34;ixia/lib/ixTcl1.0&#34;]
lappend auto_path [file join $env(HOME) &#34;ixia/lib/dp4.0&#34;]

<span class="comment-line"># mode setup   </span>
set clean [string tolower $clean]
switch $clean  {
       yes     { puts &#34;This is a clean check connection (with unconfig).&#34;}
       no      { puts &#34;This is a check connection without unconfig&#34; }
       default  { puts &#34;No Match&#34;}
}
      
if {![file isdirectory Report]} {
      file mkdir Report
 }
if {![file isdirectory Result]} {
     file mkdir Result
 }
if {![file isdirectory Tmp]} {
      file mkdir Tmp
}
if {![file isdirectory Log]} {
      file mkdir Log
}

<span class="comment-line">############################################################</span>

set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]

set testDuration 0
set testHour 0
set testMin 0
set testSec 0
set resultDir &#34;NULL&#34;

set fd_res [open_result_file &#34;verifyTestBed&#34;]

<span class="comment-line">################################################</span>
set test &#34;Verify Test Bed&#34;
<span class="comment-line">################################################</span>
result_h1 &#34;$test&#34;
report_start_test &#34;$test&#34;

set numDUT 1
set rebList &#34;&#34;
while { [info exists DUT${numDUT}_CONNECT] } {
    set connect [set DUT${numDUT}_CONNECT]
    set DUTs_info(DUT${numDUT},connect) [set DUT${numDUT}_CONNECT]
    puts &#34;***** DUT${numDUT}_CONNECT=$connect ***** &#34;
    puts &#34;***** numDUT=$numDUT ***** &#34;
    set dutCount $numDUT
    lappend connectList $connect
    if {$bank != &#34;null&#34; &amp;&amp; [regexp -nocase &#34;pr|sec&#34; $bank]} {
        if {[regexp -nocase &#34;pr&#34; $bank]} {
            set bank primary
        } else {
            set bank secondary
        }
        Login $connect
        SendACmd &#34;use image $bank&#34;
        lappend rebList &#34;CheckReboot $numDUT -masterCheck 0&#34;
    }
    if {[regexp -nocase &#34;y&#34; $mtc]} {
        Login $connect
        SendACmd &#34;configure snmp sysName DUT$numDUT&#34;
        SendACmd &#34;enable edp po all&#34;
    }
    incr numDUT 1
}
incr numDUT -1
if {$bank != &#34;null&#34; &amp;&amp; [regexp -nocase &#34;pr|sec&#34; $bank]} {
    MultiTask $rebList
    if {$quick == &#34;no&#34;} {
        return;
    }
}

if {$clean == &#34;yes&#34;} {
    while { [info exists DUT${numDUT}_CONNECT] } {
       set connect [set DUT${numDUT}_CONNECT]
       set DUTs_info(DUT${numDUT},connect) [set DUT${numDUT}_CONNECT]
       set script [set DUT${numDUT}_SETUP]
       puts &#34;***** DUT${numDUT}_CONNECT=$connect ***** &#34;
       puts &#34;***** numDUT=$numDUT ***** &#34;
       incr numDUT 1
       lappend scriptList $script
       lappend connectList $connect
    }
    <span class="comment-line"># RunSetupScript $connectList $scriptList</span>
    set runSetupRetVal [RunSetupScript $connectList $scriptList]
    if {$runSetupRetVal==-1} {
	unset connectList
	unset scriptList
	puts stderr &#34;testSkipped&#34;
	return -1
    } elseif { $runSetupRetVal==&#34;REGROUTER_FAILED&#34; } {
	unset connectList
	unset scriptList
	puts stderr $returnFlag
	flush stderr
	return $runSetupRetVal
    }
    unset connectList
    unset scriptList
}

<span class="comment-line">#</span>
if {$quick == no} {
if {[set rc [get_DUTs_info]] != 0} {
    <a name="::result_error(1)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
    close_result_file;
    return -2;
    set returnFlag 
}

global stacking DUTs_info
if {![info exists DUTs_info(regBaseImage)]} {
    set DUTs_info(regBaseImage) 12.3.2.5
}
if {[string tolower $rescue] == &#34;yes&#34;} {
    for {set i 1} {$i &lt;=$numDUT} {incr i 1} {
        if {![regexp -nocase $stacking $DUTs_info(DUT$i,platform)] &amp;&amp; \
        ($DUTs_info(DUT$i,priImage) != &#34;$DUTs_info(regBaseImage)&#34; || \
        $DUTs_info(DUT$i,relMaster) != &#34;release-manager&#34;)} {
    
            global DUT${i}_IP
            global tftpServerList
            global connectionTimeout
            global defaultRouter
            global switchPort2DefaultRouter
            global RouterMode
            source ../Functionaltest/epm/EPM.tcl; <span class="comment-line"># to get SendBootRomCmd </span>
            <span class="comment-line">################################################</span>
            set subTest &#34;download/Install rescue image&#34;
            <span class="comment-line">################################################</span>
            result_h2 &#34;$subTest&#34;
            report_start_test &#34;$subTest&#34;
            
            Login $DUTs_info(DUT$i,connect)
            rebootToBootRom $i
            
            <a name="::result_debug(1)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Configuring the ip address and gateway at BootRom prompt&#34;
            SendBootRomCmd &#34;configip address [set DUT${i}_IP] gateway $defaultRouter&#34;
            
            <a name="::result_debug(2)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Downloading rescue image from tftp server&#34;
            
            if {$switchPort2DefaultRouter != &#34;mgmt&#34;} {
            <a name="::result_ok(1)"><a href="./loadConsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;the case only applicable if network is connected via Mgmt port&#34;
            report_end_test
            return 0
            }
            set ImageForInstall [downloadImageToTftp -version $DUTs_info(regBaseImage) -userImagePath &#34;$userImagePath&#34;]  
            <span class="comment-line">#--- Downloading image from bootrom prompt</span>
            set origConnectionTimeout $connectionTimeout
            set connectionTimeout 1000
            SendBootRomCmd &#34;download image [lindex $tftpServerList 0] $ImageForInstall&#34; NULL $fd_res
            set connectionTimeout $origConnectionTimeout
            
            <span class="comment-line">#--- Checking the installation</span>
            report_start_test &#34;Installing rescue image&#34;
            <span class="comment-line">#if {$RouterMode == &#34;EXOS&#34;} {</span>
            <span class="comment-line">#    result_ok &#34;download of image is successfull&#34;</span>
            <span class="comment-line">#    } else {</span>
            <span class="comment-line">#    result_error &#34;download of image failed&#34;</span>
            <span class="comment-line">#    }</span>
            report_end_test
            
            <span class="comment-line">#-- CleanUp</span>
            Login $DUTs_info(DUT$i,connect)
            
            <span class="comment-line">#-- Checking all slots are operational</span>
            CheckOperational
        }
    }
}

set netConFlag 1
<span class="comment-line">#check connections between DUTs and Ixia</span>
if {!$skipCC} {
    if {[info exists ixiaCh1]} {
        if {![regexp -nocase &#34;no_ixia&#34; $ixiaCh1]} {
            set returnFlag [SystemSetup]
        } else {
            set returnFlag &#34;connectionOkay&#34;
        }
    } else {
        <a name="::result_error(2)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Can't find ixia information&#34;
        set returnFlag &#34;connectionBad&#34;
    }
    global defaultRouter
    global tftpServerList
    global switchPort2DefaultRouter
    set tftpServer [lindex $tftpServerList 0]
    set netConFlag 1
    set numDUT 1
    result_h2 &#34;Network port validation&#34;
    report_start_test &#34;Network port validation&#34;
    while { [info exists DUT${numDUT}_CONNECT] } {
        set connect [set DUT${numDUT}_CONNECT]
        set dut_ip [set DUT${numDUT}_IP]
        set def_blade [set DUT${numDUT}_DefaultBlade]
        if { $def_blade != 0 } {
            set port $def_blade:$switchPort2DefaultRouter
        } else {
            set port $switchPort2DefaultRouter
        }
        result_h2 &#34;Checking Network port for DUT$numDUT&#34;
        report_start_test &#34;Checking Network port for DUT$numDUT&#34;

        Login $connect
        SendACmd &#34;conf default del po all&#34;
        ConfigGatewayNetwork
        set ret [CheckCLIPing &#34;ping vr [GetVrString] $tftpServer&#34;]
        exSleep 5
        UnconfigGatewayNetwork
        if { $ret == 1 } {
            <a name="::result_ok(2)"><a href="./loadConsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Network connection for DUT$numDUT is PASS&#34;
        } else {
            <a name="::result_error(3)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Network connection for DUT$numDUT is FAIL&#34;
            set netConFlag 0
        }
        report_end_test
        incr numDUT 1
    }
    report_end_test
} else {
    set returnFlag &#34;connectionOkay&#34;
}

    if {$setLic == &#34;yes&#34;} {
        set testDUT 1
        set numDUT 1
        while { [info exists DUT${numDUT}_CONNECT] } {
            puts &#34;# Device $DUTs_info(DUT$numDUT,sysType) Serial Number - $DUTs_info(DUT$numDUT,serial) &#34;
            if {$DUTs_info(DUT$numDUT,serial) == &#34;null&#34;} {incr numDUT 1; continue}
                set key [exec keygen -p 4 -n $DUTs_info(DUT$numDUT,serial)]
                set klist [split $key &#34; &#34;]
                set key [lindex $klist [expr [llength $klist] - 1]]
                set DUTs_info(DUT$numDUT,mpls_license) &#34;$key&#34;
                puts &#34;set DUTs_info(DUT$numDUT,mpls_license) \&#34;$key\&#34;&#34;
                set key [exec keygen -p 16 -n $DUTs_info(DUT$numDUT,serial)]
                set klist [split $key &#34; &#34;]
                set key [lindex $klist [expr [llength $klist] - 1]]
                set DUTs_info(DUT$numDUT,bgp) &#34;$key&#34;
                puts &#34;set DUTs_info(DUT$numDUT,bgp) \&#34;$key\&#34;&#34;
                if {[regexp -nocase &#34;bd-20|bd-12|bd-10&#34; $DUTs_info(DUT$numDUT,sysType)]} {
                set key [exec keygen -p 8 -n $DUTs_info(DUT$numDUT,serial)]
                set klist [split $key &#34; &#34;]
                set key [lindex $klist [expr [llength $klist] - 1]]
                set DUTs_info(DUT$numDUT,flowvsr_license) &#34;$key&#34;
                puts &#34;set DUTs_info(DUT$numDUT,flowvsr_license) \&#34;$key\&#34;&#34;
                set key [exec keygen -p 2 -n $DUTs_info(DUT$numDUT,serial)]
                set klist [split $key &#34; &#34;]
                set key [lindex $klist [expr [llength $klist] - 1]]
                set DUTs_info(DUT$numDUT,mef_license) &#34;$key&#34;
                puts &#34;set DUTs_info(DUT$numDUT,mef_license) \&#34;$key\&#34;&#34;
           }
           if {[regexp -nocase &#34;x8|670|770&#34; $DUTs_info(DUT$numDUT,sysType)]} {
               set key [exec keygen -p 12 -n $DUTs_info(DUT$numDUT,serial)]
               set klist [split $key &#34; &#34;]
               set key [lindex $klist [expr [llength $klist] - 1]]
               set DUTs_info(DUT$numDUT,trill_license) &#34;$key&#34;
               puts &#34;set DUTs_info(DUT$numDUT,trill_license) \&#34;$key\&#34;&#34;
           }
           if {[regexp -nocase &#34;460|670|770|440|430&#34; $DUTs_info(DUT$numDUT,sysType)]} {
               set key [exec keygen -p 10 -n $DUTs_info(DUT$numDUT,serial)]
               set klist [split $key &#34; &#34;]
               set key [lindex $klist [expr [llength $klist] - 1]]
               set DUTs_info(DUT$numDUT,avb_license) &#34;$key&#34;
               puts &#34;set DUTs_info(DUT$numDUT,avb_license) \&#34;$key\&#34;&#34;
           }
           set key [exec keygen -p 11 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]a
           set DUTs_info(DUT$numDUT,openflow_license) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,openflow_license) \&#34;$key\&#34;&#34;
           set key [exec keygen -p 32 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,ssh_license) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,ssh_license) \&#34;$key\&#34;&#34;
           set key [exec keygen -d 3 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,advancededge_core) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,advancededge_core) \&#34;$key\&#34;&#34;
           set key [exec keygen -d 1 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,advancedcore_edge) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,advancedcore_edge) \&#34;$key\&#34;&#34;
           set key [exec keygen -d 4 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,advancededge_advancedcore) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,advancededge_advancedcore) \&#34;$key\&#34;&#34;
           set key [exec keygen -d 4 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,core_advancedcore) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,core_advancedcore) \&#34;$key\&#34;&#34;
           set key [exec keygen -d 2 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,edge_advancededge) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,edge_advancededge) \&#34;$key\&#34;&#34;
           set key [exec keygen -d 3 -n $DUTs_info(DUT$numDUT,serial)]
           set klist [split $key &#34; &#34;]
           set key [lindex $klist [expr [llength $klist] - 1]]
           set DUTs_info(DUT$numDUT,edge_core) &#34;$key&#34;
           puts &#34;set DUTs_info(DUT$numDUT,edge_core) \&#34;$key\&#34;&#34;
           incr numDUT 1
        }
        set testDUT 1
        while { [info exists DUT${testDUT}_CONNECT] } {
            Login $DUTs_info(DUT${testDUT},connect)
            <span class="comment-line"># ------------------------------------------------</span>
            <span class="comment-line"># Disable the 30 day trial license</span>
            <span class="comment-line"># ------------------------------------------------</span>
            set parameterList &#34;&#34;
            lappend parameterList &#34;{30 days Trial} exist&#34;
            set result [CheckKeyValue &#34;show license&#34; $parameterList -reportResults 0]
            if {$result == &#34;ok&#34;} {
                EnableDebugMode
                SendACmd &#34;debug epm clear trial-license&#34;
                CheckReboot
            }
            DisableDebugMode

            <span class="comment-line"># ------------------------------------------------</span>
            <span class="comment-line"># Restore License to Core if not at Core</span>
            <span class="comment-line"># For lync L2-Edge</span>
            <span class="comment-line"># ------------------------------------------------</span>
            <span class="comment-line"># Set the license keys dynamically. Passing a 1 as second Arg sets</span>
            set varout [_SetSwitchLicVars $testDUT 1]
            set parameterList &#34;&#34;
            if {[regexp $bcmLynx $DUTs_info(DUT$testDUT,platform)]} {
                lappend parameterList &#34;L2.* exist&#34;;
            } else {
                lappend parameterList &#34;{core} exist&#34;;
            }
            if {[CheckKeyValue &#34;show license&#34; $parameterList]!=&#34;ok&#34;} {
                if {1} {
                    set parameterList &#34;&#34;
                    lappend parameterList &#34;{Enabled License Level:} 0 1&#34;
                    lappend parameterList &#34;{Enabled License Level:} 1 1&#34;
                    set getLicense [GetKeyValue &#34;show license&#34; $parameterList]
                    if {[lindex [lindex $getLicense 0] 1] != &#34;&#34;} {
                        set temp [split [lindex $getLicense 0] &#34; &#34;]
                        set currentLicense [concat [lindex $temp 0][lindex $temp 1]]
                    } else {
                        set temp [split [lindex $getLicense 0] &#34; &#34;]
                        set currentLicense [lindex $temp 0]
                    }
                    if {[EnableLicense \
                        [string tolower $currentLicense] core] == &#34;error&#34;} {
                        if {![regexp $pioneerPlatform $DUTs_info(DUT$testDUT,platform)]} {
                            return error
                        }
                    }
                } else {
                    if {![regexp $pioneerPlatform $DUTs_info(DUT$testDUT,platform)]} {
                        return error
                    }
                }
            }
            unset parameterList
            <span class="comment-line"># ------------------------------------------------</span>
            <span class="comment-line"># Restore Feature Packs if they are supported on this platform</span>
            <span class="comment-line"># ------------------------------------------------</span>
            if {![regexp -nocase &#34;stack&#34; $DUTs_info(DUT${testDUT},sysName)] &amp;&amp;
                $DUTs_info(DUT${testDUT},serial) != &#34;null&#34;} {
                set fvarout [_SetFeatureLicenses ${testDUT}]
            }
            ;<span class="comment-line"># ------------- End Feature License -----------</span>
            incr testDUT
        }
     } ;<span class="comment-line"># ------------ End of all Licensing -----------</span>


report_end_test
incr numDUT -1

} else {
    if {[set rc [get_DUTs_info]] != 0} {
        <a name="::result_error(4)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
        close_result_file;
        return -2;
    } else {
        set netConFlag 1
        for {set i 1} {$i&lt;=$dutCount} {incr i} {
            Login $DUTs_info(DUT$i,connect)
            <a name="::result_debug(3)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n-----------------------&#34;
            <a name="::result_debug(4)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $i $DUTs_info(DUT$i,imageSel)&#34;
            <a name="::result_debug(5)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $i $DUTs_info(DUT$i,imageBooted)&#34;
            <a name="::result_debug(6)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $i $DUTs_info(DUT$i,version)&#34;
            <a name="::result_debug(7)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $i $DUTs_info(DUT$i,priImage)&#34;
            <a name="::result_debug(8)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT $i $DUTs_info(DUT$i,secImage)&#34;
            if {$vv != &#34;NULL&#34;} {
                if {$DUTs_info(DUT$i,priImage) == &#34;$vv&#34; &amp;&amp; $target == &#34;primary&#34;} {
                    report_start_test &#34;DUT$i Primary is $vv&#34;;<a name="::result_ok(3)"><a href="./loadConsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;&#34;;report_end_test;
                } elseif {$target == &#34;primary&#34;} {
                    report_start_test &#34;DUT$i BAD Found $DUTs_info(DUT$i,priImage) \
                                 on primary&#34;;<a name="::result_error(5)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;&#34;;report_end_test;
                }
                if {$DUTs_info(DUT$i,secImage) == &#34;$vv&#34; &amp;&amp; $target == &#34;secondary&#34;} {
                    report_start_test &#34;DUT$i Secondary is $vv&#34;;<a name="::result_ok(4)"><a href="./loadConsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;&#34;;report_end_test;
                } elseif {$target==&#34;secondary&#34;} {
                    report_start_test &#34;DUT$i Found $DUTs_info(DUT$i,secImage) on \
                                 secondary&#34;;<a name="::result_error(6)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;&#34;;report_end_test;
                }
                if {$DUTs_info(DUT$i,imageBooted) == &#34;$target&#34;} {
                    report_start_test &#34;DUT$i image booted is $target&#34;;<a name="::result_ok(5)"><a href="./loadConsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;&#34;;report_end_test;
                } else {
                    report_start_test &#34;DUT$i $DUTs_info(DUT$i,imageBooted) is \
                                 booted&#34;;<a name="::result_error(7)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;&#34;;report_end_test;
                }            
            }
        }
        set returnFlag &#34;connectionOkay&#34;
    }

}



if {$fd_res != &#34;&#34;} {
    catch {flush $fd_res} result
    if {$result != &#34;&#34;} { <a name="::result_error(8)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$result&#34; }
}
save_test_report &#34;[get_result_dir]/report.exr&#34;
gen_text_report &#34;[get_result_dir]/report.exr&#34; &#34;stdout&#34; &#34;[file tail [pwd]]&#34; $cfgFile
close_result_file
set tEndTime [clock seconds]
set testDuration [expr $tEndTime-$tStartTime]
set testSec  [expr $testDuration % 60]
set testMin  [expr $testDuration / 60]
set testHour [expr $testMin / 60]
set testMin  [expr $testMin % 60]


<a name="::result_debug(9)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a>  &#34;\n\n*** Time for verify $cfgFile ( $testHour hours, $testMin minutes, \
              $testSec seconds )\n\n&#34;

if { $returnFlag == &#34;connectionOkay&#34; &amp;&amp;  $netConFlag==1 } {
     <span class="comment-line">#result_ok &#34;Check connection - PASS\n\n&#34;</span>
} else {
    <a name="::result_error(9)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Connections between DUTs and Ixia or network connections \
                 are not detected properly&#34;
    <a name="::result_error(10)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Please make sure physical connections match with config setup file&#34;
}
  gen_text_report &#34;[get_result_dir]/report.exr&#34; &#34;[get_result_dir]/report.txt&#34; &#34;[file tail [pwd]]&#34; $cfg
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
