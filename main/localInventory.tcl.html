<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>localInventory.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#localInventory.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>localInventory.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="localInventory.tcl-annot.html">annotations</a> | <a href="localInventory.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

package require Tclx
source ../Lib/mainLib.tcl
<span class="comment-line">#package require IxTclHal</span>
<span class="comment-line"># Connect to chassis and get chassis ID</span>

<span class="comment-line">#set hostList {&#34;10.69.1.250&#34;}</span>

load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]

set LIB_PATH ../Lib
lappend auto_path $LIB_PATH

puts &#34;DEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;
gen_index &#34;./../Lib&#34;


if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
    puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
    puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
    exit -1
}

set cTime [clock seconds]
set invFiles [glob -nocomplain -- ./Tmp/DUTINFO_*]


set cList &#34;&#34;
set gfList &#34;&#34;
set mdList &#34;&#34;
foreach if $invFiles {
    set fList [split $if &#34;/&#34;]
    set myFile [lindex $fList [expr [llength $fList] - 1]]
    puts &#34;$if&#34;
    puts &#34;$myFile&#34;

    <span class="comment-line"># Get the cfg file name temp file name</span>
    set cfgList [split $myFile &#34; &#34;]
    set cfgTxt [lindex $cfgList [expr [llength $cfgList] - 1]]
    regsub {[0-9]+_} $cfgTxt &#34;&#34; cfgTxt
    set cfgShortList [split $cfgTxt &#34;.&#34;]
    set cfgfile &#34;[lindex $cfgShortList 0].cfg&#34;
    if {[lsearch $cfgfile $cList] == -1 &amp;&amp; [file size $if] &gt; 10} {
        lappend cList $cfgfile
        puts &#34;Adding $cfgfile&#34;
        lappend gfList $if
        lappend mdList [file mtime $if]
    } elseif {[lsearch $cfgfile $cList] &gt;= 0} {
        set ci [lsearch $cfgfile $cList]
        puts &#34;Replacing $cfgfile at index $ci&#34;
        set cm [lindex $mdList $ci]
        if {$cm &lt; [file mtime $if]} {
            lreplace $gfList $ci $ci &#34;$if&#34;
            lreplace $mdList $ci $ci [file mtime $if]
        }
    } else {
        puts &#34;!!!!\n!!!!\n DID NOT ADD $if at all\n!!!!\n!!!!&#34;
    }

}


set fd_in [open &#34;./Tmp/local_inventory.csv&#34; &#34;w&#34;]

set cCount 1
set hostList &#34;&#34;
puts $fd_in &#34;Sys,Serial,Mac,Blades,FMs&#34;
foreach if $gfList {
    if {[expr $cTime - [file mtime $if]] &gt; 10000000} {
        puts &#34;!!!\n!!!\nFile is not current skipping $if \n!!!\n!!!&#34;
        file delete $if
        continue;
    }
    <span class="comment-line">#init line list</span>
    set linList &#34;&#34;
    set fList [split $if &#34;/&#34;]
    set myFile [lindex $fList [expr [llength $fList] - 1]]
    puts &#34;IF -- $if&#34;
    puts &#34;CFG FILE FOUND $myFile&#34;

    <span class="comment-line"># Get the cfg file name temp file name</span>
    set cfgList [split $myFile &#34; &#34;]
    set cfgTxt [lindex $cfgList [expr [llength $cfgList] - 1]]
    regsub {[0-9]+_} $cfgTxt &#34;&#34; cfgTxt
    set cfgShortList [split $cfgTxt &#34;.&#34;]
    set cfgfile &#34;[lindex $cfgShortList 0].cfg&#34;

    <span class="comment-line"># Clean out any previous iteration set ixiaCh1</span>
    if [info exists ixiaCh1] {
        unset ixiaCh1
    } else {
        set ixiaCh1 NULL
    }
    <span class="comment-line"># Clear out the info from the previous interation of the loop</span>
    if [info exists DUTs_info(DUT1,sysType)] {
        unset DUTs_info
    }
    <span class="comment-line">#source &#34;./Tmp2/$myFile&#34;</span>
    if {[file exists ./cfg/$cfgfile]} {
       puts &#34;SOURCING CFG FILE ./cfg/$cfgfile&#34;
       source &#34;./cfg/$cfgfile&#34;
       set goodCfg &#34;$cfgfile&#34;
    } else {
       puts &#34;NO EXIST - ./cfg/$cfgfile&#34;
       set goodCfg &#34;&#34;
       set ixiaCh1 &#34;NULL&#34;
    }
    if {[catch {source &#34;./Tmp/$myFile&#34;} why]} {
        puts &#34;\n@@@\n@@@\nFailed to source /Tmp/$myFile\n@@@\n@@@&#34;
    } 
    set numDUT 0 
    <span class="comment-line"># Figure out the number of DUT</span>
    for {set i 1} {$i &lt;= 10} {incr i} {
        if [info exists DUTs_info(DUT${i},imageBooted)] {
            incr numDUT
        } else {
            break
        }
    }
    if {$numDUT == 0} {
        puts &#34;The info file $myFile had not data&#34;
        continue;
    }

    if [info exists ixiaPath($ixiaCh1)] {
        set ixiaVer $ixiaPath($ixiaCh1)
        puts &#34;Ixia Chassis IP Address&#34;
        puts &#34;$ixiaCh1&#34;
        puts &#34;$ixiaPath($ixiaCh1)&#34;
        <span class="comment-line">#lappend linList &#34;$ixiaCh1&#34;</span>
        <span class="comment-line">#lappend linList &#34;$ixiaPath($ixiaCh1)&#34;</span>
        if {[lsearch $hostList [string trim $ixiaCh1]] == -1} {
            lappend hostList &#34;[string trim $ixiaCh1]&#34;
        }
    } else {
        puts &#34;Ixia Path Does not Exist&#34;
        set ixiaVer NULL
        puts &#34;Ixia Chassis IP Address&#34;
        puts &#34;$ixiaCh1&#34;
        <span class="comment-line">#lappend linList &#34;$ixiaCh1&#34;</span>
        <span class="comment-line">#lappend linList &#34;&#34;</span>
    }
    set csv($cCount,cfg) $goodCfg
    puts $fd_in &#34;$goodCfg,$cCount,,,&#34;
    for {set d 1} {$d &lt;= $numDUT} {incr d} {
        set linList &#34;&#34;
        if [info exists DUTs_info(DUT${d},sysType)] {
            puts &#34;DUTs_info(DUT${d},sysType) $DUTs_info(DUT${d},sysType)&#34;
            lappend linList &#34;$DUTs_info(DUT${d},sysType)&#34;
        } else {
            lappend linList &#34;&#34;
        }
        if [info exists DUTs_info(DUT${d},serial)] {
            puts &#34;DUTs_info(DUT${d},serial) $DUTs_info(DUT${d},serial) &#34;
            lappend linList &#34;$DUTs_info(DUT${d},serial)&#34;
        } else {
            lappend linList &#34;&#34;
        }
        if [info exists DUTs_info(DUT${d},sysMAC)] {
            puts &#34;DUTs_info(DUT${d},sysMAC) $DUTs_info(DUT${d},sysMAC) &#34;
            lappend linList &#34;$DUTs_info(DUT${d},sysMAC)&#34;
        } else {
            lappend linList &#34;&#34;
        }
        if [info exists DUTs_info(DUT${d},hwList)] {
            puts &#34;DUTs_info(DUT${d},hwList) $DUTs_info(DUT${d},hwList) &#34;
            regsub -all &#34;Empty&#34; $DUTs_info(DUT${d},hwList) &#34;&#34; hwL
            lappend linList &#34;$hwL&#34;
        } else {
            lappend linList &#34;&#34;
        }
        if [info exists DUTs_info(DUT${d},hwListFM)] {
            puts &#34;DUTs_info(DUT${d},hwListFM) $DUTs_info(DUT${d},hwListFM) &#34;
            regsub -all &#34;Empty&#34; $DUTs_info(DUT${d},hwListFM) &#34;&#34; fmL
            lappend linList &#34;$fmL&#34;
        } else {
            lappend linList &#34;&#34;
        }
        puts $fd_in [join $linList &#34;,&#34;]
    }
    
    puts $fd_in &#34;$ixiaCh1,$ixiaVer,,,&#34;
    set csv($cCount,ixia) $ixiaCh1
    puts $fd_in &#34;,,,,&#34;

    set iPString &#34;&#34;
    for {set u 1} {$u&lt;=12} {incr u} {
        if {[info exists ixiaPortMappingArray($u)]} {
            <span class="comment-line">#append iPString &#34;([string trimleft $ixiaPortMappingArray($u) &#34;1 &#34;]) &#34;</span>
            if {$u == 1} {
                set iList [split $ixiaPortMappingArray($u) &#34; &#34;]
                set iv &#34;[lindex $iList 1]:[lindex $iList 2]&#34;
                append iPString &#34;Ixia ports: $iv&#34;
            } else {
                set iList [split $ixiaPortMappingArray($u) &#34; &#34;]
                set iv &#34;[lindex $iList 0] [lindex $iList 1]:[lindex $iList 2]&#34;
                append iPString &#34; $iv&#34;
            }
        } else {
            append iPString &#34;&#34;
        }
    }
    if {$iPString == &#34;&#34;} {
        set csv($cCount,is) &#34;unknown&#34;
    } else {
        set csv($cCount,is) &#34;$iPString&#34;
    }
    set csv($cCount,pml) &#34;unknown&#34;
    if {[info exists portMappingList]} {
        <span class="comment-line">#set a [regsub -all {\{([0-9]+) } $portMappingList &#34;&#34;]</span>
        <span class="comment-line">#set c [regsub -all {(\} )} $a &#34;space&#34;]</span>
        <span class="comment-line">#set d [regsub -all { } $c &#34;:&#34;]</span>
        <span class="comment-line">#set e [regsub -all {space} $d &#34; &#34;]</span>
        <span class="comment-line">#set f [regsub -all {(\})} $e &#34;&#34;]</span>
        set csv($cCount,pml) &#34;DUT Ports: $portMappingList&#34;
    }
    for {set u 1} {$u&lt;=12} {incr u} {
        if {[info exists ixiaPortMappingArray($u)]} {
            unset ixiaPortMappingArray($u)
        }
    }
    incr cCount
}
puts $hostList
puts $fd_in &#34;,,,,&#34;
puts $fd_in &#34;,,,,&#34;
puts $fd_in &#34;IXIAs,,,,&#34;
puts $fd_in &#34;,,,,&#34;

foreach  hostname $hostList {
    if {$hostname == &#34;NO_IXIA&#34;} {
        continue;
    }
    set HOST [exec hostname -s]
    if {[regexp -nocase &#34;autoregeni&#34; $HOST]} {
        puts &#34;@@@@\n@@@@\nIN ENI \n@@@@\n@@@@&#34;
        if {[regexp -nocase &#34;10\.69&#34; $hostname]} {
            puts &#34;$hostname is in RTP&#34;
            continue
        }
    } else {
        puts &#34;@@@@\n@@@@\nIN ENI \n@@@@\n@@@@&#34;
        if {[regexp -nocase &#34;10\.127&#34; $hostname]} {
            puts &#34;$hostname is in ENI&#34;
            continue
        }
    }
    set auto_path_temp &#34;&#34;
    set savedType &#34;&#34;
    foreach var $auto_path {
        set var1 [split $var &#34;/&#34;]
        if {![regexp -nocase &#34;ixia&#34; $var1]} {
            lappend auto_path_temp $var
        }
    }
    set auto_path $auto_path_temp

    SetIxiaEnv &#34;$ixiaPath($hostname)&#34;
    lappend auto_path [file join $env(IXIA_HOME) &#34;lib&#34;]

    <span class="comment-line">#set timeout 10</span>
    set send_human {.1 .3 1 .05 2}
    set telnetOK 1
    <span class="comment-line">#set send_slow {10 .001}</span>
    <span class="comment-line"># Get the chassis serial number</span>
    if [catch &#34;spawn telnet $hostname&#34; reason] {
        puts &#34;failed to spawn program: $reason\n&#34;
        set label1 &#34;Not Available&#34;
    }
    expect {
        &#34;?nable to ?onnect&#34; {
            puts &#34;failed to connect to ixia&#34;
            set label1 &#34;Not Available&#34;
            set telnetOK 0
            continue
        }
        &#34;?o route to ?ost&#34; {
            puts &#34;failed to connect to ixia&#34;
            set label1 &#34;Not Available&#34;
            set telnetOK 0
            puts $fd_in &#34;$host,not reachable,,,&#34;
            continue
        }
        &#34;?onnection refused&#34; {
            puts &#34;failed to connect to ixia&#34;
            set label1 &#34;Not Available&#34;
            set telnetOK 0
            continue
        }
        &#34;?onnected to&#34; {
        <span class="comment-line">#wait for all remaining characters to come</span>
        <span class="comment-line">#puts &#34;Connection established&#34;</span>
        }
        timeout {

        }
    }

    if {$telnetOK} {
        sleep 2
        send  &#34;\r&#34;
        <span class="comment-line">#sleep 2</span>
        expect &#34;&gt;&#34;
        sleep 1
        if {[catch {send -h &#34;puts \$env(COMPUTERNAME)\r&#34;} why]} {
            puts &#34;BAD $why&#34;
        }
        sleep 2
        expect {
            -re \[A-Z0-9]+\-\[A-Z0-9]+ {
                if {[regexp -nocase {([A-Z0-9]+\-[A-Z0-9]+)} $expect_out(buffer) dummy label1]} {
                    puts &#34;Found regexp Chassis ID dummy $dummy label1 $label1&#34;
                }
            }
            -re \[A-Z]+\[0-9]+ {
                if [regexp -nocase -all {(OPT[A-Z0-9]+|[0-9A-Z]+)} $expect_out(buffer) dummy label1] {
                    puts &#34;Found regexp Chassis ID dummy $dummy label1 $label1&#34;
                }
            }
            timeout {
                set label1 &#34;NOT AVAILABLE&#34;
                puts &#34;Hit timeout $expect_out(buffer)&#34;
            }
        }
        <span class="comment-line"># Get the ixia version 'puts $env(IXTCLHAL_LIBRARY)'</span>
        catch {exp_close}
        catch {wait}
    }
    package require IxTclHal

    set host $hostname
    <span class="comment-line">#if {[regexp -nocase 1600 $label1]} {</span>
    <span class="comment-line">#    puts $fd_in &#34;$host,IS 1600 Skip,,,&#34;</span>
    <span class="comment-line">#    continue</span>
    <span class="comment-line">#}</span>
    if [catch &#34;set out [ixInitialize $host]&#34; $reason] {
        puts &#34;Ixia $host is not reachable&#34;
        puts $fd_in &#34;$host,not reachable,,,&#34;
        continue;
    }
    if {[regexp -nocase &#34;error&#34; $out]} {
        puts &#34;Ixia $host is not reachable&#34;
        puts $fd_in &#34;$host,not reachable,,,&#34;
        continue;
    }

    <span class="comment-line"># Grant Added</span>
    version get
    ixPuts -nonewline &#34;Company name is &#34;
    ixPuts [version cget -companyName]
    ixPuts -nonewline &#34;Copyright is &#34;
    ixPuts [version cget -copyright]
    ixPuts -nonewline &#34;Install Version is &#34;
    ixPuts [version cget -installVersion]
    ixPuts -nonewline &#34;ixTclHAL Version is &#34;
    ixPuts [version cget -ixTclHALVersion]
    ixPuts -nonewline &#34;Product Version is &#34;
    ixPuts [version cget -productVersion]
    ixPuts -nonewline &#34;Product Serial Number is  &#34;
    ixPuts [version cget -productVersion]

    set chas [ixGetChassisID $host]
    <span class="comment-line"># Get the chassis: number of cards</span>
    chassis getFromID $chas
    set ctype [chassis cget -typeName]
    set ncards [chassis cget -maxCardCount]
    ixPuts &#34;Chassis $ctype, id $chas,max card $ncards cards&#34;
    puts $fd_in &#34;$host,$ctype,$label1,[version cget -installVersion],#Slots $ncards&#34;

    for {set i 1} {$i &lt;= $ncards} {incr i} {
       <span class="comment-line"># Check for missing card</span>
       if {[card get $chas $i] != 0} {
         continue
       }
       set portList [list [list $chas $i 1]]
       <span class="comment-line"># Get all of the card's characteristics</span>
       set fpgaVersion [card cget -fpgaVersion]
       set hwVersion [card cget -hwVersion]
       set portCount [card cget -portCount]
       set type [card cget -type]
       set typeName [card cget -typeName]
       set serialNumber [card cget -serialNumber]
       <span class="comment-line"># And list them</span>
       ixPuts &#34;Card $i: $typeName ($type), $portCount ports, \
       fpga: $fpgaVersion, hwVersion: $hwVersion serialNumber: $serialNumber&#34;
       puts $fd_in &#34;Card $i,$typeName,$serialNumber,,&#34;
       <span class="comment-line"># If the card is a 10/100 RMII, play with its settable parameters</span>
       if {$type == $::card10100RMii} {
         card config -clockRxRisingEdge 0
         card config -clockTxRisingEdge 1
         if [card set $chas $i] {
           ixPuts &#34;Could not card set $chas $i&#34;
         }
         ixWriteConfigToHardware portList
       }
       <span class="comment-line"># Just for fun, we'll export the data associated with the first card</span>
       <span class="comment-line"># and read it to any other cards of the same type</span>
       puts &#34;PRE IF&#34;
       <span class="comment-line">#if {$i == 1} {</span>
       <span class="comment-line">#  if {[card export cardfile $chas $i] != 0} {</span>
       <span class="comment-line">#    ixPuts &#34;Could not export&#34;</span>
       <span class="comment-line">#    set savedType &#34;null&#34;</span>
       <span class="comment-line">#  } else {</span>
       <span class="comment-line">#    set savedType $type</span>
       <span class="comment-line">#  }</span>
       <span class="comment-line">#} elseif {$type == $savedType} {</span>
       <span class="comment-line">#  if {[card import cardfile $chas $i] == 1} {</span>
       <span class="comment-line">#    ixPuts &#34;Could not import&#34;</span>
       <span class="comment-line">#  }</span>
       <span class="comment-line">#}</span>
       puts &#34;END of Loop&#34;
    }
    <span class="comment-line">#puts $fd_in &#34;,,,,&#34;</span>
    <span class="comment-line">#set csv($cCount,ixia) $ixiaCh1 csv($cCount,cfg)  csv($cCount,is)</span>
    for {set x 1} {$x&lt;=$cCount} {incr x} {
        if {[info exists csv($x,ixia)] &amp;&amp; $csv($x,ixia) == &#34;$host&#34;} {
            puts $fd_in &#34;$csv($x,cfg),$csv($x,is),,,&#34;
            puts $fd_in &#34;,$csv($x,pml),,,&#34;
        }
    }
    puts $fd_in &#34;,,,,&#34;
}

close $fd_in
exit
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
