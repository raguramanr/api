<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>mysqlRunRegAll.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#mysqlRunRegAll.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>mysqlRunRegAll.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="mysqlRunRegAll.tcl-annot.html">annotations</a> | <a href="mysqlRunRegAll.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>




load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]

source ./mysqlRunRegAllLocal.tcl

;<span class="comment-line"># We pass regpcList because we need to source the runReg.cfg file before we</span>
;<span class="comment-line"># can determine this, thus we must get that information at run time.</span>
<strong><a name="::regPrintUsage_12">proc <a href="mysqlRunRegAll.tcl-annot.html#::regPrintUsage">::regPrintUsage</a></a></strong><a name="::regPrintUsage"></a> {{regpcList &#34;&#34;}} {
    puts &#34;\r&#34; 
    puts &#34;usage: runRegAll.tcl  \[-status\] \[-cvsupdate\] \[-cfg &lt;cfgfile&gt;\]&#34;
    puts &#34;       \[-i386ImagePath &lt;imagePath&gt; \[-marinerImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-aspenImagePath &lt;imagePath&gt; \[-cougarImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-x480ImagePath &lt;imagePath&gt; ]&#34;
    puts &#34;       \[-x870ImagePath &lt;imagePath&gt; ]&#34;
    puts &#34;       \[-NWIImagePath &lt;imagePath&gt; ]&#34;
    puts &#34;       \[-jaguarImagePath &lt;imagePath&gt; ] \[-viperImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-olympicImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-voyagerImagePath &lt;imagePath&gt; ]&#34; 
    puts &#34;       \[-everestImagePath &lt;imagePath&gt; ]&#34;
    puts &#34;       \[-download &lt;yes|no&gt;\] \[-mailTo &lt;emailAddress&gt;\]  \[-include \&#34;module list\&#34;]&#34; 
    puts &#34;       \[-exclude \&#34;module list\&#34;] \[-platform &lt;platformName,index&gt;] \[-regpcs \&#34;regpc list\&#34;]&#34; 
    puts &#34;       \[-killxterm &lt;yes&gt;\] \[-obuild &lt;old build version&gt;\]&#34;
    puts &#34;       \[-build_name &lt;build name&gt;\] \[-subversion &lt;subversion&gt;\] \[-pass_number &lt;pass number&gt;\] \[-heuristic &lt;heuristic algor&gt;\] \[-efence &lt;activate efence&gt;\] \[-saveConfigPerTest &lt;enable config save per test&gt;\]&#34;
    puts &#34;       \[-debugLevel\]: debug level 1|2|3. The level at which the debug information is dumped when script encounters an error&#34;
    puts &#34;       \[-lst &lt;quick|pass|all|dev&gt;\]&#34;
    puts &#34;       \[-force\] \[-help\]&#34;
    puts &#34;\r&#34;
    puts &#34;    -cvsupdate:       Execute cvs update on the automation directory of each&#34;
    puts &#34;                      regression PC&#34;
    puts &#34;    -status:          Execute ps on remote machines to see status&#34;
    puts &#34;                      To see status on a subset of regpcs, use&#34;
    puts &#34;                      i.e. -regpcs \&#34;BD1 Alpine\&#34; -status&#34;
<span class="comment-line">#    puts &#34;    -image:           Image to download. Format xxxbzz v711b23, v601b9, etc.&#34;</span>
    puts &#34;    -i386ImagePath    image path to i386 image. Format /tftp/bd10Ki386-11.0.0.16.xos&#34;
    puts &#34;    -marinerImagePath image path to mariner image. Format /tftp/bd10K-11.0.0.16.xos&#34;
    puts &#34;    -aspenImagePath image path to aspen image. Format /tftp/aspen-11.2.0.6.xos&#34;
    puts &#34;    -cougarImagePath image path to cougar image. Format /tftp/summitx450-11.2.0.6.xos&#34;
    puts &#34;    -x480ImagePath image path to x480 image. Format /tftp/summitX480-15.6.1.4.xos&#34;
    puts &#34;    -x870ImagePath image path to x870 image. Format /tftp/onie-22.2.0.23.xos&#34;
    puts &#34;    -NWIImagePath image path to NWI image. Format /tftp/NWI-15.6.1.4.xos&#34;
    puts &#34;    -viperImagePath image path to viper image. Format /tftp/summitlite-15.3.2.0.xos&#34;
    puts &#34;    -jaguarImagePath image path to jaguar image. Format /tftp/summitx450-11.2.0.6.xos&#34;
    puts &#34;    -olympicImagePath image path to olympic image. Format /tftp/olympic-11.2.0.6.xos&#34;
    puts &#34;    -voyagerImagePath image path to voyager image. Format /tftp/bd20K-12.2.0.0-pioneer-6.xos&#34;
    puts &#34;    -everestImagePath image path to everest image. Format /tftp/everest-11.2.0.6.xos&#34;
    puts &#34;    -cfg:           Config file to use in place of default runReg.cfg&#34;
    puts &#34;    -regpcs:        Regressions PC to run.  Predefined platforms in runReg.cfg&#34;
    puts &#34;                    i.e. $regpcList&#34;
    puts &#34;    -platform:      Specify a specific platform for a specific regpc.&#34;
    puts &#34;                    i.e. ALPINE,1 or BD1,2  Use -platform ? for valid entries&#34;
    puts &#34;    -exclude:       Modules to be excluded from testing.&#34;
    puts &#34;    -include:       Modules to be tested. The regression will only \
	                            run those modules you specified&#34;    
    puts &#34;    -forstats:      This is a valid run for collecting statistics.&#34;
    puts &#34;    -download       yes|no (yes)&#34;
    puts &#34;    -mailTo         Email address to send notification (sqaauto@extremenetworks.com)&#34;
    puts &#34;    -prep           yes|no (yes) Perform unconfig and def delete prior to running&#34;
    puts &#34;    -killxterm     yes|no (no). Kill xterm windows in all the regression PCs. If -regpcs are specified, only xterms running on that pc alone will be killed&#34;
    puts &#34;    -obuild:        Old build version REQUIRED for Upgrade/Downgrade runs (ie. 10.1.2.16)&#34;
    puts &#34;    -build_name      For now a name has to be given - e.g: 11.3.0.11&#34;
    puts &#34;    -subversion      Mainly used for private testing, to append additional name to build_name - eg 12.3.1.2-EFENCE&#34;
    puts &#34;    -pass_number     Give 2 if you would like to start from the second run - otherwise ignore&#34;
    puts &#34;    -heuristic       yes - if only failing modules from previous regressions are required&#34;
    puts &#34;    -efence          yes - if efence to be activated&#34;
    puts &#34;    -saveConfigPerTest   yes - if config per test to be enabled&#34;
    puts &#34;    -debugLevel      debug level 1|2|3. The level at which the debug information is dumped when script encounters an error&#34;
    puts &#34;    -lst            the lst to run in each feature: quick, pass or all; by default NULL.&#34;
    puts &#34;    -incrBuilds     A list of builds to take into account on incremental runs - requires useDbPhase '_' seperated&#34;
    puts &#34;    -rerun          reruns  failed testcases in pass and quick list&#34;
    puts &#34;    -baseLine       base line build with which the results have to be compared&#34;
    puts &#34;    -stopWithPhase   Stop regression with particular phase&#34;
    puts &#34;    -force           Kills the DUT sessions with terminal server \
          before staring the regression.&#34;
    puts &#34;    -help:           Prints this screen.&#34;
    puts &#34;\r&#34;
    puts &#34;NOTE: -regpcs and -platform are mutually exclusive as are -status and -cvsupdate&#34;

}


<strong><a name="::regPrintValidPlatforms_85">proc <a href="mysqlRunRegAll.tcl-annot.html#::regPrintValidPlatforms">::regPrintValidPlatforms</a></a></strong><a name="::regPrintValidPlatforms"></a> {} {
    
    global regplatform

    set pList [list]

    if [info exists regplatform] {
	set pList [array names regplatform]
    }
    puts &#34;              VALID PLATFORM ENTRIES:&#34;
    set pList [lsort -ascii $pList]

    set header [format &#34;%-15s {%s}&#34; {PLATFORM ENTRY}  \
	    {platform blade cfg regType regSubType}]

    set sep [format &#34;%-15s %s&#34; {==============}  \
	    {=======================================}]

    puts $header
    puts $sep
    foreach plat $pList {
	set entry [format &#34;%-15s {%s}&#34; $plat $regplatform($plat)]
	puts $entry
    }

}


<span class="comment-line"># Send a mail message to a user</span>
<strong><a name="::regSendMail_114">proc <a href="mysqlRunRegAll.tcl-annot.html#::regSendMail">::regSendMail</a></a></strong><a name="::regSendMail"></a> {user subject message } {

    set tempMsgFile   &#34;/tmp/runRegMsg.txt&#34;

    system &#34;echo $message &gt; $tempMsgFile&#34;
    system  &#34;mail -s \&#34;$subject\&#34; $user &lt; $tempMsgFile&#34;
    system &#34;rm -f $tempMsgFile&#34;
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># Get status of main.tcl and runall_monitor.tcl on a given machine.</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::regGetStatus_126">proc <a href="mysqlRunRegAll.tcl-annot.html#::regGetStatus">::regGetStatus</a></a></strong><a name="::regGetStatus"></a> {} {
    global regLogin
    
    set i 0
    <span class="comment-line"># List all processes</span>
    set cmd &#34;ps -auxww\r&#34;
    send $cmd
    
    <span class="comment-line"># Keep matching until we hit the prompt. Put results int lineArray()</span>
    while 1 {
        expect {	    
            -re &#34;\[^\r]*\r\n&#34; {
            set lineArray($i) $expect_out(0,string)
            incr i
        }
            -re &#34;$regLogin@&#34; break
            timeout break
        }
    }

    set i 0
    set taskKey &#34;runall_monitor&#34;
    <span class="comment-line"># Look for runall_monitor lines in linkArray()</span>
    while {$i &lt; [array size lineArray]}  {
        if [regexp &#34;(.*)($taskKey)(.*).tcl(.*)\r\n&#34;\
                $lineArray($i) ignore xtermCheck taskKeyMatch ignore param] {
            <span class="comment-line"># Don't display lines spawned by xterm</span>
            if { ! [regexp &#34;xterm&#34; $xtermCheck]} {
                puts &#34;$taskKeyMatch:  $param&#34;
            }
        }
        incr i 1
    }
    set i 0
    set taskKey &#34;main&#34;
    <span class="comment-line"># Look for main lines in linkArray</span>
    while {$i &lt; [array size lineArray]}  {
        if [regexp &#34;(.*)($taskKey)(.*).tcl(.*)\r\n&#34;\
            $lineArray($i) ignore ignore taskKeyMatch ignore param] {
            puts &#34;$taskKeyMatch: $param&#34;
        }
        incr i 1
    }
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line">#This is to kill the xterm windows</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::regKillXtermWindows_174">proc <a href="mysqlRunRegAll.tcl-annot.html#::regKillXtermWindows">::regKillXtermWindows</a></a></strong><a name="::regKillXtermWindows"></a> {} {

   global regLogin

   set i 0
   send &#34;ps -ef |grep xterm\r&#34;
   while 1 {
      expect {
         -re &#34;\[^\r]*\r\n&#34; {
            set lineArray($i) $expect_out(0,string)
            regexp {([0-9]+) *([0-9]+).*\-T.*} $lineArray($i) out out1 out2
            if { [info exists out2] } {
               puts &#34;killing xterm with pid $out2&#34;
               send &#34;kill -9 $out2\r&#34;
               unset out2
            }
            incr i
         }
         timeout break
      }
   }
   return 1
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::regCvsUpdateAutomationDir_201">proc <a href="mysqlRunRegAll.tcl-annot.html#::regCvsUpdateAutomationDir">::regCvsUpdateAutomationDir</a></a></strong><a name="::regCvsUpdateAutomationDir"></a> {} {
    
    global autoPath
    global regLogin

    send &#34;cd $autoPath\r&#34;
    expect &#34;$regLogin@&#34;
    
    ;<span class="comment-line"># NOTE: We update twice because CVS flakiness causes updates to sometimes fail.</span>
    ;<span class="comment-line">#       First update creates new directories and moves out locally modified files.</span>
    ;<span class="comment-line"># Create new dirs(d)/Remove empty dirs(P)/Overwrite locally modified(C)</span>
    send &#34;cvs update -dPC\r&#34;
    expect {
	-re &#34;authorization failed:.*$regLogin@&#34; {
	    return 0
	}
	-re &#34;Updating.*$regLogin@&#34; {
	    return 1
	}
    }
    ;<span class="comment-line"># Second update is a regular update.</span>
    send &#34;cvs update \r&#34;
    expect {
	-re &#34;authorization failed:.*$regLogin@&#34; {
	    return 0
	}
	-re &#34;Updating.*$regLogin@&#34; {
	    return 1
	}
    }
    return 1
}
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::regValidateReachable_236">proc <a href="mysqlRunRegAll.tcl-annot.html#::regValidateReachable">::regValidateReachable</a></a></strong><a name="::regValidateReachable"></a> { ipaddr } {

    <span class="comment-line"># Validate the machine is reachable</span>
    spawn ping -q -c 2 $ipaddr
    expect {
	-re &#34;0 packets received&#34; {
	    puts &#34;  !!! 0 packets received&#34;
	    return 0
	}
	timeout {
	    puts &#34;  !!! Ping timeout&#34;
	    return 0
	}
    }
    return -1
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::regTelnetLogin_256">proc <a href="mysqlRunRegAll.tcl-annot.html#::regTelnetLogin">::regTelnetLogin</a></a></strong><a name="::regTelnetLogin"></a> { ipaddr regLogin regPassword } {

    global spawn_id

    set timeout 60

    <span class="comment-line"># puts &#34;About to telnet to $ipaddr&#34;</span>
    <span class="comment-line"># Telnet into machine and start the specified script.</span>
    spawn telnet $ipaddr


    expect {
	-re &#34;\[L|l]ogin:&#34; {}
	timeout {	    
	    <a name="::result_error(1)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Timeout $timeout sec waiting for login prompt.&#34;
	    return 0
	}
    }
    sleep 1
    send   &#34;$regLogin\r&#34;

    expect {
	-re &#34;\[P|p]assword:&#34; {}
	timeout {	    
	    <a name="::result_error(2)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Timeout $timeout sec waiting for password prompt.&#34;
	    return 0
	}
    }
    sleep 1
    send   &#34;$regPassword\r&#34;
    expect {
	-re &#34;Login incorrect&#34; {
	    <a name="::result_error(3)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Login incorrect using $regLogin/$regPassword&#34;
	    return 0
	}
	-re &#34;$regLogin@&#34; {
	    <span class="comment-line"># Login successful...</span>
        <span class="comment-line"># puts &#34;Successful telnet into $ipaddr&#34;</span>
	}   
        -re &#34;\\$ $&#34; {
	    <span class="comment-line"># Login successful...</span>
        <span class="comment-line"># puts &#34;Successful telnet into $ipaddr&#34;</span>
	}   
    }
    
    return 1;
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># Validates the proper syntax for image name</span>
<span class="comment-line"># Namely xxxby  i.e. 710b34</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::regValidateImageName_308">proc <a href="mysqlRunRegAll.tcl-annot.html#::regValidateImageName">::regValidateImageName</a></a></strong><a name="::regValidateImageName"></a> {imageName} {
    <a name="::result_debug(1)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; imageName: $imageName &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#34;
    return [regexp {^bd10K[i386|]-[0-9]+.[0-9].[0-9].[0-9]+.xos$} $imageName]
}
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># This is to find the type of terminal server</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::getTermServerType_315">proc <a href="mysqlRunRegAll.tcl-annot.html#::getTermServerType">::getTermServerType</a></a></strong><a name="::getTermServerType"></a> { ip } {
   set termType &#34;&#34;
   set pid [spawn telnet &#34;$ip&#34;]   
   send &#34;\r&#34;
   expect {
           -re &#34;login:&#34; { set termType &#34;PC&#34;
                          send &#34;\035&#34; } 
           -re &#34;.*&gt;&#34;    { set termType &#34;Xyplex&#34;
                          send &#34;\035&#34;} 
     }
    exec kill -9 $pid
    return $termType
}
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># This procedure uses the console ips stored in the db to locate the</span>
<span class="comment-line">#    termserver and clear consoles</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<strong><a name="::clearDUTSessions_332">proc <a href="mysqlRunRegAll.tcl-annot.html#::clearDUTSessions">::clearDUTSessions</a></a></strong><a name="::clearDUTSessions"></a> { args } {
	<span class="comment-line"># ---------------------------------------------</span>
	<span class="comment-line"># Old proc used to use args ipaddress  portList</span>
	<span class="comment-line"># ---------------------------------------------</span>
	parse_args clearDUTSessions $argv {
		cfg &#34;&#34;
	}
    return &#34;Not in use yet&#34;

  set termSrvLogin &#34;autotest-sc&#34;
  set termSrvPasswd &#34;system&#34;
  set pcTermSrvLogin &#34;root&#34;
  set pcTermSrvPasswd &#34;extreme&#34;
  set pcTermSrvIp &#34;10.210.1.223&#34; 

  set termServerType [<a name="::getTermServerType(1)"><a href="./mysqlRunRegAll.tcl.html#::getTermServerType_315">::getTermServerType</a></a> $ipaddress]

  if { $termServerType != &#34;PC&#34; } {
        puts &#34;Telnet to terminal server : $ipaddress&#34;
        puts &#34;Port to be disconneted: $portList&#34;
        set pid [spawn telnet &#34;$ipaddress&#34;]
        send &#34;\r&#34;
        expect -re &#34;.*&gt;&#34; { send &#34;$termSrvLogin\r&#34; }
        expect -re &#34;.*&gt;&#34; { send &#34;set priv 1\r&#34; }
        expect -nocase &#34;Password&gt;&#34; { send &#34;$termSrvPasswd\r&#34; }
        foreach port $portList {
                puts &#34;disconnecting port# $port&#34;
                send &#34;kill $port se 1\r&#34;
                send &#34;\r&#34;
                expect -re &#34;.*&gt;&#34;
        }
        send &#34;logout\r&#34;
        exec kill $pid
   } else { 
        <span class="comment-line">#if it is PC terminal server; the session killing is a different process.</span>
        set timeout 5
        set pid [spawn telnet $pcTermSrvIp]
        expect -re &#34;.*login:&#34; { send &#34;$pcTermSrvLogin\r&#34;}
        expect -nocase &#34;password:&#34; { send &#34;$pcTermSrvPasswd\r&#34; }
	expect &#34;.*&#34;
        foreach port $portList {
        	send &#34;lsof | grep ttyS$port\r&#34;
                while { $expect_out(0,string) !=&#34;&#34; } {
               	    expect {
                        -re &#34;\[^\r]*\r\n&#34; {
                             set line  $expect_out(0,string)
                             set key  &#34;(termnetd) *(\[0-9\]+).*(ttyS$port)&#34;
                             set ret [regexp $key $line out out1 out2]
                             if { $ret == 1 &amp;&amp; [info exists out2] } {
                                puts &#34;killing ttyS$port with pid $out2&#34;
                                send &#34;kill -9 $out2\r&#34;
                                unset out2
                             }
                        }
                        timeout break
                     }
                }
        }
        send &#34;\r&#34;
        send &#34;logout\r&#34;
        exec kill $pid
   }
}
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#                  ##### MAIN SCRIPT ########</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>

<span class="comment-line"># Add a development in order to verify new development</span>
set DEVDEBUG 0
<span class="comment-line"># Turn off user process display to avoid clutter</span>
log_user 1
source ./../Lib/mainLib.tcl
package require Tclx
gen_index &#34;./../Lib&#34;
puts &#34; === MYSQLRUNREGALL   MAIN SECTION =====&#34;
source ../Lib/parse_args.tcl
set LIB_PATH ../Lib 
lappend auto_path $LIB_PATH
set harness &#34;tcl&#34;

<span class="comment-line"># Store the execution command in the database</span>
catch {source ./runReg.cfg} reason
InsertCommandLineCalls -script &#34;[info script]&#34; -aVal &#34;$argv&#34;

<span class="comment-line"># ------------------------------------------------------------------------------</span>
<span class="comment-line"># These 4 calls are REQUIRED for all sublevel libraries that use </span>
<span class="comment-line"># result_xxxx functions to work.</span>
<span class="comment-line"># TODO: Put all this in an resultLogInit{} routine!</span>
<span class="comment-line"># set resultDir &#34;RunRegAll_logs&#34;</span>
<span class="comment-line"># ------------------------------------------------------------------------------</span>

set resultDir &#34;Log&#34;
if { ! [file isdirectory $resultDir] } {
    ;<span class="comment-line"># Create it!</span>
    file mkdir $resultDir
}
set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set fd_res [open_result_file &#34;runRegAll-[clock format [clock seconds] -format &#34;%I.%M%p&#34;]-[pid]&#34;]
<span class="comment-line"># ------------------------------------------------------------------------------</span>
global staggerDelay

set cvsupdateFlag 0
set statusFlag    0
set staggerDelay  5

set fullRegStart 1
set regpcRegStart 0
set platformRegStart 0
set shastaBuild 0
set forceFlag 0

parse_args mysqlRunRegAll.tcl $argv {
    help &#34;&#34;
    force &#34;&#34;
    cvsupdate &#34;&#34;
    status &#34;&#34;
    i386ImagePath &#34;&#34;
    marinerImagePath &#34;&#34;
    aspenImagePath &#34;&#34;
    cougarImagePath &#34;&#34;
    x480ImagePath &#34;&#34;
    x870ImagePath &#34;&#34;
    NWIImagePath &#34;&#34;
    viperImagePath &#34;&#34;
    jaguarImagePath &#34;&#34;
    olympicImagePath &#34;&#34;
    voyagerImagePath &#34;&#34;
    everestImagePath &#34;&#34;
    cfg &#34;&#34;
    regpcs &#34;&#34;
    platform &#34;&#34;
    include &#34;&#34;
    exclude &#34;&#34;
    forstats &#34;no&#34;
    download &#34;yes&#34;
    prep &#34;no&#34;
    killxterm &#34;no&#34;
    mailTo &#34;sqaauto@extremenetworks.com&#34;
    obuild &#34;&#34;
    build_name &#34;&#34;
    subversion &#34;NULL&#34;
    pass_number &#34;1&#34;
    heuristic &#34;no&#34;
    efence &#34;no&#34;
    saveConfigPerTest &#34;no&#34;
    debugLevel &#34;0&#34;
    lst &#34;NULL&#34;
    incrBuilds &#34;NULL&#34;
    rerun &#34;no&#34;
    baseLine &#34;NULL&#34;
    stopWithPhase &#34;NULL&#34;
}
<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line">#    u is added as a short alias for useDbPhase let</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
set useDbPhase 0
if {$stopWithPhase != &#34;NULL&#34;} {
            set useDbPhase 1
    
}
if {$incrBuilds != &#34;NULL&#34; &amp;&amp; $useDbPhase == &#34;0&#34;} {
    <a name="::result_error(4)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;incrBuilds can only be used in a phased regression run&#34;
    exit;
}

<span class="comment-line"># Check for MINIMUM REQUIRED PARAMETER image name</span>
if { $i386ImagePath == &#34;&#34; &amp;&amp; $marinerImagePath == &#34;&#34; &amp;&amp; \
     $aspenImagePath == &#34;&#34; &amp;&amp; $cougarImagePath == &#34;&#34; &amp;&amp; $x480ImagePath == &#34;&#34; &amp;&amp; $x870ImagePath == &#34;&#34; &amp;&amp; $NWIImagePath == &#34;&#34; \
     &amp;&amp; $viperImagePath == &#34;&#34; &amp;&amp; $jaguarImagePath == &#34;&#34; &amp;&amp; $olympicImagePath == &#34;&#34; &amp;&amp; $voyagerImagePath == &#34;&#34; \
     &amp;&amp; $everestImagePath == &#34;&#34; &amp;&amp; $download != &#34;no&#34; } {

    <a name="::result_error(5)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! At least one image name should be provided !!!&#34;
    <a name="::regPrintUsage(1)"><a href="./mysqlRunRegAll.tcl.html#::regPrintUsage_12">::regPrintUsage</a></a> [array names regpc]
    exit
    
}

if {($subversion != &#34;&#34;) &amp;&amp; ($subversion != &#34;NULL&#34;) } {
   set build_name $build_name-$subversion
}


<span class="comment-line"># Check for MINIMUM REQUIRED PARAMETER build name</span>
if {$build_name == &#34;&#34;} {
    <a name="::result_error(6)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! build_name parameter not supplied !!!&#34;
    <a name="::regPrintUsage(2)"><a href="./mysqlRunRegAll.tcl.html#::regPrintUsage_12">::regPrintUsage</a></a> [array names regpc]
    exit
}
<span class="comment-line"># Check for MINIMUM REQUIRED PARAMETER platform</span>
if {$platform == &#34;&#34;} {
    <a name="::result_error(7)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! platform parameter not supplied !!!&#34;
    <a name="::regPrintUsage(3)"><a href="./mysqlRunRegAll.tcl.html#::regPrintUsage_12">::regPrintUsage</a></a> [array names regpc]
    exit
}

<span class="comment-line">###############Validate stopWithPhase input###########################</span>
if {($stopWithPhase &lt; 1 || $stopWithPhase &gt; 4) &amp;&amp; ($stopWithPhase != &#34;NULL&#34;) } {
       <a name="::result_error(8)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Please  enter a valid input !!!&#34;
       <a name="::result_error(9)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! There  are only four phases 1 to 4 !!!&#34;
       exit
}


<span class="comment-line"># If any of the following is specified, then it is assumed that it's not </span>
<span class="comment-line"># initial regression start. The DUT session cleanup should be initiated </span>
<span class="comment-line"># only for the initail full regression start.</span>

if { $cfg != &#34;&#34; || $regpcs != &#34;&#34; || $platform != &#34;&#34; || $include != &#34;&#34; \
   || $exclude != &#34;&#34; || $download != &#34;yes&#34; || $status !=&#34;&#34; || $cvsupdate !=&#34;&#34; \
   || $killxterm != &#34;no&#34; || [lsearch $argv &#34;-help&#34;] &gt; -1 } {
   
    set fullRegStart 0
}

if { $platform != &#34;&#34; } {
   set platformRegStart 1
}

if { $regpcs != &#34;&#34; } {
   set regpcRegStart 1
}

if { [lsearch $argv &#34;-force&#34;]  &gt; -1} {
        set forceFlag 1
} else {
        set forceFlag 0
}

<span class="comment-line"># Default config file</span>
set cfgFile ./runReg.cfg

if {$cfg != &#34;&#34;} {
    <span class="comment-line"># User defined cfg file passed from command line.</span>
    set cfgFile $cfg
}

<span class="comment-line"># Check REQUIRED PARAMETER VALUE lst = quick|pass|all</span>
if { ($lst != &#34;quick&#34;) &amp;&amp; ($lst != &#34;pass&#34;) &amp;&amp; ($lst != &#34;all&#34;) &amp;&amp; ($lst != &#34;passlist&#34;) &amp;&amp; ($lst != &#34;alllist&#34;) &amp;&amp; ($lst != &#34;dev&#34;) &amp;&amp; ($lst != &#34;devonly&#34;) &amp;&amp; ($lst != &#34;devlist&#34;) &amp;&amp; ($lst!= &#34;debugonly&#34;) &amp;&amp; ($lst != &#34;NULL&#34;) } {
    <a name="::result_error(10)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! -lst must contain either quick, pass,dev,debug or all !!!&#34;
    exit
}

<span class="comment-line"># Source config file that has Regression PC information</span>
if [file exists $cfgFile] {
    <a name="::result_debug(2)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sourcing $cfgFile now&#34;
    catch {source $cfgFile} reason
} else {
    <a name="::result_error(11)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Configuration file $cfgFile not found !!!&#34;
    exit
}


<span class="comment-line">###Check whether  the base line build passed is valid #########################</span>
if {$baseLine != &#34;NULL&#34;} {
    set retval [validateBaseLine $baseLine]
    if {$retval != 1} {
         <a name="::result_error(12)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Please Enter a valid  base line build !!!&#34;
         exit
    }
}

<span class="comment-line"># Display usage if -help is passed</span>
if {[lsearch $argv &#34;-help&#34;]  &gt; -1} {
    <a name="::regPrintUsage(4)"><a href="./mysqlRunRegAll.tcl.html#::regPrintUsage_12">::regPrintUsage</a></a> [array names regpc]
    exit
}

if {$platform == &#34;?&#34;} {
    <a name="::regPrintValidPlatforms(1)"><a href="./mysqlRunRegAll.tcl.html#::regPrintValidPlatforms_85">::regPrintValidPlatforms</a></a>  ;<span class="comment-line"># Requires cfgFile be sourced before calling</span>
    exit
}

if {[lsearch $argv &#34;-status&#34;] &gt; -1} {
    set statusFlag 1
    log_user 0
}

if {[lsearch $argv &#34;-cvsupdate&#34;]  &gt; -1} {

    <a name="::result_debug(3)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;*******  EXECUTING CVS UPDATE ONLY  *******&#34;
    <a name="::result_debug(4)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;CVS Update Target Dir: $autoPath&#34;
    set cvsupdateFlag 1
    log_user 1
}

if {!$cvsupdateFlag &amp;&amp; !$statusFlag} {

    if {$i386ImagePath != &#34;&#34;} {
        if {![file exists $i386ImagePath]} {
            puts &#34;ERROR: i386ImagePath: $i386ImagePath, doesn't exist&#34;
            exit
        }
    }

    if {$marinerImagePath != &#34;&#34;} {
        if {![file exists $marinerImagePath]} {
            puts &#34;ERROR: marinerImagePath: $marinerImagePath, doesn't exist&#34;
            exit
        }
    }

    if { $aspenImagePath != &#34;&#34; } {
        if {![file exists $aspenImagePath]} {
            puts &#34;ERROR: aspenImagePath: $aspenImagePath, doesn't exist&#34;
            exit
        }
    }

    if { $olympicImagePath != &#34;&#34; } {
        if {![file exists $olympicImagePath]} {
            puts &#34;ERROR: olympicImagePath: $olympicImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $voyagerImagePath != &#34;&#34; } {
        if {![file exists $voyagerImagePath]} {
            puts &#34;ERROR: voyagerImagePath: $voyagerImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $everestImagePath != &#34;&#34; } {
        if {![file exists $everestImagePath]} {
            puts &#34;ERROR: everestImagePath: $everestImagePath, doesn't exist&#34;
            exit
        }
    }
    
    if { $cougarImagePath != &#34;&#34; } {
        if {![file exists $cougarImagePath]} {
            puts &#34;ERROR: cougarImagePath: $cougarImagePath, doesn't exist&#34;
            exit
        }
       set shastaBuild 1 
    }
    if { $x480ImagePath != &#34;&#34; } {
        if {![file exists $x480ImagePath]} {
            puts &#34;ERROR: x480ImagePath: $x480ImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $x870ImagePath != &#34;&#34; } {
        if {![file exists $x870ImagePath]} {
            puts &#34;ERROR: x870ImagePath: $x870ImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $NWIImagePath != &#34;&#34; } {
        if {![file exists $NWIImagePath]} {
            puts &#34;ERROR: NWIImagePath: $NWIImagePath, doesn't exist&#34;
            exit
        }
    }
    if { $viperImagePath != &#34;&#34; } {
        if {![file exists $viperImagePath]} {
            puts &#34;ERROR: viperImagePath: $viperImagePath, doesn't exist&#34;
            exit
        }
    }

    if { $jaguarImagePath != &#34;&#34; } {
        if {![file exists $jaguarImagePath]} {
            puts &#34;ERROR: jaguarImagePath: $jaguarImagePath, doesn't exist&#34;
            exit
        }
    }

}

<span class="comment-line"># --------------------------------------------------</span>
<span class="comment-line"># REG-PCs passed in so main/runReg.cfg is not used</span>
<span class="comment-line">#   to get the regPC, type, subtype etc.</span>
<span class="comment-line"># --------------------------------------------------</span>
if {($platform == &#34;&#34;) &amp;&amp; ($regpcs != &#34;&#34;)} {
    set regpc_list [list]
    set validRegPcs [array names regpc]
    
    ;<span class="comment-line"># Make sure all entries are valid</span>
    foreach pc $regpcs {
        set pc [string toupper $pc]
        if {[lsearch -exact  $validRegPcs $pc] == -1} {
            <a name="::result_error(13)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;regpc: $pc not found.  Valid values are $validRegPcs&#34;
            exit
        }
        lappend regpc_list regpc($pc)
    }
    ;<span class="comment-line"># All entries are valid. Build regpc_list</span>
    <a name="::result_debug(5)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NEW list: $regpc_list&#34;
}

<span class="comment-line"># --------------------------------------------------</span>
<span class="comment-line">#    TYPICAL USAGE</span>
<span class="comment-line">#</span>
<span class="comment-line">#    User specified platform</span>
<span class="comment-line"># --------------------------------------------------</span>
if {$platform != &#34;&#34; } {

    if { $regpcs != &#34;&#34;} {
        <a name="::result_debug(6)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;WARNING: Platform $platform specified.  Ignoring -regpc $regpcs parameter.&#34;
    }

    <span class="comment-line"># Make sure that the plaform passed in is in the runReg.cfg</span>
    if { ![info exists regplatform($platform)]} {
        <a name="::result_error(14)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;ERROR: Invalid platform specified: $platform&#34;
        <a name="::regPrintValidPlatforms(2)"><a href="./mysqlRunRegAll.tcl.html#::regPrintValidPlatforms_85">::regPrintValidPlatforms</a></a>
        exit
    }
    ;<span class="comment-line"># Save the specific platform we need</span>
    set regplatformTemp $regplatform($platform)
    
    ;<span class="comment-line"># Unset all the platforms</span>
    unset regplatform
    
    ;<span class="comment-line"># Create a single entry for the array</span>
    set regplatform($platform) $regplatformTemp
    
    <a name="::result_debug(7)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Active Platform: $regplatform($platform)&#34;
    
    ;<span class="comment-line"># Create a single entry in regpc_list for this platform</span>
    set regplatformIndex [array names regplatform]
    
    regexp (.*),(.*) $regplatformIndex  ignore regpcName ignore
    <a name="::result_debug(8)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Active regpcName: $regpcName&#34;    
    
    ;<span class="comment-line"># reset list</span>
    set regpc_list [list]
    lappend regpc_list regpc($regpcName)
    lappend regpc_list  $regplatformTemp
    
    set staggerDelay 0
}

<span class="comment-line"># -------------------------------------------------------------</span>
<span class="comment-line"># Kill existing XTERM windows.</span>
<span class="comment-line"># -------------------------------------------------------------</span>
set tempList &#34;&#34;
if { [string tolower $killxterm] == &#34;yes&#34;} {
   foreach pc $regpc_list {
       regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
       if { ! [info exists platformPC] } {
          <a name="::result_error(15)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
          continue
       }
       set name      [lindex [set $pc] 0]
       set ipaddr    [lindex [set $pc] 1]
       set display   [lindex [set $pc] 2]


       if { ! [<a name="::regValidateReachable(1)"><a href="./mysqlRunRegAll.tcl.html#::regValidateReachable_236">::regValidateReachable</a></a> $ipaddr] } {
          <a name="::result_error(16)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;  !!! $name at $ipaddr is unreachable.&#34;
          continue;
       }

       if { ! [<a name="::regTelnetLogin(1)"><a href="./mysqlRunRegAll.tcl.html#::regTelnetLogin_256">::regTelnetLogin</a></a> $ipaddr $regLogin $regPassword ] } {
          <a name="::result_error(17)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Failed to login to $name at $ipaddr&#34;
          continue
       }
       if { [lsearch $tempList $ipaddr] != -1 } {
           puts &#34;xterm windows already killed&#34;
           continue
       }
       <span class="comment-line"># Get the PID of the xterm windows and send SIGKILL signal</span>
       <a name="::regKillXtermWindows(1)"><a href="./mysqlRunRegAll.tcl.html#::regKillXtermWindows_174">::regKillXtermWindows</a></a>
    }
    lappend tempList $ipaddr    
    puts  &#34;Xterm windows are removed&#34;
    exit
}
unset tempList

<span class="comment-line">#Clean up the DUT sessions.</span>

<span class="comment-line">#Check if this is shasta build or greater to start cougar reg.</span>
<span class="comment-line">#Take out the entry for cougar if not shahsta build.</span>
<span class="comment-line">#This will prevent starting cougar reg if the build &lt;shasta build</span>

if { $fullRegStart &amp;&amp; !$shastaBuild } {
    set tempList [list]
    foreach pc $regpc_list {
        if { [regexp -nocase &#34;cougar&#34; $pc] } {
            continue
        }
            lappend tempList $pc
    }
    set regpc_list [list]
    foreach pc $tempList {
        lappend regpc_list $pc
    } 
}

if { $fullRegStart } {
    foreach pc $term_regpc_list {
        if { !$shastaBuild  &amp;&amp; [regexp -nocase &#34;.*cougar.*&#34; $pc] ==1} {
             continue
        }
        set  termInfoList [set $pc]
        set len [llength $termInfoList]
        for {set tIndex 0; set pIndex 1 } { $tIndex &lt; $len &amp;&amp; $pIndex &lt; $len } \
            {incr tIndex 2; incr pIndex 2} {
             set termIp [lindex $termInfoList $tIndex]
             set pList  [lindex $termInfoList $pIndex] 
             <a name="::clearDUTSessions(1)"><a href="./mysqlRunRegAll.tcl.html#::clearDUTSessions_332">::clearDUTSessions</a></a> $termIp $pList
        }
    }
} elseif { $regpcRegStart &amp;&amp; $forceFlag  } {
   set termInfoList $regpcTermServer($regpcs)
   set len [llength $termInfoList]
   for {set tIndex 0; set pIndex 1 } { $tIndex &lt; $len &amp;&amp; $pIndex &lt; $len } \
       {incr tIndex 2; incr pIndex 2} {
        set termIp [lindex $termInfoList $tIndex]
        set pList  [lindex $termInfoList $pIndex] 
        <a name="::clearDUTSessions(2)"><a href="./mysqlRunRegAll.tcl.html#::clearDUTSessions_332">::clearDUTSessions</a></a> $termIp $pList
   }
} elseif { $platformRegStart &amp;&amp; $forceFlag } {
   set termInfoList $platformTermServer($platform)
   set len [llength $termInfoList]
   for {set tIndex 0; set pIndex 1 } { $tIndex &lt; $len &amp;&amp; $pIndex &lt; $len } \
       {incr tIndex 2; incr pIndex 2} {
        set termIp [lindex $termInfoList $tIndex]
        set pList  [lindex $termInfoList $pIndex] 
        <a name="::clearDUTSessions(3)"><a href="./mysqlRunRegAll.tcl.html#::clearDUTSessions_332">::clearDUTSessions</a></a> $termIp $pList
   }
}  

<span class="comment-line"># -------------------------------------------------------------</span>
<span class="comment-line"># Prep for download of images</span>
<span class="comment-line"># -------------------------------------------------------------</span>
if {!$cvsupdateFlag &amp;&amp; !$statusFlag } {
    if {($download == &#34;yes&#34;) &amp;&amp; ($prep == &#34;yes&#34;)} {
        <span class="comment-line"># This is done in 2 loops so we don't have to wait for the reboot from unconfig</span>
        <span class="comment-line"># before going to next platform</span>
        <a name="::result_debug(9)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;START UNCONFIG: [exec date]&#34;
        <span class="comment-line"># Go through and unconfig each platform</span>
        foreach pc $regpc_list {
            regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
            if { ! [info exists platformPC] } {
                <a name="::result_error(18)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
                continue
            }
            <a name="::runRegAllLocalDoCommand(1)"><a href="./mysqlRunRegAllLocal.tcl.html#::runRegAllLocalDoCommand_333">::runRegAllLocalDoCommand</a></a> $platformPC &#34;unconfig&#34;
        }
        <a name="::result_debug(10)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;END UNCONFIG DELETE: [exec date]&#34;
        
        <span class="comment-line"># Wait 60 seconds for unconfig to complete</span>
        exSleep 60
        
        <a name="::result_debug(11)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;START DEF DELETE: [exec date]&#34;
        <span class="comment-line"># Go through and def delete port all each platform</span>
        foreach pc $regpc_list {
            regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
            if { ! [info exists platformPC] } {
                <a name="::result_error(19)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
                continue
            }
            <a name="::runRegAllLocalDoCommand(2)"><a href="./mysqlRunRegAllLocal.tcl.html#::runRegAllLocalDoCommand_333">::runRegAllLocalDoCommand</a></a> $platformPC &#34;defDelete&#34;
        }
        <a name="::result_debug(12)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;END DEF DELETE: [exec date]&#34;
    }
}

<span class="comment-line"># -------------------------------------------------------------</span>
<span class="comment-line"># Walk through array and display data</span>
<span class="comment-line"># -------------------------------------------------------------</span>
foreach {pc pc2} $regpc_list {

    global autoPath
    global autoScriptPath

    regexp (.*)\\\((.*)\\\) $pc  ignore ignore platformPC
    if { ! [info exists platformPC] } {
	<a name="::result_error(20)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Error could not extract platform PC from $pc....&#34;
	continue
    }

    <span class="comment-line">#set name      [lindex [set $pc] 0]</span>
    <span class="comment-line">#set ipaddr    [lindex [set $pc] 1]</span>
    <span class="comment-line">#set display   [lindex [set $pc] 2]</span>

    set name      [lindex [set $pc] 0]
    set ipaddr    [lindex $pc2 5]
    set display   [lindex $pc2 6]


    <span class="comment-line"># ----------------------------------------</span>
    <span class="comment-line">#  Verify PC is reachable</span>
    <span class="comment-line"># ----------------------------------------</span>
    if { ! [<a name="::regValidateReachable(2)"><a href="./mysqlRunRegAll.tcl.html#::regValidateReachable_236">::regValidateReachable</a></a> $ipaddr] } {
    	<a name="::result_error(21)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;  !!! $name at $ipaddr is unreachable.&#34;
    	continue;
    }

    if { ! [<a name="::regTelnetLogin(2)"><a href="./mysqlRunRegAll.tcl.html#::regTelnetLogin_256">::regTelnetLogin</a></a> $ipaddr $regLogin $regPassword ] } {
    	<a name="::result_error(22)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! Failed to login to $name at $ipaddr&#34;
    	continue
    }
    <span class="comment-line"># ----------------------------------------</span>
    <span class="comment-line"># *Just* get the status on each reg machine.</span>
    <span class="comment-line"># ----------------------------------------</span>
    if {$statusFlag} {
    	puts &#34;\n**** Retrieving STATUS on $name at $ipaddr ****&#34;
    	<a name="::regGetStatus(1)"><a href="./mysqlRunRegAll.tcl.html#::regGetStatus_126">::regGetStatus</a></a>
    	continue;
    }
    <span class="comment-line"># ----------------------------------------</span>
    <span class="comment-line"># *Just* do a CVS Update</span>
    <span class="comment-line"># ----------------------------------------</span>
    if {$cvsupdateFlag == 1} {
    	<a name="::result_debug(13)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;**** CVS Update on $name at $ipaddr targetdir: $autoPath ****&#34;
    	if {! [<a name="::regCvsUpdateAutomationDir(1)"><a href="./mysqlRunRegAll.tcl.html#::regCvsUpdateAutomationDir_201">::regCvsUpdateAutomationDir</a></a>]} {
    	    <a name="::result_error(23)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;!!! FAILED TO UPDATE !!!&#34;
    	}
    	continue
    }
    <span class="comment-line"># ----------------------------------------</span>
    <span class="comment-line"># At this point all commands are directed to telnet window on remote REG PC.</span>
    <span class="comment-line"># Go to directory where local script lives</span>
    <span class="comment-line"># ----------------------------------------</span>
    send &#34;cd $autoScriptPath\r&#34;
    expect &#34;$regLogin@&#34;

    <a name="::result_debug(14)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Starting regressions on $name at IP: $ipaddr DISPLAY:$display on [exec date]...&#34;

    if {[catch {flush $fd_res} reason]} {
	<a name="::result_debug(15)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR: flush $reason&#34;
    }

    <span class="comment-line"># if we run directly second or greater pass and debugLevel is not set</span>
    <span class="comment-line"># then we set debug level to 1</span>
    if {($debugLevel == &#34;0&#34;) &amp;&amp; ($pass_number &gt; 1)} {
      set debugLevel &#34;1&#34;	
    }

    <span class="comment-line"># ------------------------------------------------------------------------</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># This is the procedure that connects to the regression PCs and launches</span>
    <span class="comment-line">#    the xterms</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># ------------------------------------------------------------------------</span>
    <a name="::mysqlRunRegAllLocal(1)"><a href="./mysqlRunRegAllLocal.tcl.html#::mysqlRunRegAllLocal_4">::mysqlRunRegAllLocal</a></a> -platform [string trim $platform] \
        -targetpc [string trim $platformPC] \
        -display [string trim $display]  \
        -i386ImagePath [string trim $i386ImagePath] \
        -marinerImagePath [string trim $marinerImagePath] \
        -aspenImagePath [string trim $aspenImagePath] \
        -cougarImagePath [string trim $cougarImagePath] \
        -x480ImagePath [string trim $x480ImagePath] \
        -x870ImagePath [string trim $x870ImagePath] \
        -NWIImagePath [string trim $NWIImagePath] \
        -viperImagePath [string trim $viperImagePath] \
        -jaguarImagePath [string trim $jaguarImagePath] \
        -olympicImagePath [string trim $olympicImagePath] \
        -download [string trim $download] \
        -voyagerImagePath [string trim $voyagerImagePath] \
        -everestImagePath [string trim $everestImagePath] \
        -forstats [string trim $forstats] \
        -mailTo [string trim $mailTo] \
        -obuild [string trim $obuild] \
        -build_name [string trim $build_name] \
        -subversion [string trim $subversion] \
        -pass_number [string trim $pass_number] \
        -heuristic [string trim $heuristic] \
        -efence [string trim $efence] \
        -saveConfigPerTest [string trim $saveConfigPerTest] \
        -debugLevel [string trim $debugLevel] \
        -lst [string trim $lst] \
        -include [string trim $include] \
        -exclude [string trim $exclude] \
        -incrBuilds [string trim $incrBuilds] \
        -rerun [string trim $rerun] \
        -baseLine [string trim $baseLine]\
        -stopWithPhase [string trim $stopWithPhase] 

    sleep 2
    send &#34;logout\r&#34;
}

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
