<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>mysqlAutomate.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#mysqlAutomate.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>mysqlAutomate.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="mysqlAutomate.tcl-annot.html">annotations</a> | <a href="mysqlAutomate.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

package require http 1.0;
package require Tclx
set startTime [exec date]
set manualRun 0
<span class="comment-line"># Default config file</span>
set cfgFile ../main/runReg.cfg

<span class="comment-line"># Source config file that has Regression PC information</span>
if [file exists $cfgFile] {
    puts &#34;Sourcing $cfgFile now&#34;
    catch {source $cfgFile} reason
} else {
    puts &#34;!!! Configuration file $cfgFile not found !!!&#34;
    return 0
}

set common &#34;../main/cfg/common.cfg&#34;
if [file exists $common] {
    puts &#34;Sourcing $common now&#34;
    catch {source $common} reason
} else {
    puts &#34;!!! common.cfg file $common not found !!!&#34;
    return 0
}

global mysqlIP my_db MAIN DEVREG
set host $mysqlIP
set db $my_db

<span class="comment-line"># --- Sourcing Util/runReg.cfg would cause too many headaches ---</span>
<span class="comment-line">#       Just redo the db variables here</span>
set DEVREG(mysql,localbackup)    &#34;biltmore&#34;
set DEVREG(mysql,localdb)        &#34;builddb&#34;
set DEVREG(mysql,localstatus)    &#34;&#34;
set DEVREG(mysql,localhandler)   &#34;&#34;
set DEVREG(mysql,centralserver)  &#34;biltmore&#34;
set DEVREG(mysql,centraldb)      &#34;builddb&#34;
set DEVREG(mysql,centralstatus)  &#34;&#34;
set DEVREG(mysql,centralhandler) &#34;&#34;
set DEVREG(mysql,UseDb)           1
set DEVREG(mysql,testserver)     &#34;biltmore&#34;
set DEVREG(mysql,testdb)         &#34;testdb&#34;
set DEVREG(mysql,teststatus)     &#34;&#34;
set DEVREG(mysql,testhandler)    &#34;&#34;
set DEVREG(mysql,UseTestDb)      0

<span class="comment-line">#############################################################################################################</span>
<span class="comment-line">#  [print_usage]</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Prints the usage of utility in case any of the args are incorrect or insufficient</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - none</span>
<span class="comment-line">#</span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#     print_usage</span>
<span class="comment-line">#</span>
<span class="comment-line">#############################################################################################################</span>
<strong><a name="::print_usage_66">proc <a href="mysqlAutomate.tcl-annot.html#::print_usage">::print_usage</a></a></strong><a name="::print_usage"></a> {} {
    puts &#34;\r&#34;
    puts {USAGE OLD REGRESSION: }
    puts {mysqlAutomate.tcl -regId &lt;regression id&gt; -module &lt;module name&gt; [-cliFlag &lt;cliFlag&gt;] [-help] [-obuild &lt;build&gt;] }

    puts {USAGE NEW REGRESSION: }
    puts {mysqlAutomate.tcl -platform &lt;platform_name&gt; -module &lt;module name&gt; [-cliFlag &lt;cliFlag&gt;]  \
          -build &lt;build_num&gt; [-qId &lt;regression queue id&gt;] [-help] }

    puts {   -regId:      Regression ID, i.e. 385}
    puts {   -module :    e.g. BGP_RtRedistrib}
    puts {   -cliFlag:    Optional only for &#34;cli&#34; regression (NO_REBOOT|NO_REBOOT_NO_DOWNLOAD) }
    puts {   -platform:   Platform name to upload on \(from runReg.cfg\) - e.g: JAG_FUNC_IPR,1}
    puts {   -build:      Build number to use when uploading - e.g: 11.5.0.13}
    puts {   -obuild:     Only if CLI/UpgradeDowngrade regression. Give format as e.g 11.5.0.3}
    puts {   -forstats:    if this is a valid regression result, if not run 1}
    puts {   -callLocation: Text Desc of where it is called from since is is used all over}
    puts {   -manual:     reimport using mysqlAutomateAll with manual = qId SC_######_###### or RTP_######_######}
    puts {   -qId:        Regression system queue ID SC_######_###### or RTP_######_######}
    puts {   -help:       Prints usage}
    puts &#34;\r&#34;
}

<span class="comment-line">#############################################################################################################</span>
<span class="comment-line">#  [validateArgs]</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Validates the arguments passed to the script</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Input Variables:</span>
<span class="comment-line">#                   argv p_regId p_module p_cliFlag p_runNumber regType</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#  Output Variables:</span>
<span class="comment-line">#                none</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Return Value:</span>
<span class="comment-line">#      - none</span>
<span class="comment-line">#</span>
<span class="comment-line">#Usage:</span>
<span class="comment-line">#     validateArgs</span>
<span class="comment-line">#</span>
<span class="comment-line">#############################################################################################################</span>
<strong><a name="::validatemysqlAutomateArgs_107">proc <a href="mysqlAutomate.tcl-annot.html#::validatemysqlAutomateArgs">::validatemysqlAutomateArgs</a></a></strong><a name="::validatemysqlAutomateArgs"></a> {argv p_regId p_module p_cliFlag p_runNumber p_platform p_build p_forstats} {

    upvar $p_regId                   regId
    upvar $p_module       	     module
    upvar $p_cliFlag                 cliFlag
    upvar $p_runNumber               runNumber
    upvar $p_platform                platform
    upvar $p_build                   build
    upvar $p_forstats                forstats
    
    <span class="comment-line">#puts &#34; module $module&#34;</span>
    <span class="comment-line">#puts &#34; regId $regId&#34;</span>
    <span class="comment-line">#puts &#34; cliFlag $cliFlag&#34;</span>
    <span class="comment-line">#puts &#34; runNumber $runNumber&#34;</span>

    global runflag
    global mysql_handler
    global queueId
    global logFileId
    global defaultCfgShort

    if { ([llength $argv]  == 0)  } {
         puts $logFileId &#34;Error: Some or All arguments not provided &#34;
         return 0
    }
    if {[lsearch $argv &#34;-help&#34;]  &gt; -1} {
        return 0
    }

    <span class="comment-line"># this setting of build is for the qeueing syste</span>
    if { $build == &#34;null&#34; } {
      set build &#34;0.0.0.0&#34;
    }

    <span class="comment-line"># Module name must be supplied</span>
    if { $module == &#34;null&#34; } {
        puts $logFileId &#34;Error: Module name must be specified.&#34;
        <a name="::print_usage(1)"><a href="./mysqlAutomate.tcl.html#::print_usage_66">::print_usage</a></a>
        exit
    }

    if { $regId != &#34;null&#34; } {
        <span class="comment-line"># is that regId actually a queueId ? - ex: SC_060614_124245</span>
        if [regexp -nocase {[a-z]} $regId] {
          puts $logFileId &#34;regId was queueId $regId&#34;
          set queueId $regId
          <span class="comment-line"># do we have platform?</span>
          if {$platform != &#34;null&#34;} {
            set platformInfoList [DetermineCfgRegTypeSubTypeFromPlatform $platform]
         
            set defaultCfg [lindex $platformInfoList 0]
            set regType    [lindex $platformInfoList 1]
            puts &#34;regType : $regType&#34;

            set regSubType [lindex $platformInfoList 2]
            puts &#34;regSubType : $regSubType&#34;
            set regPath    &#34;[GetRegPath $regType $regSubType]&#34;
            puts &#34;regPath : $regPath&#34;
          
            
            puts $logFileId &#34;======= mysqlAutomate regId is not null ======\n\
	                     defaultCfg: $defaultCfg regType: $regType  regSubType: $regSubType\n\
			     regPath: $regPath&#34; 
            set platform_id [mysqlsel $mysql_handler \
                            &#34;SELECT platform_id FROM platform_table \
                             WHERE platform_cfg_file_name='$defaultCfg'&#34; -flatlist]
            <span class="comment-line">#result_debug &#34;platform_id = $platform_id&#34;</span>
            puts $logFileId &#34; validateArgs platform_id = $platform_id&#34;

            set defaultCfgShortList [split $defaultCfg .]
            set defaultCfgShort [lindex $defaultCfgShortList 0]
            puts $logFileId &#34; validateArgs defaultCfgShort = $defaultCfgShort&#34;
          } else {
            set platform_id &#34;null&#34;
          }

          <span class="comment-line"># do we have existing regId queueId build?</span>
          puts $logFileId &#34;do we have existing regId queueId $queueId build $build platform_id $platform_id ?&#34;
          set regId [GetRegressionIdFromQueueId $queueId $build $platform_id $module ]
          if { $regId == &#34;&#34; } {
            set regId &#34;null&#34;
          }
        } else {
          set queueId &#34;null&#34;
        }
    }

    <span class="comment-line"># Either regId or platform+build MUST exist</span>
    if { ($regId == &#34;null&#34;) &amp;&amp; ($queueId == &#34;null&#34;) } {
        <span class="comment-line"># Regression ID is not given</span>
        if { ($platform == &#34;null&#34;) || ($build == &#34;null&#34;) } {
            puts $logFileId &#34;Error: Either Regression ID or Platform+Build must be supplied.&#34;
            <a name="::print_usage(2)"><a href="./mysqlAutomate.tcl.html#::print_usage_66">::print_usage</a></a>
            exit
        }
    } else {
        <span class="comment-line"># Regression ID is given</span>
        if { ((($platform != &#34;null&#34;) || (($build != &#34;null&#34;) &amp;&amp; ($build != &#34;0.0.0.0&#34;))) \
               &amp;&amp; ($queueId == &#34;null&#34;)) } {
            puts $logFileId &#34;platform = $platform build = $build&#34;
            puts $logFileId &#34;queueId = $queueId&#34;
            puts $logFileId &#34;Error: Either Regression ID or Platform+Build must be supplied, but not any combination of the above.&#34;
            <a name="::print_usage(3)"><a href="./mysqlAutomate.tcl.html#::print_usage_66">::print_usage</a></a>
            exit
        }
    }

    if {$cliFlag == &#34;&#34; || $cliFlag == &#34;NO_DOWNLOAD&#34; || $cliFlag == &#34;NO_REBOOT&#34; \
        || $cliFlag == &#34;NO_DOWNLOAD_NO_REBOOT&#34; || $cliFlag == &#34;NO_REBOOT_NO_DOWNLOAD&#34; } {

<span class="comment-line">#        if { ([regexp -nocase &#34;cli&#34; $regType]) &amp;&amp; ($cliFlag == &#34;&#34;) } {</span>
<span class="comment-line">#    	    puts $logFileId &#34;ERROR: Required Parameters: -cliFlag when regType is cli &#34;</span>
<span class="comment-line">#       	    return 0</span>
<span class="comment-line">#        }</span>
   } else {
       puts $logFileId &#34;ERROR: Invalid cliFlag :$cliFlag&#34;
       return 0
   }

    if {[lsearch $argv &#34;-noconfig&#34;]  &gt; -1} {
	set runflag &#34;noconfig&#34;
    } else {
	set runflag &#34;config&#34;
    }

}

<span class="comment-line">#############################################################################################################</span>
<span class="comment-line"># Procedure Name: getModuleNamesDirectories </span>
<span class="comment-line"># </span>
<span class="comment-line">#############################################################################################################</span>
<strong><a name="::getModuleNamesDirectories_238">proc <a href="mysqlAutomate.tcl-annot.html#::getModuleNamesDirectories">::getModuleNamesDirectories</a></a></strong><a name="::getModuleNamesDirectories"></a> { module_names module_directories } {
    global mysql_handler regSubType regType
    upvar $module_names moduleNamesTmp
    upvar $module_directories moduleDirectoriesTmp

    <span class="comment-line">#puts &#34;regSubType regType =  $regSubType $regType&#34;</span>
    set sel_clause &#34;SELECT feature_name FROM feature_table WHERE status = 'Active' AND feature_type = '$regType' AND feature_sub_type = '$regSubType'&#34;
    set moduleNamesTmp [mysqlsel $mysql_handler $sel_clause -flatlist]

    <span class="comment-line">#puts &#34;moduleNamesTmp $moduleNamesTmp&#34;</span>
    set sel_clause &#34;SELECT feature_directory FROM feature_table WHERE status = 'Active' AND feature_type = '$regType' AND feature_sub_type = '$regSubType'&#34;
    set moduleDirectoriesTmp [mysqlsel $mysql_handler $sel_clause -flatlist]
    <span class="comment-line">#puts &#34;moduleDirectoriesTmp $moduleDirectoriesTmp&#34;</span>
    global logFileId
    puts $logFileId &#34;======= In getModuleNamesDirectories to gather module names ======\n\
       globals regSubType: $regSubType  regType: $moduleNamesTmp&#34;
}

puts &#34;######################################################################&#34;
puts &#34;                        POSTTOMYSQL.TCL STARTED &#34;
puts &#34;######################################################################&#34;

set LIB_PATH &#34;../Lib&#34;
lappend auto_path $LIB_PATH

source ../Lib/parse_args.tcl
source ../Lib/mainLib.tcl
load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
set LIB_PATH &#34;../Lib&#34;
lappend auto_path $LIB_PATH
gen_index ../Lib
gen_index .

source ../Lib/mysqlLib.tcl

catch { parse_args mysqlAutomate.tcl $argv {
    regId &#34;null&#34;
    queueId &#34;null&#34;
    module &#34;null&#34;
    reportDir &#34;null&#34;
    regType &#34;null&#34;
    regSubType &#34;null&#34;
    platform &#34;null&#34;
    build &#34;null&#34;
    obuild &#34;&#34;
    cliFlag &#34;&#34;
    runNumber &#34;-1&#34;
    forstats &#34;no&#34;
    help &#34;&#34;
    isFullRun &#34;1&#34;
    callLocation &#34;not specified&#34;
    qId &#34;null&#34;
    sustaining &#34;0&#34;
    manual  &#34;false&#34;
  }
} result

if { $result != &#34;&#34; } {
    puts &#34;ERROR: $result&#34;
    <a name="::print_usage(4)"><a href="./mysqlAutomate.tcl.html#::print_usage_66">::print_usage</a></a>
    exit
}

set scmJob 0
if {[regexp -nocase &#34;regServer&#34; $callLocation] &amp;&amp; \
      ![regexp -nocase &#34;mainfail&#34; $callLocation] &amp;&amp; \
      ![regexp -nocase &#34;download&#34; $callLocation]} {
    set scmJob 1
}

puts &#34;argv $argv&#34;
puts &#34; module $module&#34;
puts &#34; runNumber $runNumber&#34;
puts &#34;This mysqlAutomate is called from $callLocation&#34;
puts &#34; --------------------------------------------------------------------------------------&#34;

<span class="comment-line"># connect to database</span>
puts &#34;connecting to database $db at $host&#34;
set connStatus [conn_to_db $host $db]
puts &#34;database $db at $host - status $connStatus&#34;

<span class="comment-line"># check if reportDir includes the word downloadImage</span>
if { [regexp -nocase &#34;downloadImage&#34; $reportDir] } {
   puts &#34;reportDir includes the word downloadImage&#34;
   set isDownloadImage 1
} else {
   puts &#34;reportDir does not includes the word downloadImage&#34;
   set isDownloadImage 0
}

<span class="comment-line"># Open log file</span>
set tmStr [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]

set logRegId $regId
set logQueueId $queueId

if { $regId != &#34;null&#34; } {
   <span class="comment-line"># is that regId actually a queueId ? - ex: SC_060614_124245</span>
   if [regexp -nocase {[a-z]} $regId] {
     set logQueueId $regId
     <span class="comment-line"># lets find logRegId</span>
     set logRegId [mysqlsel $mysql_handler &#34;SELECT regression_id FROM regression_table \
                                             WHERE queue_id='$logQueueId'&#34; -flatlist]
     puts &#34;logRegId $logRegId queue_id $logQueueId \n&#34;;
     if { [llength $logRegId] == 0} {
       set logRegId &#34;null&#34;
     }
   } else {
     <span class="comment-line"># lets find logQueueId</span>
     set logQueueId [mysqlsel $mysql_handler &#34;SELECT queue_id FROM regression_table \
                                             WHERE regression_id='$regId'&#34; -flatlist]
     puts &#34;logRegId $logRegId queue_id $logQueueId \n&#34;;
     if { [llength $logQueueId] == 0} {
       set logQueueId &#34;null&#34;
     }
   }
}

set logFileName &#34;../main/Log/A $logRegId $logQueueId $platform $build $module $tmStr.txt&#34;
if { [catch {open $logFileName w} logFileId] } {
   puts &#34;ERROR:: Can't Open $logFileName&#34;
   puts $logFileId &#34;ERROR:: Can't Open $logFileName&#34;
   return
} 
puts $logFileId &#34;============= Called From $callLocation ===============&#34;
puts $logFileId &#34;original input arguments argv $argv&#34;
puts $logFileId &#34;database $db at $host - status $connStatus&#34;


<span class="comment-line"># if it's download pass lets get the module from the reportDir</span>
if {$isDownloadImage} {
  set reportDirPathList [split $reportDir /]
  set module [lindex $reportDirPathList 6]
  puts $logFileId &#34;this download image pass module: $module&#34;
  puts &#34;this download image pass module: $module&#34;
}

if {[<a name="::validatemysqlAutomateArgs(1)"><a href="./mysqlAutomate.tcl.html#::validatemysqlAutomateArgs_107">::validatemysqlAutomateArgs</a></a> $argv regId module cliFlag runNumber platform build forstats] == 0 } {
    <a name="::print_usage(5)"><a href="./mysqlAutomate.tcl.html#::print_usage_66">::print_usage</a></a>
    exit
}

puts &#34;mysqlAutomate starts with: \n \
queueId: $queueId \n \
regId: $regId \n \
module: $module \n \
reportDir: $reportDir \n \
regType: $regType \n \
regSubType: $regSubType \n \
platform: $platform \n \
build: $build \n \
obuild: $obuild \n \
cliFlag: $cliFlag \n \
runNumber: $runNumber \n \
forstats: $forstats \n \
manual: $manual \n \
sustaining: $sustaining \n \
isFullRun: $isFullRun \n &#34;


puts $logFileId &#34;mysqlAutomate starts starts with: \n \
queueId: $queueId \n \
regId: $regId \n \
module: $module \n \
reportDir: $reportDir \n \
regType: $regType \n \
regSubType: $regSubType \n \
platform: $platform \n \
build: $build \n \
obuild: $obuild \n \
cliFlag: $cliFlag \n \
runNumber: $runNumber \n \
sustaining: $sustaining \n \
qId: $qId \n \
manual: $manual \n \
isFullRun: $isFullRun \n &#34;

if { $regId != &#34;null&#34; } {
    <span class="comment-line">#result_debug &#34;regression_id is supplied, regId = $regId&#34;</span>
    puts &#34;regression_id is supplied, regId = $regId&#34;
    puts $logFileId &#34;regression_id is supplied, regId = $regId&#34;
    
    set cfgregTyperegSubTypeList [DetermineCfgRegTypeSubTypeFromRegId $regId]
    
    if { $cfgregTyperegSubTypeList == -1 } {
        puts $logFileId &#34;Nice try ... something wrong with your eyes?&#34;
        puts $logFileId &#34;Regression ID $regId does not exist... please double check webpage and try again.&#34;
        exit
    }
    
    set defaultCfg [lindex $cfgregTyperegSubTypeList 0]
    set regType    [lindex $cfgregTyperegSubTypeList 1]
    set regSubType [lindex $cfgregTyperegSubTypeList 2]
    set build [DetermineBuildNumFromRegId $regId]

    set defaultCfgShortList [split $defaultCfg .]
    set defaultCfgShort [lindex $defaultCfgShortList 0]
    puts $logFileId &#34;-------------------------------------------------------&#34;
    puts $logFileId &#34;defaultCfgShort = $defaultCfgShort&#34;
    puts $logFileId &#34;regType = $regType&#34;
    puts $logFileId &#34;regSubType = $regSubType&#34;
    puts $logFileId &#34;build from reg_id = $build&#34;
    puts $logFileId &#34;-------------------------------------------------------&#34;
} else {
    
    <span class="comment-line">#result_debug &#34;regression_id is not supplied, try to find it or create it&#34;</span>
    puts &#34;regression_id is not supplied, try to find it or create it - platform $platform&#34;
    puts $logFileId &#34;regression_id is not supplied, try to find it or create it - platform $platform&#34;
    
    
    if {$platform == &#34;null&#34;} {
	<span class="comment-line"># we have to have regType and regSubType</span>
	if { ($regType == &#34;Functional&#34;) &amp;&amp; ($regSubType == &#34;standard&#34;)} {
	    set platform &#34;NON_FUNC_STD,1&#34;
	}
	if { ($regType == &#34;Functional&#34;) &amp;&amp; ($regSubType == &#34;ipRoute1&#34;)} {
	    set platform &#34;NON_FUNC_IPR,1&#34;
	}
    }
    
    set platformInfoList [DetermineCfgRegTypeSubTypeFromPlatform $platform]
    
    set defaultCfg [lindex $platformInfoList 0]
    puts &#34;defaultCfg $defaultCfg&#34;
    puts $logFileId &#34;defaultCfg $defaultCfg&#34;
    set regType    [lindex $platformInfoList 1]
    puts &#34;regType $regType&#34;
    puts $logFileId &#34;regType $regType&#34;
    set regSubType [lindex $platformInfoList 2]
    puts &#34;regSubType $regSubType&#34;
    puts $logFileId &#34;regSubType $regSubType&#34;
    set regPath    &#34;[GetRegPath $regType $regSubType]&#34;
    puts &#34;regPath $regPath&#34;
    puts $logFileId &#34;regPath $regPath&#34;

    set defaultCfgShortList [split $defaultCfg .]
    set defaultCfgShort [lindex $defaultCfgShortList 0]
    puts $logFileId &#34;defaultCfgShort = $defaultCfgShort&#34;
    
    puts $logFileId &#34;defaultCfg  = $defaultCfg&#34;
    set platform_id [mysqlsel $mysql_handler &#34;SELECT platform_id FROM platform_table WHERE platform_cfg_file_name='$defaultCfg'&#34; -flatlist]
    <span class="comment-line">#result_debug &#34;platform_id = $platform_id&#34;</span>
    puts $logFileId &#34;platform_id = $platform_id&#34;
    
    puts $logFileId &#34;getting build_id from build $build&#34;
    if { $build != &#34;null&#34; } {
        puts $logFileId &#34;-------------------------------------------------------&#34;
        puts $logFileId &#34;build for case where no reg_id is set = $build&#34;
        puts $logFileId &#34;-------------------------------------------------------&#34;
	    set build_id [GetBuildIdFromBuild $build]
    } else {
	    set build_id &#34;null&#34;
    }
    
    <span class="comment-line"># this is needed for the queuing system</span>
    if {$isDownloadImage == 1} {
	    set moduleWithDownl $module
    } else {
	    set moduleWithDownl &#34;NULL&#34;
    }
    set regId [GetRegressionId -queue_id $queueId -build_id $build_id \
	    -platform_id $platform_id \
	    -feature_type $regType -feature_sub_type $regSubType \
	    -download_phase_module $moduleWithDownl]
    
}

<span class="comment-line">####################################################################################</span>
<span class="comment-line"># Get Module Name, Module Directories</span>
<span class="comment-line">#</span>
<span class="comment-line"># from the database get the module names and the feature durectory names</span>
<span class="comment-line">#</span>
<span class="comment-line">####################################################################################</span>
<a name="::getModuleNamesDirectories(1)"><a href="./mysqlAutomate.tcl.html#::getModuleNamesDirectories_238">::getModuleNamesDirectories</a></a> module_names module_directories 

if { [llength $module_names] == 0} {
    puts $logFileId &#34;Error: No module names in the database&#34;;
    exit;
}
if { [llength $module_directories] == 0} {
    puts $logFileId &#34;Error: No module directories in the database&#34;;
    exit;
}
puts $logFileId &#34;module_names: $module_names \n&#34; 
puts $logFileId &#34;\nmodule_directories: $module_directories\n&#34;

<span class="comment-line">###################################################################################</span>
<span class="comment-line"># for the give configuration file</span>
<span class="comment-line"># get platform_name,platform_id and  blade for the given configuration file</span>
<span class="comment-line">#</span>
<span class="comment-line">###################################################################################</span>
<span class="comment-line">#get platform data</span>
set platform_id [mysqlsel $mysql_handler &#34;SELECT platform_id FROM regression_table WHERE regression_id='$regId'&#34; -flatlist]
set platform_list [mysqlsel $mysql_handler &#34;SELECT platform_name, platform_blade FROM platform_table WHERE platform_id = '$platform_id'&#34; -flatlist]
set platform_name [lindex $platform_list 0]
set blade [lindex $platform_list 1]

puts $logFileId &#34;platform_name=$platform_name, platform_id=$platform_id, blade=$blade&#34;

<span class="comment-line">####################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line"># check for platform names for older releases</span>
<span class="comment-line">#     </span>
<span class="comment-line">####################################################################</span>

set build [DetermineBuildNumFromRegId $regId]
puts $logFileId &#34;----------       Another build name case    -----------&#34;
puts $logFileId &#34;build from DetermineBuildNumFromRegId $regId = $build&#34;
puts $logFileId &#34;-------------------------------------------------------&#34;
if {$build &gt;= &#34;11.3.0.0&#34;} {
    if {[regexp -nocase &#34;aspen&#34; $platform_name]} {
	set platform_name &#34;BD-88&#34;
    }
} else {
    if {[regexp -nocase &#34;aspen&#34; $platform_name]} {
	set platform_name &#34;Aspen&#34;
    }
}

if {[regexp -nocase &#34;G60X&#34; $blade]} {
    set blade &#34;G60X&#34;
}
<span class="comment-line">####################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line"># change the platform name for OLYMPIC</span>
<span class="comment-line">#     </span>
<span class="comment-line">####################################################################</span>
if {[regexp -nocase &#34;olympic&#34; $platform_name]} {
    set platform_name &#34;BD-12804&#34;
}
<span class="comment-line">####################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line"># change the platform name for TORINO</span>
<span class="comment-line">#     </span>
<span class="comment-line">####################################################################</span>
if {[regexp -nocase &#34;torino&#34; $platform_name]} {
    set platform_name &#34;BD-12802&#34;
}

<span class="comment-line">####################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line"># change the platform name for Voyager</span>
<span class="comment-line">#     </span>
<span class="comment-line">####################################################################</span>
if {[regexp -nocase &#34;Voyager&#34; $platform_name]} {
    set platform_name &#34;BD-20808&#34;
}
puts $logFileId &#34;platform_id=$platform_id, regression_id = $regId\n&#34;

<span class="comment-line">################################################################################</span>
<span class="comment-line"># get the feature_id</span>
<span class="comment-line">################################################################################</span>
puts $logFileId &#34;DB Feature query - SELECT feature_directory FROM feature_table WHERE \
feature_type='$regType' AND feature_sub_type='$regSubType' AND status = 'Active'&#34;

set feature_directory &#34;NULL&#34;
set regressionModules [mysqlsel $mysql_handler &#34;SELECT feature_directory FROM feature_table WHERE \
	feature_type='$regType' AND feature_sub_type='$regSubType' AND status = 'Active'&#34; -flatlist]
    <span class="comment-line">#set match &#34;&#34;</span>
    <span class="comment-line">#set str &#34;&#34;</span>
    if {[lsearch -exact  $regressionModules $module] != -1} {
        set feature_directory $module

    }

if { $feature_directory == &#34;NULL&#34; } {
    puts $logFileId &#34;\nERROR: Module name '$module' does not correspond to any feature name in the mysql database. Check spelling and try again.&#34;
    exit
}
set module $feature_directory
puts $logFileId &#34;module = $module&#34;

set sel_clause &#34;SELECT feature_id FROM feature_table WHERE  feature_directory = '$module' AND \
	feature_type='$regType' AND feature_sub_type='$regSubType' AND status = 'Active'&#34; 

set feature_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
if {[llength $feature_id_list] &gt; 1} {
    puts $logFileId &#34;Error: In feature_table more than one feature_id for the feature :$module&#34;
    puts $logFileId &#34;got feature_id_list: $feature_id_list&#34;
    exit 0
}
set feature_id [lindex $feature_id_list end]
puts $logFileId &#34;got feature_id: $feature_id&#34;


<span class="comment-line">################################################################################</span>
<span class="comment-line"># Set the path names </span>
<span class="comment-line">################################################################################</span>
set relativePath &#34;..&#34;
<span class="comment-line">#set thisDir [pwd]</span>
<span class="comment-line">#cd  &#34;..&#34;</span>
set regPath &#34;[GetRegPath $regType $regSubType]&#34;
puts $logFileId &#34;------------------       Regression Path    -----------&#34;
puts $logFileId &#34;Path from GetRegPath regtype $regType regsubtype $regSubType = $regPath&#34;
puts $logFileId &#34;-------------------------------------------------------&#34;

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Get the report directory</span>
<span class="comment-line"># as the names are case sensitive in some tables, </span>
<span class="comment-line"># have to get the real name from module_directories list</span>
<span class="comment-line">################################################################################</span>
set noCaseModule $module 
foreach mod $module_directories {
    if { [string compare -nocase $module $mod] == 0} {
	set module $mod 
	break;
    }
}
set MAIN(feature_directory) $module
set MAIN(RESULTBUILD)       $build
puts $logFileId &#34;\ngetting report directory  module=$module, noCaseModule=$noCaseModule\n&#34;
puts &#34;\nDANY getting report directory  module=$module, noCaseModule=$noCaseModule\n&#34;
set dirList &#34;&#34;

if { [regexp -nocase &#34;upgrade&#34; $regPath] } {
    if { $obuild == &#34;&#34; } {
	puts $logFileId &#34;-obuild must be supplied for CLI/upgradedowngrade test.&#34;
	exit
    }
    set fullbuild &#34;$build:$obuild&#34;
} else {
    set fullbuild $build
}

if {$reportDir == &#34;null&#34; || [string trim $reportDir] == &#34;&#34;} {
   if {$qId != &#34;null&#34;} {
       set mDir &#34;$qId&#34;
       set sDir $mDir
   } else {
       set mDir &#34;$defaultCfgShort *$fullbuild &#34;
       set sDir &#34;$defaultCfgShort&#34;
   }
   if {$manual != &#34;false&#34; &amp;&amp; $manual == $qId} {
       if {$runNumber==2} {
           set rep2Dir &#34;/var/spool/regression/imagesFinished/$qId/$module/Report1/&#34; 
           puts $logFileId &#34;glob -nocomplain -- \&#34;$rep2Dir\&#34;&#34;
           set dirList  [glob -nocomplain -- &#34;$rep2Dir&#34;]
           set manualRun 2
           _update_scm_db_from_report_txt -run &#34;2&#34; -log_pid $logFileId -module $module \
                 -reportDir $rep2Dir -qId $qId  -scmJob &#34;1&#34;
       } else {
           set rep1Dir &#34;/var/spool/regression/imagesFinished/$qId/$module/Report/&#34;
           puts $logFileId &#34;glob -nocomplain -- \&#34;$rep1Dir\&#34;&#34;
           set dirList  [glob -nocomplain -- &#34;$rep1Dir&#34;]
           set manualRun 1
           _update_scm_db_from_report_txt -run &#34;1&#34; -log_pid $logFileId -module $module \
                 -reportDir $rep1Dir -qId $qId  -scmJob &#34;1&#34;
       }
   } else {
       if {!$sustaining} {
           puts $logFileId &#34;glob -nocomplain -- \&#34;$regPath/$module/Report/*$mDir*\&#34;&#34;
           set dirList  [glob -nocomplain -- &#34;$regPath/$module/Report/*$mDir*&#34;]
       } else {
           puts $logFileId &#34;glob -nocomplain -- \&#34;$regPath/$module/Report/*$sDir *\&#34;&#34;
           set dirList  [glob -nocomplain -- &#34;$regPath/$module/Report/*$sDir *&#34;]
       }
   }
   puts $logFileId &#34;\nsearch - dirList: $dirList&#34; 
   puts &#34;\nsearch - dirList: $dirList&#34; 
   puts &#34;\nregPath: $regPath&#34; 
   puts &#34;\nmodule: $module&#34; 
   puts &#34;\ndefaultCfgShort: $defaultCfgShort&#34; 
   puts &#34;\nfullbuild $fullbuild&#34; 

   <span class="comment-line"># this section is removed - cfg file name added to directory name</span>
  if {$dirList == &#34;&#34;} {
      puts $logFileId &#34;Error: There is no directory list&#34;
      exit 0
  }
  puts $logFileId &#34;\n Directory List: $dirList\n&#34;
  <span class="comment-line">#set module $noCaseModule </span>
}

<span class="comment-line">##################################################################################</span>
<span class="comment-line"># Sort based on the index of the directory and not lsort command to get the index</span>
<span class="comment-line">##################################################################################</span>
set logDir &#34;&#34;
if {$reportDir != &#34;null&#34; &amp;&amp; [string trim $reportDir] != &#34;&#34;} { 
  <span class="comment-line"># report directory is supplied - done in the queuing system</span>
  set logDir $reportDir
} else {
  set highestIndx 0
  set highestCreateTime 0
  foreach tdir $dirList {
      <span class="comment-line">#get directory index</span>
      set splitDir [split $tdir &#34; &#34;]
      <span class="comment-line"># get the last element</span>
      set indx [lindex $splitDir end]
      set createTimeThis [file mtime $tdir]
      if {$logDir == &#34;&#34;} {
          set logDir $tdir
          set highestIndx $indx
      } else {
          if {($indx &gt; $highestIndx) || (($indx == $highestIndx) &amp;&amp; ($createTimeThis &gt; $highestCreateTime))} {
              set highestIndx $indx
              set highestCreateTime $createTimeThis
              set logDir $tdir
              set creatTime [file mtime $logDir]
              <span class="comment-line"># puts $logFileId &#34;this directory creation time: $creatTime&#34;</span>
          }
      }
  }
}

if {$logDir == &#34;&#34; } {
    puts $logFileId &#34;Error: There is no Report Directory - reportDir = $reportDir&#34;
    exit
}
set sourceDir  &#34;$regPath/$module&#34;
puts $logFileId &#34; logDir: $logDir, sourceDir: $sourceDir&#34;

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Get the run_number</span>
<span class="comment-line">################################################################################</span>
set sel_clause &#34;SELECT run_number FROM report_table WHERE \
	regression_id = '$regId' and \
	feature_id = '$feature_id' \
	ORDER BY run_number ASC&#34; 
set run_number_list [mysqlsel $mysql_handler $sel_clause -flatlist]
if {[llength $run_number_list] &gt;= 1} { 
    puts $logFileId &#34;got run_number_list: $run_number_list&#34;
    set run_number [lindex $run_number_list end]
} else {
    set run_number 0
}

puts $logFileId &#34;\nfound run_number=$run_number from report_table where regression_id = $regId, feature_id= $feature_id\n&#34;

<span class="comment-line">##################################################################################</span>
<span class="comment-line"># If the run numbers is greater than zero get the report id</span>
<span class="comment-line">##################################################################################</span>
if {$run_number &gt; 0} {
    set sel_clause &#34;SELECT report_id FROM report_table WHERE \
        regression_id = '$regId' and \
        feature_id = '$feature_id' \
        ORDER BY run_number ASC&#34;
    set rId [mysqlsel $mysql_handler $sel_clause -flatlist]
    puts $logFileId &#34;\nFound Report ID: $rId&#34;
    puts &#34;\n--------------------------------------------------------------&#34;
    puts &#34;--------------------------------------------------------------&#34;
    puts &#34; The $module Report ID for regId $regId is $rId&#34;
    puts &#34;--------------------------------------------------------------&#34;
    puts &#34;--------------------------------------------------------------&#34;
}



<span class="comment-line">#########################################################################################################################</span>
<span class="comment-line"># Compare the run number found from the table (run_number) with that provided by the user (runNumber)</span>
<span class="comment-line"># If runNumber provided by the user already exists, then delete the existing run and upload the new run at the same run</span>
<span class="comment-line">#</span>
<span class="comment-line"># Don;t insert same report multiple times</span>
<span class="comment-line"># If a report alredy exists then compare the report start time with the one in the database and insert only if its a new</span>
<span class="comment-line"># report</span>
<span class="comment-line">#             regression_id= '$regId' AND</span>
<span class="comment-line">#             run_number= '$run_number' AND </span>
<span class="comment-line">#             feature_id= '$feature_id' AND &#34;</span>
<span class="comment-line">#########################################################################################################################</span>
if {$run_number == 0} {
    set insertNewRep 1
    incr run_number 
} elseif   { ($runNumber &gt; 0) &amp;&amp; ($runNumber &lt;= $run_number) } {
    puts $logFileId &#34;WARN: Deleting run_number = $run_number from database and uploading the latest run in its place &#34;
    set run_number $runNumber
    deleteReporWithLogs -regression_id $regId -run_number $run_number -feature_id $feature_id
    set insertNewRep 1
} else {
    set sel_clause &#34;SELECT report_id FROM report_table WHERE \
	    regression_id= '$regId' AND \
	    run_number= '$run_number' AND \
	    feature_id= '$feature_id'&#34;
    
    set report_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
    set report_id [lindex $report_id_list end]
    if {$report_id == &#34;&#34;} {
	    exit
    } 
    puts $logFileId &#34;\nfound run_number=$run_number from report_table where regression_id = $regId, feature_id= $feature_id,report_id=$report_id\n&#34;
    set sel_clause &#34;SELECT test_report_file_content FROM report_table WHERE \
	    report_id= '$report_id'&#34;
    
    set file_report_list [mysqlsel $mysql_handler $sel_clause -flatlist]
    puts $logFileId &#34;\ncame back from mysql\n&#34;
    set report_text [lindex $file_report_list 0]
    <span class="comment-line">#puts $logFileId &#34;\ngot report_text $report_text&#34;</span>
    set report_text_list [split $report_text \n]
    set foundSqlDate 0
    foreach line $report_text_list {
	if { [regexp {.*(Test starting time =).* (([0-9|-]+) ([0-9|\.]+)[A|P]M)(.*)} $line sqlMatch start sqlDate rest rest2 ] == 1 } {
	    if { [info exist sqlMatch] &amp;&amp; [info exist start] &amp;&amp; [info exist sqlDate] } {
		puts $logFileId &#34;found sqlDate =$sqlDate&#34;
		set foundSqlDate 1
		break
	    }
	}
    }
    if {$foundSqlDate == 0 } {
	puts $logFileId &#34;ERROR: Doesn't exist sqlMatch, start, sqlDate&#34;
	set sqlDate &#34;noSqlDate&#34;
	<span class="comment-line">#return</span>
    }
    
    set fname &#34;$logDir/report.txt&#34;
    if { [catch {open $fname r} fileId] } {
	puts $logFileId &#34;ERROR:: Can't Open $fname&#34;
	return
    } 
    set foundReportDate 0
    while { [gets $fileId line] &gt;= 0} {
	if { [regexp {.*(Test starting time =).* (([0-9|-]+) ([0-9|\.]+)[A|P]M)(.*)} $line match start reportDate rest ] == 1} {
	    if { [info exist match] &amp;&amp; [info exist start] &amp;&amp; [info exist reportDate] } {
		puts $logFileId &#34;found reportDate =$reportDate&#34;
		set foundReportDate 1
		break
	    } 
	}
    }
    
    if {$foundReportDate == 0 } {
	puts $logFileId &#34;ERROR: Doesn't exist sqlMatch, start, reportDate&#34;
	set reportDate &#34;noReportDate&#34;
	<span class="comment-line">#return</span>
    }
    if {[string compare $sqlDate $reportDate] == 0} {
	set insertNewRep 0
	puts $logFileId &#34;ERROR: Report already exists. Report Will not be  inserted&#34;
    } else {
	puts $logFileId &#34;New report. Will be uploaded&#34;
	set insertNewRep 1
	incr run_number
    }
}

<span class="comment-line">#########################################################################################################################</span>
<span class="comment-line"># Insert new report.</span>
<span class="comment-line"># Get the new report_id</span>
<span class="comment-line"># first remove the old report/logs if any from previous runs</span>
<span class="comment-line"># then insert the entries into report table and from it read the new run_number</span>
<span class="comment-line">#</span>
<span class="comment-line">#puts $logFileId &#34;calling deleteReporWithLogs  regression_id $regId run_number $run_number feature_id $feature_id&#34;</span>
<span class="comment-line">#deleteReporWithLogs -regression_id $regId -run_number $run_number -feature_id $feature_id</span>
<span class="comment-line">#########################################################################################################################</span>
set build_id [GetBuildIdFromBuild $build]


if {(($insertNewRep == 1) &amp;&amp; ($reportDir == &#34;null&#34;)) || (($isDownloadImage == 0) &amp;&amp; ($reportDir != &#34;null&#34;))} {
    puts $logFileId &#34;Uploading new report to database&#34;
    puts &#34;--------- Uploading NEW Reprot to database -----------&#34;

    _update_scm_db_from_report_txt -run $run_number -log_pid $logFileId -module $module \
           -reportDir $logDir -qId $qId -scmJob $scmJob

   catch { 
    InsertAllIntoReportTable -regression_id $regId \
	    -feature_id $feature_id  \
	    -run_number $run_number  \
	    -run_type &#34;results&#34;  \
        -build_id &#34;$build_id&#34; \
	    -report_directory &#34;$logDir&#34;
    set sel_clause &#34;SELECT report_id FROM report_table WHERE \
	    regression_id= '$regId' AND \
	    run_number= '$run_number' AND \
	    feature_id= '$feature_id'&#34;
    puts $logFileId &#34;sel_clause to get report_id: $sel_clause&#34;
    set report_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
    <span class="comment-line"># get the last report_id in the list</span>
    set report_id [lindex $report_id_list end]
    puts $logFileId &#34;got report_id: $report_id&#34;
   } uploadReportFileResult
   if { $uploadReportFileResult != &#34;&#34; } {
      puts &#34;uploadReportFileResult FAILED: $uploadReportFileResult&#34;
      puts $logFileId  &#34;uploadReportFileResult FAILED: $uploadReportFileResult&#34;
   }
    
    if { [regexp -nocase &#34;cli&#34; $regType] } {
	set sourceDir &#34;../CLItest/cli-ew/$module&#34;
    }

    puts &#34;===== regType $regType module = $module feature_id = $feature_id =====&#34;; 

    catch { 
    InsertAllIntoLogTable -report_id $report_id \
            -feature_id $feature_id \
            -build_id $build_id \
            -logDir &#34;$logDir&#34; \
            -sourceDir &#34;$sourceDir&#34;
   } uploadLogFilesResult
   if { $uploadLogFilesResult != &#34;&#34; } {
      puts &#34;uploadLogFilesResult FAILED: $uploadLogFilesResult&#34;
      puts $logFileId  &#34;uploadLogFilesResult FAILED: $uploadLogFilesResult&#34;
   }
    
    <span class="comment-line"># this is a first step - inser all the text (info) and</span>
    <span class="comment-line"># binary files into xfile_table</span>
    <span class="comment-line"># in this step upload the binary files into the report_table</span>
    <span class="comment-line"># later only report.txt will be inserted there</span>
    
   catch { 
    <span class="comment-line"># insert the text (info) files</span>
    InsertAllInfoFilesIntoXfileTable -report_id $report_id \
	    -logDir $logDir
   } uploadInfoXfilesResult
   if { $uploadInfoXfilesResult != &#34;&#34; } {
      puts &#34;uploadInfoXfilesResult FAILED: $uploadInfoXfilesResult&#34;
      puts $logFileId  &#34;uploadInfoXfilesResult FAILED: $uploadInfoXfilesResult&#34;
   }
    
   catch { 
    <span class="comment-line"># insert the binary (core dumps) files</span>
    InsertAllBinaryFilesIntoXfileTable -report_id $report_id \
	    -logDir $logDir -host $host
   } uploadBinaryXfilesResult
   if { $uploadBinaryXfilesResult != &#34;&#34; } {
      puts &#34;uploadBinaryXfilesResult FAILED: $uploadBinaryXfilesResult&#34;
      puts $logFileId  &#34;uploadBinaryXfilesResult FAILED: $uploadBinaryXfilesResult&#34;
   }
    

   <span class="comment-line"># no report analysis in case of image download phase</span>
   if {!$isDownloadImage} {
     catch { 
        <span class="comment-line"># let PHP analyze the report files and update log files</span>
        set regression_id_url [http_formatQuery regression_id $regId feature_id \
                                               $feature_id run_number $run_number forstats $forstats] 
        puts $logFileId &#34; regression_id_url: $regression_id_url&#34;
        
        if {$my_db == &#34;autoweb_db_5&#34; || $my_db == &#34;autoweb_db_7&#34;} {
          set analyseURL &#34;http://$host/phpdb4/failAnalysis.php&#34;
          catch { exec {tclsh} mysqlFailAnalysis.tcl -regression_id $regId -feature_id $feature_id \
                -run_number $run_number -forstats $forstats &amp;} result
        } else {
          set analyseURL &#34;http://$host/failAnalysis.php&#34;
        }
        set analyseURL [append analyseURL &#34;?$regression_id_url&#34;]
        puts $logFileId &#34; analyseURL: $analyseURL&#34;
        set token [http_get $analyseURL -timeout 1000000 ]
        upvar #0 $token httpState
        while { [string match eof $httpState(state)] != 1 } {
            set incommingHttp &#34;$httpState(state) [string match eof $httpState(state)]&#34;
	    puts $logFileId $incommingHttp
	    puts stderr $incommingHttp
	    flush stderr
            if {$incommingHttp == &#34;header 0&#34;} {
	      puts $logFileId we got $incommingHttp which causes a loop - terminating mysqlAutomate&#34;
              return
            }
	    after 100
        }
        if { [info exists httpState(error)] } {
          set lasterror $httpState(http)
          puts &#34;GOT HTTP ERROR: $lasterror&#34;
          puts $logFileId &#34;GOT HTTP ERROR: $lasterror&#34;
        }
    
     } httpResult
     
    
     if { $httpResult != &#34;&#34; } {
        puts &#34;HTTP CRASH: $httpResult&#34;
        puts $logFileId &#34;HTTP CRASH: $httpResult&#34;
     }
   }

} elseif {($isDownloadImage == 1) &amp;&amp; ($reportDir != &#34;null&#34;)} { 
   catch { 
     InsertAllIntoReportTable -regression_id $regId \
	     -feature_id $feature_id  \
         -build_id $build_id \
	     -run_number '0'  \
	     -run_type &#34;downloadImage&#34;  \
	     -report_directory &#34;$logDir&#34;
     set sel_clause &#34;SELECT report_id FROM report_table WHERE \
	     regression_id= '$regId' AND \
	     run_number= '0' AND \
	     feature_id= '$feature_id'&#34;
     set report_id_list [mysqlsel $mysql_handler $sel_clause -flatlist]
     <span class="comment-line"># get the last report_id in the list</span>
     set report_id [lindex $report_id_list end]
     puts $logFileId &#34;got report_id: $report_id&#34;
     puts &#34;GOT REPORT_ID: $report_id&#34;
   } uploadReportFileResult
   if { $uploadReportFileResult != &#34;&#34; } {
      puts &#34;uploadReportFileResult FAILED: $uploadReportFileResult&#34;
      puts $logFileId  &#34;uploadReportFileResult FAILED: $uploadReportFileResult&#34;
   }

   catch { 
      <span class="comment-line"># in this case - it's a queuing system - upload only info files</span>
      <span class="comment-line"># insert the text (info) files</span>
        InsertAllInfoFilesIntoLimgFileTable -report_id $report_id \
                -logDir $logDir
   } uploadInfoLimgFilesResult
   if { $uploadInfoLimgFilesResult != &#34;&#34; } {
      puts &#34;uploadInfoLimgFilesResult FAILED: $uploadInfoLimgFilesResult&#34;
      puts $logFileId  &#34;uploadInfoLimgFilesResult FAILED: $uploadInfoLimgFilesResult&#34;
   }
} else { 
set recover_fa 1
    if {$recover_fa} {
     catch {
        <span class="comment-line"># let PHP analyze the report files and update log files</span>
        set regression_id_url [http_formatQuery regression_id $regId feature_id \
                                               $feature_id run_number $run_number forstats $forstats]
        puts $logFileId &#34; regression_id_url: $regression_id_url&#34;

        if {$my_db == &#34;autoweb_db_5&#34; || $my_db == &#34;autoweb_db_7&#34;} {
          puts &#34;usha I am here&#34;
          puts &#34;regId $regId&#34;
          puts &#34;feature_id $feature_id&#34;
          puts &#34;run_number $run_number&#34;
          set analyseURL &#34;http://$host/phpdb4/failAnalysis.php&#34; 
          catch { exec {tclsh} mysqlFailAnalysis.tcl -regression_id $regId -feature_id $feature_id \
                -run_number $run_number  -forstats $forstats &amp;} result
          puts &#34;result $result&#34;
        } else {
          set analyseURL &#34;http://$host/failAnalysis.php&#34;
        }
        puts &#34;Already RAN mysqlFailAnalysis&#34;;
        puts $logFileId &#34;Already RAN mysqlFailAnalysis&#34;
        set analyseURL [append analyseURL &#34;?$regression_id_url&#34;]
        puts $logFileId &#34; analyseURL: $analyseURL&#34;
        puts &#34; analyseURL: $analyseURL&#34;
        set token [http_get $analyseURL -timeout 1000000 ]
        upvar #0 $token httpState
        while { [string match eof $httpState(state)] != 1 } {
            set incommingHttp &#34;$httpState(state) [string match eof $httpState(state)]&#34;
            puts $logFileId $incommingHttp
            puts stderr $incommingHttp
            flush stderr
            if {$incommingHttp == &#34;header 0&#34;} {
              puts $logFileId &#34;we got $incommingHttp which causes a loop - terminating mysqlAutomate&#34;
              return
            }
            after 100
        }
        if { [info exists httpState(error)] } {
          set lasterror $httpState(http)
          puts &#34;GOT HTTP ERROR: $lasterror&#34;
          puts $logFileId &#34;GOT HTTP ERROR: $lasterror&#34;
        }

     } httpResult


     if { $httpResult != &#34;&#34; } {
        puts &#34;HTTP CRASH: $httpResult&#34;
        puts $logFileId &#34;HTTP CRASH: $httpResult&#34;
     }

    }
    puts $logFileId &#34;No upload - the report already exists&#34;
    puts $logFileId &#34;report $fname&#34;
    puts $logFileId &#34;report_id=$report_id,  run_number=$run_number ,regression_id = $regId, feature_id= $feature_id\n&#34;
}

<span class="comment-line">########################## TEST EnD ##########################</span>

if {!$isDownloadImage} {
  if [catch {set rr [http_data httpState]} reason] {
    puts $logFileId &#34;PHP FAIL ANALYSIS COULD NOT RUN DUE TO:\n$reason\n&#34;;
    puts &#34;PHP FAIL ANALYSIS COULD NOT RUN DUE TO:\n$reason\n&#34;;
    return
  }
  puts $logFileId &#34;PHP FAIL ANALYSIS DEBUG INFO\n&#34;;
  puts $logFileId &#34;$rr&#34;;
}

puts &#34;######################################################################&#34;
puts &#34;                        POSTTOMYSQL.TCL ENDED &#34;
puts &#34; Log file: $logFileName&#34;
puts &#34;######################################################################&#34;
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
