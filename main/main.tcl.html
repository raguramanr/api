<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>main.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#main.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>main.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="main.tcl-annot.html">annotations</a> | <a href="main.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

source ../Lib/parse_args.tcl
source ../Lib/mainLib.tcl
source ../Lib/filetools.tcl
source ../Util/iTest.cfg

package require http 1.0;
package require Tclx

<span class="comment-line"># Global Variables</span>
global ezinfofile env
global initsend mySock
global TrafficGen
global MAIN_LOG; <span class="comment-line"># main_log.txt file descriptor</span>
global currentTestNumber
global NEWBUILD
global OLDBUILD
global efence
global subversion
global enableSaveConfigPerTest
global enableAbortTestCondition
global gHeapTracingProcess
global heapTraceEnabled
global DEBUGFAILLOCK FAILLOCK
global modName regPath showErrorData configurationFile
global DUTs_info tStartDateString
global bcmLynx CTLIST
global lynxIncludeModList regressionModules
global HEADERFORMAT;<span class="comment-line"># the formatting for headers and notifications</span>
global MAIN;<span class="comment-line"># single dem array of important main.tcl stateful info</span>
global FEATMAIN;<span class="comment-line"># 2 dem array of important feature stateful info</span>
global FEATPLAT;<span class="comment-line"># Feature support per test bed using a dut list and sysType list. in ct.lst</span>
<span class="comment-line"># ----- Test variables setup</span>
set clitestDir &#34;cli-ew&#34;
set skipCount 0
set _VERSION 6.0 ;<span class="comment-line"># define here as global variable.  Will change later</span>
set VERSION 6    ;<span class="comment-line"># define here as global variable.  Will change later</span>
set returnFlag &#34;NULL&#34;
set runMode    0
set MAIN(ifPipe)   &#34;NULL&#34;
set MAIN(initFile) &#34;NULL&#34;
set MAIN(skipIxInit) 0
set MAIN(CCIMAINDEBUG) 0
set MAIN(initAdminCheck) 1;<span class="comment-line"># first login check if the console is at a user prompt.</span>
set retFlag &#34;&#34;
set licenseList {l2edge edge advancededge core advancedcore mpls}
set ITESTMODS [concat $istdMods(functional,All) $irtrMods(functional,All)];<span class="comment-line">#from iTest.cfg above</span>
set debugLevel 0
set currentTestNumber main
set DEBUGFAILLOCK 0
set FAILLOCK &#34;no&#34;
set powerCyclerRetry 0
set MAIN(user) [id effective user]
<span class="comment-line">#       Report variables</span>
set MAIN(timeFile) &#34;NULL&#34;
set MAIN(tSetupDuration) 0;
set MAIN(tCheckConnectionDuration) 0;
set MAIN(testDuration) 0;
set MAIN(startexecution) 0
set MAIN(FAILSAFEHIT) 0;
set FEATPLAT(SupportedTypes) &#34;&#34;;<span class="comment-line"># Ex VXLAN ct.lst = [list &#34;$bcmx690|$bcmx870|$bcmx770|$bcmx670_G2&#34; &#34;$bcmxG2&#34;]</span>
set FEATPLAT(SupportedDUTs) &#34;&#34;; <span class="comment-line">#                 = [list &#34;1 2 3&#34;  &#34;4 5&#34;]</span>
set FEATPLAT(NoSupportTypes) &#34;&#34;; <span class="comment-line"># 03-2017 not coded yet</span>
set FEATPLAT(NoSupportDUTs) &#34;&#34;;<span class="comment-line"># 03-2017 not coded yet</span>
set CTLIST(quick) &#34;&#34;;<span class="comment-line"># check common.cfg for all mixes quick_pass, quick_pass_all etc. Lib/tests_to_exec.tcl</span>
set tSetupDuration 0;
set tCheckConnectionDuration 0;
set testDuration 0;
set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]
set passCount 0
set failCount 0
set skipCount 0
set testDuration 0
set testHour 0
set testMin 0
set testSec 0
<span class="comment-line">#       Report directory structure variables</span>
<span class="comment-line">#  Note - resultDir name = &#34;timestamp $randomIndex&#34;</span>
set resultDir &#34;NULL&#34;;<span class="comment-line"># NULL forces creation of a new resultDir (also global resultDir)</span>
set MAIN(RESULTPATH) &#34;Result&#34;
set MAIN(RESULTDIR) &#34;null&#34;;<span class="comment-line"># all script results file will be posted here while running</span>
set MAIN(REPORTDIR) &#34;null&#34;;<span class="comment-line"># ResultDir is renamed to this at the very end.</span>
set optionalPath &#34;&#34;;<span class="comment-line"># optional location for the Report directory</span>
set optionalFlag &#34;null&#34;;<span class="comment-line"># used for cliFlag by default.</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<span class="comment-line"># The help output on invalid or too few args</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<strong><a name="::print_usage_91">proc <a href="main.tcl-annot.html#::print_usage">::print_usage</a></a></strong><a name="::print_usage"></a> {} {
    puts &#34;\r&#34;
    puts {Usage: main.tcl -mode &lt;mode&gt; -module &lt;module&gt; -cfg &lt;config file&gt; \n \
    [-lst &lt;test list&gt;|-tcList] [-regPath &lt;regression Path&gt;] [-testlinkplan &lt;testlinkplan&gt;] \n \
    [-build &lt;xos build1&gt;] [-subversion &lt;subversion&gt;] [-obuild &lt;xos build2&gt;] [-cliFlag &lt;cliFlag&gt;]\n \
    [-moduleArg &lt;module specific arg&gt;] [-debugLevel &lt;error debug level&gt;] \n \
    [-efence &lt;process list&gt;] [-saveConfigPerTest &lt;yes/no&gt;] [-stopRegOn &lt;condition to abort&gt;] \n \
    [-qId &lt;regserver queue id&gt;] [-heapTracingProcess &lt;process list&gt;] [-ezinfofile &lt;infofile&gt;] \n \
    [-ezkillfile &lt;id&gt;] [-harness &lt;all|tcl|itest&gt;] \n \
    [-launchserver &lt;on|off&gt;] [-comment &lt;text comments&gt;]}
    puts {   &lt;mode&gt;: auto|dev|autodev}
    puts {      (auto: Official automation run from start, performs unconfig, checkConnection)}
    puts {      (dev: Development run using init file, skips unconfig, checkConnection)}
    puts {      (autodev: Official automation run using init file, skips checkConnection)}
    puts {   &lt;module&gt;: L2|L3|IGMPS|QOS-AC (case insensitive, nearest match accepted)}
    puts {   &lt;cfg&gt;: Path of the config file name (e.g. short/ptgm4x6.2.2b4.cfg)}
    puts {   [&lt;lst&gt;]: test list (all|pass|quick|userDefined). By default all, userDefined is a filename value in module)}
    puts {   [&lt;regPath&gt;]: regression Path (func|snmp|per|stres. By default function, case insensitive, nearest match accepted)}
    puts {         If running CLI test, give regPath as ../CLItest/uploadanddownload.}
    puts {   [&lt;testlinkplan&gt;]: TestLink test plan name.  All plan cases with a scriptPath will execute}
    puts {   [&lt;clean | c&gt;]: If running in dev mode the allcleanup cli script can be run to insure no cfg on switch}
    puts {   [&lt;cliFlag&gt;]: cliFlag (NO_REBOOT|NO_REBOOT_NO_DOWNLOAD, optional with regPath clitest)}
    puts {   [&lt;debugLevel&gt;]: debug level 1|2|3. The level at which the debug information is dumped when script encounters an error}
    puts {   [&lt;subversion&gt;]: subversion variable if any, used for private testing}
    puts {   [&lt;efence&gt;]: list of efence activated processes}
    puts {   [&lt;saveConfigPerTest&gt;]: enable saving of switch configuration before start of each test supported from  release 12.1}
    puts {   [&lt;stopRegOn&gt;]: testFailure|coreDump|anyFailure conditions which will cause regression to abort}
    puts {   [&lt;qId&gt;]: SC_######_######|RTP_######_###### the id of the currently running queue}
    puts {   [&lt;heapTracingProcess&gt;]: process for which heaptracing is required}
    puts {   [&lt;TrafficGen&gt;]: default = ixia.  ixia|ixvm|stc}
    puts {   [&lt;harness&gt;]: all|tcl|itest|tpb|testlink which harness cases to execute}
    puts {   [&lt;trackport&gt;]: official use only}
    puts {   [&lt;launchserver&gt;]: on|off default: on Starts a server which can interact with regression}
    puts {   [&lt;comment&gt;]: null default: could be just a note but mostly for retext control options}
    puts &#34;\r&#34;
}

<span class="comment-line"># ------------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">#      Start MAIN functionality</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># ------------------------------------------------------------------------------</span>

<span class="comment-line"># checking command parameters</span>
if {$argc&lt;3} {
    puts &#34;Not enough parameters&#34;
    <a name="::print_usage(1)"><a href="./main.tcl.html#::print_usage_91">::print_usage</a></a>
    puts stderr &#34;Not enough parameters&#34;
    return
}

parse_args main $argv {
    mode &#34;null&#34;
    module &#34;null&#34;
    cfg &#34;null&#34;
    lst &#34;dev&#34;
    tcList &#34;all&#34;
    regPath &#34;Functional&#34;
    cc &#34;&#34;
    clean &#34;no&#34;
    c     &#34;null&#34;
    cliFlag &#34;&#34;
    testlinkplan &#34;null&#34;
    build &#34;&#34;
    subversion &#34;&#34;
    obuild &#34;&#34;
    moduleArg &#34;&#34;
    debugLevel &#34;0&#34;
    randomIndex &#34;unknown&#34;
    efence &#34;no&#34;
    saveConfigPerTest &#34;no&#34;
    stopRegOn &#34;null&#34;
    qId &#34;null&#34;
    heapTracingProcess &#34;no&#34;
    ezinfofile &#34;&#34;
    ezkillfile &#34;&#34;
    TrafficGen &#34;ixia&#34;
    harness &#34;tcl&#34;
    trackport  &#34;null&#34;
    launchserver &#34;off&#34;
    comment      &#34;null&#34;
}


<span class="comment-line"># ---------------------------------------------------------</span>
<span class="comment-line"># ----             ARGUMENT VERIFCATION                ----</span>
<span class="comment-line"># ---------------------------------------------------------</span>

    <span class="comment-line">############################################################</span>
    <span class="comment-line">#  -mode is meant to determine the run state of this current test</span>
    <span class="comment-line">#     the switch command is mostly self explanitory.</span>
    <span class="comment-line">#    auto      =  results will be copied to a central repository</span>
    <span class="comment-line">#                 as well as to the &#34;Report&#34; directory</span>
    <span class="comment-line">#    autodev   =  same as auto plus init file used instead of</span>
    <span class="comment-line">#                 systemsetup and getdutinfo to save time</span>
    <span class="comment-line">#    dev       =  systemsetup and getdutinfo skipped and init</span>
    <span class="comment-line">#                 file sourced to save time</span>
    <span class="comment-line">#############################################################</span>
    set mode [string tolower $mode]
    switch $mode  {
        &#34;auto&#34;    {
            puts &#34;\n\nThis is an official automation run.&#34;
            puts &#34;The cfg file setup script and check connections will be run&#34;
            set runMode 0;
            set MAIN(runMode) 0;
                }
        &#34;autodev&#34; {
            puts &#34;\n\nThis is an autodev run&#34;;
            puts &#34;The setup script is being run&#34;;
            puts &#34;Using the initFile from a previous run&#34;;
            set runMode 1;
            set MAIN(runMode) 1;
        }
        &#34;dev&#34;     {
            puts &#34;\n\nDEVELOPMENT RUN NO UNCONFIG BOXES&#34;
            puts &#34;Using the initFile from a previous run&#34;
            set runMode 2;
            set MAIN(runMode) 2;
        }
        default  {
            puts &#34;\n\nNo -mode define!! Using -mode auto&#34;;
            puts &#34;The cfg file setup script and check connections will be run&#34;;
            set runMode 0;
            set MAIN(runMode) 0;
        }
    }

    <span class="comment-line">## module setup</span>
    if {$module == &#34;null&#34;} {
        puts &#34;\n\n-module is a required argument&#34;
        exit 1
    } else {
        puts &#34;Setting to run regression for module $module&#34;
    }
    <span class="comment-line">## cfg check</span>
    if {$cfg == &#34;null&#34;} {
        puts &#34;\n\n-cfg is a required argument&#34;
        exit 1
    }

    <span class="comment-line"># check test vendor selection</span>
    set TrafficGen [string tolower $TrafficGen]
    switch -exact -- $TrafficGen {
        stc -
        ixvm -
        stcvm -
        ixia -
        ept -
        none {
            puts &#34;main.tcl: Test vendor selection - $TrafficGen&#34;
        }
        default {
            <a name="::result_error(1)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;main.tcl: Invalid test vendor selected ($TrafficGen)\n \
                 - must be one of IXIA,IXVM,STC or NONE. Aborting...&#34;
            exit 1
        }
    }
    switch -exact -- $harness {
        all {puts &#34;\nExecuting tcl and iTest cases - tcl runs first&#34;}
        tcl {puts &#34;\nExecuting tcl cases Only&#34;}
        itest {puts &#34;\nExecuting iTest cases Only&#34;}
        tpb {puts &#34;\nExecuting in TPB mode&#34;}
        testlink {puts &#34;\nExecuting in TestLink mode&#34;}
        default {
            puts &#34;main.tcl: Invalid harness type.  \n\
               Must be \&#34;all\&#34; \&#34;tcl\&#34; \&#34;tpb\&#34; \&#34;testlink\&#34; or \&#34;itest\&#34;. Aborting...&#34;
            exit 1
        }
    }
    if { $tcList == &#34;&#34; } {
        puts &#34;Fatal Error: tcList cannot be empty. \n\
           Specify 'all' or do not give -tcList option.&#34;
        exit 1
    }
    if { $testlinkplan != &#34;null&#34; &amp;&amp; $harness != &#34;tpb&#34;} {
        <span class="comment-line">#If testplan does not appear in json exit</span>
        puts &#34;You are in Test Link Mode&#34;
        puts &#34;Your results will post to TestLink/$testlinkplan/$module/Report&#34;
    }
    if {$c != &#34;null&#34;} {
        set clean $c
    }
    switch -nocase -regexp $clean {
        y.* {
            set clean yes
        }
        n.* {
            set clean no
        }
        c.* {
            set clean cli
        } default {
            set clean yes
        }
    }
    <span class="comment-line"># Verify the regPath</span>
    set MAIN(mainPath) [pwd]
    set MAIN(origRegPath) $regPath
    set regPath [_verifyRegPathArg -regPath $regPath];<span class="comment-line"># Full/real path. Not the short one passed in</span>
    set MAIN(regPath) $regPath;<span class="comment-line"># More portable</span>
    set MAIN(feature_type) [file tail $regPath];<span class="comment-line">#</span>

    <span class="comment-line"># Rename a bunch of stuff - for compatibility</span>
    set enableAbortTestCondition $stopRegOn
    set enableSaveConfigPerTest $saveConfigPerTest
    set gHeapTracingProcess $heapTracingProcess
    set heapTraceEnabled &#34;no&#34;
    set NEWBUILD $build
    set OLDBUILD $obuild

    <span class="comment-line"># Verify the module / feature / testplan to run</span>
    set module [_verifyModuleNameArg $regPath $module];<span class="comment-line"># Set the full, verified module name</span>
    set DUTs_info(current_module) $module
    set MAIN(module) $module;<span class="comment-line"># Full path, not just the short one passed into the arg</span>
    set modName [file tail $module]; <span class="comment-line"># modName is feature_directory name</span>
    
    <span class="comment-line"># Make some cli args more portable</span>
    set MAIN(randomIndex) $randomIndex 
    set MAIN(cliFlag)     $cliFlag
    set MAIN(build)       $build
    set MAIN(subversion)  $subversion
    set MAIN(efence)      $efence
    set MAIN(qId)         $qId
    set MAIN(lst)         $lst
    set MAIN(clean)       $clean

<span class="comment-line"># ------------------------------------------------------</span>
<span class="comment-line"># ----   Set harness paths and source important files</span>
<span class="comment-line"># ------------------------------------------------------</span>

    <span class="comment-line"># -- Normalize the current directory --</span>
    set curAutoRoot [_setCurrentAutoDir]
    set MAIN(autoRoot) $curAutoRoot;<span class="comment-line"># More portable</span>
    set LIB_PATH ${curAutoRoot}/Lib
    set MAIN(LIB_PATH) $LIB_PATH
    set SYSTEM_LIB_PATH ${curAutoRoot}/SystemTest/Lib
    set MAIN(SYSTEM_LIB_PATH) $SYSTEM_LIB_PATH

    <span class="comment-line"># -- Remove user ixia environment variables from the auto_path</span>
    set auto_path [_cleanAutoPath -remove ixia]
    lappend auto_path $LIB_PATH
    lappend auto_path $SYSTEM_LIB_PATH

    <span class="comment-line"># Load TrafficGen specific libraries</span>
    switch -exact -- $TrafficGen {
        stc {
            set MAIN(IxInitialized) 0
        }
        ixia {
            set MAIN(IxInitialized) 0
        }
        ept {
        }
        default {
        }
    }

    <span class="comment-line"># -------  Create the main and lib tclIndex files -------</span>
    gen_index &#34;./../Lib&#34;
    if {[file isdirectory ./../SystemTest/Lib]} {
        gen_index &#34;./../SystemTest/Lib&#34;
    }

    puts &#34;\nDEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;

<span class="comment-line"># -------------------------------------------------------------</span>
<span class="comment-line"># -- Source important harness files. runReg,common and test bed</span>
<span class="comment-line"># -------------------------------------------------------------</span>
    if [catch {source &#34;../main/runReg.cfg&#34;} rea] {
        puts &#34;*** WARNING: Unable to source runReg.cfg:$rea............... ***&#34;
        puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
        exit -1
    }
    set sourceFile &#34;&#34;
    <span class="comment-line"># backtracked path needed for other utilties outside main to work</span>
    if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
        puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
        puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
        exit -1
    }
    if {$cfg != &#34;null&#34;} {
        set sourceFile $cfg
        if {([regexp -nocase &#34;^short&#34; $sourceFile]&amp;&amp;[regexp -nocase {/} $sourceFile]) || \
                  [regexp -nocase &#34;^pt&#34; $sourceFile]} {
            puts &#34;regPath:$regPath  module:$module  sourceFile: $sourceFile&#34;
            <span class="comment-line">#set sourceFile [format %s/%s/%s $regPath $module $sourceFile]</span>
            set sourceFile [format %s/%s $module $sourceFile]
            set sourceFile [string trim $sourceFile];
        } elseif {![regexp -nocase &#34;^cfg&#34; $sourceFile] &amp;&amp; ![regexp -nocase {/} $sourceFile]} {
            if {[file exists $sourceFile]==0} {
                set sourceFile [format %s/%s cfg $sourceFile]
                set sourceFile [string trim $sourceFile];
            }
        }
        puts &#34;Using config file: ($sourceFile)&#34;
    }
    if {[file exists $sourceFile] == 0} {
        puts &#34;Cannot find config file: $sourceFile\n&#34;
        puts stderr &#34;Cannot find config file: $sourceFile&#34;
        return
    }
    set configurationFile $sourceFile
    set MAIN(sourceFile)  $sourceFile
    set MAIN(cfg)         [file tail $cfg]
    puts &#34;**** ABOUT TO source test bed cfg $sourceFile ****&#34;
    if [catch {source $sourceFile} reason] {
        puts &#34;*** ERROR: Unable to source $sourceFile :$rea............... ***&#34;
        puts &#34;*** ERROR: Application level variables may not be defined. ***&#34;
        exit -1
    }
    <span class="comment-line"># --------  Reset globals which are initialized in common.cfg</span>
    set MAIN(feature_directory) $modName;

    <span class="comment-line"># Get the repo info</span>
    set MAIN(REPO_VERSION) [_getRepoVersion]
<span class="comment-line"># --------------------------------------------------------------------------------</span>
<span class="comment-line"># ----  Configurations for regression types / paths other than Functionaltest ----</span>
<span class="comment-line"># --------------------------------------------------------------------------------</span>
    if { [regexp -nocase &#34;cli&#34; $regPath] &amp;&amp; [info exists ixiaCh1] } {
        unset ixiaCh1 ;<span class="comment-line"># prevent Ixia from initializing for CLI run</span>
        set optionalFlag $cliFlag
    }
    <span class="comment-line"># If regPath is snmp then check whether SNMP configuraiton file exists or not</span>
    if {[regexp -nocase &#34;snmp&#34; $regPath]} {
        source ./../Lib/snmplib.tcl
        if {[file exists &#34;../main/cfg/snmp.cfg&#34;] == 0} {
            puts stderr &#34;Cannot find SNMP config file: cfg/snmp.cfg&#34;
            return
        } else {
            source ../main/cfg/snmp.cfg
            snmpInit
            puts &#34;ENVIRONMENT VARIABLE = $env(MIBS)&#34;
            puts &#34;                       $env(MIBDIRS)&#34;
            puts &#34;                       $env(SNMPCONFPATH)&#34;
        }
    }
    set optionalPath &#34;&#34;
    set optionalFlag $cliFlag
<span class="comment-line"># ----------------------------------------------------------------</span>
<span class="comment-line">#  The comment arg allows for various random variables to be set</span>
<span class="comment-line">#     in main by the handler below. Do it below sourcing cfg files</span>
<span class="comment-line">#     becauses comment may be used to overwrite the defaults</span>
<span class="comment-line"># ----------------------------------------------------------------</span>
    if {$comment != &#34;null&#34;} {
        _commentHandler &#34;$comment&#34;
    }
<span class="comment-line"># ----------------------------------------------------------------</span>
<span class="comment-line"># Error handling, report structure, main communication socket</span>
<span class="comment-line">#</span>
<span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># -- Make sure directory structure exists in main folder</span>
    _createSupportDirectories -dirList &#34;Report Result Tmp Tmp2 Log&#34;
    
    <span class="comment-line"># ----------   Set up global error display levels ----------</span>
    <span class="comment-line"># Set the showErrorData flag for multiple level debug</span>
    <span class="comment-line"># showErrorData = 0 means don't dump debug info in result_error</span>
    <span class="comment-line"># showErrorData != 0 means dump debug info in result_error a this level</span>
    set showErrorData $debugLevel
    unset debugLevel   

    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line"># Test Plan Builder Controlled TCL --</span>
    <span class="comment-line">#    TPB starts main.tcl from a wrapper in this directory tpb_main.tcl</span>
    <span class="comment-line">#    TPB uses the socket to pass tests to main.tcl and receive results</span>
    <span class="comment-line"># --------------------------------------------------------------------   </span>
    if {$harness == &#34;tpb&#34;} {
        global useSocket
        set useSocket 0
        if {$trackport != &#34;null&#34;} {
            set useSocket 1
        }

        <span class="comment-line"># --- TPB controller may run main.tcl as root. Set user to regLogin</span>
        if {[id effective user] == &#34;root&#34;} {
            puts &#34;\nTPB Controller SETTING USER TO $regLogin\n&#34;
            id user $regLogin
            set MAIN(user) $regLogin
        }
        puts &#34;TPBMainClearConsole $qId $modName $regPath $useSocket&#34;
        TPBMainClearConsole $qId $modName $regPath $useSocket
        set initsend &#34;TPB Control Session Started&#34;
        if {$launchserver == &#34;on&#34; || $trackport != &#34;null&#34;} {
            if {![OpenTPBControlPort  -port &#34;$trackport&#34;]} {
                puts &#34;&#34;;
                exit;
            }
        }
    }

<span class="comment-line"># --------------------------------------------------------------</span>
<span class="comment-line"># Expect and traffic gen libraries</span>
<span class="comment-line"># --------------------------------------------------------------</span>
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># Load Expect</span>
    <span class="comment-line">############################################################</span>
    load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
    <span class="comment-line"># --- increase the default buffer</span>
    match_max -d 200000
    log_user 0


    <span class="comment-line">############################################################</span>
    <span class="comment-line"># Setup the Ixia libraries</span>
    <span class="comment-line">############################################################</span>
    if {[info exists ixiaCh1] &amp;&amp; [regexp -nocase {[0-9]\.[0-9]+} $ixiaCh1]} {
        SetIxiaEnv &#34;$ixiaPath($ixiaCh1)&#34;
        lappend auto_path [file join $env(IXIA_HOME) &#34;lib&#34;]
    }

<span class="comment-line"># --------------------------------------------------------------</span>
<span class="comment-line"># Register this scipt and testbed with tracking db and open tracking socket</span>
<span class="comment-line"># --------------------------------------------------------------</span>
    set MAIN(TrackInit) [OpenTrackingPort -cfg &#34;[file tail $cfg]&#34; -script_name &#34;MAIN&#34; ]

<span class="comment-line"># --------------------------------------------------------------</span>
<span class="comment-line"># Decide the how to run main.</span>
<span class="comment-line">#   - In the module, for a single run</span>
<span class="comment-line">#   - A TestLink run, jumping between different directories</span>
<span class="comment-line"># --------------------------------------------------------------</span>

    <span class="comment-line"># Save the base auto_path which holds all TCL necessary up</span>
    <span class="comment-line">#     until this point.  No test case TCL procs are in yet</span>
    set MAIN(auto_path_clean) $auto_path;

    if {$testlinkplan == &#34;null&#34;} {
        <span class="comment-line"># ----------------------------------------------------------</span>
        <span class="comment-line"># If in single module mode LEGACY MAIN.TCL</span>
        <span class="comment-line"># ----------------------------------------------------------</span>
        cd $module
        set REG_PATH [pwd]
        set MAIN(REG_PATH) [pwd]

        <span class="comment-line"># Create supporting dirctories for this feature</span>
        _createSupportDirectories -dirList &#34;Report Result Tmp Log&#34;    
        
        if {[regexp -nocase &#34;^../clitest&#34; $regPath]} {
            set reportPath &#34;./Report&#34;;
            set moduleRegression [file tail $module]
            puts &#34;the moduleRegression $moduleRegression&#34;
            if {![file isdirectory $reportPath]} {
                file mkdir $reportPath;
            }
            set reportPath &#34;./Report&#34;;
            set resultPath &#34;./Result&#34;;
            set tmpPath &#34;./Tmp&#34;;
            set logPath &#34;./Log&#34;;
            set LIB_PATH &#34;../../../Lib&#34;
            lappend auto_path $LIB_PATH
            set auto_path [linsert $auto_path 0 ..]
        } else {
            set auto_path [linsert $auto_path 0 . ]
            gen_index .
            lappend MAIN(indexedList) [pwd];<span class="comment-line"># track fresh indexes</span>
            <span class="comment-line"># --- load module directory libs in other locations ---</span>
            if {[file exists lib_links.tcl]} {
                catch {source lib_links.tcl}
            }
        }
        puts &#34;\n\nmain.tcl CUR DIR: [pwd]&#34;
        <span class="comment-line"># ----------------------------------------------------------------</span>
        <span class="comment-line"># Depending on your run type - create the dir to hold results</span>
        <span class="comment-line"># ----------------------------------------------------------------</span>
        <span class="comment-line">#</span>
        <span class="comment-line">#    If normal module run  (testlinkplan=null)</span>
        <span class="comment-line">#       ./Result/&lt;timestamp&gt;_&lt;autogenindex&gt;</span>
        <span class="comment-line">#    Passing in randomIndex to main or resetting randomIndex = qid</span>
        <span class="comment-line">#       ./Result/&lt;timestamp&gt;_&lt;randomIndex&gt;</span>
        <span class="comment-line">#    Setting global MAIN(RESULTPATH) to override &#34;./Result&#34;</span>
        <span class="comment-line">#       For SystemSetup -</span>
        <span class="comment-line">#       set MAIN(RESULTPATH) &#34;$MAIN(autoRoot)/TestLink/$testlinkplan/Result&#34;</span>
        <span class="comment-line">#       For feature_dirs during the run</span>
        <span class="comment-line">#       set MAIN(RESULTPATH) &#34;$MAIN(autoRoot)/TestLink/$testlinkplan/$modName/Result&#34;</span>
        <span class="comment-line"># ----------------------------------------------------------------</span>
        get_result_dir $randomIndex;<span class="comment-line"># Create resultDir, set global</span>
    } else {
        <span class="comment-line"># -------------------------------------------------------------</span>
        <span class="comment-line"># Test Link Mode</span>
        <span class="comment-line">#   -Always execute from within the main dir.</span>
        <span class="comment-line">#   -Adjust the auto_path for feature_directories</span>
        <span class="comment-line">#   -Change the resultDir to where you want the results to post</span>
        <span class="comment-line">#</span>
        <span class="comment-line">#   Note: executeTestLink below is the first time main.tcl will</span>
        <span class="comment-line">#       know which feature_directories are going to be executed</span>
        <span class="comment-line"># -------------------------------------------------------------</span>
        lappend tlDirs &#34;../TestLink&#34;
        lappend tlDirs &#34;../TestLink/$testlinkplan&#34;
        _createSupportDirectories -dirList $tlDirs
        set MAIN(RESULTPATH) &#34;$MAIN(autoRoot)/TestLink/$testlinkplan/Result&#34;
        set MAIN(RESULTDIR) [get_result_dir $randomIndex];<span class="comment-line">#</span>
    }
    <span class="comment-line"># My need to move this.  Probably will be used for variable dir posting</span>
    set MAIN(optionalPath) $optionalPath
<span class="comment-line"># -------------------------------------------------------------------</span>
<span class="comment-line"># -------------------------------------------------------------------</span>

<span class="comment-line"># Start the run</span>

<span class="comment-line"># -------------------------------------------------------------------</span>
<span class="comment-line"># Set the xterm title if the common.cfg flag is on</span>
<span class="comment-line"># -------------------------------------------------------------------</span>
SetTerminalTitle -add &#34;MAIN GetDutsInfo&#34;

<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line"># Harness specific / Test bed variable gathering</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">#dummy first file</span>
    set fd_main_skip [open_result_file &#34;skipTestsList&#34;];
    close_result_file

    <span class="comment-line"># --- Create the main_log file for capturing harness related log messages</span>
    open_mainlog_file; <span class="comment-line"># open main_log.txt in the result dir. (WriteToMainLog $text)</span>

    <span class="comment-line"># #########################################################</span>
    <span class="comment-line"># ---- Open the main.txt result file to hold init dut learn</span>
    <span class="comment-line"># #########################################################</span>
    _initDUTs_infoArray;
    set numDUT $MAIN(NODECOUNT)
    set fd_res [open_result_file &#34;init_switchinfo&#34;]
    result_h1 &#34;[file tail [pwd]] Test&#34;
    if {$MAIN(runMode) &lt; 2 || $harness == &#34;tpb&#34;} {

        <span class="comment-line"># --------------------------------------------------------</span>
        <span class="comment-line"># Gather DUTs_info variables that are not Software Related</span>
        <span class="comment-line">#   - loop to get the DUT count and build multitask procs</span>
        <span class="comment-line"># --------------------------------------------------------</span>
        set getInfoList &#34;&#34;
        foreach dut $MAIN(DUTLIST) {
            puts &#34;***** DUT${dut}_CONNECT=[set DUT${dut}_CONNECT] ***** &#34;
            puts &#34;***** numDUT=$dut ***** &#34;
            _SetPartitionVars -dut $dut;<span class="comment-line"># Get port info from cfg file</span>
            set wayToBootPart($dut) &#34;setupScript&#34;
            Login [set DUT${dut}_CONNECT] -masterCheck 1 -CheckOperational 1
            SendACmd &#34;disable log display&#34;
            lappend getInfoList  &#34;_get_HW_DUTs_info -dut $dut -checkOperational 0&#34;
            if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
                lappend makeXsfList &#34;CreateDefaultXsf -dut $dut&#34;
            }
        }
        foreach sBy $MAIN(STDBYLIST) {
            if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
                lappend makeXsfList &#34;CreateDefaultXsf -dut none -standby $sBy&#34;
            }
        }
        <a name="::result_debug(1)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;------------------  Gather DUT Information  ------------------&#34;
        MultiTask $getInfoList
        _printMultiTaskOutput;<span class="comment-line"># show the output in order + in result file</span>
        <span class="comment-line">#_printDutsInfoVars</span>
    } else {
        foreach dut $MAIN(DUTLIST) {
            puts &#34;***** DUT${dut}_CONNECT=[set DUT${dut}_CONNECT] ***** &#34;
            puts &#34;***** numDUT=$dut ***** &#34;
            set wayToBootPart($dut) &#34;setupScript&#34;;<span class="comment-line"># should be dev mode so not needed.</span>
            _SetPartitionVars -dut $dut;<span class="comment-line"># Get port info from cfg file</span>
            Login [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0
            lappend cleancliList &#34;allCleanup $dut&#34;
        }
        if {$MAIN(runMode) == &#34;2&#34; &amp;&amp; ($MAIN(clean) == &#34;cli&#34; || $MAIN(clean) == &#34;yes&#34;)} {
            puts &#34;\n\n# ------------------------------------------------------------------&#34;
            puts &#34;               S T A R T I N G     PARALLEL CLI CLEANUP&#34;
            puts &#34;# ------------------------------------------------------------------&#34;
            _setShowOutput -screen off -log off -res_fmt on
            MultiTask $cleancliList
            _setShowOutput -screen on -log on -res_fmt on
            puts &#34;\n# ------------------------------------------------------------------&#34;
            puts &#34;               E N D               PARALLEL CLI CLEANUP&#34;
            puts &#34;# ------------------------------------------------------------------&#34;
        }
    }
    <span class="comment-line"># ----- Just in case failsafe passwords where hit in a fork, we need to log back in</span>
    if {$MAIN(FAILSAFEHIT)} {
        set fDUT 1
        while { $fDUT &lt;= $MAIN(NODECOUNT) } {
            Login [set DUT${fDUT}_CONNECT] -CheckOperational 1
            incr fDUT 1
        }
    }
    close_result_file;<span class="comment-line"># end of main.txt</span>
<span class="comment-line"># -------------------------------------------------------------------------------------</span>
<span class="comment-line"># Check Feature content available for this test bed</span>
<span class="comment-line"># -------------------------------------------------------------------------------------</span>
    if {$testlinkplan != &#34;null&#34;} {
        <span class="comment-line">#_validTestLinkSupport</span>
    } else {
        set fd_res [open_result_file &#34;main&#34;]
        result_h1 &#34;[file tail [pwd]] Starting Test&#34;
        set MAIN(NOFEATSUPPORT) 0
        <span class="comment-line"># ---------------------------------------------------------------------</span>
        <span class="comment-line">#          FEATURE SUPPORT ON THIS PLATFORM SECTION</span>
        <span class="comment-line">#</span>
        <span class="comment-line">#      Use the global MAIN(NOFEATSUPPORT) 0|1</span>
        <span class="comment-line">#      if a skip is found the next section will end main    </span>
        <span class="comment-line"># ---------------------------------------------------------------------</span>

        <span class="comment-line"># ---------------------------------------------------------</span>
        <span class="comment-line"># bcmLynx feature checks</span>
        <span class="comment-line"># ---------------------------------------------------------</span>
        if {[regexp -nocase $bcmLynx $DUTs_info(DUT1,platform)]} {
            <a name="::result_debug(2)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT platform is $DUTs_info(DUT1,platform) a bcmLynx&#34;
            if {[lsearch $lynxIncludeModList [file tail $module]] == -1 } {
                <a name="::result_debug(3)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;This module [file tail $module] skipped for Lynx platform&#34;
                if {$harness == &#34;tpb&#34;} {
                    <a name="::result_debug(4)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skip all TPB cases for this feature&#34;
                    <span class="comment-line">#_TPBLynxExecution</span>
                } else {
                    <span class="comment-line">#report_start_test &#34;Lynx Skip $MAIN(feature_directory) on $DUTs_info(DUT1,platform)&#34;</span>
                    <span class="comment-line">#result_skip &#34;Lynx Skip $MAIN(feature_directory) on $DUTs_info(DUT1,platform)&#34;</span>
                    <span class="comment-line">#report_end_test;</span>
                }
                set MAIN(NOFEATSUPPORT) 1
            }
        }
        <span class="comment-line"># ---------------------------------------------------------</span>
        <span class="comment-line"># Other feature support checking</span>
        <span class="comment-line">#</span>
        <span class="comment-line"># use plats_to_run(all) OR plats_to_skip(all)</span>
        <span class="comment-line"># ---------------------------------------------------------</span>

        if {[catch {source ./completetests.lst} reason]} {
            puts &#34;Sourcing [pwd] completetest.lst failed: $reason&#34;
        } else {
            if {[info exists FEATPLAT(SupportedTypes)] &amp;&amp; [info exists FEATPLAT(SupportedDUTs)]} {
                if {$FEATPLAT(SupportedTypes) != &#34;all&#34;} {
                    set p 0
                    foreach sysNStr $FEATPLAT(SupportedTypes) {
                        if {[regexp -nocase &#34;all&#34; [lindex $FEATPLAT(SupportedDUTs) $p]]} {
                            for {set d 1} {$d&lt;=$MAIN(NODECOUNT)} {incr d} {
                                if {![regexp -nocase &#34;$sysNStr&#34; $DUTs_info(DUT$d,sysType)]} {
                                    <a name="::result_debug(5)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                     &#34;$DUTs_info(DUT$d,sysType) System Type Not supported by $MAIN(feature_directory):$sysNStr&#34;
                                    set MAIN(NOFEATSUPPORT) 1
                                }
                            }
                        } else {
                            foreach d [lindex $FEATPLAT(SupportedDUTs) $p] {
                                if {$p &gt; $MAIN(NODECOUNT)} {
                                    <a name="::result_error(2)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;There are not $p DUTs in this Test Bed.  Wrong test bed type?&#34;
                                    set MAIN(NOFEATSUPPORT) 1
                                    TrackingCleanup
                                    exit;
                                }
                                if {![regexp -nocase &#34;$sysNStr&#34; $DUTs_info(DUT$d,sysType)]} {
                                    <a name="::result_debug(6)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                     &#34;$DUTs_info(DUT$d,sysType) System Type Not supported by $MAIN(feature_directory):$sysNStr&#34;
                                    set MAIN(NOFEATSUPPORT) 1
                                }
                            }
                        }
                    }
                }
            }
            if {[info exists FEATPLAT(PlatNoSupport)] &amp;&amp; [info exists FEATPLAT(NoSupportDuts)]} {
                set p 0
                foreach platStr $FEATPLAT(PlatNoSupport) {
                    if {[regexp -nocase &#34;all|any&#34; [lindex $FEATPLAT(NoSupportDuts) $p]]} {
                        for {set d 1} {$d&lt;=$MAIN(NODECOUNT)} {incr d} {
                            if {[regexp -nocase &#34;$platStr&#34; $DUTs_info(DUT$d,platform)]} {
                                <a name="::result_debug(7)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                 &#34;$DUTs_info(DUT$d,platform) Platform Not supported by $MAIN(feature_directory):$platStr&#34;
                                set MAIN(NOFEATSUPPORT) 1
                            }
                        }
                    } else {
                        foreach d [lindex $FEATPLAT(NoSupportDuts) $p] {
                            if {$p &gt; $MAIN(NODECOUNT)} {
                                <a name="::result_error(3)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;There are not $p DUTs in this Test Bed.  Wrong test bed type?&#34;
                                set MAIN(NOFEATSUPPORT) 1
                                TrackingCleanup
                                exit;
                            }
                            if {[regexp -nocase &#34;$platStr&#34; $DUTs_info(DUT$d,platform)]} {
                                <a name="::result_debug(8)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                 &#34;$DUTs_info(DUT$d,platform) Platform Not supported by $MAIN(feature_directory):$platStr&#34;
                                set MAIN(NOFEATSUPPORT) 1
                            }
                        }
                    }
                }
            }
        }
    };<span class="comment-line"># End the non test link TCL skip check</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line">#  Cleanup and exit main.tcl for features that are not supported</span>
<span class="comment-line">#  on this test bed</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
    if {$MAIN(NOFEATSUPPORT)} {
        set retFlag testSkipped
        ;<span class="comment-line"># Setup Durations with a not covered feature</span>
        set tSetupStart [clock seconds]
        set tSetupDuration [expr $tSetupStart - $tStartTime]
        set MAIN(tSetupDuration) $tSetupDuration

        if {$harness == &#34;tpb&#34;} {
            <a name="::result_debug(9)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skip all TPB cases for this feature&#34;
            _TPBLynxExecution
            <a name="::result_debug(10)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;End Skip all TPB cases for this feature&#34;
        } else {
            _initCompleteTests -regPath $MAIN(regPath) -module $modName \
                 -version $DUTs_info(DUT1,version) -platform $DUTs_info(DUT1,platform) \
                 -lst $lst
            <span class="comment-line">#CTLIST(quick_pass_all_dev)</span>
            if ([info exists CTLIST($LSTGROUPING($lst))]) {
                if {[set fd_main_skip [open &#34;[get_result_dir]/skipTestsList.txt&#34;\
                  &#34;w&#34;]] == -1} {
                       return -1
                }
                set MAIN(MAKESKIPRESULTFILE) 1;<span class="comment-line"># create the tc.txt result files and put entries in report.txt</span>
                foreach st $CTLIST($LSTGROUPING($lst)) {
                    if {[regexp -nocase &#34;init|end&#34; $st]} {
                        continue;
                    }
                    if {[catch {eval $st} tc]} {
                    } else {
                        puts $fd_main_skip &#34;$tc&#34;
                    }
                }
                set MAIN(MAKESKIPRESULTFILE) 0
                close $fd_main_skip
            }
        }
        save_incrementally_run_data
        set repDir [create_report_directory &#34;$sourceFile&#34; &#34;no&#34; &#34;$optionalPath&#34; &#34;&#34; &#34;$subversion&#34; &#34;$qId&#34;]
        if {$harness == &#34;tpb&#34;} {
            set dir [string trimleft [pwd] &#34;$autoPath&#34;]
            set link &#34;http://${RESWEB}/${dir}/${repDir}/&#34;
            puts &#34;\n\n@@@@ TPB TCL Report Link @@@@&#34;
            puts &#34;\&#34;$link\&#34;&#34;
            puts &#34;@@@@ Test Builder END Report Link @@@@\n&#34;
        }

        <span class="comment-line"># Cleanup all of the main.tcl harness files..move to report dir</span>
        set returnFlag [_cleanAndStoreResults -returnFlag $retFlag]


        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <span class="comment-line"># Print to stderr so any tracking wrapper can make decisions</span>
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        puts stderr $returnFlag
        flush stderr
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <span class="comment-line"># Module mode of main.tcl runs regressions from with the feature dir</span>
        <span class="comment-line">#    Return to main directory</span>
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        puts &#34;Made it to the feature end - location [pwd]&#34;
        cd $MAIN(mainPath)
        puts &#34;Made it to the end of main - location [pwd]&#34;
        return $returnFlag
    }
<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line"># END of CLEANUP FOR FEATURES NOT SUPPORTED ON THIS TEST BED</span>
<span class="comment-line"># --------------------------------------------------------------------</span>

<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line"># Continue for supported fetures.</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># MODE auto,autodev,dev Init Setup</span>
    <span class="comment-line">############################################################</span>
    set MAIN(initFile) [GetInitFileName $curAutoRoot $cfg]

    <span class="comment-line"># -- MAIN(runMode) &gt; 0 check for the init and verify source of init</span>
    <span class="comment-line">#    If this fails, change to MAIN(runMode) 0 and create a new initFile</span>
    <span class="comment-line">#    source the init file with VerifyInitFile</span>
    if {($MAIN(runMode) &gt;= 1) &amp;&amp; (![file exists $MAIN(initFile)]) || \
        ($MAIN(runMode) &gt;= 1 &amp;&amp; ![VerifyInitFile $MAIN(initFile)])} {
        puts &#34;\n@\n@\nInit check failed\n@\n@&#34;
        set MAIN(runMode) 0
    }
    if {$MAIN(runMode) == 0} {
        catch {open $MAIN(initFile) &#34;w&#34;} MAIN(ifPipe)
        if {[regexp -nocase &#34;denied&#34; $MAIN(ifPipe)]} {
            puts &#34;@\n@\nNO INIT FILE WILL BE CREATED. ERROR OPENING FILE\n@\n@&#34;
            set MAIN(ifPipe) NULL
        }        
    }
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># --- Take ownership of the traffic generator</span>
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># Spirent is auto set if the chassis is defined in the cfg</span>
    if {[info exists ixiaCh1] &amp;&amp; [info exists SPIRENTCH1] &amp;&amp; ![regexp -nocase {[0-9]+\.\[0-9]+} $ixiaCh1]} {
        set TrafficGen stc
    }
    switch -exact -- $TrafficGen {
        stc {
            set ::_DEBUG 0
            set MAIN(skipIxInit) 0; set MAIN(IxiaReady) 1;
            set ::LABSERVER $stcLabserver($SPIRENTCH1)
            set env(IXIA_HOME) null
            lappend auto_path &#34;/auto/ixia_5_70/lib/mpexpr-1.1/&#34;
            overWriteProcs $LIB_PATH [file join $LIB_PATH spirent]
            source [file join $LIB_PATH ePTLib ePTUtils.tcl]
            logcmd set auto_path [linsert $auto_path 1 $stcPath($SPIRENTCH1)]
            <span class="comment-line">#logcmd lappend auto_path $stcPath($SPIRENTCH1)</span>
            stcInit $LABSERVER
            package require Mpexpr
            puts &#34;\n\nPackage Require SpirentTestCenter - Ch:$SPIRENTCH1 LS:$::LABSERVER&#34;
            logcmd package require SpirentTestCenter
            GenerateDUTPortMapping; <span class="comment-line"># Add here temporarily b/c called in SystemSetup</span>
            set returnFlag &#34;connectionOkay&#34;
            ReservePorts
            set MAIN(IxInitialized) 1
        }
        ixia -
        ixvm {
            if {[shareDevInit] == -1} {
                set returnFlag &#34;connectionBad&#34;
                <a name="::result_error(4)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34; IXIA Reservation FAILED&#34;
            } else {
                set MAIN(IxInitialized) 1
                <a name="::result_debug(11)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34; IXIA Reservation OK&#34;
    <span class="comment-line"># move this</span>
                if {[file exists &#34;license.lst&#34;]} {
                    source &#34;./license.lst&#34;
                    <a name="::result_debug(12)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;license.lst file found. sourcing the contents&#34;
                }
            }
        }
        ept {
        }
        default {
        }
    }
<span class="comment-line"># ----------------------------------------------------------------------------</span>
<span class="comment-line">#   Start the run.</span>
<span class="comment-line">#   - run setup script for auto and autodev</span>
<span class="comment-line">#   - get DUTs info if auto mode</span>
<span class="comment-line">#   - checkConnections</span>
<span class="comment-line"># ---------------------------------------------------------------------------</span>
    if {($MAIN(runMode) != &#34;2&#34;)} {
        <span class="comment-line"># ----  NOT dev mode, unc sw will happen, create default.xsf ----</span>
        if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
            <a name="::result_debug(13)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;------------------  Create default.xsf of all DUTs  ------------------&#34;
            _setShowOutput -screen off -log off -res_fmt off
            MultiTask $makeXsfList
            _setShowOutput -screen on -log on -res_fmt on
        }
        <span class="comment-line"># ----  Execute the setup script from bottom of cfg file  ----</span>
        set runSetupRetVal [_multiRunSetupScript]
        if {$runSetupRetVal==-1} {
            puts stderr &#34;testSkipped&#34;
            if {[set fd_main_skip [open &#34;[get_result_dir]/skipTestsList.txt&#34;\
            &#34;w&#34;]] == -1} {
                return -1
            }
            puts $fd_main_skip &#34;FeatureSkipped&#34;
            close $fd_main_skip
            return -1
        } elseif { $runSetupRetVal==&#34;REGROUTER_FAILED&#34; } {
            puts stderr $returnFlag
            flush stderr
            return $runSetupRetVal
        }

        <span class="comment-line">#added following definition to aid per module report-mailing</span>
        global DUTs_info

        set DUTs_info(current_module) $module

        <span class="comment-line">#Capture the number of DUT for the MAIN(ifPipe) setup file</span>
        if {$MAIN(ifPipe) != &#34;NULL&#34;} {
            puts $MAIN(ifPipe) &#34;set numDUT $numDUT&#34;
        }

        if {$MAIN(runMode) == 0} {
            global eware_dut
            set dutlst &#34;&#34;

            if {[set rc [get_DUTs_info]] != 0} {
                <a name="::result_error(5)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
                close_result_file;
                return -2;
            }

        }
    }

    ;<span class="comment-line"># Setup Durations with a covered feature</span>
    set tSetupStart [clock seconds]
    set tSetupDuration [expr $tSetupStart - $tStartTime]
    set MAIN(tSetupDuration) $tSetupDuration
    set tCheckConnectionDuration 0

    <span class="comment-line">#############################################################################</span>
    <span class="comment-line"># Verify the test bed connections and gather port variables</span>
    <span class="comment-line">#############################################################################</span>
    <span class="comment-line">#  Skip SystemSetup if &#34;autodev&#34; or &#34;dev&#34; are selected</span>
    if {$MAIN(runMode) == 0 &amp;&amp; ![regexp -nocase &#34;^../clitest&#34; $regPath]} {
        <span class="comment-line"># added for checkConnection overRide if necessary</span>
        if {$cc != &#34;&#34;} {
            set checkConnection $cc;
        }

        switch -exact -- $TrafficGen {
            stc {
                set returnFlag [SystemSetup]
                set tCheckConnectionDuration [expr [clock seconds] - $tSetupStart]
                set MAIN(tCheckConnectionDuration) $tCheckConnectionDuration
            }
            ixia -
            ixvm {
                if {[info exists ixiaCh1]} {
                    if {![regexp -nocase &#34;no_ixia&#34; $ixiaCh1]} {
                        set returnFlag [SystemSetup]
                        set tCheckConnectionDuration [expr [clock seconds] - $tSetupStart]
                        set MAIN(tCheckConnectionDuration) $tCheckConnectionDuration
                    } else {
                        set returnFlag connectionOkay
                    }
                } else {
                    set returnFlag connectionOkay
                }
            }
            default {
                <span class="comment-line"># no test equipment selected, assume connection OK</span>
                set returnFlag connectionOkay
            }
        }
    } else {
        if {$MAIN(runMode)==0 &amp;&amp; $MAIN(ifPipe) != &#34;NULL&#34;} {
            close $MAIN(ifPipe);
            set MAIN(ifPipe) &#34;NULL&#34;
        }
        source $MAIN(initFile); <span class="comment-line"># Get all test bed variables from the main/Tmp/DUTsINFO tmp file</span>
        set returnFlag connectionOkay
        foreach dut $MAIN(DUTLIST) {
            set connect [set DUT${dut}_CONNECT]
            Login $connect -CheckOperational 0
            set buf [SendACmd &#34;clear log st&#34;]  ;<span class="comment-line"># Check if MSM is backup, abort</span>
            set backupStr &#34;Error: This command can only be executed on Master&#34;
            if {[regexp -nocase $backupStr $buf]} {
                <a name="::result_error(6)"><a href="./loadConsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Backup encountered, aborting&#34;
                return -1
            }
            
            <span class="comment-line"># set correct time</span>
            set tm [exec date &#34;+%m %d %Y %H %M %S&#34;]
            set timeCmd &#34;configure time &#34;
            append timeCmd $tm
            SendACmd $timeCmd
            
            SendACmd &#34;disable clipa&#34;
            SendACmd &#34;disable idletime&#34;
            SendACmd &#34;disable edp ports all&#34;
            SendACmd &#34;con edp advertisement-interval 60 holddown-interval 180&#34;
            SendACmd &#34;configure default delete port all&#34;
            SendACmd &#34;disable stp s0&#34;
            if {[CompareRelease [GetVersion DUT${dut}] 22.2.0.26]&gt;=0} {
                SendACmd &#34;configure cli column 248&#34;
            }
            global DUTs_info bcmStackable bcmPlatform
            if {[info exists DUTs_info(DUT${dut},coreFileTarget)]} {
                SendACmd &#34;configure debug core-dumps $DUTs_info(DUT${dut},coreFileTarget)&#34;
            }
        }
        switch -exact -- $TrafficGen {
            stc {
            }
            ixia -
            ixvm {
                if {$ixiaCh1 != &#34;NO_IXIA&#34;} {
                    smallIxiaInit
                }
            }
            ept {
            }
            default {
            }
        }
    }
    if {$MAIN(ifPipe) != &#34;NULL&#34;} {
       flush $MAIN(ifPipe)
    }
<span class="comment-line"># ---------------------------------------------------------------------------------</span>
<span class="comment-line"># End of Variable Gathering and CheckConnections</span>
<span class="comment-line"># ---------------------------------------------------------------------------------</span>
if {$retFlag == &#34;testSkipped&#34;} {
    set tEndTime [clock seconds]
    set MAIN(MainDuration) [expr $tEndTime-$tStartTime]

    <a name="::result_debug(14)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n*** Time for [file tail [pwd]] Regression test = $MAIN(MainDuration) seconds&#34;
    <a name="::result_debug(15)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;***    ( [formatSeconds $MAIN(MainDuration)] )\n\n&#34;

    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    <span class="comment-line"># Move the execution to the final request.</span>
    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    set returnFlag [lindex $returnFlag 0]
    _cleanAndStoreResults -returnFlag $returnFlag

    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    <span class="comment-line"># Print to stderr so any tracking wrapper can make decisions</span>
    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    puts stderr $returnFlag
    flush stderr
    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    <span class="comment-line"># Module mode of main.tcl runs regressions from with the feature dir</span>
    <span class="comment-line">#    Return to main directory</span>
    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    close_result_file
    TrackingCleanup
    puts &#34;Made it to the feature end - location [pwd]&#34;
    cd $MAIN(mainPath)
    puts &#34;Made it to the end of main - location [pwd]&#34;
    exit;
}

<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Create EXOS log filter on the test bed</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
CreateRegLogFilter
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Create debug cli procedure and source commands</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
CalculateDebug $modName $showErrorData;
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Figure out what tests to run</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
set MAIN(initAdminCheck) 0;<span class="comment-line"># At this point admin is assumed. Avoid hitting in script</span>

    _initCompleteTests -regPath $MAIN(regPath) -module $modName \
        -platform $DUTs_info(DUT1,platform) -lst $lst \
        -version $DUTs_info(DUT1,version)

<span class="comment-line"># If tests_to_run not defined so far, try to source now</span>
<span class="comment-line"># If this were a re-run, we would use a pt_xxx cfg file which would contain</span>
<span class="comment-line"># tests_to_run in it.  In this case, we don't need to &#34;figure out&#34; which</span>
<span class="comment-line"># tests to run.</span>
    set fName &#34;&#34;

    ;<span class="comment-line"># Go to the CLITest/&lt;module&gt; directory to source completetests.lst</span>
    set curDir [pwd]
    if [regexp -nocase &#34;CLItest&#34; $curDir] {
        puts &#34;Temporily changing directory to  ../../$clitestDir/$modName&#34;
        cd ../../$clitestDir/$modName
    } 
    set testsToRun [calculateTestToRun $lst [GetPlatform]]
    array set init_tests_to_run $testsToRun
    array set tests_to_run $testsToRun

    ;<span class="comment-line"># Go back to old directory</span>
    cd $curDir


<span class="comment-line">#    _initCompleteTests -regPath $MAIN(regPath) -module $modName \</span>
<span class="comment-line">#                           -platform $DUTs_info(DUT1,platform) -lst $lst</span>

<a name="::result_debug(16)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DEBUG PRINTING -- tests to run [parray tests_to_run]&#34;

AddTestbedInfoToDUTs_info;

<span class="comment-line">#only start test if connections checked to be okay</span>
<span class="comment-line">#then eval each tests_to_run array var based on version index</span>

if { $returnFlag == &#34;connectionOkay&#34; } {
    set MAIN(startexecution) 1
    set MAIN(timeFile) &#34;[get_result_dir { $randomIndex }]/execTime.txt&#34;
    
    <a name="::result_debug(17)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a>  &#34;*********** DUT1 VERSION : [GetVersion DUT1] Your HARNESS: $harness timefile $MAIN(timeFile) *****************&#34;

    

    if {$harness == &#34;itest&#34;} {
        <span class="comment-line"># This case is for tcList passed in or a lst file from rdureg, which is similar to tcList</span>
        if {$tcList != &#34;all&#34; || [file exists $lst]} {
               if {$tcList != &#34;all&#34;} {
                   set outList $tcList
               } else {
                   set outList &#34;&#34;
                   foreach testcase $init_tests_to_run(all) {
                       lappend outList $testcase
                   }
		   set tcList $outList
               }
        }
    } elseif {$harness == &#34;tcl&#34; || $harness == &#34;all&#34;} {
        <span class="comment-line"># This case is for tcList passed in or a lst file from rdureg, which is similar to tcList</span>
        if {$tcList != &#34;all&#34; || [file exists $lst]} {
             if {$harness == &#34;all&#34;} {
                global lst
                <a name="::result_debug(18)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Test case list defined on command line: $tcList&#34;
                unset tests_to_run
                set tests_to_run [list]
                set tmpTCList &#34;&#34;
                if {$tcList != &#34;all&#34;} {
                    foreach testcase $tcList {
                        lappend tmpTCList $testcase
                    }
                } else {
                    foreach testcase $init_tests_to_run(all) {
                        puts $testcase
                        lappend tmpTCList $testcase
                    }
                }
                puts &#34;tmpTCList is $tmpTCList&#34;
                puts &#34;[GetCfgTestList $DUTs_info(DUT1,platform) $tmpTCList [GetVersion DUT1] inList outList]&#34;
                puts &#34;TCL Cases: $inList&#34;
                foreach testcase $inList {
                    set tests_to_run &#34;$tests_to_run\n$testcase&#34;
                }
                puts &#34;outList: $outList&#34;
                set tcList $outList
                puts &#34;NEW tcList $tcList&#34;
                set lst &#34;custom&#34;
            } else {
                global lst
                <a name="::result_debug(19)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Test case list defined on command line: $tcList&#34;
                unset tests_to_run
                set tests_to_run [list]
                if {$tcList != &#34;all&#34;} {
                    foreach testcase $tcList {
                        set tests_to_run &#34;$tests_to_run\n$testcase&#34;
                    }
                } else {
                    foreach testcase $init_tests_to_run(all) {
                        set tests_to_run &#34;$tests_to_run\n$testcase&#34;
                    }
                }
                set lst &#34;custom&#34;
            }
        }

        if { [array size tests_to_run] == 0 } {
            ;<span class="comment-line"># Convert old list style to array</span>
            set tempList $tests_to_run
            unset tests_to_run
            set tests_to_run(all) $tempList
            puts &#34;set tests_to_run(all) $tempList&#34;
        }

        set testtorunNo 1

        ;<span class="comment-line"># Array of tests_to_run() lists. i.e. tests_to_run(all), tests_to_run(7.0),etc.</span>
        set indexList [array names tests_to_run]      
        mainSort indexList

        ;<span class="comment-line"># create the reportdir.txt filedirectory</span>
        create_report_directory $sourceFile no $optionalPath &#34;&#34; $subversion $qId
    
        foreach arrayIndex $indexList {
            puts &#34;Index Loop $arrayIndex&#34;
            set ver [string tolower $arrayIndex]

            if { (&#34;$ver&#34; == &#34;all&#34;) || (&#34;$ver&#34; == &#34;null&#34;) \
                   || [CompareRelease $ver [GetVersion DUT1 ]] &lt;= 0 } {

                if {[regexp -nocase &#34;clitest&#34; $regPath]} {
                    set returnFlag [executeCLITestsToRun $tests_to_run($ver) \
                        $regPath $testtorunNo]

                    if {$returnFlag == &#34;testCompleted&#34;} {
                        incr testtorunNo
                        cleanup
                    }
                } else {
                    if {$harness == &#34;tcl&#34; || $harness == &#34;all&#34;} {
                        set returnFlag [<a name="::executeTestsToRun(1)"><a href="./maindiag.tcl.html#::executeTestsToRun_83">::executeTestsToRun</a></a> $tests_to_run($ver)]
                        if { ($returnFlag==-1) || ($returnFlag == &#34;testSkipped&#34;) || ($returnFlag == &#34;REGROUTER_FAILED&#34;) } {
                            break
                        }
                        if {$FAILLOCK==&#34;yes&#34; &amp;&amp; $returnFlag == &#34;testCompleted&#34; &amp;&amp; $DEBUGFAILLOCK &gt; 0} {
                            puts &#34;Main.tcl hit user lock on fail case&#34;
                            break
                        }
                    }
               }

           } else {
               set returnFlag &#34;testSkipped&#34;
           }
        }
    } elseif {$harness == &#34;tpb&#34;} {
        set testtorunNo 1
        ;<span class="comment-line"># create the reportdir.txt filedirectory</span>
        create_report_directory $sourceFile no $optionalPath &#34;&#34; $subversion $qId

        set what [GetCleanTestList dev]
        set verList [GetVerSkipList dev]
        puts &#34;*****\n*****ALL:\n$what\n*****\n*****&#34;
        puts &#34;*****\n*****VERSKIP:\n$verList\n*****\n*****&#34;
        set mydev [GetCleanTestList devonly]
        puts &#34;*****\n*****DEVONLY:\n$mydev\n*****\n*****&#34;
        set mydebug [GetCleanTestList debugonly]
        puts &#34;*****\n*****DEBUGONLY:\n$mydebug\n*****\n*****&#34;

        set elist &#34;&#34;
        if {[file isfile license.lst] &amp;&amp; \
            [regexp $bcmLynx $DUTs_info(DUT1,platform)]} {
            source license.lst
            foreach edgetc $license_to_run(edge) {
                lappend elist $edgetc
            }
            puts &#34;Found EDGE: $elist&#34;
        }
        set ALLPLATTESTS $what
        set ALLPLATDEV $mydev
        set ALLPLATDEBUG $mydebug
        set ALLPLATEDGE $elist
        set SKIPVERTESTS $verList
        set currInit &#34;&#34;
        set currEnd &#34;&#34;
        set hitPair 0
        set numInit &#34;A&#34;
        set numEnd &#34;B&#34;
        foreach w $what {
            if {[regexp -nocase &#34;init&#34; $w]} {
                if {!$hitPair} {
                    set currInit &#34;&#34;
                    set numInit &#34;&#34;
                    set currEnd &#34;&#34;
                    set numEnd &#34;&#34;
                }
                regsub -all &#34;\.init&#34; $w &#34;&#34; myInit
                set currInit $w
                set numInit $myInit
            }
            if {[regexp -nocase &#34;end&#34; $w]} {
                regsub -all &#34;\.end&#34; $w &#34;&#34; myEnd
                set currEnd $w
                set numEnd $myEnd
            }
            if {$numEnd == $numInit} {
                puts &#34;found pair $currInit - $currEnd&#34;
                set initEndScript($currInit) $currEnd
                set INITBYENDSCRIPT($currEnd) $currInit
                set currInit &#34;&#34;
                set numInit &#34;&#34;
                set currEnd &#34;&#34;
                set numEnd &#34;&#34;
                set hitPair 1
            }
        }
        set currInit &#34;NULL&#34;
        set currEnd &#34;&#34;
        foreach w $what {
            if {[regexp -nocase &#34;init&#34; $w]} {
                set currInit $w
            } elseif {[regexp -nocase &#34;end&#34; $w]} {
                set currInit NULL
            } else {
                if {[info exists initEndScript($currInit)]} {
                   set blockEnd $initEndScript($currInit)
                } else {
                   set blockEnd &#34;NULL&#34;
                }
                set TESTPRE($w) $currInit
                set TESTPOST($w) $blockEnd
                puts &#34;Prereq $currInit  TestCase $w  TestCleanup $blockEnd&#34;
            }
        }
        set useSocket 0
        if {$trackport != &#34;null&#34;} {
            set useSocket 1
        }
        create_report_directory $sourceFile no $optionalPath &#34;&#34; $subversion $qId
        if {[set tpblogfile [open &#34;[get_result_dir { $randomIndex }]/tpblogfile.txt&#34; \
           &#34;w&#34;]] == -1} {
              puts &#34;Opening the tpblogfile failed&#34;
        }
        set returnFlag &#34;[executeTestsToRunTPB $tpblogfile $useSocket]&#34;
        close $tpblogfile 
        if { ($returnFlag==-1) || ($returnFlag == &#34;testSkipped&#34;) } {
            break
        }
        global EX_REPORT_DATA
        <span class="comment-line">#result_debug &#34;\n\n!!! returnFlag:$returnFlag  Returned test data:\n$EX_REPORT_DATA\n\n&#34;</span>
    }
    if {($harness == &#34;itest&#34; || $harness == &#34;all&#34;) &amp;&amp; ([lsearch $ITESTMODS $modName] &gt;= 0 || [lsearch $DEVITESTMODS $modName] &gt;= 0)} {
        set nDUT 1
        while { [info exists DUT${nDUT}_CONNECT] } {
            set connect [set DUT${nDUT}_CONNECT]
            Login $connect -CheckOperational 0
            SendACmd &#34;disable log display&#34;
            logout
            incr nDUT 1
	   
        }

        if {$harness == &#34;all&#34; &amp;&amp; $tcList != &#34;all&#34;} {
            set tcList $outList
        }
        <span class="comment-line"># Determine if this is a devlopment module that has a different itar path</span>
        if {[lsearch $DEVITESTMODS $modName] &gt;= 0} {
            set MODPATHDEF [lindex $DEVITESTMODPATH [lsearch $DEVITESTMODS $modName]]
            set ITARPATHDEF [lindex $DEVITESTITARPATH [lsearch $DEVITESTMODS $modName]]
            <a name="::result_debug(20)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;!!! Changing the modPath to : [lindex $DEVITESTMODPATH [lsearch $DEVITESTMODS $modName]]&#34;;
            <a name="::result_debug(21)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;!!! Changing the itarPath to : [lindex $DEVITESTITARPATH [lsearch $DEVITESTMODS $modName]]&#34;;
        }
        set iCategory [get_itest_category -modPath &#34;$regPath&#34;]
        set rPath &#34;[pwd]/[get_result_dir { $randomIndex }]&#34;
        set jPath &#34;${ITARPATHDEF}/[pid]&#34;
        <span class="comment-line"># Create the tbml file</span>
        if {![file isdirectory $jPath]} {
            puts &#34;Creating dir $jPath&#34;
            file mkdir $jPath    
        }
        if {![regexp -nocase &#34;tbml&#34; $moduleArg]} {
            CreateTBML -cfg &#34;${fn}.cfg&#34; -path &#34;$jPath&#34; -homeDir &#34;module&#34;
        } else {
           if {[file exists ../../main/cfg/$moduleArg]} {
               file copy ../../main/cfg/$moduleArg $jPath/
               puts &#34;Hit Mod Arg ../../main/cfg/$moduleArg $jPath&#34;
               puts &#34;&#34;
           }  
        }
        <a name="::result_debug(22)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;exec_itest -module \&#34;$modName\&#34; -topoDir \&#34;$tbml_sub_dir\&#34; -cfg \&#34;$fn\&#34; \
            -category \&#34;$iCategory\&#34; \
            -itarPath \&#34;$ITARPATHDEF\&#34; \
            -modPath \&#34;$MODPATHDEF\&#34; \
            -version \&#34;[GetVersion DUT1]\&#34; \
            -iplatform \&#34;NULL\&#34; \
            -eplatform \&#34;NULL\&#34; \
            -qId \&#34;$qId\&#34; \
            -tcList \&#34;$tcList\&#34; \
            -resultDir \&#34;$rPath\&#34; \
            -ntafServer \&#34;$NTAFSERVERDEF\&#34; \
            -licenseServer \&#34;$LICSERVERDEF\&#34; \
            -jobDir \&#34;$jPath\&#34;&#34;

        set returnFlag [exec_itest -module &#34;$modName&#34; -topoDir &#34;$tbml_sub_dir&#34; -cfg &#34;$fn&#34; \
            -category &#34;$iCategory&#34; \
            -itarPath &#34;$ITARPATHDEF&#34; \
            -modPath &#34;$MODPATHDEF&#34; \
            -version &#34;[GetVersion DUT1]&#34; \
            -iplatform &#34;NULL&#34; \
            -eplatform &#34;NULL&#34; \
            -qId &#34;$qId&#34; \
            -tcList &#34;$tcList&#34; \
            -resultDir &#34;$rPath&#34; \
            -ntafServer &#34;$NTAFSERVERDEF&#34; \
            -licenseServer &#34;$LICSERVERDEF&#34; \
            -list &#34;$lst&#34; \
            -jobDir &#34;$jPath&#34;]

    }
} else {
    ;<span class="comment-line"># create the reportdir.txt file for the case when setup failed</span>
    save_incrementally_run_data
    create_report_directory $sourceFile no $optionalPath &#34;&#34; $subversion $qId
}
<span class="comment-line"># --- Setup sharing device</span>
shareDevDeInit;

set tEndTime [clock seconds]
set MAIN(MainDuration) [expr $tEndTime-$tStartTime]

<a name="::result_debug(23)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n*** Time for [file tail [pwd]] Regression test = $MAIN(MainDuration) seconds&#34;
<a name="::result_debug(24)"><a href="./loadConsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;***    ( [formatSeconds $MAIN(MainDuration)] )\n\n&#34;

<span class="comment-line"># -----------------------------------------------------------------------------</span>
<span class="comment-line"># Move the execution to the final request.</span>
<span class="comment-line"># -----------------------------------------------------------------------------</span>
set returnFlag [lindex $returnFlag 0]
_cleanAndStoreResults -returnFlag $returnFlag
TrackingCleanup
<span class="comment-line"># -----------------------------------------------------------------------------</span>
<span class="comment-line"># Print to stderr so any tracking wrapper can make decisions</span>
<span class="comment-line"># -----------------------------------------------------------------------------</span>
puts stderr $returnFlag
flush stderr
<span class="comment-line"># -----------------------------------------------------------------------------</span>
<span class="comment-line"># Module mode of main.tcl runs regressions from with the feature dir</span>
<span class="comment-line">#    Return to main directory</span>
<span class="comment-line"># -----------------------------------------------------------------------------</span>
close_result_file
puts &#34;Made it to the feature end - location [pwd]&#34;
cd $MAIN(mainPath)
puts &#34;Made it to the end of main - location [pwd]&#34;
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 16:57.</cite>
</div>

</body>
</html>
