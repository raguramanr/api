

################################################################## 
# Procedure Name: GetIpxOption
#   
# Description: This proc is used to get IPXRIP packet options. A number of options are returned
#              based on optionName value
#
#
# Input args: rawFrame, optionName
# Output args: none
# Return value: list of optionName values or 1 as default
# Typical usage:
#             set routes [GetIpxOption $frame "RouteInfo"]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc GetIpxOption {rawFrame optionName} {

   set type [string range $rawFrame 36 40]
   # if tagged, get rid of type and tag field from 36 to 47
   if {$type == "81 00"} {
     set leftRawFrame [string range $rawFrame 0 35] 
     set rightRawFrame [string range $rawFrame 48 [string length $rawFrame]] 
     set rawFrame [format "%s%s" $leftRawFrame $rightRawFrame]
   }

   set MessageType [GetMessageType $rawFrame]
   switch -- $optionName {
      "SourceNetwork" {
         switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENETII_IPXRIP_REPLY" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
            # ENETII & ENET8023
               return [string range $rawFrame 96 106]
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               return [string range $rawFrame 105 115]
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               #ENETSNAP
               return [string range $rawFrame 120 130]
            } default {
               return 1
            }
         }
      }
      "SourceNode" {
         switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP_REPLY" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
            # ENETII & ENET8023
               return [string range $rawFrame 108 124]
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               return [string range $rawFrame 117 133]
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               #ENETSNAP
               return [string range $rawFrame 132 148]
            } default {
               return 1
            }
         }
      }
      "SourceSocket" {
            switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP_REPLY" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
            # ENETII & ENET8023
               return [string range $rawFrame 126 130]
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               return [string range $rawFrame 135 139]
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               #ENETSNAP
               return [string range $rawFrame 150 154]
            } default {
               return 1
            }
         }
      } "DestNetwork" {
         switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENETII_IPXRIP_REPLY" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
            # ENETII & ENET8023
               return [string range $rawFrame 60 70]
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               return [string range $rawFrame 69 79]
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               #ENETSNAP
               return [string range $rawFrame 84 94]
            } default {
               return 1
            }
         }
      } "DestNode" {
         switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP_REPLY" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
            # ENETII & ENET8023
               return [string range $rawFrame 72 88]
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               return [string range $rawFrame 81 97]
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               #ENETSNAP
               return [string range $rawFrame 96 112]
            } default {
               return 1
            }
         }
      } "DestSocket" {
            switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP_REPLY" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
            # ENETII & ENET8023
               return [string range $rawFrame 90 94]
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               return [string range $rawFrame 99 103]
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               #ENETSNAP
               return [string range $rawFrame 114 118]
            } default {
               return 1
            }
         }
      } default {
         result_debug "Unknown optionName supplied: $optionName"
         #just return the type
         return 1
      } "RouteInfo" {
         switch -glob -- $MessageType {
            "ENETII_IPXRIP_REQUEST" -
            "ENETII_IPXRIP_REPLY" -
            "ENETII_IPXRIP" -
            "ENET8023_IPXRIP" -
            "ENET8023_IPXRIP_REQUEST" -
            "ENET8023_IPXRIP_REPLY" {
               # ENETII & ENET8023
               set startLoc 138
               set numToCount 22
            } "ENET8022_IPXRIP_REQUEST" -
              "ENET_8022_IPXRIP" -
              "ENET8022_IPXRIP_REPLY" {
               # ENET8022
               set startLoc 147
               set numToCount 22
            } "ENETSNAP_IPXRIP_REQUEST" -
              "ENETSNAP_IPXRIP" -
              "ENETSNAP_IPXRIP_REPLY" {
               # ENETSNAP
               set startLoc 162
               set numToCount 22
            }  "ENETII_IPXSAP" -
               "ENETII_IPXSAP_REPLY" -
               "ENETII_IPXSAP_REQUEST" {
               set startLoc 138
               set numToCount 190
            } "ENET8022_IPXSAP" -
              "ENET8022_IPXSAP_REPLY" -
              "ENET8022_IPXSAP_REQUEST" {
               set startLoc 147
               set numToCount 190
            } "ENET8023_IPXSAP" -
              "ENET8023_IPXSAP_REPLY" -
              "ENET8023_IPXSAP_REQUEST" {
               set startLoc 138
               set numToCount 190
            } "ENETSNAP_IPXSAP" -
              "ENETSNAP_IPXSAP_REPLY" -
              "ENETSNAP_IPXSAP_REQUEST" {
               set startLoc 162
               set numToCount 190
            } default {
#              result_debug "Unknown Type: $type"
               #just return the type
               return 1
            }
         }
         set route ""
         for {set startLoc $startLoc} {[expr $startLoc + $numToCount] < [expr [string length $rawFrame]-12]} {incr startLoc [expr $numToCount + 2]} {
            lappend routes [string range $rawFrame $startLoc [expr $startLoc + $numToCount]]
         }
         return $routes
      }
      "GNSTypeAndName" {
         switch -glob -- $MessageType {
            "ENETII_IPXSAP_GNSREPLY" -
            "ENET8023_IPXSAP_GNSREPLY" {
               set type [string range $rawFrame 138 142]
               set name [string range $rawFrame 144 288]
               regsub -all " " [string trimleft $name " "] "" names
               set server [string range [ConvertHexToAscii "$names"] 0 16]
               return "$type $server"
            }
            "ENET8022_IPXSAP_GNSREPLY" {
               set type [string range $rawFrame 147 151]
               set name [string range $rawFrame 153 297]
               regsub -all " " [string trimleft $name " "] "" names               
               set server [string range [ConvertHexToAscii "$names"] 0 16]
               return "$type $server"
            }
            "ENETSNAP_IPXSAP_GNSREPLY" {
            } default {
#              result_debug "Unknown Type: $type"
               #just return the type
               return 1
            }
         }
      }
   }
}

################################################################## 
# Procedure Name: ixia_SendIpxPackets
#   
# Description: This internal proc is used to send ipx packets from test equipment
#
#     IMP: Starts ports' capture (startPortsCapture) on rxPortId by default.
#
# Input args: args
# Output args: none
# Return value: Stream sent
# Typical usage:
#  set frameSent [ixia_SendIpxPackets -direction $direction -txPortId $txPortId -rxPortId $rxPortId \
#              -etherType $etherType -sNetwork $sNetwork -sSocket $sSocket \
#              -dNetwork $dNetwork -dSocket $dSocket -dNode $dNode -rxProto $rxProto \
#              -packetType $packetType -numFrames $numFrames -frameSize $frameSize \
#              -frameRate $frameRate -dataPattern $dataPattern -streamType $streamType \
#              -fcsError $fcsError -wTag $wTag -tagNo $tag -tagCfi $tagCfi \
#              -sourceNodeCounterMode $sourceNodeCounterMode]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: SendTraffic
##################################################################
proc ixia_SendIpxPackets {args} {
   parse_args ixia_SendIpxPackets $args {
      txPortId "1"
      rxPortId "2"
      etherType "ethernetII"
      rxProto "ethernetII"
      sNetwork "00 00 00 00"
      sSocket "0400"
      dNetwork "00 00 00 00"
      sNode "00 00 00 00 00 00"
      dNode "00 00 00 00 00 00"
      dSocket "0400"
      packetType "typeUnknown"
      numFrames "1"
      frameSize "64"
      frameRate "default"
      dataPattern "0000"
      streamType "stopStream"
      fcsError "good"
      direction "1Way"
      wTag "false"
	   tagNo "002"
	   tagCfi "resetCFI"
      tagMode "vIdle"
	   tagRepeat "1"
	   userPriority "0"
      percentage "100"
      priority "0"
      sendLearn "true"
      saMode "idle"
      daMode "idle"
      chid "1"
      enableUdf "false"
      offset "52"
      counterType "c32"
      initVal "08 00"
      destNodeCounterMode "1"
      sourceNodeCounterMode "1"
   }
   
   global spawn_id
   global one2oneArray
   global preambleSize
   global DUTs_info
   global startCardNum
   globalSetDefault
   protocolStackSetDefault
   
   set macBroadcast "FF FF FF FF FF FF"
   set numIxiaCd [GetNumIxiaCd $txPortId]

   MapIxiaPortId $txPortId txChas txCard txPort
   if { $rxPortId == 0 } {
      set rxPortId $txPortId
   }
   MapIxiaPortId $rxPortId rxChas rxCard rxPort

   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   result_debug "\n*** date=$date"
   set time1 [clock seconds]
   puts "2nd txPort:$txPort, txCard:$txCard, rxPort:$rxPort, rxCard:$rxCard"

   set patternOffset	32
   set preambleSize 8

   # Create mapping
   map new -type one2one
   map config -type one2one
   set txSideGwMac ""
   set rxSideGwMac ""
   if { $sendLearn == "true" } {
      map add $txChas $txCard $txPort $txChas $txCard $txPort
      learn config -numframes 1   
      protocol config -ethernetType $etherType
      protocol config -name ipx
      if {([llength $tagNo]>=1) && ($wTag == "true")} {
         protocol config -enable802dot1qTag $wTag
         vlan config -vlanID [lindex $tagNo 0]
      } else {
         protocol config -enable802dot1qTag false
      }
      vlan set	$txChas $txCard $txPort
      stream set $txChas $txCard $txPort 1
      ClearPortsStats "$txPortId"
      StartPortsCapture "$txPortId"
      catch {send_ripx_frames one2oneArray}
      set capturedFrames [GetCapturedFrames $txPortId]
      set txSideGwMac [GetSourceMacAddress [lindex $capturedFrames 0]]
      map del $txChas $txCard $txPort $txChas $txCard $txPort
      map add $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort
      protocol config -ethernetType $rxProto
      protocol config -name ipx
      if {([llength $tagNo]>1) && ($wTag == "true")} {
         protocol config -enable802dot1qTag $wTag
         vlan config -vlanID [lindex $tagNo 1]
      } else {
         protocol config -enable802dot1qTag false
      }
      vlan set	$rxChas $rxCard $rxPort
      stream set $rxChas $rxCard $rxPort 1
      ClearPortsStats "$rxPortId"
      StartPortsCapture "$rxPortId"
       catch {send_ripx_frames one2oneArray}
      set capturedFrames [GetCapturedFrames $rxPortId]
      set rxSideGwMac [GetSourceMacAddress [lindex $capturedFrames 0]]
      map del $rxChas $rxCard $rxPort $rxChas $rxCard $rxPort      
   }
   if {$txSideGwMac==""} {
      set txSideGwMac $DUTs_info(DUT1,sysMAC)
   }
   map add $txChas $txCard $txPort $rxChas $rxCard $rxPort
   if { $direction == "2Way" } {
      map add $rxChas $rxCard $rxPort $txChas $txCard $txPort
   }

   StartPortsCapture "$txPortId"
   #-----------------------------------------------------------------
   # Config streams for validation traffic
   foreach txMap [lsort [array names one2oneArray]] {
      scan $txMap "%d,%d,%d" chid c p
      port get $chid $c $p
      set txSpeed	[port cget -speed]
      stream setDefault
      if {$enableUdf != "false"} {
         udf setDefault
         if {$etherType=="ieee8022"} {
            udf config -enable $enableUdf
            udf config -offset $offset
            udf config -countertype $counterType
            # IXIA GBIC did not support
            set udf1InitVal [string range $initVal 0 10]
            set udf2InitVal [string range $initVal 12 13]
            result_debug "the udf1InitVal $udf1InitVal, udf2InitVal $udf2InitVal"
            udf config -initval $udf1InitVal
            udf set 1
            
            udf config -enable $enableUdf
            udf config -offset 50
            udf config -countertype c8
            udf config -initval $udf2InitVal
            udf set 2
         } else {
            udf config -enable $enableUdf
            udf config -offset $offset
            udf config -countertype $counterType
            udf config -initval $initVal
            udf set 1
         }
      }

      stream config -numFrames $numFrames
      stream config -name S_${c}_${p}
      stream config -framesize $frameSize
      stream config -dma $streamType
      if { $frameRate == "default" } {
         set frameRate [decideFrameRate $txSpeed $frameSize $percentage]
      } else {
         set percentage [decidePercentage $txSpeed $frameSize $frameRate]
      }
result_debug "@@@ frameRate=$frameRate"
      stream config -rateMode usePercentRate
      stream config -percentPacketRate $percentage

      #set ifg [calculateGap $frameRate $frameSize $preambleSize $txSpeed]
      stream config -fcs $fcsError
      #stream config -ifg $ifg
      #stream config -isg $ifg
      #stream config -ibg $ifg
      stream config -fir false		;# for timestamp
      stream config -dataPattern	userpattern -pattern $dataPattern
      if {$sNode=="00 00 00 00 00 00"} {
         set sNode [port cget -MacAddress]      
      }
      set rxMap $one2oneArray($txMap)
      scan [join $rxMap] "%d %d %d" rxch rxc rxp
   
      port get $rxch $rxc $rxp
      set destAddr [port cget -MacAddress]
      
      stream config -saRepeatCounter $saMode
      stream config -daRepeatCounter $daMode
      if { $saMode != "idle" } { stream config -numSA $numFrames }
      if { $daMode != "idle" } { stream config -numDA $numFrames }

      stream config -sa $sNode
      if {[string compare "$sNetwork" "$dNetwork"]==0} {
         stream config -da $dNode
      } else {
         stream config -da $txSideGwMac
      }

      protocol setDefault
	   protocol config -ethernetType $etherType
	   protocol config -name ipx
	   protocol config -enable802dot1qTag $wTag

      ipx setDefault
      if {($chid == $txChas) && ($c == $txCard) && ($p == $txPort) } {
	      ipx config -sourceNetwork $sNetwork
#	      ipx config -sourceNetworkMaskSelect	$sNwMask
         ipx config -sourceNode $sNode
         ipx config -sourceSocket $sSocket
	      ipx config -destNetwork $dNetwork
	      ipx config -destNode $dNode
         ipx config -destSocket $dSocket
	  } else {
         ipx config -sourceNetwork $dNetwork
#	      ipx config -sourceNetworkMaskSelect	$dNwMask
         ipx config -sourceNode $dNode
         ipx config -sourceSocket $dSocket
	      ipx config -destNetwork $sNetwork
	      ipx config -destNode $sNode
         ipx config -destSocket $sSocket
     }
     
     # Put this length override kludge for stupid ixia correct format packet.
#     if {[regexp -nocase "Summit*" [GetPlatform]]} {
#        ipx config -length "43"
#        ipx config -lengthOverride "true"
#     }
     if {$sourceNodeCounterMode>0} {
         ## This interface does not work in ixia.
         ## own defined udf for incremental sourceNode
         udf setDefault
         udf config -enable $enableUdf
         udf config -countertype $counterType
         set LaterPartMac [string range $sNode 6 end]
         if {$etherType == "ethernetII"} {
            udf config -offset 38
         } elseif {$etherType == "ieee8022"} {
            udf config -offset 42
            udf config -countertype c24
            set LaterPartMac [string range $sNode 9 end]
         } elseif {$etherType == "ieee8023"} {
            udf config -offset 38
         } elseif {$etherType == "ieee8023snap"} {
            udf config -offset 46
         }
         udf config -repeat $numFrames
         udf config -initval $LaterPartMac
         udf set 3
         ## Ideally following should be used but it has problems
#        puts "the sourceNodeCounterMode:$sourceNodeCounterMode"
#        ipx config -sourceNodeCounterMode $sourceNodeCounterMode
#        ipx config -sourceNodeRepeatCounter $numFrames
     }

#	  ipx config -sourceNetworkCounterMode $sNwRepeatCounterMode
#	  ipx config -sourceNetworkRepeatCounter $sNwRepeatCounter
#	  ipx config -sourceNodeCounterMode $sNoRepeatCounterMode
#	  ipx config -sourceNodeCounterMode $sNoRepeatCounterMode

	  ipx config -packetType $packetType
	  
	  ipx set $chid $c $p
	  
     vlan config -cfi $tagCfi
     vlan config -mode $tagMode
     vlan config -repeat $tagRepeat
     vlan config -userPriority $userPriority
      
     if {[llength $tagNo] >1} {
        if {[lindex $tagNo 0]!=0} {
           vlan config -vlanID [lindex $tagNo 0]
           vlan set $txChas $txCard $txPort
        } else {
        	  protocol config -enable802dot1qTag false
        }
        vlan config -vlanID [lindex $tagNo 1]
        vlan set $rxChas $rxCard $rxPort
     } else {
        vlan config -vlanID [lindex $tagNo 0]
        vlan set $txChas $txCard $txPort
     }
      
     stream set $chid $c $p 1

     #set packet group to default, otherwise will cause ICMP bad CRC
     packetGroup setDefault						
     packetGroup setTx $chid $c $p 1

     # Define filter & capture
     filter config -captureFilterEnable true
     filter config -captureTriggerEnable true
     filter config -userDefinedStat1Enable true
     filter config -userDefinedStat1DA addr1
     filter config -captureFilterPattern anyPattern
     filter config -captureTriggerPattern anyPattern
     filter config -captureTriggerDA anyAddr
     filter config -captureFilterDA anyAddr
     filter set $rxch $rxc $rxp

     filterPallette config -DA1 $destAddr
     filterPallette config -pattern1 $dataPattern
     filterPallette config -patternOffset1 $patternOffset
     filterPallette set $rxch $rxc $rxp
   }
   writeConfigToHardware one2oneArray
   StartPortsCapture "$txPortId $rxPortId"

   for {set c $startCardNum} {$c<=[expr $startCardNum + $numIxiaCd - 1]} {incr c 1} { ixiaConf_clearStat $c }
   ixiaStartCaptureCards $numIxiaCd $startCardNum
   startTx one2oneArray
   set time2 [clock seconds]
   stream get $txChas $txCard $txPort 1
   set streamSent [stream cget -packetView]
   result_debug "*** Frame sent from ($txChas $txCard $txPort) = $streamSent"
   result_debug "*** Time for Ixia TX setup = [expr $time2-$time1] secs"

   # Make sure TX done
   if { $streamType == "stopStream" } {
      if { ($saMode != "contIncrement") && ($saMode != "contDecrement") &&  
           ($daMode != "contIncrement") && ($daMode != "contDecrement") } {
         ixiaCheckTxDone $txChas $txCard $txPort $numFrames $txPortId
         if { $direction == "2Way" } {
            ixiaCheckTxDone $rxChas $rxCard $rxPort $numFrames $txPortId
         }
      }
   }
   after 1000
   set time3 [clock seconds]
   result_debug "*** Time for Ixia TX done = [expr $time3-$time2] secs\n"
   return $streamSent
}

################################################################## 
# Procedure Name: VerifyIpxRouteInfo
#   
# Description:
#     This proc is used to compare IPX route info on a given list of 
#     ixia ports and a DUT. Important reference commands include "sh ipxro"
#     on DUT (associated proc GetColumnValues).
#     Sleeps for 70 secs for IPXRIP update capture. Calculate DUT number 
#     associated with a given port automagically.
#
#
# Input args:
#     portInfoList: It is a list of Ixia port number, vlan's xnetid and
#                   IPXRIP type on that port
#    update_time: Default param to pass update interval
#
# Output args:
# Return Values:
#     returns true(1) on success (All routes matched)
#     returns false (0) on failure (Any of the route remained unmatched)
# Typical usage:
#    if {VerifyIpxRouteInfo {{1 809a ENETII_IPXRIP_REPLY} \
#                            {4 235e ENETSNAP_IPXRIP_REPLY}}} {
#       puts "success"
#    } else {
#       puts "failure"
#    }
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc VerifyIpxRouteInfo {portInfoList {update_time 70}} {

   global portMappingList
   set con "_CONNECT"
   set DUT "DUT"
   
   if {![llength $portInfoList]} {
      return 0
   }
   
   # Start capture before sleep
   foreach portInfo $portInfoList {
      lappend portList [lindex $portInfo 0]
   }
   
   ClearPortsStats "$portList"
   StartPortsCapture "$portList"

   # Wait for 70 secs to capture RIP updates
   result_debug "Wait for $update_time secs to capture IPX route updates"
   after [expr $update_time * 1000]
   
   # Capture stats on each ixia port
   set i 0
   foreach port $portList {
      set frameList [GetCapturedFrames $port]
      #result_debug "frameList on $port:$frameList"
      set capturedRoute "";
      foreach frame $frameList {
         if {[GetMessageType $frame] == "[lindex [lindex $portInfoList $i] 2]"} {
            set routes [GetIpxOption $frame "RouteInfo"]
            foreach route $routes {
               if {[lsearch $capturedRoute $route] == -1} {
                  lappend capturedRoute $route
               }
            }
         }
      }
      set capturedRoute$port $capturedRoute
      incr i
   }
   
   set cap "capturedRoute"
   foreach port $portInfoList {
      set portNum [lindex $port 0]
      set portNet [string toupper [lindex $port 1]]

      set dut ""
      foreach p $portMappingList {
         if {[lindex $p 0] == "$portNum"} {
            set dut [lindex $p 2]
            break
         }
      }

      ################################################
      set subTest "Verify that ipx packets have complete route info on port$portNum"
      ################################################
      result_h2 "$subTest"
      report_start_test "$subTest"

      global $DUT$dut$con
      Login [expr $$DUT$dut$con]
      SendACmd "dis clipaging"
         #EnableDebugMode
         #SendACmd "!echo dump_stack > /sys/module/watchdog/parameters/watchdog_warn_behavior"
      
      set capRoutes ""
      set ColumnVals ""
      #result_debug "the mesagetype:[lindex $port 2]"
      #result_debug "the capturedPort Values: [expr $$cap$portNum]"
      
      if {[regexp -nocase "SAP" [lindex $port 2]]} {
         set ColumnVals [GetColumnValues  "sh ipxser" {{0 3} {5 21} {23 26} {28 35} {37 53} {55 58}} "----" "Total number"]
         #result_debug "the columnVals for SAP:$ColumnVals"
         if {([llength [lindex $ColumnVals 0]]) && \
             ([llength [expr $$cap$portNum]])} {
            set routesNotMatched ""
         } else {
            set routesNotMatched "no routes captured on switch"
            sleep 3 
            set ColumnVals [GetColumnValues  "sh ipxser" {{0 3} {5 21} {23 26} {28 35} {37 53} {55 58}} "----" "Total number"]
            if {([llength [lindex $ColumnVals 0]]) && \
                ([llength [expr $$cap$portNum]])} {
               set routesNotMatched ""
            }
         }

         foreach routeInfo [expr $$cap$portNum] {
            #result_debug "the routeInfo $routeInfo"
            regsub -all " " [string trimleft [string range $routeInfo 0 4] " 0"] "" operation
            regsub -all " " [string trimleft [string range $routeInfo 6 148] " "] "" server
            set Server [string range [ConvertHexToAscii "$server"] 0 16]
            regsub -all " " [string trimleft [string range $routeInfo 150 161] " 0"] "" network
            regsub -all " " [string trimleft [string range $routeInfo 162 178] " "] ":" node
            regsub -all " " [string trimleft [string range $routeInfo 180 185] " "] "" port
            regsub -all " " [string trimleft [string range $routeInfo 187 191] " 0"] "" hops
            lappend capRoutes "$operation $Server $hops $network $node $port"
         }
         #result_debug "the capRoutes:$capRoutes"
         for {set i 0} {$i < [llength [lindex $ColumnVals 0]]} {incr i} {
            set actualOp [string trimleft [string toupper [lindex [lindex $ColumnVals 0] $i]] " 0"]
            set actualSe [string trimleft [string toupper [lindex [lindex $ColumnVals 1] $i]] " 0"]
            set actualHo [string trimleft [string toupper [format %x [lindex [lindex $ColumnVals 2] $i]]] " 0"]
            set actualNw [string trimleft [string toupper [lindex [lindex $ColumnVals 3] $i]] " 0"]
            set actualNo [string toupper [lindex [lindex $ColumnVals 4] $i]]
            set actualPo [string toupper [lindex [lindex $ColumnVals 5] $i]]

            if {[lsearch $capRoutes "$actualOp $actualSe $actualHo $actualNw $actualNo $actualPo"]==-1} {
               lappend routesNotMatched "$actualOp $actualSe $actualHo $actualNw $actualNo $actualPo"
            }
         }
      } elseif {[regexp -nocase "RIP" [lindex $port 2]]} {
         set ColumnVals [GetColumnValues  "sh ipxro" {{0 9} {10 15} {16 21} {30 33}} "Network" "Total number"]
         #result_debug "the columnVals for RIP:$ColumnVals";
         set routesNotMatched ""
         if {([llength [lindex $ColumnVals 0]]) && \
             ([llength [expr $$cap$portNum]])} {
            set routesNotMatched ""
         } else {
            set routesNotMatched "no routes captured on switch"
         }
         foreach routeInfo [expr $$cap$portNum] {
            regsub -all " " [string trimleft [string range $routeInfo 0 10] " 0"] "" network
            regsub -all " " [string trimleft [string range $routeInfo 12 16] " 0"] "" hops
            regsub -all " " [string trimleft [string range $routeInfo 18 22] " 0"] "" tics
            lappend capRoutes "$network $hops $tics"
         }
         for {set i 0} {$i < [llength [lindex $ColumnVals 0]]} {incr i} {
            set actualNw [string toupper [lindex [lindex $ColumnVals 0] $i]]
            if {$actualNw == "$portNet"} {
               continue
            }
            set actualHops 0
            set actualTics 0
            set actualAge 0
            if {[lindex $ColumnVals 1]!=""} {
               set actualHops [string toupper [format %x [lindex [lindex $ColumnVals 1] $i]]]
            }
            if {[lindex $ColumnVals 2]!=""} {
               set actualTics [string toupper [format %x [lindex [lindex $ColumnVals 2] $i]]]
            }
            set actualAge [lindex [lindex $ColumnVals 2] $i]
            if {([lsearch $capRoutes "$actualNw $actualHops $actualTics"]==-1)&&($actualAge<60)} {
               lappend routesNotMatched "$actualNw $actualHops $actualTics"
            }
         }
      }

      if {[llength $routesNotMatched] > 0} {
         result_error "IPX route check failed, routes unmatched: $routesNotMatched"
      } else {
         result_ok "IPX route check passed, all routes:$capRoutes matched."
      }
      report_end_test
   }
   return "1"
}

################################################################## 
# Procedure Name: VerifyProtoUpdateInterval
#   
# Description:
#     This proc is used to verify a given IPXRIP/IPXSAP/others update time on a port
#     Calls capture function to capture packets on tester and verifies
#     their time stamping spaced by intervalInSec secs.
#     It uses a tolerance of +/- .01 percent in intervalInSec (by default)
# 
# Input args:
#     intervalInSec: Update Interval in seconds
#     port: Test equipment port number to verify on. can be a list
#     packetType: Ethernet encapsulation packet type expected...
#               (Valid values can be ENETII/ENET8022/ENET8023/ENETSNAP_IPXRIP_REPLY
#                Valid values can be ENETII/ENET8022/ENET8023/ENETSNAP_IPXSAP_REPLY)
#               (pimV2Hello...)
#
# Output args:
# Return Values:
#     returns true(1) on success (Update interval matched)
#     returns false (0) on failure (Any of 3 captured not spaced by intervalInSec)
# Typical usage:
#
# if {VerifyIpxUpdateInterval "60 9 ENETSNAP_IPXRIP_REQUEST"} {
#   result_ok "Default IPXRIP update time verified correct, PASS"
# } else {
#   result_error "Default IPXRIP update time not correct, FAIL"
# }
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc VerifyProtoUpdateInterval {intervalInSec portList packetType {tolerance 20}} {

foreach port $portList {
   ClearPortsStats "$port"
   StartPortsCapture "$port"
   ################################################
   set subTest "Verify $packetType packets generated every $intervalInSec seconds on port $port"
   ################################################
   result_h2 "$subTest"
   report_start_test "$subTest"

   result_debug "Wait around [expr $intervalInSec * 3] secs to capture $packetType packets on tester ports"
   after [expr $intervalInSec * 3000 - 1234]

   set capturedFrames [GetCapturedFrames "$port"]
   set timeStamps [GetCapturedFramesTimeStamp "$port"]
   set TimeStamps ""

   # Look for only IPX packets in all captured packets
   for {set i 0} {$i < [llength $capturedFrames]} {incr i} {
      #result_debug "The messagetype captured:[GetMessageType [lindex $capturedFrames $i]]"
      if {[GetMessageType [lindex $capturedFrames $i]] == "$packetType"} {
         lappend TimeStamps [lindex $timeStamps $i]
      }
   }

   result_debug "the timestamps:$TimeStamps"
   set interval 0
   set result "ng"
   if {[regexp -nocase {[2-9]} [llength $TimeStamps]]} {
      for {set i 0} {$i < [expr [llength $TimeStamps]-1]} {incr i} {
         set secondTimeStamp [lindex $TimeStamps [expr $i + 1]]
         set firstTimeStamp [lindex $TimeStamps $i]
         # Store in mili seconds
 #        set secTimeStamp [string range $secondTimeStamp 0 [expr [string length $secondTimeStamp] - 10]]
 #        set firTimeStamp [string range $firstTimeStamp 0 [expr [string length $firstTimeStamp] - 10]]
         #result_debug "the firTimeStamp:$firTimeStamp, secTimeStamp:$secTimeStamp"
         set interval [mpexpr abs($secondTimeStamp - $firstTimeStamp)/1000000000]
         set diff [mpexpr abs( $intervalInSec - $interval)]
         set percent [mpexpr double($diff)/ double($intervalInSec)*100.0]
         result_debug "The interval=$interval, percent=$percent"
         # Count for a percentage of .01 tolerance
         if {$percent <= $tolerance} {
            set result "ok"
            break  ;# break as soon as one correct timespace found
         } else {
            set result "ng"
         }
      }
   }
   if {$result == "ok"} {
      result_ok "port$port:$packetType update interval $intervalInSec verified correct, PASS"
      report_end_test
   } elseif {$result=="ng"} {
      result_error "port$port:$packetType update interval incorrect, expected $intervalInSec but got $interval, FAIL"
      report_end_test
   }
}
   return 0
}

################################################################## 
# Procedure Name: ConvertHexToAscii
#   
# Description: A internal proc that returns the hex packet format to ascii value for 
#              a given novell server type
#
# 
# Input args: server
#
# Output args: none
# Return Values:
#      returns the ascii value of server
# Typical usage:
#           ConvertHexToAscii "$server"
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc ConvertHexToAscii  {server} {

   set hexPrefix "\\x"
   set asciiVal ""
   
   for {set i 0} {$i < [string length $server]} {incr i 2} {
      set hexVal [string range $server $i [expr $i + 1]]
      lappend asciiVal [string toupper [eval format %s "$hexPrefix$hexVal"]]
      if {[regexp {[^A-Z^a-z^0-9^ ^_^-]} $asciiVal]} {
         break
      }
   }
   regsub -all {[^A-Z^a-z^0-9^_^-]} $asciiVal "" asciiVal
   return [join $asciiVal ""]
}

################################################################## 
# Procedure Name: CheckServerTypeInGnsResponse
#   
# Description: This proc verifies the server type in rawPacket's GNS response.
#              the desired serverType and serverName are supplied in in args along with rawFrame
#
# 
# Input args: rawFrame, serverType, serverName
#
# Output args: none
# Return Values:
#      1 on success or 0 on failure
# Typical usage:
#         CheckServerTypeInGnsResponse $rawFrame "00 04" $serverName
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: VerifyTraffic
##################################################################
proc CheckServerTypeInGnsResponse {rawFrame serverType serverName} {

   set serverType [format %04d [string trimleft $serverType " 0"]]
   set serverType "[string range $serverType 0 1] [string range $serverType 2 3]"
   report_start_test "checking GNS reply for serverType:$serverType, serverName:$serverName"
   set typename [GetIpxOption $rawFrame "GNSTypeAndName"]

   if {[regexp -nocase "$serverType $serverName" $typename]} {
      result_ok "GNS Reply ok with serverType: $serverType, serverName:$serverName, PASS"
      report_end_test
      return "1"
   } else {
      result_error "Wrong GNS Reply serverType and serverName:$typename, FAIL"
      report_end_test
      return 0
   }
}

################################################################## 
# Procedure Name: GetPortIdsOnSameBlade
#   
# Description: This proc checks the ports from portMappingList, finds ports on the same
#              blade for required number of vlans. For non-slot platforms like summit
#              it returns an error.
#              This proc currently only works for any DUT
# 
# Input args: numPortsPerVlan: number of ports per vlan
#             numVlans: total number of vlans for which ports are desired
#             [dut] dut number to scan for, default is 1
#
# Output args: portsList: List of ports to be returned to caller
# Return Values:
#      1 on success, -1 on failure.
# Typical usage:
#      set resultOfSameBladePorts [GetPortIdsOnSameBlade $numPortsPerVlan $numVlans portIdsList]
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: GetSwitchInfo
##################################################################
proc GetPortIdsOnSameBlade {numPortsPerVlan numVlans portIdsList args} {

   upvar $portIdsList portsList
   set portsList ""
   
   parse_args GetPortIdsOnSameBlade $args {
      dut     1
   }

   global stackable i386Stackable
   if {[regexp -nocase "$stackable|$i386Stackable" [GetPlatform DUT$dut]]} {
      result_debug "Found a non-slot platform for GetPortIdsOnSameBlade"
      return -2
   }

   global DUTs_info
   set slots ""
   foreach portId $DUTs_info(portmappinglist) {
      if {[lindex $portId 2]==$dut} {
         lappend portIdList [lindex $portId 0]
         lappend slotList [lindex [split [lindex $portId 1] :] 0]
      }
   }
#   result_debug "the portIdList $portIdList, slotList $slotList"
   
   for {set i 0} {$i<$numVlans} {incr i} {
      foreach slot $slotList {
         set portIds ""
         set flag 0
         for {set k 0} {$k<[llength $slotList]} {incr k} {
            if {[lindex $slotList $k]==$slot&&[lsearch $slots $slot]==-1} {
               if {[llength $portsList]} {
                  foreach po $portsList {
                     if {[lsearch $po [lindex $portIdList $k]]==-1 && [lsearch $portIds [lindex $portIdList $k]]==-1} {
                        lappend portIds [lindex $portIdList $k]
 #                       result_debug "1.the slot $slot and portsList $portsList and slots $slots and portIds $portIds"
                     }
                  }
               } else {
                  lappend portIds [lindex $portIdList $k]
               }
            }
            if {[llength $portIds]==$numPortsPerVlan} {
               set flag 1
               break
            }
         }
         if {$flag} {lappend portsList $portIds; lappend slots $slot; break}
      }
   }
   if {[llength $portsList]} {
      return 1
   } else {
      return -1
   }
}

################################################################################
# Procedure Name: ConfigIPXServiceNetwork   
# Description: proc to configuration the IPX gateway vlan enet_server to IPX service.
#
# Input args: n/a
# Output args: n/a
# Typical usage:
#             ConfigIPXServiceNetwork;
# Category: setup
##################################################################
proc ConfigIPXServiceNetwork {} {
    global switchPort2DefaultRouter;  
    global whichDutNow;
    global IPXSRVR_TAG;
    global IPXSRVR_NWNUM;
    global IPXSRVR_PROTOCOL;
    global ixiaCh1; 
   
    result_debug "\nConfigIPXServiceNetwork: Setting up IPX gateway VLAN on DUT$whichDutNow.";
    if {[regexp -nocase $switchPort2DefaultRouter "mgmt"]} {
        result_debug "CAN NOT USE MGMT PORT FOR IPX NETWORK!!!";
        return;
    }

    if {![info exists IPXSRVR_TAG]} {
        # Generate the tag number.
        set ipad [split $ixiaCh1 .];
        set ipF3 [lindex $ipad 2];
        set IPXSRVR_TAG [expr $ipF3 + 100];
    }
  
    if {![info exists IPXSRVR_NWNUM]} {
        set IPXSRVR_NWNUM [GetIPXNetworkNumber];
    }

    if {![info exists IPXSRVR_PROTOCOL]} {
        set IPXSRVR_PROTOCOL "enet_snap";
    }

    # Build IPX network.
    set gwPort [GetDUTPort $switchPort2DefaultRouter $whichDutNow];
    SendACmd "enable port $gwPort";       
    SendACmd "create vlan enet_server";
    SendACmd "config enet_server tag $IPXSRVR_TAG";
    SendACmd "config enet_server add port $gwPort tag";
    SendACmd "config enet_server xnetid $IPXSRVR_NWNUM $IPXSRVR_PROTOCOL";
} ;# ConfigIPXServiceNetwork

################################################################################
# Procedure Name: UnconfigIPXServiceNetwork   
# Description: proc to delete the IPX gateway vlan enet_server to IPX service.
#
# Input args: n/a
# Output args: n/a
# Typical usage:
#             UnconfigGatewayNetwork;
# Category: Setup
##################################################################
proc UnconfigIPXServiceNetwork {} {
    global switchPort2DefaultRouter; 
    global defaultRouter;
    global whichDutNow;
 
    result_debug "\nUnconfigIPXServiceNetwork{}: delete gateway vlan on DUT$whichDutNow"
    SendACmd    "delete enet_server";
}

################################################################################
# Procedure Name: GetIPXNetworkNumber  
# Description: Use the ixia network number to create the IPX network number
#
# Input args: n/a
# Output args: IPX network number
# Typical usage:
#             GetIPXNetworkNumber
# Category: Utility
#################################################################################
proc GetIPXNetworkNumber {} {
    global ixiaCh1; 
    
    # To generate the IPX network number, the IXIA's IP address is treated
    # as a string.  The dots are removed, and the last four characters of
    # that result will form the IPX network number.
    regsub -all {\.} $ixiaCh1 "" tmp;
    set lng [string length $tmp];
    set st [expr $lng - 4];
    set value [string range $tmp $st end];
    
    return $value;
}

