##################################################################
# $RCSfile: SystemSetup.tcl,v $ - 
#
# Copyright (c) 2000 by Extreme Networks Inc.
# 
# Revision control history
# ------------------------
# $Header: /export/cvsroot/automation/Lib/SystemSetup.tcl,v 2.37.2.3.4.95 2010/08/24 01:39:50 ghundertmark Exp $
#
# Extreme Networks modification history
# -------------------------------------
# $Log: SystemSetup.tcl,v $
# Revision 2.37.2.3.4.95  2010/08/24 01:39:50  ghundertmark
# Merge branch 12_4 to trunk
#
# Revision 2.37.2.3.4.95  2010/08/24 01:39:50  ghundertmark
# Merge branch 12_4 to trunk
#
# Revision 2.37.2.3.4.94  2010/04/29 00:17:52  ghundertmark
# Add skip license check
#
# Revision 2.37.2.3.4.93  2010/03/23 19:45:30  ghundertmark
# local changes on regserver, verify duts_info memcard exits, unrem conf def del po all
#
# Revision 2.37.2.3.4.92  2010/03/22 16:38:10  ghundertmark
# Local rtpreg changes
#
# Revision 2.37.2.3.4.91  2010/02/23 00:41:50  ghundertmark
# Add sysType to isExosPlat proc
#
# Revision 2.37.2.3.4.90  2009/09/24 18:43:39  ghundertmark
# Merge from branch
#
# Revision 2.37.2.3.4.89  2009/08/27 19:03:21  lagrawal
# merge from dev branch
#
# Revision 2.37.2.3.4.88  2009/08/26 03:43:07  ghundertmark
# merge from branch-dev_v12-4-rel1
#
# Revision 2.37.2.3.4.85.2.14  2010/04/22 11:27:16  nellinivasu
# Added to skip license check, if defined in the cfg file.
#
# Revision 2.37.2.3.4.85.2.13  2010/02/22 23:30:04  ghundertmark
# Add sysType check to isExosPlatform
#
# Revision 2.37.2.3.4.85.2.12  2009/10/19 16:18:38  autotest-sc
# added time configuration at the beginning of a feature test
#
# Revision 2.37.2.3.4.85.2.11  2009/10/08 13:48:01  ghundertmark
# Remove save option from GetPortIDInfo
#
# Revision 2.37.2.3.4.85.2.10  2009/09/24 18:40:50  ghundertmark
# Move GetPortInfo to AddTestbedInfoToDUTs_info
#
# Revision 2.37.2.3.4.85.2.9  2009/08/27 18:34:25  lagrawal
# change ixia traffic from line rate to lower number as this was cuasing hub edp check failure in cfg files using port 9 in ixia port mapping list as well as trunk connection
#
# Revision 2.37.2.3.4.85.2.8  2009/08/26 20:25:51  lagrawal
# reduce edp advertisement-interval to 15 seconds to avoid some check connection failure
#
# Revision 2.37.2.3.4.85.2.7  2009/08/26 03:35:48  ghundertmark
# Fix case where duts_info current_module is not defined in trace utility - Missed one
#
# Revision 2.37.2.3.4.85.2.6  2009/08/26 03:32:39  ghundertmark
# Fix case where duts_info current_module is not defined in trace utility
#
# Revision 2.37.2.3.4.85.2.5  2009/08/25 20:57:39  lagrawal
# fixed core/trace file rename proc to handle the case where currentTestNumber is not defined
#
# Revision 2.37.2.3.4.85.2.4  2009/08/16 12:24:16  lagrawal
# change ixia traffic to continuous non stop traffic till ixia connection are verified fro check connection
#
# Revision 2.37.2.3.4.85.2.3  2009/08/13 09:35:42  lagrawal
# 'Configure vlan default del po  all' addded before creating ixiaVlan.
#
# Revision 2.37.2.3.4.85.2.2  2009/07/28 01:53:18  lagrawal
# added proc to verify CF state before regression
#
# Revision 2.37.2.3.4.85.2.1  2009/07/07 21:56:59  dsuk
# added tftp connectivity test in SystemSetup
#
# Revision 2.37.2.3.4.85  2009/07/01 10:55:48  nellinivasu
# Merged From Branch 'branch-dev_v12-1-rel4'
#
# Revision 2.37.2.3.4.84  2009/05/01 18:07:26  lagrawal
# merge from dev
#
# Revision 2.37.2.3.4.83  2009/04/08 20:14:28  jramarao
# commit from branch-dev_v12-1-rel4
#
# Revision 2.37.2.3.4.82  2009/03/18 21:48:26  jramarao
# From branch-dev_v12-1-rel4
#
# Revision 2.37.2.3.4.81  2009/01/15 21:17:41  eyoung
# Fixed regexp pattern from revision 2.37.2.3.4.80.
#
# Revision 2.37.2.3.4.80  2009/01/15 20:18:32  eyoung
# Fixes to accomodate new "h" flag for Manhattan hardware in "show fdb" output.
#
# Revision 2.37.2.3.4.78.2.10  2009/04/08 20:49:05  jramarao
# EnableBGPServiceProviderEdgeLicence corrected to show error
#
# Revision 2.37.2.3.4.79  2008/10/30 03:48:31  ghundertmark
# Add license for pioneer
#
# Revision 2.37.2.3.4.78.2.6  2009/03/13 15:02:17  nellinivasu
# Added workaround if tag used in checkconnection matches existing vlan on DUT.
#
# Revision 2.37.2.3.4.78.2.5  2009/03/12 19:07:09  lagrawal
# Check Connection optimization
#
# Revision 2.37.2.3.4.78.2.4  2009/02/24 02:57:51  lagrawal
# fixed proc ChangeTraceFile and ChangeCoreFile
#
# Revision 2.37.2.3.4.78.2.3  2009/01/30 15:11:57  autotest-sc
# merge from branch-pioneer2_dev-v12-1-rel4
#
# Revision 2.37.2.3.4.78.2.2.4.4  2008/12/30 02:02:48  autotest-sc
# Show fdb delayed from 5 to 20 secs for voyager testbeds----PD4-512754823
#
# Revision 2.37.2.3.4.78.2.2.4.3  2008/12/11 01:25:33  jramarao
# Sleep added
#
# Revision 2.37.2.3.4.78.2.2.4.2  2008/12/03 01:22:20  autotest-sc
# to avoid show fdb failure on voyager platforms change the d .*m flag to d.*m
#
# Revision 2.37.2.3.4.78.2.2.4.1  2008/11/28 05:10:33  jramarao
# merge from branch-pioneer_dev-v12-1-rel4
#
# Revision 2.37.2.3.4.78.2.2  2008/10/27 22:49:53  jramarao
# show log added at the time of core file
#
# Revision 2.37.2.3.4.78.2.1  2008/09/24 01:43:10  autotest-sc
# Fixed merged issue
#
# Revision 2.37.2.3.4.78  2008/09/20 07:30:02  jramarao
# Merge from branch-fixes_v12-1-rel0
#
# Revision 2.37.2.3.4.77  2008/08/05 03:44:06  lagrawal
# merge from branch-fixes_v12-1-rel0
#
# Revision 2.37.2.3.4.76.4.14  2008/08/02 01:01:49  lagrawal
# commented hub connection check faling badly in regression
#
# Revision 2.37.2.3.4.76.4.13  2008/08/02 00:18:08  lagrawal
# Send traffic for some more time for hub connections
#
# Revision 2.37.2.3.4.76.4.12  2008/07/30 23:20:21  lagrawal
# fix script issue
#
# Revision 2.37.2.3.4.76.4.11  2008/07/30 22:52:00  lagrawal
# added code to check connetion from ixia to DUT though hub
#
# Revision 2.37.2.3.4.76.4.10  2008/07/25 23:01:59  lagrawal
# merged changes from branch-dev_v12-1-rel2 and trunk-exos. cmd cvs update -dj branch-dev_v12-1-rel2 automation
#
# Revision 2.37.2.3.4.76.4.4.2.1  2008/07/02 17:36:30  msubramanian
# Change for option to not reset ixia by setting ixiaNoReset in .cfg file.
#
# Revision 2.37.2.3.4.76.4.4  2008/06/23 11:12:47  pmanda
# DisableDebugMode added
#
# Revision 2.37.2.3.4.76.4.3  2008/06/23 09:34:37  pmanda
# Clearing Trial License if any
#
# Revision 2.37.2.3.4.76.4.2  2008/06/12 15:49:07  ghundertmark
# Remove limitation to setup broadcom global variables only on std testbeds
#
# Revision 2.37.2.3.4.76.4.1  2008/06/07 01:33:18  lagrawal
# murge from branch-dev_v12-1-rel0
#
# Revision 2.37.2.3.4.76.2.1  2008/06/06 22:09:24  autotest-sc
# Murged from exos_br_12_1 to branch-dev_v12-1-rel0
#
# Revision 2.37.2.3.4.76  2008/04/15 05:09:54  djain
# code added for core with test case number
#
# Revision 2.37.2.3.4.75  2008/04/11 20:49:31  djain
# Moved report_end_test
#
# Revision 2.37.2.3.4.74  2008/02/20 01:36:15  djain
# Remove while spaces from the test number
#
# Revision 2.37.2.3.4.73  2008/01/17 23:07:40  dsuk
# efence modifications
#
# Revision 2.37.2.3.4.71  2008/01/11 21:16:30  dsuk
# using SendACmd for efence
#
# Revision 2.37.2.3.4.70  2008/01/11 11:12:15  nellinivasu
# Modified CheckCmdLegal to SendACmd in code to enable Ctrl+v+x+b reboot.
#
# Revision 2.37.2.3.4.69  2008/01/09 13:57:33  skumar
# Info exists efence
#
# Revision 2.37.2.3.4.68  2008/01/09 00:18:42  ghundertmark
# exSleep after stoptransmit to recover from contPacket
#
# Revision 2.37.2.3.4.67  2008/01/08 23:32:11  dsuk
# corrected handling of efence parameter
#
# Revision 2.37.2.3.4.66  2008/01/08 21:52:29  dsuk
# added support for ELECTRONIC FENCE
#
# Revision 2.37.2.3.4.65  2008/01/03 23:27:39  djain
# Added proc ChangeTraceFileName for check point
#
# Revision 2.37.2.3.4.64  2007/12/07 22:40:37  ghundertmark
# Add case for system setup failure for GetBcmInfoStd
#
# Revision 2.37.2.3.4.63  2007/12/04 18:06:18  ghundertmark
# Add condition to skip port info init for rtr testbeds
#
# Revision 2.37.2.3.4.62  2007/12/04 15:58:00  ghundertmark
# Add code to save bcom globals to fast
#
# Revision 2.37.2.3.4.61  2007/11/09 21:08:57  jramarao
# added support for ewar duts and continuous packet on ixia
#
# Revision 2.37.2.3.4.60  2007/10/09 17:27:38  jramarao
# Script error from the branch corrected
#
# Revision 2.37.2.3.4.59  2007/10/04 22:06:05  jramarao
# Merged from br 12-1
#
# Revision 2.37.2.3.4.58  2007/08/03 21:39:07  djain
# Added check for core on msm-a and msm-b
#
# Revision 2.37.2.3.4.57  2007/07/26 00:19:02  djain
# Renaming core file on msm-b
#
# Revision 2.37.2.3.4.56  2007/06/27 19:46:57  igokhale
# removed logout/login again for _verifyCFCorruptionStatusOnLogin
#
# Revision 2.37.2.3.4.55  2007/06/26 04:02:03  pananthasubramanian
# updated proc SystemSetup, SetupIxiaConnections to support generic DUT topology
#
# Revision 2.37.2.3.4.54.2.1  2007/08/20 22:57:53  djain
# Merged changes from trunk-exos Lib and added changes manually
#
# Revision 2.37.2.3.4.58  2007/08/03 21:39:07  djain
# Added check for core on msm-a and msm-b
#
# Revision 2.37.2.3.4.57  2007/07/26 00:19:02  djain
# Renaming core file on msm-b
#
# Revision 2.37.2.3.4.56  2007/06/27 19:46:57  igokhale
# removed logout/login again for _verifyCFCorruptionStatusOnLogin
#
# Revision 2.37.2.3.4.55  2007/06/26 04:02:03  pananthasubramanian
# updated proc SystemSetup, SetupIxiaConnections to support generic DUT topology
#
# Revision 2.37.2.3.4.54.2.2  2007/10/26 12:19:48  pananthasubramanian
# update SystemSetup proc and isEdpWorking proc to support eware duts
#
# Revision 2.37.2.3.4.54.2.1  2007/08/20 22:57:53  djain
# Merged changes from trunk-exos Lib and added changes manually
#
# Revision 2.37.2.3.4.58  2007/08/03 21:39:07  djain
# Added check for core on msm-a and msm-b
#
# Revision 2.37.2.3.4.57  2007/07/26 00:19:02  djain
# Renaming core file on msm-b
#
# Revision 2.37.2.3.4.56  2007/06/27 19:46:57  igokhale
# removed logout/login again for _verifyCFCorruptionStatusOnLogin
#
# Revision 2.37.2.3.4.55  2007/06/26 04:02:03  pananthasubramanian
# updated proc SystemSetup, SetupIxiaConnections to support generic DUT topology
#
# Changed license check to look for L2 license for Lynx platform.
#
# Revision 2.37.2.3.4.53  2007/05/02 16:34:03  igokhale
# added a "logout" before start of check connection, to let cf corruption command execute
#
# Revision 2.37.2.3.4.52  2007/04/05 00:15:03  igokhale
# *** empty log message ***
#
# Revision 2.37.2.3.4.51  2007/03/07 22:59:01  achilukuri
# Checking bad connection with just one show edp port all
#
# Revision 2.37.2.3.4.50  2007/03/03 03:30:24  achilukuri
# Added code to detect if there are any bad connections betwwen DUT and Hub
#
# Revision 2.37.2.3.4.49  2007/01/04 19:15:48  jramarao
# License failure correction
#
# Revision 2.37.2.3.4.48  2006/12/21 17:49:25  skumar
# Added send another frame for portId learning
#
# Revision 2.37.2.3.4.47  2006/12/07 14:14:06  skumar
# Clean tmpedp file, clear fdb removed
#
# Revision 2.37.2.3.4.46  2006/10/25 00:10:27  smohanty
# Merged from exos-br-11_5
#
# Revision 2.37.2.3.4.45  2006/10/04 00:24:02  jramarao
# changed for checkconnection
#
# Revision 2.37.2.3.4.44.2.1  2006/10/25 00:07:29  smohanty
# Added code to populate ixiaPortMappingArray for portId 9. This problem was
# introduced as the DUT port mapping was removed from cfg files for ixia port
# id 9
#
# Revision 2.37.2.3.4.44  2006/08/03 13:00:23  nellinivasu
# Added bcmPlatform check for cli 'clear platform system-dump'
#
# Revision 2.37.2.3.4.43  2006/08/01 11:45:23  nellinivasu
# Added 'clear platform system-dump' to proc SystemSetup
#
# Revision 2.37.2.3.4.42  2006/05/19 20:26:29  ghundertmark
# Add CheckForPreviousCore functionality
#
# Revision 2.37.2.3.4.41  2006/05/03 03:31:27  igokhale
# corrected spacing
#
# Revision 2.37.2.3.4.40  2006/03/31 02:47:59  igokhale
# Q3FY06 Rel commit
#
# Revision 2.37.2.3.4.39  2006/03/16 19:57:32  igokhale
# merged from branch12
#
# Revision 2.37.2.3.4.38  2006/03/16 19:33:16  igokhale
# merged from branch12
#
# Revision 2.37.2.3.4.37.2.1  2006/03/16 19:32:28  igokhale
# added code to allow for startcardnum:startportnum format in cfg file
#
# Revision 2.37.2.3.4.37.2.2  2006/03/16 19:54:58  igokhale
# undid last change
#
# Revision 2.37.2.3.4.37.2.1  2006/03/16 19:32:28  igokhale
# added code to allow for startcardnum:startportnum format in cfg file
#
# Revision 2.37.2.3.4.37  2005/10/18 00:47:47  skumar
# Put core file internal if no external card
#
# Revision 2.37.2.3.4.36  2005/09/16 02:05:49  skumar
# Committed topology optimization code for 8 port support
#
# Revision 2.37.2.3.4.35  2005/09/10 01:32:29  igokhale
# Changed delay after config vlan in checkConnection to 5 seconds to allow for 10gig
#
# Revision 2.37.2.3.4.34  2005/06/28 01:23:49  igokhale
# Added delay of 1 second before FDB learning to accomodate 10gig Aspen setup
#
# Revision 2.37.2.3.4.33  2005/06/16 01:40:03  skumar
# New product defs at Rel10
#
# Revision 2.37.2.3.4.32  2005/05/04 19:17:05  skumar
# Check license at least core
#
# Revision 2.37.2.3.4.31  2005/05/02 20:07:36  alim
# Login changes
#
# Revision 2.37.2.3.4.30  2005/04/13 01:00:58  skumar
# Add back clear log st as uncon sw all does not clear log
#
# Revision 2.37.2.3.4.29  2005/03/14 16:59:03  skumar
# Reduced edp interval, reset edp after CheckConnection
#
# Revision 2.37.2.3.4.27  2005/02/19 00:11:25  cshaw
# dumpAllSwitchInfo when connectionBad
#
# Revision 2.37.2.3.4.26  2005/01/07 23:46:02  skumar
# Added sleep 5 for edp delay, fix for loop for correct trunkports
#
# Revision 2.37.2.3.4.25  2004/12/18 01:57:59  dchan
# commit for release 8
#
# Revision 2.37.2.3.4.24  2004/12/10 00:06:09  skumar
# Check for summit for SummitX450 for memoryCard
#
# Revision 2.37.2.3.4.23  2004/12/07 18:49:17  skumar
# Fix the fdb learning reports specific to DUT
#
# Revision 2.37.2.3.4.22  2004/11/18 20:43:31  skumar
# Fix bug w.r.t. card get ixia routine for 10G blades
#
# Revision 2.37.2.3.4.21  2004/11/17 19:11:30  skumar
# Fix erronous return value from IsEDPWorking
#
# Revision 2.37.2.3.4.20  2004/11/13 00:35:24  skumar
# Redo edp routines, isExosPlatform, isEDPWorking
#
# Revision 2.37.2.3.4.19  2004/11/11 18:33:28  mverma
# Reverting back the accidental change to useNewMethod variable.
#
# Revision 2.37.2.3.4.18  2004/11/09 22:55:49  mverma
# Adding snmp library files to support STP
#
# Revision 2.37.2.3.4.17  2004/11/03 12:44:20  skumar
# Do not use regexp instead use string match
#
# Revision 2.37.2.3.4.16  2004/11/03 12:12:31  skumar
# Avoid regex issue in older redhat versions
#
# Revision 2.37.2.3.4.15  2004/10/20 19:21:01  skumar
# Disable edp for Aspen until fixed
#
# Revision 2.37.2.3.4.14  2004/10/19 20:15:32  mverma
# Added the support to use the old method for trunk port validation.
#
# Revision 2.37.2.3.4.13  2004/10/15 18:32:12  skumar
# Put non-default vlan code for checkConnection
#
# Revision 2.37.2.3.4.12  2004/10/15 02:33:43  skumar
# Core file capture, ixiaVlan in checkConnection
#
# Revision 2.37.2.3.4.11  2004/10/12 22:07:20  mverma
# Using "show edp" for trunk-port connection validation, during check connection.
#
# Revision 2.37.2.3.4.10.2.1  2004/10/15 00:54:43  skumar
# coredump on memorycard starting 11.1.0.21
#
# Revision 2.37.2.3.4.10  2004/09/30 00:59:25  mverma
# Exos Rel7 check in.
#
# Revision 2.37.2.3.4.9  2004/08/03 16:10:19  rmendis
# Put delay to sync vlan table
#
# Revision 2.37.2.3.4.8.2.1  2004/08/20 20:26:12  alim
# Add support for startPortNum
#
# Revision 2.37.2.3.4.8  2004/07/28 18:39:11  skumar
# Added Aspen support
#
# Revision 2.37.2.3.4.7  2004/07/09 01:15:15  alim
# Remove references to exos variable
#
# Revision 2.37.2.3.4.6  2004/06/04 02:54:50  skumar
# Moved SetupIxiaConnections before skip ixia for checkConnection NO_IXIA
#
# Revision 2.37.2.3.4.5  2004/04/01 21:57:03  skumar
# Commit as part of release5
#
# Revision 2.37.2.3.4.4  2003/12/03 03:44:34  skumar
# Enable "dis idletime"
#
# Revision 2.37.2.3.4.3  2003/11/24 06:02:13  dchan
# trunk-exos release 3
#
# Revision 2.37.2.3.4.2.2.2  2003/11/10 19:57:21  skumar
# Avoid package req twice
#
# Revision 2.37.2.3.4.2.2.1  2003/10/28 17:59:35  skumar
# Fixes for no-l3 license, isExosPlatform added.
#
# Revision 2.37.2.3.4.2.4.2  2003/10/11 03:17:12  tnguyen
# BD-Mariner changed to BD-10808
#
# Revision 2.37.2.3.4.2.4.1  2003/10/08 19:35:29  tnguyen
# Support downloading image for Mariner and PC
#
# Revision 2.37.2.3.4.2  2003/10/06 17:16:20  dchan
# trunk-exos release 2
#
# Revision 2.37.2.3.4.1.2.2  2003/09/26 19:41:36  cshaw
# seet RELEASE_MASTER from env(EXOS_RELEASE_MASTER)
#
# Revision 2.37.2.3.4.1.2.1  2003/09/24 18:37:19  skumar
# EXOS specific fixes/changes.
#
# Revision 2.37.2.3.2.1  2003/06/23 21:28:45  cshaw
# Merged in EW trunk
#
# Revision 2.37.2.3  2003/06/10 23:50:47  tnguyen
# Changes for mariner support
#
# Revision 2.37.2.2  2003/03/22 01:03:47  avillait
# Chassis and stackable support
#
# Revision 2.37.2.1  2003/03/06 22:17:48  tnguyen
# Skipping checking release version for exos platform
#
# Revision 2.47  2003/04/18 19:31:46  autotest
# Change as taken from br-1-3.
#
# Revision 2.46.8.1  2003/04/14 19:40:38  autotest
# Fix check for Release master
#
# Revision 2.46  2002/12/10 22:49:45  skumar
# Merged from br-1-0.
#
# Revision 2.45.2.2  2002/12/10 21:09:38  skumar
# Put comments, proc headers.
#
# Revision 2.45.2.1  2002/12/05 00:38:45  skumar
# Minor change to writing to fast init file.
#
# Revision 2.45  2002/10/30 19:46:29  eyoung
# Moved setup of numIxiaCd variable after call to SetupIxiaConnections.  This fixes a problem when running tests without an IXIA.
#
# Revision 2.44  2002/10/29 23:57:04  skumar
# Grant's support for non-ethernet wans.
#
# Revision 2.42  2002/09/23 19:15:12  skumar
# Add config reboot-loop-prote threshold at systemSetup.
#
# Revision 2.41  2002/09/16 20:47:27  skumar
# Move cl lo st, cl fd, dis clipa etc outta CheckConnection.
#
# Revision 2.40  2002/08/26 23:30:53  skumar
# Add dis idletime.
#
# Revision 2.39  2002/08/08 20:56:45  skumar
# Change call to CheckKeyValue.
#
# Revision 2.38  2002/07/30 21:36:52  aleu
# add description header for each proc
#
# Revision 2.37  2002/07/11 20:45:06  rsrinivasan
# 1] Added support to configure Summit 24e3 Advanced-edge license.
# 2] Added support to verify build info other than Release_Master
#
# Revision 2.36  2002/05/06 21:44:07  aleu
# remove usage of all cardSpeed global var
#
# Revision 2.35  2002/04/24 21:34:38  aleu
# modify GetNumIxiaCd{} to be based on ports no. card by card (10/100 card type may vary due to TXS8 addition)
#
# Revision 2.34  2002/04/02 23:07:07  aleu
# give the DUT # in GetDUTPort{}
#
# Revision 2.33  2002/03/30 02:47:05  skumar
# Put portMappingList in fast file with {}.
#
# Revision 2.32  2002/03/28 22:40:02  skumar
# Add bladeType into fastInit file in DUTs_info, portMappingList too.
#
# Revision 2.31  2002/03/28 18:19:42  skumar
# Remove EXTREME_PLATFORM, add fast global var.
#
# Revision 2.30  2002/01/12 04:04:11  tquach
# Take out xmk
#
# Revision 2.29  2001/12/13 01:50:08  eyoung
# Removed extraneous result_debug statement and comments.
#
# Revision 2.28  2001/12/10 20:40:09  ghundertmark
# Uncomment CheckXMKStatus $DUT to correct errant commit
#
# Revision 2.27  2001/12/10 16:38:09  eyoung
# Erase ATMSystemSetup
#
# Revision 2.26  2001/11/08 01:24:17  aleu
# add "package require Mpexpr"
#
# Revision 2.25  2001/04/18 01:10:31  Autotest
# Add godzillla platform
#
# Revision 2.24  2001/04/17 23:22:42  skumar
# Disable network port in systemsetup.
#
# Revision 2.24  2001/04/17 23:22:42  skumar
# Disable network port in systemsetup.
#
# Revision 2.24  2001/04/17 23:22:42  skumar
# Disable network port in systemsetup.
#
# Revision 2.23  2001/03/05 22:06:06  skumar
# Add a if construct to avoid tcl break because of undefined
# Variable detectMACList.
#
# Revision 2.22  2001/03/03 20:09:29  skumar
# Send All arps and then check fdb in "AutoDetect" option in
# PortMappingList.
#
# Revision 2.21  2001/02/16 16:50:06  skumar
# Put cli to enable full l3 license.
#
# Revision 2.20  2001/02/12 21:20:46  skumar
# Return valid portId for MapDUTPortId.
# Use GetDUTPort for any other purpose.
#
# Revision 2.19  2001/01/12 00:37:51  tnguyen
# Add xmk (2nd OS) status check
#
# Revision 2.18  2001/01/02 19:47:52  tnguyen
# Add command to clear DUTs log,
# so the logs can be saved in each regression run
#
# Revision 2.17  2000/12/15 20:41:40  tnguyen
# Add automatic DUT ports detection
#
# Revision 2.16  2000/11/03 23:15:18  tnguyen
# Add feature to detect ports and support different kinds of ixia cards
#
# Revision 2.15  2000/10/18 00:56:41  skumar
# Added check for build owner to be "Relase_Master".
#
# Revision 2.14  2000/10/12 21:23:08  skumar
# Added "disable clipaging"
#
# Revision 2.13  2000/09/25 18:17:27  tnguyen
# Add logic to bypass ixia initialization
#
# Revision 2.12  2000/09/12 22:52:00  tnguyen
# Add option not to initialize ixia and check connection
#
# Revision 2.11  2000/08/10 22:08:13  tnguyen
# Add checking trunking pair on different ports correctly
#
# Revision 2.10  2000/08/07 20:43:17  tnguyen
# Change getATrunkPort to GetATrunkPort
#
# Revision 2.9  2000/08/04 22:25:33  tnguyen
# Global change of commonly used funtions to conform with new conventions
#
# Revision 2.8  2000/08/04 18:16:05  skumar
# Logic change in Trunk check.
#
# Revision 2.7  2000/08/04 01:14:32  skumar
# Removed erronous "!" in trunkPortList.
#
# Revision 2.6  2000/08/04 00:58:33  tnguyen
# Not crash if trunkPortList not exist
#
# Revision 2.5  2000/08/02 18:08:40  tnguyen
# Fix portMapping for Trunking Port, no need to map
#
# Revision 2.4  2000/08/02 17:27:43  tnguyen
# Modify so that TrunkingList should specify blade id also for BD
#
# Revision 2.3  2000/07/27 20:59:22  skumar
# Set the default port number to be totalPorts in GetNumIxiaCd.
#
# Revision 2.2  2000/07/27 19:19:07  tnguyen
# Temporary fix for check trunking problem
#
# Revision 2.1  2000/07/27 01:54:46  tnguyen
# Function to do initialization and check connection setup
#
#
##################################################################

##################################################################    
# Procedure Name: SystemSetup
# Description:
#     	Do ixia initialization, build portMapping, and optionally 
#	check connections setup.
#       Performs CheckConnection if CheckConnection is set
#       otherwise basic cli setup on DUTs
# Input args: none 
# Return value: ConnectionOkay or Connectionbad
# Output args: none 
# Typical usage: 
#	 SystemSetup
# Category: SetupSwitch
##################################################################
proc SystemSetup {} {

    ################################################################
    set testNo "System Setup"
    set title $testNo
    ################################################################

    # ----- Environment variables setup
    global ixiaCh1
    global startCardNum
    global portMappingList
    global trunkPortList
    global checkConnection
    global switchPort2DefaultRouter
    global ixiaPortMappingArray
    global fast
    global RELEASE_MASTER
    global DUTs_info
    global exos
    global DUT
    global env
    global whichDutNow
    # EY-06-08-2007: Added bcmLynx global variable.
    global bcmPlatform bcmLynx;
    global lastDUT
    global numDUT 
    global pioneerPlatform 
    set useNewMethod 1
    
    if ![info exist RELEASE_MASTER] {
	set RELEASE_MASTER Release_Master
    }  
    set fd_res [open_result_file "$testNo"]
    set time1 [clock seconds]
    
    result_h1 "$title"
    report_start_test "$title"
    
    #generate mapping info for physical portId connected between DUT
    set portDutListUsed [SetupDUTConnections]
    
    set firstSubStr "DUT"
    set lastSubStr "_CONNECT"
    for {set i 1} {$i <=$numDUT} {incr i 1} {
	global $firstSubStr$i$lastSubStr
	global $firstSubStr$i${lastSubStr}B ;#global variable for msm-b
	if [info exists $firstSubStr$i$lastSubStr] {
	    lappend DUTList $i
	}
    }
    
    foreach testDUT $DUTList {

    #------ adding this part of script to support eware duts
       global eware_dut
       if {[info exists eware_dut]} {
         if {[lsearch $eware_dut $testDUT] == -1 } {
            set loopVar 1
         } else {
            set loopVar 0
         }
       } else {
         set loopVar 1
       }

      #---- adding the loop for  exos duts
      if {$loopVar} {

	# ----- Switch config 
	Login  [expr $$firstSubStr$testDUT$lastSubStr]
        
        # testing tftp connectivity
        set returnFlagTftp [tftpTest]
        if {$returnFlagTftp == "ok"} {
          result_ok "tftp server connectivity test passed"
        } else {
          result_error "tftp server connectivity test failed"
        }

	Login  [expr $$firstSubStr$testDUT$lastSubStr]
        
        # Code Added to enable Ctrl+v+x+b reboot
        EnableDebugMode
        SendACmd "debug hal configure sysrq 1"
        exSleep 2
        DisableDebugMode

        # set regresession server time
        set tm [exec date "+%m %d %Y %H %M %S"]
        set timeCmd "configure time "
        append timeCmd $tm
        SendACmd $timeCmd

         #------ check added to skip license if not needed
         set skipLicVar 1
         global skipLicenceCheck
         if [info exists skipLicenceCheck] {
            if {$skipLicenceCheck} {
            set skipLicVar 0
            }
          }
        if $skipLicVar {

        set parameterList ""
        lappend parameterList "{30 days Trial} exist"
        set result [CheckKeyValue "show license" $parameterList -reportResults 0]
        if {$result == "ok"} {
           EnableDebugMode
           SendACmd "debug epm clear trial-license"
           CheckReboot
        }
        DisableDebugMode

	set parameterList ""
        # EY-06-08-2007: Check for L2(edge) license for Lynx platform.
        if {[regexp $bcmLynx $DUTs_info(DUT$testDUT,platform)]} {
            lappend parameterList "L2.* exist";
        } else {
            lappend parameterList "{core} exist";
        }
	if {[CheckKeyValue "show license" $parameterList]!="ok"} {
         if {$testDUT == 1} {
            set parameterList ""
            lappend parameterList "{Enabled License Level:} 0 1"
            lappend parameterList "{Enabled License Level:} 1 1"
            set getLicense [GetKeyValue "show license" $parameterList]
            if {[lindex [lindex $getLicense 0] 1] != ""} {
              set temp [split [lindex $getLicense 0] " "]
              set currentLicense [concat [lindex $temp 0][lindex $temp 1]]
            } else {
              set temp [split [lindex $getLicense 0] " "]
              set currentLicense [lindex $temp 0]
            }
            if {[EnableLicense \
                 [string tolower $currentLicense] core] == "error"} {
	         if {![regexp $pioneerPlatform $DUTs_info(DUT$testDUT,platform)]} {
                     return error
	         }    
            }
           } else {
                if {![regexp $pioneerPlatform $DUTs_info(DUT$testDUT,platform)]} { 
                    return error
                }    
          }
        }
       


	unset parameterList
        }
	
	SendACmd "clear log st"
	SendACmd "disable clipa"
	SendACmd "disable idletime"
	SendACmd "enable edp ports all"
	SendACmd "con edp advertisement-interval 15 holddown-interval 60"
         EnableDebugMode
         SendACmd "!echo dump_stack > /sys/module/watchdog/parameters/watchdog_warn_behavior"
        if {[regexp -nocase $bcmPlatform $DUTs_info(DUT$testDUT,platform)]} {
           SendACmd "clear platform system-dump"
        }

	global stackable
	if {[string match "present" $DUTs_info(DUT${testDUT},memoryCard)] && \
		![regexp -nocase $stackable $DUTs_info(DUT$testDUT,platform)] && \
		[CompareRelease [GetVersion DUT${testDUT}] 11.1.0.21]>=0} {
	    SendACmd "configure debug core-dumps memorycard"
	} elseif {[CompareRelease [GetVersion DUT${testDUT}] 11.1.0.21]>=0} {
	    SendACmd "configure debug core-dumps internal-memory"
	}
        if {[info exists DUTs_info(current_module)]} {
	    CheckForPreviousCore $testDUT
            if {[info exists $firstSubStr$testDUT${lastSubStr}B]} {
               result_debug "Renaming core on msm-b if any"
               Login  [expr $$firstSubStr$testDUT${lastSubStr}B] -masterCheck 0 -CheckOperational 0
	       CheckForPreviousCore $testDUT backup
               Login  [expr $$firstSubStr$testDUT${lastSubStr}] -masterCheck 0 -CheckOperational 0
            }
        }
    }
	#Don't check for mariner now 
        if { [isExosPlatform "DUT$testDUT"] != 1 } {
           # ----- Switch config
           Login  [expr $$firstSubStr$testDUT$lastSubStr]
           SendACmd "clear log st"
           SendACmd "clear fdb"
           SendACmd "disable clipa"
           SendACmd "disable idletime"
           SendACmd "configure reboot-loop-protection threshold 10 3"
           SendACmd "enable edp ports all"
         EnableDebugMode
         SendACmd "!echo dump_stack > /sys/module/watchdog/parameters/watchdog_warn_behavior"

            #    SendACmd "configure reboot-loop-protection threshold 10 3"

            lappend parameterList "{Image *:.*by} $RELEASE_MASTER"
            CheckKeyValue "show version" $parameterList -comment "- Show $RELEASE_MASTER"
            unset parameterList

            set version [GetVersion "DUT$testDUT" "2"]
            puts "DUT$testDUT version: $version"
            if {($version >= 6.2) && ([regexp -nocase "godzilla" [GetPlatform]] != 1) } {
                ##  CheckXMKStatus $testDUT
            }

            lappend licenseKey "{License:} 1"
            set licenseVal [GetKeyValue "show sw" $licenseKey]
            if [regexp -nocase "summit24e3" $DUTs_info(DUT${testDUT},platform)] {
                if ![regexp -nocase "advanced edge" $licenseVal] {
                    SendACmd "enable license advanced-edge 7656871"
                }
            } elseif ![regexp -nocase "full l3" $licenseVal] {
                # Enable full l3 license
                SendACmd "enable license fullL3 7656871"
            }

            unset licenseKey
            unset licenseVal

    }

}
#   puts "----------------------- 10 -------------------------" 
    #Connect to ixia and setup connections
    if { [SetupIxiaConnections] == "connectionBad" } {
#   puts "----------------------- 11 -------------------------" 
	return connectionBad
    }
#   puts "----------------------- 12 -------------------------" 
    
    # Not initializing ixia or check connection
    if {([info exists checkConnection] == 1) && $checkConnection == "NO_IXIA" } {
	
	result_debug "Skipping ixia initialization and check connection"
	
	################################################
	# Clean up
	################################################
	set time2 [clock seconds]
	result_p "*** Time for $testNo = [expr $time2-$time1] secs\n\n"
	close_result_file
	report_end_test
	return "connectionOkay"
    }
    
    
    # ----- Test variables setup
    set numIxiaCd [GetNumIxiaCd]
    if {$numIxiaCd == 0} {
	result_debug "No ixia card found to be initialized"
	return "connectionBad"
    }
    
    # Check if desired to proceed
    if {([info exists checkConnection] == 1) && $checkConnection == 0} {
	foreach dut $DUTList {
	    # ----- Switch config 
	    Login  [expr $$firstSubStr$dut$lastSubStr]
	    SendACmd "clear log st"
	    SendACmd "disable clipa"
         EnableDebugMode
         SendACmd "!echo dump_stack > /sys/module/watchdog/parameters/watchdog_warn_behavior"
            if {[regexp -nocase $bcmPlatform $DUTs_info(DUT$dut,platform)]} {
               SendACmd "clear platform system-dump"
            }

        }
	################################################
	# Clean up
	################################################
	set time2 [clock seconds]
	result_p "*** Time for $testNo = [expr $time2-$time1] secs\n\n"
	close_result_file
	report_end_test
	return "connectionOkay"
    }
    
    set returnVal "connectionOkay"
    set lastDUT 0
    foreach testDUT $DUTList {
	
	set thisDutPorts ""
	foreach portDutPair $portDutListUsed {
	    if {[lindex $portDutPair 1] == $testDUT} {
		lappend thisDutPorts [lindex $portDutPair 0]
	    }
	}
	
	Login  [expr $$firstSubStr$testDUT$lastSubStr]
        # Added By nellinivasu; to overcome ports still part of default vlan.
        SendACmd "configure vlan default delete ports all"
	# Next two lines required temporarily for "debug hal show compact-flash"
	#logout
	#Login  [expr $$firstSubStr$testDUT$lastSubStr]
	set tagId [random 4094]
	if {$tagId==1||$tagId==0} {set tagId 2}
	SendACmd "create vlan ixiaVlan"
        set output  [SendACmd "config vlan ixiaVlan tag $tagId"]          
        result_debug "output :: $output"
        if {[regexp -nocase "Error" $output]} {                
           set tagId 3
           SendACmd "config vlan ixiaVlan tag $tagId"
        }

	SendACmd "config vlan ixiaVlan add port all tag"
	
	exSleep 5

	#result_debug "Ports checked for $testDUT DUT are $thisDutPorts"
	foreach portId $thisDutPorts {
	    set frameSent [SendFrame -txPortId $portId -tag $tagId -frameSize 68 -frameRate 100 -streamType "contPacket"]
#	    set frameSent [SendFrame -txPortId $portId -tag $tagId -frameSize 68]
#puts "------------------------c-1 ----- frameSent -- $frameSent" 
	    set sourceMac [GetSourceMacAddress $frameSent]
#puts " ------------ c-2 ---- sourceMac -------- $sourceMac"
	    set sourceMacFdb($portId) [IxiaMacFormat2FdbFormat $sourceMac]
	    result_debug "FdbMac for port $portId: Source:|$sourceMacFdb($portId)| Dest:|[GetDestMacAddress $frameSent]|"
            #LK commented below 2 second sleeep and StopPortsTransmit will be done after checkConnection is verified
            exSleep 2
           StopPortsTransmit $portId
	}
        exSleep 20
	foreach portId $thisDutPorts {
	    if { [regexp -nocase "a" [MapDUTPortId $portId $testDUT] ] } {
		lappend detectMACList "{$sourceMacFdb($portId) .*ixiaVlan.* d.*m} 1"
	    } else {
		lappend checkMACList "$sourceMacFdb($portId) ixiaVlan [MapDUTPortId $portId $testDUT] exist"
	    }
	}
#puts "----------------- c0 ---- detectMACList ---- $detectMACList"
	if {[info exists detectMACList]} {
	    set DUTPortList [GetKeyValue "show fdb" $detectMACList]
	}
	
	foreach portId $thisDutPorts {
	    if { [regexp -nocase "a" [MapDUTPortId $portId $testDUT] ] } {
		set portIndex [lsearch -regexp $detectMACList "$sourceMacFdb($portId) .*ixiaVlan.* d.*m"]
		#result_debug "Auto detecting portId: $portId DUTPort: [lindex $DUTPortList $portIndex]"
		set replaceIndex [lsearch -regexp $portMappingList "$portId *A * $testDUT"]

#puts "------------------- c1 replaceIndex --- $replaceIndex"
		if {$replaceIndex != -1} {
#puts " ------- c2 portMappingList --------- $portMappingList"
#puts " -------- c3 portId  ---- $portId"
#puts "---------- c4 DUTPortList ---- $DUTPortList"
#puts "-------- c5 portIndex -------- $portIndex"
#puts "---------- c6 testDUT --------- $testDUT"
		    set portMappingList [lreplace $portMappingList $replaceIndex $replaceIndex "$portId [lindex $DUTPortList $portIndex] $testDUT"]
		}
	    }
	}
	result_debug "portMappingList: $portMappingList"
	
	if {([info exists checkMACList] == 1)} {
	    ################################################
	    set subTest "Checking DUT$testDUT Connections via MAC fdb Learning"
	    ################################################
	    result_h2 "$subTest"
	    report_start_test "$subTest"
	    set returnFlag [CheckFdb $checkMACList $fd_res $testNo]
	    unset checkMACList
	    report_end_test
	} else {
	    set returnFlag "ok"
	}
	
	################################################
	set subTest "Detecting DUT$testDUT Connections via MAC fdb Learning"
	################################################
	result_h2 "$subTest"
	report_start_test "$subTest"
	SetupDUTConnections
	set dutSpecificPortMappingList ""
	foreach el $portMappingList {
	    if {[lindex $el 2]==$testDUT} {
		lappend dutSpecificPortMappingList $el
	    }
	}
	if {[regexp "NOT" $dutSpecificPortMappingList] } {
	    set returnFlag "error"
	    result_error "Unable to detect one or more connections on DUT$testDUT"
	    result_debug "Please recheck all links"
	}
#	foreach portId $thisDutPorts {
#            StopPortsTransmit $portId
#	}
	SendACmd "delete vlan ixiaVlan"
	report_end_test

	#EDP check whether it's working or not
	set dut [expr $$firstSubStr$testDUT$lastSubStr]
	if {$useNewMethod==1} {
	    set dutEdpInfo($dut) [isEdpWorking $dut $DUTList]
	   	
	    if {$dutEdpInfo($dut)==0} {
		set returnVal "connectionBad"
	    } elseif {$dutEdpInfo($dut)==-1} {
		set useNewMethod 0
	    } 
}
	
        if { ($returnFlag != "ok") || ($returnFlagTftp != "ok") } {
	    set returnVal "connectionBad"
	}
    }
    if {[info exist fast] && ($fast != "NULL")} {
	puts $fast "set portMappingList \{$portMappingList\}"
    }
    
    # In case EDP did not work at all
    if {$useNewMethod==0} {
	result_debug "Using the old Ixia traffic based trunk port validation..."
	puts "|[llength $DUTList]|[info exists trunkPortList]|"
	if {[llength $DUTList] > 1 && [info exists trunkPortList]} {
	    foreach trunkPair $trunkPortList {
		set firstDUT [lindex $trunkPair 0]
		set secondDUT [lindex $trunkPair 1]
		#trunk port specification, no need to check
		if {$secondDUT == 0 } { continue }
		set portNumber [lindex $trunkPair 2]
		Login [expr $$firstSubStr$firstDUT$lastSubStr]
		SendACmd "create vlan ixiaVlan"
		SendACmd "config vlan ixiaVlan tag $tagId"
		SendACmd "config vlan ixiaVlan add port $portNumber tag"
		
		#now we have to find the corresponding index
		set secondDUTPort "PORT_NOT_FOUND"
		set index 1
		while { [GetATrunkPort $firstDUT $secondDUT $index] != "PORT_NOT_FOUND" } {
		    if { [GetATrunkPort $firstDUT $secondDUT $index] == $portNumber} {
			set secondDUTPort [GetATrunkPort $secondDUT $firstDUT $index]
			break
			
		    }
		    incr index
		}
		# Add support for non ethernet wans
		#Each port added adds { {1 2 1 6:1 F48T} {fSw sSw index port hdWare} }
		unset   DUT(trunk,usageList)
		lappend DUT(trunk,usageList) "$firstDUT $secondDUT $index $portNumber\
			[GetSlotNumType $firstDUT $portNumber]"
		lappend DUT(trunk,usageList) "$secondDUT $firstDUT $index $secondDUTPort\
			[GetSlotNumType $secondDUT $secondDUTPort]"
		puts "##########################\r"
		puts "trunk $DUT(trunk,usageList) ##############"
		
		#need to get a portId that belongs to the firstDUT
		set ixiaCdPort [lindex [lindex $portMappingList 0] 0]
		foreach port $portMappingList {
		    if {[lindex $port 2] == $firstDUT } {
			set ixiaCdPort [lindex $port 0]
			break
		    }
		}
		SendACmd "config vlan ixiaVlan add port [MapDUTPortId $ixiaCdPort $firstDUT] tag"
		
		Login [expr $$firstSubStr$secondDUT$lastSubStr]
		SendACmd "create vlan ixiaVlan"
		SendACmd "config vlan ixiaVlan tag $tagId"
		SendACmd "config vlan ixiaVlan add port $secondDUTPort tag"
		
		set frameSent [SendFrame -txPortId $ixiaCdPort -tag $tagId -frameSize 68]
		after 300
		set frameSent [SendFrame -txPortId $ixiaCdPort -tag $tagId -frameSize 68]
		set sourceMac [GetSourceMacAddress $frameSent]
		set srcMacFdb [IxiaMacFormat2FdbFormat $sourceMac]
		result_debug "FdbMac for port $ixiaCdPort:|$srcMacFdb|[GetDestMacAddress $frameSent]|"
		lappend checkMAC "$srcMacFdb ixiaVlan $secondDUTPort exist"
		
		
		################################################
		set subTest "Checking Trunking #$index between DUT$firstDUT and DUT$secondDUT via MAC fdb Learning"
		################################################
		result_h2 "$subTest"
		report_start_test "$subTest"
		
		set returnFlag [CheckFdb $checkMAC $fd_res $testNo]
		unset checkMAC
		report_end_test
		
		if { $returnFlag != "ok" } {
		    set returnVal "connectionBad"
		}
		#have to remove this trunk port, otherwise might cause flooding if there is a loop
		AlienWanClean
		Login [expr $$firstSubStr$firstDUT$lastSubStr]
		SendACmd "delete ixiaVlan"
		
		Login [expr $$firstSubStr$secondDUT$lastSubStr]
		SendACmd "delete ixiaVlan"
	    }
	    
	}
    }
    
    ################################################
    # Clean up
    ################################################
    foreach testDUT $DUTList {
	Login  [expr $$firstSubStr$testDUT$lastSubStr]
        global eware_dut
            if {[info exists eware_dut]} {
               if {[lsearch $eware_dut $testDUT] == -1 } {
                  SendACmd "disable edp ports all"
                  SendACmd "con edp advertisement-interval 60 holddown-interval 180"
               } else {
                  SendACmd "disable edp ports all"
               }
           } else {
                  SendACmd "disable edp ports all"
                  SendACmd "con edp advertisement-interval 60 holddown-interval 180"
           }
           #_verifyCFCorruptionStatusOnLogin

    }
    # Gather portID info (generation platform speed etc) on a portid basis
    if {$returnFlag == "ok"} {
        #GetPortIdInfoStd 1
    }
set numPortIdNeeded [GetHighestPortId]
# adding check for ixia to hub connection
set hubConnectionStatus "ok"
#commenting the code for time beeing need to work on it
if { 0 } {
if {[llength $DUTList] > 1 && ($numDUT == 5 ) && [info exists trunkPortList] && ($numPortIdNeeded >= 11)} {
       set tagId 99
       set portId 9
       foreach testDUT $DUTList {
                Login  [expr $$firstSubStr$testDUT$lastSubStr]
	SendACmd "create vlan ixiaVlan"
	SendACmd "config vlan ixiaVlan tag $tagId"
	SendACmd "config vlan ixiaVlan add port all tag"
        }
       set frameSent [SendFrame -txPortId $portId -tag $tagId -frameSize 68 -streamType "contPacket"]
       exSleep 5 
       set sourceMac [GetSourceMacAddress $frameSent]
       set sourceMacFdb($portId) [IxiaMacFormat2FdbFormat $sourceMac]
       result_debug "FdbMac for port $portId: Source:|$sourceMacFdb($portId)| Dest:|[GetDestMacAddress $frameSent]|"	
       StopPortsTransmit $portId
       exSleep 2
        foreach testDUT $DUTList {
	    foreach trunkPair $trunkPortList {
		set firstDUT [lindex $trunkPair 0]
		set secondDUT [lindex $trunkPair 1]
		set portNumber [lindex $trunkPair 2]
		if {($secondDUT == 0 ) && ($firstDUT == $testDUT) } {
                  set detectMACList "" 
	         lappend detectMACList "{$sourceMacFdb($portId) .*ixiaVlan.* d.*m} exist"
                Login  [expr $$firstSubStr$testDUT$lastSubStr]
                set returnFlag [CheckKeyValue "show fdb" $detectMACList -time {s: 1 i: 5 d: 20 f: 20 r} -comment "check ixia to DUT connection through hub between Ixia and DUT $testDUT" ]
		SendACmd "delete ixiaVlan"
                if { $returnFlag != "ok" } {
                    set hubConnectionStatus "connectionBad"
                }
                break
               }
             }
          }
    }
}
    

    set time2 [clock seconds]
    result_p "*** Time for $testNo = [expr $time2-$time1] secs\n\n"
    close_result_file
    report_end_test
    if {$hubConnectionStatus == "connectionBad"} {
      set returnVal "connectionBad"
    }
    if {$returnVal == "connectionBad"} {
	dumpAllSwitchInfo;
    }
    return $returnVal
}

##################################################################    
# Procedure Name: GetNumIxiaCd
# Description:
#     	Get the number of ixia cards in testbed by a given total 
#	number of ports
# Input args: {totalPorts} 
# Output args: none 
# Return value: integer
# Typical usage: 
#	 set numIxiaCd [GetNumIxiaCd $maxPorts]
# Category: Utility
##################################################################
proc GetNumIxiaCd { {totalPorts 0} } {
    global portMappingList
    global startCardNum
    
    # get the last ixia port number from cfg port list, if no port is specified
    if {$totalPorts == 0 } {
	set totalPorts [lindex [lindex $portMappingList [expr [llength $portMappingList] -1 ]] 0]
    }
    
    set result 1
    set cardNum $startCardNum
    set numPortPerCd [findNumPortPerIxiaCard $cardNum]
    while { $totalPorts > $numPortPerCd } {
	incr result
	set totalPorts [expr $totalPorts - $numPortPerCd]
if {0} {
	if {![card get 1 [expr $cardNum+1]]} {
	    incr cardNum
	}
}
	set numPortPerCd [findNumPortPerIxiaCard $cardNum]
    }
    return $result
}

##################################################################    
# Procedure Name: GetHighestPortId
# Description:
#     	Get the highest ixia portId based on portMappingList 
# Input args: none 
# Output args: none 
# Return value: integer
# Typical usage: 
#	 set numPortIdNeeded [GetHighestPortId]
# Category: Utility
##################################################################
proc GetHighestPortId { } {
    global portMappingList
    set maxPortId 0
    foreach portList $portMappingList {
	set portId [lindex $portList  0]
	if {$portId > $maxPortId} {set maxPortId $portId}
    }
    return $maxPortId
}

##################################################################    
# Procedure Name: GetATrunkPort
# Description:
#     	Return the index-th port number on firstSw that links to secondSw.
# Input args: firstSw secondSw {index} 
# Output args: none 
# Return value: integer or a : separated integer set
# Typical usage: 
#	  SendACmd  "conf ebgp add port [GetATrunkPort 1 3]"
# Category: Utility
##################################################################
proc GetATrunkPort {firstSw secondSw {index 1} } {
    global DUT
    global DUTs_info
    
    set portList [GetTrunkPortList $firstSw $secondSw]
    #use the first switch id to get the default blade
    if {$index > [llength $portList]} { return "PORT_NOT_FOUND" }
    if {$index < 1} { return "PORT_NOT_FOUND" }
    # add support for non ethernet wan ports
    #Each port added adds { {1 2 1 6:1 F48T} {fSw sSw index port hdWare} }
    set tempList [GetTrunkPortList $secondSw $firstSw]
    if {[info exists DUTs_info(debugFlag)]} {
	if {$DUTs_info(debugFlag)==1} {
	    result_debug "INFO: DUT$firstSw [lindex $portList [expr $index -1]] goes to DUT$secondSw [lindex $tempList [expr $index -1]]"
	}
    }
    lappend DUT(trunk,usageList) "$firstSw $secondSw $index [lindex $portList [expr $index -1]] \
	    [GetSlotNumType $firstSw [lindex $portList [expr $index -1]]]"
    return [lindex $portList [expr $index -1]]
}

##################################################################    
# Procedure Name: GetTrunkPortList
# Description:
#     	Return the list of all trunk port numbers on firstSw that link to secondSw.
# Input args: firstSw secondSw 
# Output args: none 
# Return value: list of integers or list of : separated integer set
# Typical usage: 
#	  set portList [GetTrunkPortList $firstSw $secondSw]
# Category: Utility
##################################################################
proc GetTrunkPortList {firstSw secondSw} {
    global trunkPortList
    
    set returnList ""
    if {![info exists trunkPortList]} {
	return $returnList
    }
    
    foreach s2sConnectPair $trunkPortList {
	if {[lindex $s2sConnectPair 0] == $firstSw && \
		[lindex $s2sConnectPair 1] == $secondSw} {
	    lappend returnList [lindex $s2sConnectPair 2]
	}
    }
    
    return $returnList
}

##################################################################    
# Procedure Name: SetupIxiaConnections
# Description:
#     	Check number of ixia ports, build ixiaPortMappingArray, and 
#	initialize each port.
# Input args: none 
# Output args: none 
# Return value: connectionBad in failure
# Typical usage: 
#	 SetupIxiaConnections
# Category: SetupSwitch
##################################################################
proc SetupIxiaConnections {} {
    global ixiaCh1
    global startCardNum
    global startPortNum
    global ixiaMappingList
    global ixiaPortMappingArray
    global portMappingList
    global fast
    global ixiaNoReset
    
    if { ![info exist startCardNum] } {
	result_error "startCardNum not defined "
	return -1
    }
    if { [llength [split $startCardNum :]] == 2 }  {
	set startPortNum [lindex [split $startCardNum :] 1]
	set startCardNum [lindex [split $startCardNum :] 0]
	if { ($startPortNum < 1) || ($startCardNum < 1) } {
	    result_error "startCardNum not defined properly $startCardNum"
	    return -1
	}
    } elseif { [llength [split $startCardNum :]] == 1 }  {
	if { ![info exist startPortNum] } {
	    # If dot1x is running, this will not be called,
	    # otherwise set default startPortNum to be 1
	    set startPortNum 1
	}
    } else {
	result_error "startCardNum not defined properly $startCardNum"
	return -1
    } 
    
    
    # ----- Ixia initialization
    #package require IxTclHal
    package require Mpexpr
    #clean up any previous mess
    #cleanUp
    ixInitialize $ixiaCh1
    #set chid1 [getChassisID $ixiaCh1]
    set chid1 1
    set numPortIdNeeded [GetHighestPortId]
    set numPortIdFound 0
    set portIdList ""
    foreach item $portMappingList {
	lappend portIdList [lindex $item 0]
        if {($numPortIdNeeded >= 11) && ([lindex $item 0] == 8)} {
	   lappend portIdList 9
        }
    }
    result_debug "Total ports needed: $numPortIdNeeded"
    if {([info exists ixiaMappingList] == 0) || [regexp -nocase "AUTO" $ixiaMappingList] } {
	result_debug "Auto detecting connections startCard:$startCardNum startPort:$startPortNum"
	for {set card $startCardNum } {$card <= 16 } {incr card } {
	    #if {[card get 1 $card]!=0} {continue}  ;# only go on if card is correct, 10G fails w/o it
#    set portCount [card cget -portCount]
#           set portCount 26
           set portCount 19
	    #   puts "cardType: [card cget -type]"
	    set skipFlag 0
	    for {set port $startPortNum } {$port <= $portCount} {incr port} {
		incr numPortIdFound
		#      puts "numPortIdFound: $numPortIdFound $card $port"
		if {[lsearch -exact $portIdList $numPortIdFound]!=-1} {
		    set skipFlag 1
		    set ixiaPortMappingArray($numPortIdFound) "1 $card $port"
		    #RTP-SQA added for fast init

		    if {[info exist fast] && ($fast != "NULL")} {
			puts $fast "set ixiaPortMappingArray($numPortIdFound) \"1 $card $port\""
		    }
		} elseif {$numPortIdFound<=$numPortIdNeeded} {
		    set port [expr $port-1]
		}
	    }
	    
	    if {$skipFlag==0} {
		set card [expr $card-1]
	    } else {
		set startPortNum 1
	    }
	    
	    if {$numPortIdFound >= $numPortIdNeeded} { break }
	}
	if {$numPortIdFound < $numPortIdNeeded } {
	    result_error "Not enough connections detected"
	    result_error "Wanted $numPortIdNeeded but only got $numPortIdFound"
	    return "connectionBad"
	}
    } else {
	result_debug "Using user-defined connection pattern"
	GenerateIxiaPortMapping
    }
    result_debug "================Ixia port mapping==================="
    result_debug "            portId       \[ChasisId, Card, Port\]"
    for {set portId 1 } {$portId <= $numPortIdNeeded } { incr portId } {
	if {[lsearch -exact $portIdList $portId]!=-1} {
	    set rxPort [MapIxiaPortId $portId chas card port]
	    result_debug "              $portId      ->            \[$chas, $card, $port\]"
	}
    }
    if {![info exists ixiaNoReset]} {
        IxiaPortsInit
    }
}

##################################################################    
# Procedure Name: SetupDUTConnections
# Description:
#     	Generate mapping info for physical portId connection between 
#	DUT and Ixia.
# Input args: none 
# Output args: none
# Return value: list of portId->DUTPort integers
# Typical usage: 
#	 SetupDUTConnections
# Category: SetupSwitch
##################################################################
proc SetupDUTConnections {} {
    global portMappingList
    
    #generate mapping info for physical portId connected between DUT and Ixia
    GenerateDUTPortMapping
    result_debug "================DUT port mapping==================="
    result_debug "            portId           DUTPort"
    
    foreach port $portMappingList {
	set portNum [lindex $port 0]
	set dutNum [lindex $port 2]
	if {$dutNum == "" } {set dutNum 1}
	lappend portListUsed $portNum
	lappend portDutListUsed "$portNum $dutNum"
	
	set DUTPort [MapDUTPortId $portNum $dutNum]
	result_debug "              $portNum      ->        $DUTPort on DUT$dutNum"
    }
    #also need to see how it maps port range
    #result_debug "              1-22,23      ->    [MapDUTPortId 1-22,23]"
    result_debug ""
    
    return $portDutListUsed
}

##################################################################    
# Procedure Name: CheckXMKStatus
# Description:
#     	This function checks and reports for 2nd OS running on dual 
#	cpu with 256MB or more
# Input args: dut 
# Output args: none 
# Return value: None
# Typical usage: 
#	 CheckXMKStatus $dutNo
# Category: VerifySwitchOutput
##################################################################
proc CheckXMKStatus {dut} {

    lappend parameterList "{Total DRAM Size:} 1"
    set memory [GetKeyValue "show memory" $parameterList]
    puts "memory: $memory"
    
    SendACmd "show switch"
    SendACmd "nofeep"
    
    set flag [CheckXMK]
    puts "Flag: $flag"
    set dualCPU 1
    switch -- [GetPlatform "DUT$dut"] {
	Summit48i -
	Summit24i {
	    set dualCPU "0"     		   
	} 
    }
    if {$dualCPU } {
	report_start_test "Checking 2nd OS (xmk) status on 2nd CPU"
	if {$memory >= 256 } {
	    if {$flag == "xmk"} {
		result_ok "2nd OS is running on 2nd CPU"
	    } else {
		result_error "2nd OS is not running on 2nd CPU"
	    }
	} else {
	    if {$flag == "xmk"} {
		result_error "2nd OS is running on 2nd CPU, but should not"
	    } else {
		result_ok "2nd OS is not running on 2nd CPU"
	    }      
	}
	report_end_test
    } else {
	report_start_test "Checking for no 2nd OS (xmk) on single CPU"
	if {$flag == "xmk"} {
	    result_error "2nd OS is running on, but should not"
	} else {
	    result_ok "2nd OS is not running"
	}      
	report_end_test    
    }
    SendACmd "shswitch"
}

##################################################################    
# Procedure Name: CheckXMK
# Description:
#     	This function checks if 2nd OS is running on 2nd CPU by nofeep
#	command "xmk".
# Input args: none 
# Output args: none 
# Return value: verybadifgethere if failure
# Typical usage: 
#	 set flag [CheckXMK]
# Category: VerifySwitchOutput
##################################################################
proc CheckXMK {} {

    send "xmk\r"
    expect {
	timeout {
	    return "TIMEOUT"
	}
	"2\\-> " {
	    send "vx\r"
	    return "xmk"
	}
	"\\-> " {
	    return "noxmk"
	}
    }
    return "verybadifgethere"
}

##################################################################    
# Procedure Name: AddTestbedInfoToDUTs_info
# Description:
#     	This function appends test bed specific information to DUTs_info array
#        
#
# Input args: none
# Output args: none
# Return value: none
# Typical usage: 
#	 AddTestbedInfoToDUTs_info
# Category: Setup
##################################################################
proc AddTestbedInfoToDUTs_info {} {
   
    global ixiaCh1 defaultRouter tftpServerList startCardNum switchPort2DefaultRouter \
	    POWERCYCLE_IP POWERCYCLE_PORTS tftpShareName portMappingList trunkPortList \
	    checkConnection connectionTimeout
    global numDUT DUTs_info
puts "------------- 4 ---------- numDUT --------------- $numDUT"    
    if {[info exists ixiaCh1]} {
	set DUTs_info(ixiaip) $ixiaCh1   
    }
    if {[info exists tftpServerList]} {
	set DUTs_info(tftpserverlist) $tftpServerList   
    }
    if {[info exists defaultRouter]} {
	set DUTs_info(defaultRouter) $defaultRouter
    }
    if {[info exists POWERCYCLE_IP]} {
	set DUTs_info(powercycle_ip) $POWERCYCLE_IP
    }
    if {[info exists POWERCYCLE_PORTS]} {
	set DUTs_info(powercycle_ports) $POWERCYCLE_PORTS
    }
    if {[info exists tftpShareName]} {
	set DUTs_info(tftpsharename) $tftpShareName
    }
    if {[info exists startCardNum]} {
	set DUTs_info(startcardnum) $startCardNum
    }
    if {[info exists portMappingList]} {
	set DUTs_info(portmappinglist) $portMappingList
    }
    if {[info exists trunkPortList]} {
	set DUTs_info(trunkportlist) $trunkPortList
    }
    if {[info exists switchPort2DefaultRouter]} {
	set DUTs_info(switchport2defaultrouter) $switchPort2DefaultRouter
    }
    if {[info exists checkConnection]} {
	set DUTs_info(checkconnection) $checkConnection
    }
    if {[info exists connectionTimeout]} {
	set DUTs_info(connectiontimeout) $connectionTimeout
    }
    
    for {set i 1} {$i <= $numDUT} {incr i 1} {
	global DUT${i}_CONNECT
	global DUT${i}_IP
	global DUT${i}_DefaultBlade
	global DUT${i}_SETUP
	set DUTs_info(DUT$i,connect) [set DUT${i}_CONNECT]
	set DUTs_info(DUT$i,ip) [set DUT${i}_IP]
	set DUTs_info(DUT$i,defaultblade) [set DUT${i}_DefaultBlade]
	set DUTs_info(DUT$i,setup) [set DUT${i}_SETUP]
    }

puts "---------------  5 ------------------------"
    # Gather information about the slots / platform and assign to portIds
    #   The portId info comes from SystemSetup, so this must be run first
    GetPortIdInfoStd 
puts "---------------  6 ------------------------"
}


proc isExosPlatform { DUT } {
    global DUTs_info
    global supportedPlatform i386Platform
    
    #    if {$DUTs_info($DUT,platform)=="BD-Mariner"||$DUTs_info($DUT,platform)=="BD-10808"||$DUTs_info($DUT,platform)=="BD-PC"||$DUTs_info($DUT,platform)=="Summit-PC"||$DUTs_info($DUT,platform)=="Aspen"} 
    # SK: Removed above line as we need liberal regexp than hard equate
    if {[regexp -nocase "$supportedPlatform|$i386Platform" $DUTs_info($DUT,platform)] || \
        [regexp -nocase "$supportedPlatform|$i386Platform" $DUTs_info($DUT,sysType)]} {
        return 1
    } else {
        result_debug "\n-------------------------\n$DUTs_info($DUT,sysType) OR $DUTs_info($DUT,platform) NOT EXOS platform\n---------
----------------"
        return 0
    }
}

proc isEdpWorking {DUT DUTList} {
    global DUTs_info
    global whichDutNow
    global trunkPortList
    global lastDUT
    global checkHubConnection	

    if {[llength $DUTList] > 1 && [info exists trunkPortList]} {
	for {set i 0} {$i<[llength $trunkPortList]} {incr i} {
	    set trunkPair [lindex $trunkPortList $i]
	    set localDUT [lindex $trunkPair 0]
	    set remoteDUT [lindex $trunkPair 1]
	    if {$remoteDUT==0} continue;
            global eware_dut
            if {[info exists eware_dut]} {
               if {[lsearch $eware_dut $whichDutNow] == -1 } {
                  set loopVar 1
               } else {
                  set loopVar 0
               }
           } else {
               set loopVar 1
           }

           if {$loopVar} {

	    if {$localDUT==$whichDutNow} {
		if {$localDUT<$remoteDUT} {
		    global stackable i386Stackable ewareStackable
		    if {[regexp -nocase "$stackable|$i386Stackable|$ewareStackable" [GetPlatform DUT$remoteDUT]]} {
			lappend edpList "{[lindex $trunkPair 2] .* 00:00:$DUTs_info(DUT$remoteDUT,sysMAC) *1:[lindex [lindex $trunkPortList [expr $i+1]] 2]} exist"
		    } else {
			lappend edpList "{[lindex $trunkPair 2] .* 00:00:$DUTs_info(DUT$remoteDUT,sysMAC) *[lindex [lindex $trunkPortList [expr $i+1]] 2]} exist"
		    }
		} else {
		    global stackable i386Stackable ewareStackable
		    if {[regexp -nocase "$stackable|$i386Stackable|$ewareStackable" [GetPlatform DUT$remoteDUT]]} {
			lappend edpList "{[lindex $trunkPair 2] .* 00:00:$DUTs_info(DUT$remoteDUT,sysMAC) *1:[lindex [lindex $trunkPortList [expr $i-1]] 2]} exist"
		    } else {
			lappend edpList "{[lindex $trunkPair 2] .* 00:00:$DUTs_info(DUT$remoteDUT,sysMAC) *[lindex [lindex $trunkPortList [expr $i-1]] 2]} exist"
		    }
		}
	    }
     } else {
            if {$localDUT==$whichDutNow} {
                if {$localDUT<$remoteDUT} {

                    global stackable i386Stackable ewareStackable
                    if {[regexp -nocase "$stackable|$i386Stackable|$ewareStackable" [GetPlatform DUT$remoteDUT]]} {
   lappend edpList "{port.*[lindex $trunkPair 2]} {EDP is enabled} inLine"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-ID\=00:00:$DUTs_info(DUT$remoteDUT,sysMAC)} inLine exist 2"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-Port\=1:[lindex [lindex $trunkPortList [expr $i+1]] 2]} inLine exist 3"
                    } else {
  lappend edpList "{port.*[lindex $trunkPair 2]} {EDP is enabled} inLine"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-ID\=00:00:$DUTs_info(DUT$remoteDUT,sysMAC)} inLine exist 2"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-Port\=[lindex [lindex $trunkPortList [expr $i+1]] 2]} inLine exist 3"

                    }
                } else {
                    global stackable i386Stackable ewareStackable
                    if {[regexp -nocase "$stackable|$i386Stackable|$ewareStackable" [GetPlatform DUT$remoteDUT]]} {

   lappend edpList "{port.*[lindex $trunkPair 2]} {EDP is enabled} inLine"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-ID\=00:00:$DUTs_info(DUT$remoteDUT,sysMAC)} inLine exist 2"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-Port\=1:[lindex [lindex $trunkPortList [expr $i-1]] 2]} inLine exist 3"
                    } else {
   lappend edpList "{port.*[lindex $trunkPair 2]} {EDP is enabled} inLine"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-ID\=00:00:$DUTs_info(DUT$remoteDUT,sysMAC)} inLine exist 2"
   lappend edpList "{port.*[lindex $trunkPair 2]} {Remote-Port\=[lindex [lindex $trunkPortList [expr $i-1]] 2]} inLine exist 3"
                       }
                    }
                }
            }

	}
	Login $DUT

	#SK: Doing file based CheckKeyValue to avoid dual edp port all, in case it does not work
	set fd_edp [open "Tmp/tmp_edp[pid]" "w"]
        if {[info exists eware_dut]} {
             if {[lsearch $eware_dut $whichDutNow] == -1 } {
           set output [SendACmd "show edp ports all" NULL $fd_edp]

	# Build regular expression pattern for EDP neighbor MAC address.
           set key {^[0-9]+}
        } else {
           set key {[a-z]+}
           set output [SendACmd "show edp" NULL $fd_edp]
        }
        } else  {
       # Build regular expression pattern for EDP neighbor MAC address.
            set key {^[0-9]+}
            set output [SendACmd "show edp ports all" NULL $fd_edp]
        }

	close $fd_edp

# Check connection of DUT with HUB and if doesn't exist return connectionBad
 if {([info exists checkHubConnection] == 1) && $checkHubConnection == 0} {
     #do nothing skip the hub connection check
     } else {
	set DUT_Cnt [llength $DUTList]
	set retHubConnVal 0 
        for {set i $lastDUT} {$i<[llength $trunkPortList]} {incr i} {
            set trunkPair [lindex $trunkPortList $i]
            set localDUT [lindex $trunkPair 0]
	    if {$lastDUT==$localDUT} continue;
            set remoteDUT [lindex $trunkPair 1]
            set localDUTPort [lindex $trunkPair 2]
            if {$remoteDUT!=0} continue;
		 for {set j 1} {$j<=$DUT_Cnt} {incr j} {	
			if {$j==$localDUT} continue; 
                  set DUT_HUBPortMap [GetATrunkPort $j $remoteDUT] 
		  set DUT_Mac [GetDUTMac DUT$j]
		global stackable i386Stackable
		if {[regexp -nocase "$stackable|$i386Stackable" [GetPlatform DUT$j]]} {
		lappend edpList "{$localDUTPort .*$DUT_Mac *1:$DUT_HUBPortMap } exist"
                    } else {
		lappend edpList "{$localDUTPort .*$DUT_Mac *$DUT_HUBPortMap } exist"
		}
	}
	set lastDUT $localDUT
	break;	
}
}
	if {[regexp -line $key $output]!=1} {
            result_debug "EDP not working ..."
            file delete "Tmp/tmp_edp[pid]"
            return -1
	} else {
	    set output [CheckKeyValue "Tmp/tmp_edp[pid]" $edpList  -comment "for file operation: Check edp info"]
	    file delete "Tmp/tmp_edp[pid]"
	    if {$output=="ok"} {
		return 1
	    } else {
		return 0
	    }
	}
    } else {
	return 1
    }
}
proc CheckForPreviousCore {numDUT {msmType "primary"}} {
   global DUTs_info

   set date [clock format [clock seconds] -format "%m%d%I%p"]
   if {[info exists DUTs_info(current_module)]} {
       set modStringList [split $DUTs_info(current_module) "/"]
   } else {
       set modStringList [split [file tail [pwd]] "/"]
   }
   set modListLength [llength $modStringList]
   set mod [lindex $modStringList [expr $modListLength - 1]]

   if {[CompareRelease [GetVersion DUT${numDUT}] 11.1.0.21]>=0} {
    if { $msmType == "primary" } {
      result_debug " Memory Card Present : [regexp -nocase \"present\" $DUTs_info(DUT${numDUT},memoryCard)]"
      if {[regexp -- "present" $DUTs_info(DUT${numDUT},memoryCard)]} {
         set coreBuf [SendACmd "ls memorycard"]
      } else {
         set coreFileList ""
         lappend coreFileList "core\.\[a-z\]+\.\[0-9\]+ 0"
         if {[CompareRelease [GetVersion DUT${numDUT}] 11.4.0.1]>=0} {
            set coreBuf [SendACmd "ls internal-memory"]
         } else {
            EnableDebugMode
            set coreBuf [GetKeyValue "!ls /scratch" $coreFileList 1]
         }
      }
    } else {
      EnableDebugMode ; # Required for executing !mv and !rm command
      # if MSM-A has memeory card, please make sure MSM-B also has memeory card.
      if {[regexp -- "present" $DUTs_info(DUT${numDUT},memoryCard)]} {
         set coreBuf [SendACmd "ls memorycard"]
      } else {
         set coreFileList ""
         lappend coreFileList "core\.\[a-z\]+\.\[0-9\]+ 0"
         if {[CompareRelease [GetVersion DUT${numDUT}] 11.4.0.1]>=0} {
            set coreBuf [SendACmd "ls internal-memory"]
         } else {
            EnableDebugMode
            set coreBuf [GetKeyValue "!ls /scratch" $coreFileList 1]
         }
      }
    }


      if {[regexp -nocase "core.*" $coreBuf]} {
         report_start_test "NOTE: found core dump on memoryCard, mv to different name"
         result_debug "NOTE: found core dump on memoryCard, mv to different name"
         foreach coreFile $coreBuf {
            result_debug "coreFile:|$coreFile,[regexp -nocase "core" $coreFile]|"
            if {[regexp -nocase "core" $coreFile]} {
               regsub -all {core} $coreFile Kore newCore
               set newCoreFile ${mod}_${date}_$newCore
               set newProcFile ${mod}_${date}_process_traces.tgz
               
              if { $msmType == "primary" } { 
               if {[regexp -- "present" $DUTs_info(DUT${numDUT},memoryCard)]} {
                  report_start_test "NOTE: found core dump on memoryCard, mv to different name"
                  SendACmd "show log" 
                  SendACmd "mv memorycard $coreFile memorycard $newCoreFile"
                  report_start_test "NOTE: moving process traces"
                  SendACmd "mv memorycard process_traces.tgz memorycard $newProcFile"
                  report_end_test;
                  report_end_test;
               } else {
                  if {[CompareRelease [GetVersion DUT${numDUT}] 11.4.0.1]>=0} {
                     report_start_test "NOTE: found core dump on internal, mv to different name"
                     SendACmd "mv internal-memory $coreFile internal-memory $newCoreFile"
                     report_start_test "NOTE: moving process traces"
                     SendACmd "mv internal-memory process_traces.tgz internal-memory $newProcFile"
                     report_end_test;
                     report_end_test;
                  } else {
                     report_start_test "NOTE: found core dump on scratch, mv to different name"
                     SendACmd "!mv /scratch/$coreFile /scratch/$newCoreFile"
                     report_start_test "NOTE: moving process traces"
                     SendACmd "!mv /scratch/process_traces.tgz /scratch/$newProcFile"
                     report_end_test;
                     report_end_test;
                  }
               }
              } else {
               # if MSM-A has memeory card, please make sure MSM-B also has memeory card.
               if {[regexp -- "present" $DUTs_info(DUT${numDUT},memoryCard)]} {
                  report_start_test "NOTE: found core dump on memoryCard, mv to different name"
                  SendACmd "!mv /mnt/a/$coreFile /mnt/a/$newCoreFile"
                  report_start_test "NOTE: moving process traces"
                  SendACmd "!mv /mnt/a/process_traces.tgz /mnt/a/$newProcFile"
                  report_end_test;
                  report_end_test;
               } else {
                  if {[CompareRelease [GetVersion DUT${numDUT}] 11.4.0.1]>=0} {
                     report_start_test "NOTE: found core dump on internal, mv to different name"
                     SendACmd "!mv /scratch/intern/$coreFile /scratch/intern/$newCoreFile"
                     report_start_test "NOTE: moving process traces"
                     SendACmd "!mv /scratch/intern/process_traces.tgz /scratch/intern/$newProcFile"
                     report_end_test;
                     report_end_test;
                  } else {
                     report_start_test "NOTE: found core dump on scratch, mv to different name"
                     SendACmd "!mv /scratch/$coreFile /scratch/$newCoreFile"
                     report_start_test "NOTE: moving process traces"
                     SendACmd "!mv /scratch/process_traces.tgz /scratch/$newProcFile"
                     report_end_test;
                     report_end_test;
                  }
               }
              }
            }
         }
      }
   }
}


proc ChangeTraceFileName {} {
   global DUTs_info
   global whichDutNow
   global currentTestNumber

   if { ![info exists currentTestNumber] } {
        set tempCurrentTestNumber "main"
   } else {
        set currentTestNumber [string trim $currentTestNumber]
        if {[regexp {(.*) *;.*} $currentTestNumber match match1]} {
           set tempCurrentTestNumber $match1
        } else {
           set tempCurrentTestNumber $currentTestNumber
        }
        set tempCurrentTestNumber [string trim $tempCurrentTestNumber]
   }


   set date [clock format [clock seconds] -format "%m%d%I%p"]
   if {[info exists DUTs_info(current_module)]} {
       set modStringList [split $DUTs_info(current_module) "/"]
   } else {
       set modStringList [split [file tail [pwd]] "/"]
   }
   set modListLength [llength $modStringList]
   set mod [lindex $modStringList [expr $modListLength - 1]]

   EnableDebugMode ; # Required for executing !mv and !rm command

   if {([info exist DUTs_info(DUT${whichDutNow},memoryCard)]) && ([regexp -- "present" $DUTs_info(DUT${whichDutNow},memoryCard)])} {
      set traceBuf [SendACmd "ls memorycard"]
   } else {
      if {[CompareRelease [GetVersion DUT${whichDutNow}] 11.4.0.1]>=0} {
         set traceBuf [SendACmd "ls internal-memory"]
      } else {
         set traceBuf [GetKeyValue "!ls /scratch" $coreFileList 1]
      }
   }

   if {[regexp -nocase "trace.*" $traceBuf]} {
      report_start_test "NOTE: found traces, mv to different name"
      foreach traceFile $traceBuf {
         result_debug "traceFile:|$traceFile,[regexp -nocase trace $traceFile]|"
         if {[regexp -nocase "trace" $traceFile]} {
            #regsub -all {trace} $traceFile grace newTrace
            #set newTraceFile ${newTrace}_${mod}_${date}
            #set newTraceFile ${newTrace}_${mod}_${tempCurrentTestNumber}
            set newTraceFile ${traceFile}_${mod}_${tempCurrentTestNumber}

            if {([info exist DUTs_info(DUT${whichDutNow},memoryCard)]) && ( [regexp -- "present" $DUTs_info(DUT${whichDutNow},memoryCard)])} {
               result_debug "NOTE: found traces on memoryCard, mv to different name"
               report_start_test "NOTE: moving traces"
               SendACmd "mv memorycard $traceFile memorycard $newTraceFile"
               report_end_test;
            } else {
               if {[CompareRelease [GetVersion DUT${whichDutNow}] 11.4.0.1]>=0} {
                  result_debug "NOTE: found traces on internal-memory, mv to different name"
                  report_start_test "NOTE: moving process traces"
                  SendACmd "mv internal-memory $traceFile internal-memory $newTraceFile"
                  report_end_test;
               } else {
                  report_start_test "NOTE: moving traces"
                  SendACmd "!mv /scratch/$traceFile /scratch/$newTraceFile"
                  report_end_test;
               }
            }
         }
      }
      report_end_test;
   }
}

proc ChangeCoreFileName {} {
   global DUTs_info
   global whichDutNow
   global currentTestNumber
   global numDUT
   global spawn_id
   global spawn_ids
   global enableAbortTestCondition

   for {set i 1} {$i <= $numDUT} {incr i} {
        global DUT${i}_CONNECT DUT${i}_CONNECTB
   }

   #find out the ipAddr of this session if it is MSM-A or MSM-B
   global hostname
   foreach name $hostname {
      if { $spawn_id == $spawn_ids($name) } {
           set ipAddr $name
      }
   }
   result_debug "hostname : $hostname , ipAddr : $ipAddr"
   exSleep 60 ; # Delay after process died as DUT takes some time to reboot

   # Verifying whether process died on master/backup.
   if { [info exists DUT${whichDutNow}_CONNECTB] } {
      if { $ipAddr == [set DUT${whichDutNow}_CONNECTB] } {
          result_debug "Backup ip address : [set DUT${whichDutNow}_CONNECTB] , ipAddr : $ipAddr"
          Login [set DUT${whichDutNow}_CONNECT] -masterCheck 0 -CheckOperational 0
          set showSwitchOutput ""
          lappend showSwitchOutput "{Current State:} {In *Sync} inLine exists"
          CheckKeyValue "show switch" $showSwitchOutput -time {s: 1 i: 5 d: 150 f: 150 r} -comment "check both MSMs up in sh switch output"

         SendACmd "show log warning"
         SendACmd "clear log"
         lappend getKey "{Current State:} 1"
         set stateA [GetKeyValue "show switch" $getKey]
         result_debug "stateA : $stateA"
         if {[string tolower $stateA] == "master"} {
             # Calling run msm-failover as reboot happened due to process died. 
             # can not use MakeMSMBMaster.
             SendACmd "run msm-failover"
             exSleep 90
             Login [set DUT${whichDutNow}_CONNECTB] 
             CheckOperational
         } else {
             Login [set DUT${whichDutNow}_CONNECTB] 
             CheckOperational
         }
      } else {
          result_debug "Master ip address : [set DUT${whichDutNow}_CONNECT] , ipAddr : $ipAddr"
          Login [set DUT${whichDutNow}_CONNECTB] -masterCheck 0 -CheckOperational 0
          set showSwitchOutput ""
          lappend showSwitchOutput "{Current State:} {In *Sync} inLine exists"
          CheckKeyValue "show switch" $showSwitchOutput -time {s: 1 i: 5 d: 150 f: 150 r} -comment "check both MSMs up in sh switch output"

         SendACmd "show log warning"
         SendACmd "clear log"
         lappend getKey "{Current State:} 1"
         set stateA [GetKeyValue "show switch" $getKey]
         result_debug "stateA : $stateA"
         if {[string tolower $stateA] == "backup"} {
             # Calling run msm-failover as reboot happened due to process died. 
             # can not use MakeMSMAMaster.
             SendACmd "run msm-failover"
             exSleep 90
             Login [set DUT${whichDutNow}_CONNECT]
             CheckOperational
         } else {
             Login [set DUT${whichDutNow}_CONNECT]
             CheckOperational
         }
      }
   } else {
          result_debug "Backup not exist. Dut ip address : [set DUT${whichDutNow}_CONNECT] , ipAddr : $ipAddr"
          Login [set DUT${whichDutNow}_CONNECT]
   }

   result_debug "Processing core files" 
   if { ![info exists currentTestNumber] } {
       set tempCurrentTestNumber "main"
   } else {
         set currentTestNumber [string trim $currentTestNumber]
         set tempCurrentTestNumber $currentTestNumber
         if {[regexp {(.*) *;.*} $currentTestNumber match match1]} {
           set tempCurrentTestNumber $match1
         } else {
           set tempCurrentTestNumber $currentTestNumber
         }
   }
   set date [clock format [clock seconds] -format "%m%d%I%p"]
   if {[info exists DUTs_info(current_module)]} {
       set modStringList [split $DUTs_info(current_module) "/"]
   } else {
       set modStringList [split [file tail [pwd]] "/"]
   }
   set modListLength [llength $modStringList]
   set mod [lindex $modStringList [expr $modListLength - 1]]

   #Login $DUTs_info(DUT$whichDutNow,connect) -masterCheck 1
   EnableDebugMode ; # Required for executing !mv and !rm command
   SendACmd "show log warning"
   SendACmd "clear log"

   if {([info exist DUTs_info(DUT${whichDutNow},memoryCard)]) && ([regexp -- "present" $DUTs_info(DUT${whichDutNow},memoryCard)])} {
      set coreBuf [SendACmd "ls memorycard"]
   } else {
      if {[CompareRelease [GetVersion DUT${whichDutNow}] 11.4.0.1]>=0} {
         set coreBuf [SendACmd "ls internal-memory"]
      } else {
         set coreFileList ""
         lappend coreFileList "core\.\[a-z\]+\.\[0-9\]+ 0"
         set coreBuf [GetKeyValue "!ls /scratch" $coreFileList 1]
      }
   }

   if {[regexp -nocase "core.*" $coreBuf]} {
      report_start_test "NOTE: found core, mv to different name"
      foreach coreFile $coreBuf {
         result_debug "coreFile:|$coreFile,[regexp -nocase core $coreFile]|"
         if {([regexp -nocase "core" $coreFile]) && (![regexp -nocase "core.*\.gz_" $coreFile]) && (![regexp -nocase "core\.nvram.*_" $coreFile])} {
            set newCoreFile ${coreFile}_${mod}_${tempCurrentTestNumber}

            if {([info exist DUTs_info(DUT${whichDutNow},memoryCard)]) && ( [regexp -- "present" $DUTs_info(DUT${whichDutNow},memoryCard)])} {
               result_debug "NOTE: found core on memoryCard, mv to different name"
               report_start_test "NOTE: moving core"
               SendACmd "mv memorycard $coreFile memorycard $newCoreFile"
               report_end_test;
            } else {
               if {[CompareRelease [GetVersion DUT${whichDutNow}] 11.4.0.1]>=0} {
                  result_debug "NOTE: found core on internal-memory, mv to different name"
                  report_start_test "NOTE: moving core"
                  SendACmd "mv internal-memory $coreFile internal-memory $newCoreFile"
                  report_end_test;
               } else {
                  report_start_test "NOTE: moving core"
                  SendACmd "!mv /scratch/$coreFile /scratch/$newCoreFile"
                  report_end_test;
               }
            }
         }
      }
      report_end_test;
   }
  if { ([info exists enableAbortTestCondition] ) && ($enableAbortTestCondition =="coreDump") } {
    exit
  }
}
proc EnableBGPServiceProviderEdgeLicence { {duts ""} } {
   global DUTs_info

   if {$duts==""} {
      set duts 1 
   }
   set dutList [split $duts ,]
   foreach dut $dutList {
      set DUTName [format %s%d DUT $dut]
      global ${DUTName}_CONNECT
      Login [set ${DUTName}_CONNECT]

   if { [CompareRelease [GetVersion DUT${dut}] 12.1] >=0 && \
        [regexp -nocase "X450e|X250e" $DUTs_info(DUT${dut},platform)] } {
      set licenseInfo [SendACmd "show licenses"]
     if {[regexp -nocase "ServiceProviderEdge" $licenseInfo] !=1} {
         result_debug "Platform is not enabled with ServiceProviderEdge license"
            if { [info exist DUTs_info(DUT${dut},bgp)] } {
                 SendACmd "enable license $DUTs_info(DUT${dut},bgp)"
                 set licenseInfo [SendACmd "show licenses"]
                 if {[regexp -nocase "ServiceProviderEdge" $licenseInfo] !=1} {
                     result_debug "Platform is not enabled with BGP ServiceProviderEdge license."
	             close_result_file
	             report_end_test
                     return -code return testSkipped
                  }
             } else {
                    result_error "ServiceProviderEdge licence key for bgp does not exist in cfg file. Please add the same and restart regression"
	             close_result_file
	             report_end_test
                     return -code return testSkipped
             }
      } else {
         result_debug "$DUTName is enabled with ServiceProviderEdge license"
      }
    } else {
         result_debug "$DUTName is not X450e|X250e or release <12.1 does not require ServiceProviderEdge license"
   }
   }

}
