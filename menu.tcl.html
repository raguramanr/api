<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>menu.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#menu.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>menu.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="menu.tcl-annot.html">annotations</a> | <a href="menu.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#</span>
<strong><a name="::::NumberedMenu_2">proc <a href="menu.tcl-annot.html#::::NumberedMenu">::::NumberedMenu</a></a></strong> {args} {
    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> NumberedMenu $args {
        head             &#34;This is a Menu&#34;
        question1        &#34;What&#34;
        choices          &#34;This That TheOther&#34;
        chAppendList     &#34;null&#34;
        chPrependList    &#34;null&#34;
        menuWidth        100
        keyWidth         5
        headerPadChar    &#34;-&#34;
        barChar          &#34;-&#34;
        clearXterm       &#34;yes&#34;
        clearXtermInfo   &#34;&#34;
        all              &#34;no&#34;
        simple           &#34;no&#34;
    }

    if {$chAppendList != &#34;null&#34;} {
        set choices [concat $choices $chAppendList]
    }
    if {$chPrependList != &#34;null&#34;} {
        set choices [concat $chPrependList $choices]
    }
    if {[llength $choices] &lt; 1} {
        puts &#34;No elements passed into menu&#34;
        exit
    } else {
        <span class="comment-line">#puts &#34;Choices $choices&#34;</span>
    }
    set nWidth $keyWidth; <span class="comment-line"># width of number column</span>
    set longest 0; <span class="comment-line"># init longest value in</span>
    set i 0
    foreach cc $choices {
        set ln [string length $cc]
        if {$ln &gt; $longest} {
            set longest $ln; <span class="comment-line"># return the longest string length pased in</span>
        }
        incr i
    }
    set choiceCount $i
    set valWidth [expr $longest + 4]; <span class="comment-line"># leave some white space 3 spaces</span>
    set numValWidth [expr $nWidth + $valWidth];<span class="comment-line"># entire col width</span>
    set colCount [expr int(floor($menuWidth / $numValWidth))]; <span class="comment-line"># columns in menu 100 chars/ longest val</span>
    set choiceLen [llength $choices]
    if {$choiceLen &gt; $colCount} {
        set numRows [expr int(ceil($choiceLen/$colCount))];<span class="comment-line"># elements in array div by num rows</span>
    } else {
        set numRows 1
    }
    <span class="comment-line"># Create a bar the width of the menu</span>
    set bl 0
    set bar &#34;&#34;
    while {$bl &lt;= $menuWidth} {
        append bar &#34;$barChar&#34;
        incr bl
    }
    <span class="comment-line"># ------------------------------------------------</span>
    <span class="comment-line">#        make header</span>
    <span class="comment-line"># ------------------------------------------------</span>
    <span class="comment-line"># Header will look like -----  $head  -----</span>
    set headWidth [expr $menuWidth - 4]; <span class="comment-line"># leave for with spaces</span>
    set slen [string length $head];<span class="comment-line"># Length of the header passed in</span>
    set pad [expr $headWidth - $slen];<span class="comment-line"># buffer is line length of 90 - 4 spaces - header</span>
    set pad [expr int(floor($pad / 2))];<span class="comment-line"># div buffer by 2 to left and right side</span>

    set h 0 ;<span class="comment-line"># counter for pad string</span>
    set padStr &#34;&#34;
    while {$h&lt;=$pad} {
        append padStr $headerPadChar;<span class="comment-line"># create the pad string</span>
        incr h ;<span class="comment-line"># pad length</span>
    }
    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">#  Create the menu</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>

    <span class="comment-line"># init the menu counters</span>
    set lastSelection &#34;&#34;
    set listOut &#34;&#34;
    set listIn $choices
    <span class="comment-line"># make the menu</span>
    while {1} {
        <span class="comment-line"># print the header</span>
        puts &#34;\n\n&#34;
        <span class="comment-line"># ------------------------------------------------</span>
        <span class="comment-line"># Previous app important info to display</span>
        <span class="comment-line">#   this menu may clear stdout.  If you want</span>
        <span class="comment-line">#   to add important info to display at the top</span>
        <span class="comment-line">#   after stdout is cleared. Pass it in as a list</span>
        <span class="comment-line">#   $clearXtermInfo &#34;&#34;</span>
        if {[llength $clearXtermInfo] &gt; 0} {
            puts &#34;$bar&#34;
            foreach preI $clearXtermInfo {
                if {[llength $preI] == 2} {
                    set pic 0
                    foreach kv $preI {
                        set pikv($pic) $kv
                        incr pic
                    }
                    puts &#34;[format &#34;%-20s %-20s&#34; ${pikv(0)}: ${pikv(1)}]&#34;
                } else {
                    puts &#34;$preI&#34;
                }
            }
        }
        puts &#34;${padStr}  ${head}  $padStr&#34;

        set r 0;
        set x 0;
        while {$x &lt;= $choiceLen} {
            <span class="comment-line"># build the format colCount   nWidth valWidth</span>
            set ls &#34;&#34;
            for {set ccc 0} {$ccc&lt;$colCount} {incr ccc} {
                <span class="comment-line"># Loop formats the </span>
                if {[string trim [lindex $listIn $x]] != &#34;&#34;} {
                    set pDigit [expr $x+1]; <span class="comment-line"># print digit is 1 higher than key</span>
                    lappend ls [format &#34;%-${nWidth}s %-${valWidth}s&#34; ${pDigit}: [lindex $listIn $x]]
                } else {
                    set blk &#34;&#34;
                    lappend ls [format &#34;%-${nWidth}s %-${valWidth}s&#34; $blk $blk]
                }
                incr x
            }
            puts &#34;[join $ls &#34;&#34;]&#34;
        }

        if {[llength $listOut] &gt; 0} {
            set selLen [llength $listOut]
            puts &#34;\n\nYour Current Selections:&#34;
            set xx 0;
            set blk &#34; &#34;

            while {$xx &lt;= $selLen} {
                <span class="comment-line"># build the format colCount   nWidth valWidth</span>
                set ls &#34;&#34;
                for {set ccc 0} {$ccc&lt;$colCount} {incr ccc} {
                    <span class="comment-line"># Loop formats the </span>
                    if {[string trim [lindex $listOut $xx]] != &#34;&#34;} {
                        lappend ls [format &#34;%-${valWidth}s %-${nWidth}s&#34; [lindex $listOut $xx] $blk]
                    } else {
                        set blk &#34; &#34;
                        lappend ls [format &#34;%-${valWidth}s %-${nWidth}s&#34; $blk $blk]
                    }
                    incr xx
                }
                puts &#34;[join $ls &#34;&#34;]&#34;
            }
        }
        <span class="comment-line"># reset selection to array index</span>
        puts &#34; &#34;
        if {$simple == &#34;yes&#34;} {
            puts -nonewline &#34;$question1 : Default = 1: [lindex $listIn 0] :&#34;;
        } else {
            puts -nonewline &#34;$question1 : (a)ll, (u)ndo, (f)inished &lt;CR&gt;Default = 1: [lindex $listIn 0] :&#34;;
        }
        flush stdout;
        gets stdin userChoice;
        if {$userChoice==&#34;&#34;} {
            set userChoice 1
        }
        <span class="comment-line"># Simple, what's next, menu case</span>
        if {$simple == &#34;yes&#34;} {
            if {![regexp {[0-9]+} $userChoice]} {
                puts &#34;You can only enter an integer in this menu&#34;
                continue;
            }
            set inIndex [expr $userChoice - 1]
            lappend ol [lindex $listIn $inIndex]
            return $ol
        }
        <span class="comment-line"># ---------- Complex, build array menu -------------</span>
        if {[regexp -nocase &#34;^a&#34; $userChoice]} {
            set listOut $listIn
            break
        }
        if {[regexp -nocase &#34;^f&#34; $userChoice]} {
            break
        }
        if {[regexp -nocase &#34;^u&#34; $userChoice]} {
            if {$lastSelection == &#34;&#34;} {
                puts &#34;You can only undo the last selection&#34;
                after 3000
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                continue
            }
            lappend listIn $lastSelection
            set listOut [<a name="::ldelete(1)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $listOut &#34;$lastSelection&#34;];
            set choiceLen [llength $listIn]
            if {$clearXterm == &#34;yes&#34;} {
                catch {exec clear &gt;@ stdout} ww
            }
            set lastSelection &#34;&#34;
            continue;
        }
        if {[regexp -nocase &#34;\[a-zA-Z]&#34; $userChoice]} {
            puts &#34;Must be a number&#34;;
            after 2000;
            if {$clearXterm == &#34;yes&#34;} {
                catch {exec clear &gt;@ stdout} ww
            }
            continue;
        }
        set userChoice [expr $userChoice - 1];<span class="comment-line"># reset to list key value</span>
        if {$userChoice &gt;= 0 &amp;&amp; $userChoice &lt; $x} {
            <span class="comment-line">#puts -nonewline &#34;You selected: [lindex $listIn $userChoice].\</span>
            <span class="comment-line">#                     &lt;R|Retry&gt;  &lt;S|Select 1&gt; and Contiue &lt;F|Finished&gt; &lt;A|Add&gt;\[A]:&#34;;</span>

            <span class="comment-line">#flush stdout;</span>
            <span class="comment-line">#gets stdin whatNext;</span>
            set whatNext a
            if {$whatNext == &#34;&#34;} {
                set whatNext &#34;a&#34;
            }
            if {[regexp -nocase &#34;^a&#34; $whatNext]} {
                lappend listOut [lindex $listIn $userChoice]
                set lastSelection &#34;[lindex $listIn $userChoice]&#34;
                set listIn [<a name="::ldelete(2)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $listIn &#34;[lindex $listIn $userChoice]&#34;];
                set choiceLen [llength $listIn]
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                continue;
            } elseif {[regexp -nocase &#34;^r&#34; $whatNext]} {
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                continue;

            } elseif {[regexp -nocase &#34;^f&#34; $userChoice]} {
                set listOut $listIn
                break
            } elseif {[regexp -nocase &#34;^s&#34; $whatNext]} {
                if {[llength $listOut] &lt;= 0} {
                    set listOut &#34;[lindex $listIn $userChoice]&#34;
                }
                if {$clearXterm == &#34;yes&#34;} {
                    catch {exec clear &gt;@ stdout} ww
                }
                break;
            } else {
                puts &#34;You did not enter a legal value. A to Add, R to Retry, S for select and continue&#34;
                after 2000
                continue;
            }
        } else {
            puts &#34;Error: You must select a number 1 through [expr $x - 1]\n&#34;;
            continue;
        }

    }
    puts &#34;\nRETURN:\n[join $listOut &#34;\n&#34;]\n&#34;
    return $listOut;
}
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Single question</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<strong><a name="::::SingleQuestion_262">proc <a href="menu.tcl-annot.html#::::SingleQuestion">::::SingleQuestion</a></a></strong> {args} {

   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> SingleQuestion $args {
        head             &#34;This is a Menu&#34;
        q1               &#34;What&#34;
        choices          &#34;This That TheOther&#34;
        chAppendList     &#34;null&#34;
        chPrependList    &#34;null&#34;
        menuWidth        100
        keyWidth         5
        headerPadChar    &#34;-&#34;
        barChar          &#34;-&#34;
        clearXterm       &#34;yes&#34;
        clearXtermInfo   &#34;&#34;
        all              &#34;no&#34;
        simple           &#34;no&#34;
    }
    catch {flush stdin}
    set uChoice &#34;ok&#34;
    puts &#34; &#34;
    puts -nonewline &#34;$q1 : &#34;;
    flush stdout;
    set uChoice [gets stdin];
    return $uChoice
}
<span class="comment-line"># -----------------------------------------------------------------</span>
<span class="comment-line"># </span>
<span class="comment-line">#</span>
<span class="comment-line"># simple yes no script</span>
<span class="comment-line">#</span>
<span class="comment-line"># inputs: question and init yes/no</span>
<span class="comment-line"># -----------------------------------------------------------------</span>
<strong><a name="::::menuYesNo_294">proc <a href="menu.tcl-annot.html#::::menuYesNo">::::menuYesNo</a></a></strong> {q yn} {

    set def $yn
    puts &#34; &#34;
    while {1} {
        puts -nonewline &#34;${q}? Y/N \[$yn] : &#34;
        flush stdout;
        set ans [gets stdin]
        if {[string trim $ans] == &#34;&#34;} {
            if {[regexp -nocase &#34;y&#34; $yn]} {
                set out &#34;yes&#34;
                break;
            } else {
                set out &#34;no&#34;
                break;
            }
        } else {
            if {[regexp -nocase &#34;y&#34; $ans]} {
                set out &#34;yes&#34;
                break;
            } elseif {[regexp -nocase &#34;n&#34; $ans]} {
                set out &#34;no&#34;
                break;
            } else {
                puts &#34;Your answer must be Yes|y|No|n&#34;
                continue
            }
        }
    }
    puts &#34;You selected $out&#34;
    return $out
}
<span class="comment-line"># -------------------------------------------------------------------</span>
<span class="comment-line"># proc imenu</span>
<span class="comment-line">#</span>
<span class="comment-line"># The i_main menu</span>
<span class="comment-line">#</span>
<span class="comment-line"># -------------------------------------------------------------------</span>
<strong><a name="::::imenu_332">proc <a href="menu.tcl-annot.html#::::imenu">::::imenu</a></a></strong> {} {
    global MAIN

        set iList {
            &#34;Cleanup all DUTs&#34;
            &#34;Init Ixia&#34;
            &#34;Results Summary&#34;
            &#34;Set and Show DUTs_info&#34;
            &#34;exit&#34;
        }

        set sList [<a name="::NumberedMenu(1)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;What would you like to do&#34; \
                    -question1 &#34;What do you want to do?&#34; \
                    -choices $iList \
                    -menuWidth        75 \
                    -keyWidth         3 \
                    -headerPadChar    &#34;=&#34; \
                    -chAppendList     &#34;null&#34; \
                    -chPrependList    &#34;null&#34; \
                    -barChar          &#34;-&#34; \
                    -clearXterm       &#34;yes&#34; \
                    -simple           &#34;yes&#34; \
                    -clearXtermInfo   &#34;&#34; ]

        if {[lsearch $sList &#34;Cleanup all DUTs&#34;] &gt;= 0} {
            <a name="::CleanTestBedCfgs(1)"><a href="./cleanup.tcl.html#::CleanTestBedCfgs_1102">::CleanTestBedCfgs</a></a>;
            return;
        }
        if {[lsearch $sList &#34;Results Summary&#34;] &gt;= 0} {
            <a name="::save_test_report(1)"><a href="./report.tcl.html#::save_test_report_329">::save_test_report</a></a> &#34;[<a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> { $randomIndex }]/report.exr&#34;
            <a name="::gen_text_report(1)"><a href="./report.tcl.html#::gen_text_report_602">::gen_text_report</a></a> &#34;[<a name="::get_result_dir(2)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34; &#34;stdout&#34; &#34;[file tail [pwd]]&#34; $MAIN(cfg)
            return;
        }
        if {[lsearch $sList &#34;Change Modules&#34;] &gt;= 0} {
            <a name="::_changeFeature(1)"><a href="./maincleanup.tcl.html#::_changeFeature_169">::_changeFeature</a></a> -m [<a name="::SingleQuestion(1)"><a href="./menu.tcl.html#::SingleQuestion_262">::SingleQuestion</a></a> -q1 &#34;What module do you want&#34;]
            return;
        }
        if {[lsearch $sList &#34;Init Ixia&#34;] &gt;= 0} {
            <a name="::::smallIxiaInit(1)"><a href="./swConf.tcl.html#::::smallIxiaInit_1778">::::smallIxiaInit</a></a>;
            return;
        }
        if {[lsearch $sList &#34;Set and Show DUTs_info&#34;] &gt;= 0} {
            <a name="::::_get_duts_info(1)"><a href="./swConf.tcl.html#::::_get_duts_info_3680">::::_get_duts_info</a></a> show print
        }
        if {[lsearch $sList &#34;Last TCL Error&#34;] &gt;= 0} {
            global errorInfo
            puts $errorInfo;
            return;
        }        
        if {[lsearch $sList &#34;exit&#34;] &gt;= 0} {
            return;
        }
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
