<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>mainLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#mainLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>mainLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="mainLib.tcl-annot.html">annotations</a> | <a href="mainLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line"># mainLib.tcl </span>
<span class="comment-line">#</span>
<span class="comment-line">#   Library of procedures shared by utilities in main directory.</span>
<span class="comment-line">#     i.e. main.tcl, automate.tcl, runall_monitor.tcl, runRegAll.tcl</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##############################################################################</span>
global skipFileFilled
set skipFileFilled 0


<span class="comment-line"># Based on regType and regSubType, retrieve the module list as</span>
<span class="comment-line"># defined by regTypeArray() in config file modulesToBeConfigured.cfg</span>
<strong><a name="::getRegressionModuleList_14">proc <a href="mainLib.tcl-annot.html#::getRegressionModuleList">::getRegressionModuleList</a></a></strong><a name="::getRegressionModuleList"></a> { regType regSubType platform_id } {

    <span class="comment-line"># The regressionModules are defined in modulesToBeSummarized.cfg.  The list</span>
    <span class="comment-line"># is accessed as $regType($regSubType)</span>
    global regTypeArray
    global validRegTestTypeSubType

    set regressionModules [list]
    set errorString &#34;ERROR: You have entered regType:$regType  regSubType:$regSubType \
	    \nThe valid regType/regSubType combinations are: $validRegTestTypeSubType&#34;

    puts &#34;ENTERING....&#34;
    <span class="comment-line"># check to see if the regression test type exists in our array</span>
    if {[info exists regTypeArray($regType)]} {

	puts &#34;[set regTypeArray($regType)]&#34;
	uplevel 1 {set moduleList [set regTypeArray($regType)]}
	uplevel 1 {set arrayName [set moduleList]($regSubType)}
	uplevel 1 {global $arrayName}
	
	if {[uplevel 1 {info exists arrayName}]} {
	    set regressionModules [uplevel 1 {set $arrayName}]
	} else {
	    puts $errorString
	    puts &#34;ERROR: [set moduleList]($regSubType) was not found...exiting&#34;
	}

    } else {
	puts $errorString
	puts &#34;ERROR: regTypeArray($regType) was not found...exiting&#34;
    }

    return [<a name="::reorderRegressionModules(1)"><a href="./mainLib.tcl.html#::reorderRegressionModules_51">::reorderRegressionModules</a></a> $regressionModules $platform_id]
    <span class="comment-line">#return $regressionModules</span>
}

<span class="comment-line"># Reorder the modules to be run so that they can be distributed across testbeds.</span>
<strong><a name="::reorderRegressionModules_51">proc <a href="mainLib.tcl-annot.html#::reorderRegressionModules">::reorderRegressionModules</a></a></strong><a name="::reorderRegressionModules"></a> { regressionModules platform_id} {

    global regSubType
    global platform

    switch $regSubType {
	standard {set numNodes 2}
	ipRoute1 {set numNodes 5}
	uploadanddownload {set numNodes 1}
	upgradedowngrade {set numNodes 1}
	default {return $regressionModules}
    }

    set allPlatformIds     [GetAllPlatformIds $numNodes]
    <span class="comment-line"># Get ids of platforms that are actually running</span>
    <span class="comment-line">#set runningPlatformIds [GetRunningPlatformIds $numNodes]</span>
    <span class="comment-line"># Get ids of platforms of this specific of a specific name and num nodes</span>
    set platformTypeIds [GetPlatformTypeIds $numNodes $platform]
    <span class="comment-line">#set numPlatforms [llength $allPlatformIds]</span>
    set numPlatforms [llength $platformTypeIds]
    set numFeatures [llength $regressionModules]
    if { $numPlatforms &lt;= 0 } {
    set numPlatforms 1 
    }
    set skip [expr round($numFeatures/$numPlatforms)]
    <span class="comment-line">#set startNum [expr $skip*[lsearch $allPlatformIds $platform_id]]</span>
    set startNum [expr $skip*[lsearch $platformTypeIds $platform_id]]

    if { $startNum &gt; 0 } {
        result_debug &#34;\n***         Modify Regression Module Order Start &gt; 0                 ***&#34;
        result_debug &#34;Found $numPlatforms $platform Types - Starting at module index $startNum&#34;
        result_debug &#34;curPlatformId=$platform_id PlatformTypeIds=$platformTypeIds&#34;
        result_debug &#34;NumFeatures=$numFeatures Skip=$skip&#34;
        result_debug &#34;***                                                                  ***&#34;
	set newListBegin [lrange $regressionModules $startNum end]
	set newListEnd [lrange $regressionModules 1 [expr $startNum-1] ]
	set newList &#34;[lindex $regressionModules 0] $newListBegin $newListEnd&#34;
    } else {
        result_debug &#34;\n***                Modify Regression Module Order                    ***&#34;
        result_debug &#34;Found $numPlatforms $platform Types - Starting at module index $startNum&#34;
        result_debug &#34;curPlatformId=$platform_id PlatformTypeIds=$platformTypeIds&#34;
        result_debug &#34;NumFeatures=$numFeatures Skip=$skip&#34;
        result_debug &#34;***                                                                  ***&#34;
	set newList $regressionModules
    }

    puts &#34;\nnewList=$newList; \nlen = [llength $newList]&#34;

    return $newList
}

<span class="comment-line"># Send a mail message to a user</span>
<strong><a name="::sendMailNotification_103">proc <a href="mainLib.tcl-annot.html#::sendMailNotification">::sendMailNotification</a></a></strong><a name="::sendMailNotification"></a> {user subject message} {

    global autowebLink 

    puts &#34;sendMailNotification: $user $subject $message&#34;
    set tempMsgFile   &#34;/tmp/runRegMsg.txt.[pid]&#34;
   
    
    ;<span class="comment-line"># Add link to autoweb (as defined in modulesToBeSummarized.cfg)&#34;</span>
    if {[info exists autowebLink]} {
        set message &#34;$message\nAUTOWEB: $autowebLink&#34;
    } else {
        set message &#34;$message\n&#34;
    }
    exec echo $message &gt; $tempMsgFile
    catch {exec dos2unix -f $tempMsgFile} a
    exec cat -t $tempMsgFile &gt; tempMsgFile_[pid].txt
    exec mail -s \&#34;$subject\&#34; $user &lt; tempMsgFile_[pid].txt
    exec rm -f $tempMsgFile
    exec rm -f tempMsgFile_[pid].txt
}


<span class="comment-line"># Based on regType regSubType platform and blade, this proc generates</span>
<span class="comment-line"># a bat file name to run. This bat file was created with automate.tcl.</span>
<span class="comment-line"># Both runall_monitor and automate use this to create a consistent</span>
<span class="comment-line"># bat file name.</span>
<strong><a name="::genRerunBatFileName_130">proc <a href="mainLib.tcl-annot.html#::genRerunBatFileName">::genRerunBatFileName</a></a></strong><a name="::genRerunBatFileName"></a> {regType regSubType platform blade} {
    
    set rerunBatFileName [format &#34;pt_%s_%s&#34; $regType $regSubType]
    
    if {($platform != &#34;&#34;) || ($platform != &#34;null&#34;)} {
	set rerunBatFileName [format &#34;$rerunBatFileName\_%s&#34; $platform]
    }

    if {($blade != &#34;&#34;) || ($blade != &#34;null&#34;)} {
	set rerunBatFileName [format &#34;$rerunBatFileName%s&#34; $blade]
    }

    append rerunBatFileName &#34;.bat&#34;

    set rerunBatFileName [string tolower $rerunBatFileName]

    puts &#34;genRerunBatFileName: $rerunBatFileName&#34;
    
    return $rerunBatFileName
}


<strong><a name="::gen_index_152">proc <a href="mainLib.tcl-annot.html#::gen_index">::gen_index</a></a></strong><a name="::gen_index"></a> {dir} {
    global SWDEVSERVER
    set old_dir [pwd]
    cd $dir
    if {[file exists tclIndex]} {
        set tTime [file mtime tclIndex]
        set cTime [clock seconds]
        set range 1000
        set rnum [expr {int(rand()*$range)}]
        if {[expr $cTime - $tTime] &lt; $rnum &amp;&amp; [info exists SWDEVSERVER] &amp;&amp; $SWDEVSERVER} {
            <span class="comment-line">#only do this on rdureg and citreg for now.</span>
            cd $old_dir
            return
        }
        catch {exec chmod 777 tclIndex} result
        if {[catch {open tclIndex r+} fd_out]} {
           cd $old_dir
           return -1
        }
        <span class="comment-line">#flock $fd_out </span>
    }

    auto_mkindex .
    cd $old_dir
}

<strong><a name="::getBuildNumber_178">proc <a href="mainLib.tcl-annot.html#::getBuildNumber">::getBuildNumber</a></a></strong><a name="::getBuildNumber"></a> { build } {
    if {[regexp -nocase {^[0-9].[0-9].[0-9]b[0-9]+_[a-z]+[_.][0-9a-z]+.*xtr} $build]} {
        set build [string range $build 0 [expr [string length $build]-5]]
        set brVerStr [lindex [split $build _] end]
        set brVerStr [format %d.%d.%d [string range $brVerStr 0 0] \
                [string range $brVerStr 1 1] [string range $brVerStr 2 end]]
        set build [lreplace [split $build _] end end $brVerStr]
        regsub -all &#34; &#34; $build &#34;_&#34; build

    } elseif {[regexp -nocase {^v[0-9]+b[0-9]+_[a-z]+[_.][0-9a-z]+.*xtr} $build]} {
        set build [string range $build 1 [expr [string length $build]-5]]
        set build [format %d.%d.%d%s [string range $build 0 0] \
                [string range $build 1 1] [string range $build 2 2] \
                [string range $build 3 end]]
        set brVerStr [lindex [split $build _] end]
        set brVerStr [format %d.%d.%d [string range $brVerStr 0 0] \
                [string range $brVerStr 1 1] [string range $brVerStr 2 end]]
        set build [lreplace [split $build _] end end $brVerStr]
        regsub -all &#34; &#34; $build &#34;_&#34; build  

    } elseif {[regexp -nocase {^v[0-9]+b[0-9]+_[0-9a-z].*} $build]} {
        set build $build
        set build [format %d.%d.%d%s [string range $build 1 1] \
                [string range $build 2 2] [string range $build 3 3] \
                [string range $build 4 end]]
        set brVerStr [lindex [split $build _] end]
        set brVerStr [format %d.%d.%d [string range $brVerStr 0 0] \
                [string range $brVerStr 1 1] [string range $brVerStr 2 end]]
        set build [lreplace [split $build _] end end $brVerStr]
        regsub -all &#34; &#34; $build &#34;_&#34; build  

    } elseif {[regexp -nocase {^v[0-9]+b([0-9]+)-([0-9a-z].*)-([0-9]+)} \
            $build match bld br rel]} {
        set build $build
        set build [format %d.%d.%db%d_br_%s_0.0.%d [string range $build 1 1] \
                [string range $build 2 2] [string range $build 3 3] $bld $br $rel]

    } elseif {[regexp -nocase {^[0-9]+[et].*} $build]} {
        set release &#34;&#34;
        set buildNum &#34;&#34;
        set prefix &#34;&#34;
        scan $build %de%db%d release prefix buildNum
        if {[string length $release]==2} {
            set f [string index $release 0]
            set s [string index $release 1]
            set build [format %d.%de.%db%d $f $s $prefix $buildNum]
        } else {
            puts &#34;ERROR: Wrong build $build&#34;
            return 0
        }

    } elseif {![regexp -nocase {[._^-]} $build]} {
        set release &#34;&#34;
        set buildNum &#34;&#34;
        set retVal [scan $build %db%d release buildNum]
        if {([string length $release]==3) &amp;&amp; $retVal==2} {
            set f [string index $release 0]
            set s [string index $release 1]
            set t [string index $release 2]
            set build [format %d.%d.%db%d $f $s $t $buildNum]
        } elseif {$retVal==1} {
            set retVal [scan $build %dtrb%d release buildNum]
            if {([string length $release]==3) &amp;&amp; $retVal==2} {
                set f [string index $release 0]
                set s [string index $release 1]
                set t [string index $release 2]
                set build [format %d.%d.%dtrb%d $f $s $t $buildNum]
            }
        } else {
            puts &#34;ERROR: Wrong build $build&#34;
            return 0
        }
   } else {
        if {[regexp -nocase &#34;xtr&#34; $build]} {
            set buildList [split $build .]
            set release [lindex $buildList 0]
            if {[string index $release 0]==&#34;v&#34;} {
                set buildName [string range $release 1 end]
                set retVal [scan $buildName %db%d release buildNum]
                if {([string length $release]==3) &amp;&amp; $retVal==2} {
                    set f [string index $release 0]
                    set s [string index $release 1]
                    set t [string index $release 2]
                    set build [format %d.%d.%db%d $f $s $t $buildNum]
                } elseif {$retVal==1} {
                    set retVal [scan $buildName %dtrb%d release buildNum]
                    if {([string length $release]==3) &amp;&amp; $retVal==2} {
                        set f [string index $release 0]
                        set s [string index $release 1]
                        set t [string index $release 2]
                        set build [format %d.%d.%dtrb%d $f $s $t $buildNum]
                    }
                }
            } else {
                puts &#34;ERROR: Wrong build $build&#34;
                return 0
            }
        } else {
            set build $build
        }
    }
    set build [string tolower $build]
    return $build
}
<span class="comment-line">#############################################################</span>
<span class="comment-line"># Procedure: CalculateDebug</span>
<span class="comment-line">#    This procedure checks for a debug file in the </span>
<span class="comment-line">#    Functionaltests/Module directory.  A specific format</span>
<span class="comment-line">#    is expected in the debug file.  From this debug file</span>
<span class="comment-line">#    a proc is created in the showDebugInfo&lt;Module&gt; format.</span>
<span class="comment-line">#    The showDebugInfo&lt;Module&gt; proc is interpretted by</span>
<span class="comment-line">#    showDebugInfo in fmt_add (result.tcl)</span>
<span class="comment-line">#    </span>
<span class="comment-line">#    </span>
<span class="comment-line">#    Initially this is just for the queuing system, but</span>
<span class="comment-line">#    can be expanded to be a standard part of the auto infra</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#############################################################</span>
<strong><a name="::CalculateDebug_297">proc <a href="mainLib.tcl-annot.html#::CalculateDebug">::CalculateDebug</a></a></strong><a name="::CalculateDebug"></a> {modName fileName} {
   global DUTs_info;
   global debugLevel;
   global debugStart;
   global showErrorData;

   <span class="comment-line">#</span>
   <span class="comment-line"># Start the creation of the proc data</span>
   <span class="comment-line">#</span>
   set debugOverRide 0
   <span class="comment-line"># Check to see if there is a cli debug file in the feature directory</span>
   if {[file exists $fileName]} {
      source $fileName
      if {$debugOverRide} {
<span class="comment-line">#         set debugLevel 1</span>
         set showErrorData 1
      }
      set procText &#34;global DUTs_info\nglobal whichDutNow\nglobal time1\nglobal FAILLOCK&#34;;
      set procText &#34;$procText\nglobal DEBUGFAILLOCK&#34;
      set procText &#34;$procText\nset initDutAddr \&#34;\[set DUTs_info(DUT\${whichDutNow},connect)\]\&#34;\n&#34;;
      set procText &#34;$procText\n   set DEBUGFAILLOCK 1\n\n&#34;;
      set procText &#34;$procText\n   EnableDebugMode\n\n&#34;;
      set procText &#34;$procText   if \{\$level&gt;0\} \{\n&#34;
      set procText &#34;$procText       if \{\[info level\]&lt;15\} \{\n&#34;
      foreach dut $dutList {
         set procText &#34;$procText          if \{\[info exists DUTs_info(DUT$dut,connect)\]\} \{\n&#34;
         set procText &#34;$procText             Login \$DUTs_info(DUT$dut,connect)\n&#34;;
         foreach command $debugCliList {
            set procText &#34;$procText             SendACmd \&#34; $command \&#34;\n&#34;; 
         }
         set procText &#34;$procText          \}\n&#34;;
      }
      set procText &#34;$procText      \}\n&#34;;
      set procText &#34;$procText\n   Login \$initDutAddr\n&#34;;
      if {[info exists faillock] &amp;&amp; $faillock == &#34;yes&#34;} {
          set procText &#34;$procText\n   set FAILLOCK \&#34;yes\&#34;\n&#34;;
          set procText &#34;$procText\n   result_debug \&#34;HIT DEBUG MODE USER LOCK ON FAILURE\&#34;\n&#34;;
          if {[info exists time1]} {
              set procText &#34;$procText\n   set time2 \[clock seconds\]\n&#34;;
              set procText &#34;$procText\n   result_p \&#34;Time = \[expr \$time2-\$time1\] secs\n\&#34;\n&#34;;
          }
          set procText &#34;$procText\n   close_result_file\n&#34;;
          set procText &#34;$procText\n   report_end_test\n&#34;;
          set procText &#34;$procText\n   error \&#34;User Lock on Failure is set\&#34;\n&#34;;
      }
      set procText &#34;$procText   \}\n&#34;;
      set plist [info procs]
      if { [lsearch $plist showDebugInfo$modName] &gt;= 0 } {
         rename showDebugInfo$modName &#34;&#34;;
      }
      <strong><a name="::"showDebugInfo$modName"_347">proc <a href="mainLib.tcl-annot.html#::"showDebugInfo$modName"">::"showDebugInfo$modName"</a></a></strong><a name="::"showDebugInfo$modName""></a> &#34;level&#34; &#34;$procText&#34;;
      puts &#34;\n\n################### Debug Procedure Enabled ###################\n\
                 showDebugInfo$modName level \n$procText\n\n&#34;
      return;
   } else {
      return;
   }
}
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># A procedure to categorize platform names for indexes in completetest.lst</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
<strong><a name="::CompleteTestsSkipPlatforms_358">proc <a href="mainLib.tcl-annot.html#::CompleteTestsSkipPlatforms">::CompleteTestsSkipPlatforms</a></a></strong><a name="::CompleteTestsSkipPlatforms"></a> {platform tests_to_s} {
    array set tests_to_skip $tests_to_s
    <span class="comment-line"># Get the current platform type that this test bed is running then define</span>
    <span class="comment-line">#   plat = the OR'd string of all the platforms in the family</span>
    global gnssPlatform bcmPlatform i386Platform pioneerPlatform bcmx440
    set plat bcmPlatform
    if {[regexp -nocase $gnssPlatform $platform]} {
        set plat gnssPlatform
    }
    if {[regexp -nocase $pioneerPlatform $platform]} {
        set plat pioneerPlatform 
    }
    if {[regexp -nocase $bcmPlatform $platform]} {
        set plat bcmPlatform
    }
    <span class="comment-line"># In some cases test_to_skip is at a lower level than product families</span>
    <span class="comment-line">#   ie, olympic verses mariner instead of all gnssPlatforms.  For these</span>
    <span class="comment-line">#   scenerios limit the plat variable to the lower platform setting</span>
    if {[info exists tests_to_skip(mariner)]} {
        if {[regexp -nocase &#34;bd-10808&#34; $platform]} {
            set plat mariner
        }
    }
    if {[info exists tests_to_skip(olympic)]} {
        if {[regexp -nocase &#34;bd-89|bd-128&#34; $platform]} {
            set plat olympic
        }
    }
    if {[info exists tests_to_skip(torino)]} {
        if {[regexp -nocase &#34;bd-128&#34; $platform]} {
            set plat torino
        }
    }
    if {[info exists tests_to_skip(pioneer)]} {
        if {[regexp -nocase &#34;bd-16808&#34; $platform]} {
            set plat pioneer 
        }
    }
    if {[info exists tests_to_skip(SummitX450)]} {
        if {[regexp -nocase &#34;X450|x250|x150|x350|x650|SummitX406|NWI|x480&#34; $platform]} {
            set plat SummitX450
        }
    }
    if {[info exists tests_to_skip(bcmx440)]} {
        if {[regexp -nocase $bcmx440 $platform]} {
            set plat bcmx440
        }
    }
    if {[info exists tests_to_skip(Aspen)]} {
        if {[regexp -nocase &#34;Aspen|BD-88|XCM&#34; $platform]} {
            set plat Aspen
        }
    }
    if {[info exists tests_to_skip(Everest)]} {
        if {[regexp -nocase &#34;BD-X8&#34; $platform]} {
            set plat Everest
        }
    }
    if {[regexp -nocase $i386Platform $platform]} {
        set plat i386Platform
    }
    if {[info exists tests_to_skip(Summit-PC)]||[info exists tests_to_skip(BD-PC)]} {
        if {[regexp -nocase &#34;Summit-PC|BD-PC&#34; $platform]} {
            set plat $platform
        }
    }
    return $plat
}
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># A procedure to categorize platform names for indexes in completetest.lst</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
<strong><a name="::CompleteTestsDebugPlatforms_429">proc <a href="mainLib.tcl-annot.html#::CompleteTestsDebugPlatforms">::CompleteTestsDebugPlatforms</a></a></strong><a name="::CompleteTestsDebugPlatforms"></a> {platform tests_to_run_d} {
    array set tests_to_run_debug $tests_to_run_d
    <span class="comment-line"># Get the current platform type that this test bed is running then define</span>
    <span class="comment-line">#   plat = the OR'd string of all the platforms in the family</span>
    global gnssPlatform bcmPlatform i386Platform pioneerPlatform bcmx440
    set plat bcmPlatform
    if {[regexp -nocase $gnssPlatform $platform]} {
        set plat gnssPlatform
    }
    if {[regexp -nocase $pioneerPlatform $platform]} {
        set plat pioneerPlatform 
    }
    if {[regexp -nocase $bcmPlatform $platform]} {
        set plat bcmPlatform
    }
    <span class="comment-line"># In some cases test_to_skip is at a lower level than product families</span>
    <span class="comment-line">#   ie, olympic verses mariner instead of all gnssPlatforms.  For these</span>
    <span class="comment-line">#   scenerios limit the plat variable to the lower platform setting</span>
    if {[info exists tests_to_run_debug(mariner)]} {
        if {[regexp -nocase &#34;bd-10808&#34; $platform]} {
            set plat mariner
        }
    }
    if {[info exists tests_to_run_debug(olympic)]} {
        if {[regexp -nocase &#34;bd-89|bd-128&#34; $platform]} {
            set plat olympic
        }
    }
    if {[info exists tests_to_run_debug(torino)]} {
        if {[regexp -nocase &#34;bd-128&#34; $platform]} {
            set plat torino
        }
    }
    if {[info exists tests_to_run_debug(pioneer)]} {
        if {[regexp -nocase &#34;bd-16808&#34; $platform]} {
            set plat pioneer 
        }
    }
    if {[info exists tests_to_run_debug(SummitX450)]} {
        if {[regexp -nocase &#34;X450|x250|x150|x350|x650|SummitX406|NWI|x480&#34; $platform]} {
            set plat SummitX450
        }
    }
    if {[info exists tests_to_run_debug(Aspen)]} {
        if {[regexp -nocase &#34;Aspen|BD-88|XCM&#34; $platform]} {
            set plat Aspen
        }
    }
    if {[info exists tests_to_run_debug(Everest)]} {
        if {[regexp -nocase &#34;BD-X8&#34; $platform]} {
            set plat Everest
        }
    }
    if {[regexp -nocase $i386Platform $platform]} {
        set plat i386Platform
    }
    if {[info exists tests_to_run_debug(Summit-PC)]||[info exists tests_to_run_debug(BD-PC)]} {
        if {[regexp -nocase &#34;Summit-PC|BD-PC&#34; $platform]} {
            set plat $platform
        }
    }
    return $plat
}
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># A procedure to return clean lists from the completetests.lst file</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
<strong><a name="::GetCompleteTestsLists_495">proc <a href="mainLib.tcl-annot.html#::GetCompleteTestsLists">::GetCompleteTestsLists</a></a></strong><a name="::GetCompleteTestsLists"></a> {args} {
    global skipFileFilled;
    global DUTs_info
    global efence

    parse_args GetCompleteTestsLists $args {
        sourcefile &#34;completetests.lst&#34; 
        platform   &#34;null&#34;
        lst        &#34;dev&#34;
        pId        &#34;null&#34;
        test       &#34;null&#34;
        inVersion  &#34;null&#34;
        inHwList   &#34;null&#34;
        debugFile  &#34;0&#34;
        debugSkip  &#34;0&#34;
        debugSkipCom  &#34;0&#34;
        debugOut   &#34;0&#34;
        debugCom   &#34;0&#34;
        debug      &#34;0&#34;
    }
    if {$inVersion != &#34;null&#34;} {
        set DUTs_info(DUT1,version) $inVersion
    } else {
        set DUTs_info(DUT1,version) 12.4.1.7
    }
    if {$inHwList != &#34;null&#34;} {
        set DUTs_info(DUT1,hwList) $inHwList
    } else {
        set DUTs_info(DUT1,hwList) &#34;&#34;
    }
    if {$test != &#34;null&#34;} {
        set originalDir [pwd]
        if {[file isdirectory ../Functionaltest/$test]} {
            cd &#34;../Functionaltest/$test&#34;
        } elseif {[file isdirectory ../../Functionaltest/$test]} {
            cd &#34;../../Functionaltest/$test&#34;
        } else {
            puts &#34;Can not find the test directory [pwd] $test&#34;
        }
    }
    set inPlatform $platform


    <span class="comment-line"># Set variables</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>
    set initFile 0
    <span class="comment-line"># ============= Create Tmp directory if it does not exist ============</span>
    if {![file isdirectory Tmp]} {
        if {[catch {file mkdir Tmp} reason]} {
            puts &#34;Error: Can not create Tmp dir...$reason&#34;
            return 0
        }
    }
    <span class="comment-line"># ============= open test_to_run tempfile for reading ================</span>
    if {[file isfile $sourcefile]} {
        if {[set fd_src [FileOpen $sourcefile r]]==-1} {
            puts &#34;Can't open $sourcefile&#34;
            return -1
        }
    } else {
        puts &#34;!!!!!!! NO SOURCE FILE FOUND !!!!!!!&#34;
        return &#34;error&#34;;
    }
    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line"># open a tmp file to hold lists with all white space removed (all except)</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>
    if {[set fd_tmp [FileOpen &#34;Tmp/${pId}test_to_run.tmp&#34; w]]==-1} {
        return $fd_tmp
    }
    <span class="comment-line"># read one line/test per loop</span>
    while {[gets $fd_src line] != -1} {
        set line [string trim $line \t]
        set line [string trim $line &#34; &#34;]
        if {![regexp -nocase {^set} $line]} {
            regsub -all \t $line &#34;&#34; line
            regsub -all &#34; &#34; $line &#34;&#34; line
        }
        if {$debug || $debugFile} {
            puts $line
        }
        puts $fd_tmp $line
    }
    close $fd_tmp
    close $fd_src
    source Tmp/${pId}test_to_run.tmp
    if {[catch {file delete -force &#34;Tmp/${pId}test_to_run.tmp&#34;} reason]} {
        puts &#34;ERROR: proc calculateTestToRun{1} Can't delete \
            Tmp/${pId}test_to_run.tmp: $reason&#34;
        return 0
    }
    if {$test != &#34;null&#34;} {
        cd &#34;$originalDir&#34;
    }
    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line"># Debug list gather debug list for this platform</span>
    <span class="comment-line">#    it the -test option is used, that means this is called from</span>
    <span class="comment-line">#    gettests.tcl so return at the end</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>
    set platform [<a name="::CompleteTestsDebugPlatforms(1)"><a href="./mainLib.tcl.html#::CompleteTestsDebugPlatforms_429">::CompleteTestsDebugPlatforms</a></a> $inPlatform [array get tests_to_run_debug]]
    set debug_cases {all gnssPlatform pioneerPlatform bcmPlatform SummitX450 Aspen mariner olympic}
    set debugIndexList &#34;&#34;
    set possibleDebugList &#34;&#34;
    if {($lst == &#34;debug&#34; &amp;&amp; [info exists tests_to_run_debug($platform)]) || \
        ($lst == &#34;debug&#34; &amp;&amp; [info exists tests_to_run_debug(all)])} {
        if {[info exists tests_to_run_debug($platform)]} {
            lappend debugIndexList $platform
        }
        if {[info exists tests_to_run_debug(all)]} {
            lappend debugIndexList all
        }
        foreach dIndex $debugIndexList {
            foreach iList $tests_to_run_debug($dIndex) {
                foreach listValue $iList {
                    set listValue [string trim [lindex [split [string trimleft $listValue] &#34;;&#34;] 0]]
                    if {$listValue == &#34;&#34;} {
                        continue
                    }
                    if {[regexp -nocase {^#} $listValue]} {
                        if {$debugSkipCom || $debug} {
                            puts &#34;Skip removed $listValue&#34;
                        }
                        continue
                    }
                    lappend possibleDebugList $listValue
                }
            }
        }
        if {$test != &#34;null&#34;} {
            if {$debugOut || $debug} {
                foreach testout $possibleDebugList {
                    puts $testout
                }        
            }
            return $possibleDebugList
        }        
    }
    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line"># Append to list all possible skip list conditions</span>
    <span class="comment-line"># --------------------------------------------------------------------</span>
    set platform [<a name="::CompleteTestsSkipPlatforms(1)"><a href="./mainLib.tcl.html#::CompleteTestsSkipPlatforms_358">::CompleteTestsSkipPlatforms</a></a> $inPlatform [array get tests_to_skip]]
    set possibleSkipIndexList &#34;&#34;
    if {[info exists tests_to_skip($platform)]} {
        foreach iList $tests_to_skip($platform)] {
            foreach listValue $iList {
                set listValue [string trim [lindex [split [string trimleft $listValue] &#34;;&#34;] 0]]
                if {$listValue == &#34;&#34;} {
                    continue
                }
                if {[regexp -nocase {^#} $listValue]} {
                    if {$debugSkipCom || $debug} {
                        puts &#34;Skip removed $listValue&#34;
                    }
                    continue
                }
                lappend possibleSkipIndexList $listValue
            }
        }
    }
    <span class="comment-line"># Special Case to Handle Queens Platforms which are bcmPlatforms, but have less features</span>
    if {[regexp -nocase &#34;8500&#34; $DUTs_info(DUT1,hwList)]} {
        if {[info exists tests_to_skip(queens)]} {
            foreach iList $tests_to_skip(queens)] {
                foreach listValue $iList {
                    set listValue [string trim [lindex [split [string trimleft $listValue] &#34;;&#34;] 0]]
                    if {$listValue == &#34;&#34;} {
                        continue
                    }
                    if {[regexp -nocase {^#} $listValue]} {
                        if {$debugSkipCom || $debug} {
                            puts &#34;Skip removed $listValue&#34;
                        }
                        continue
                    }
                    lappend possibleSkipIndexList $listValue
                }
            }
        }
    }
    if {[info exists efence]} {
        if {[info exists tests_to_skip(efence)]} {
            foreach iList $tests_to_skip(efence)] {
                foreach listValue $iList {
                    set listValue [string trim [lindex [split [string trimleft $listValue] &#34;;&#34;] 0]]
                    if {$listValue == &#34;&#34;} {
                        continue
                    }
                    if {[regexp -nocase {^#} $listValue]} {
                        if {$debugSkipCom || $debug} {
                            puts &#34;Skip removed $listValue&#34;
                        }
                        continue
                    }
                    lappend possibleSkipIndexList $listValue
                }
            }
        }
    }

    <span class="comment-line"># ------------------------------------------------------------------------------</span>
    <span class="comment-line"># Create the tests to run list</span>
    <span class="comment-line">#    -Order from quick pass all to dev based on the possibleTestsToRunList</span>
    <span class="comment-line">#    list below</span>
    <span class="comment-line">#    -Get all indexes for each possible list and loop through each</span>
    <span class="comment-line">#    -Do not loop through build indexes that are greater than the current running</span>
    <span class="comment-line">#    -On each loop, don't append the test case if it is in the skip list</span>
    <span class="comment-line"># ------------------------------------------------------------------------------</span>
    set new_tests_to_run &#34;&#34;
    switch $lst {
        &#34;quick&#34; {
            set possibleTestsToRunList {tests_to_run_quick tests_to_run}
        }
        &#34;pass&#34; {
            set possibleTestsToRunList {tests_to_run_quick tests_to_run_pass tests_to_run}
        }
        &#34;passlist&#34; {
            set possibleTestsToRunList {tests_to_run_pass tests_to_run}
        }
        &#34;all&#34; {
            set possibleTestsToRunList {tests_to_run_quick tests_to_run_pass \
                              tests_to_run_all tests_to_run tests_to_run_debug}
        }
        &#34;alllist&#34; {
            set possibleTestsToRunList {tests_to_run_all tests_to_run}
        }
        &#34;dev&#34; {
            set possibleTestsToRunList {tests_to_run_quick tests_to_run_pass \
                              tests_to_run_all tests_to_run_dev tests_to_run_debug tests_to_run}
        }
        &#34;alldevdebug&#34; {
            set possibleTestsToRunList {tests_to_run_all tests_to_run_dev \
                              tests_to_run_debug tests_to_run}
        }
        &#34;devonly&#34; {
            set possibleTestsToRunList {tests_to_run_dev tests_to_run}
        }
        &#34;devlist&#34; {
            set possibleTestsToRunList {tests_to_run_dev tests_to_run_debug \
					 tests_to_run}
        }
        &#34;debugonly&#34; {
            set possibleTestsToRunList {tests_to_run_debug tests_to_run}
        }
    }
    foreach possibleList $possibleTestsToRunList {
        foreach index [array names $possibleList] {
            <span class="comment-line"># The debug list has different text indexes from the debug_cases list above</span>
            <span class="comment-line">#   For this reason, the version check below is invalid and will cause a failure</span>
            <span class="comment-line">#   the condition below verifies that the index is legal add sets a variable to</span>
            <span class="comment-line">#   avoid the version check </span>
            if {$possibleList == &#34;tests_to_run_debug&#34; &amp;&amp; [lsearch -exact $debug_cases &#34;$index&#34;] &gt;= 0 } {
                if {$debug} {
                    puts &#34;hit debut ok&#34;
                }
                set debugListOK 1
            } else {
                set debugListOK 0
            }
            if { ($debugListOK) || (&#34;$index&#34; == &#34;all&#34;) || (&#34;$index&#34; == &#34;null&#34;) \
		               || [CompareRelease $index [GetVersion DUT1 ]] &lt;= 0 } {
                foreach iList [set ${possibleList}($index)] {
                    foreach listValue $iList {
                        set listValue [string trim [lindex [split [string trimleft $listValue] &#34;;&#34;] 0]]
                        if {$listValue == &#34;&#34;} {
                            if {$debugCom || $debug} {
                                puts &#34;Skip blank line&#34;
                            }
                            continue
                        }
                        if {[regexp -nocase {^#} $listValue]} {
                            if {$debugCom || $debug} {
                                puts &#34;Skip Comment $listValue&#34;
                            }
                            continue
                        }
                        if {[lsearch -exact $possibleSkipIndexList &#34;$listValue&#34;] &gt;= 0} {
                            if {$debugSkip || $debug} {
                                puts &#34;Skip Comment $listValue&#34;
                            }
                            continue
                        }
                        if {$debug} {
                            puts &#34;Appending $listValue&#34;
                        }
                        lappend new_tests_to_run $listValue
                    }
                }
            }
        }
    }
    if {$debugOut || $debug} {
        foreach testout $new_tests_to_run {
            puts $testout
        }        
    }
    return $new_tests_to_run
}

<strong><a name="::mainSort_792">proc <a href="mainLib.tcl-annot.html#::mainSort">::mainSort</a></a></strong><a name="::mainSort"></a> {indexList} {

    set allFlag FALSE
    set nullFlag FASLSE
    upvar $indexList newIndexList
    
    <span class="comment-line"># check if 'all' index exists</span>
    <span class="comment-line"># if found remove and set flag</span>
    set allIndex [lsearch $newIndexList all]
    puts &#34;newIndexList $newIndexList&#34;
    if {$allIndex != -1} {
        set newIndexList [lreplace $newIndexList $allIndex $allIndex]
        set allFlag TRUE
        puts &#34;all found&#34;
    }
    
    <span class="comment-line"># check if 'null' index exists</span>
    <span class="comment-line"># if found remove and set flag</span>
    set nullIndex [lsearch $newIndexList null]
    if {$nullIndex != -1} {
        set newIndexList [lreplace $newIndexList $nullIndex $nullIndex]
        set nullFlag TRUE
        puts &#34;null found&#34;
    }
    
    <span class="comment-line"># Now sort the list</span>
    set newIndexList [lsort -dic $newIndexList]
    
    <span class="comment-line"># Now add back all and null if they existed in the first place</span>
    if {$allFlag == &#34;TRUE&#34;} {
        set newIndexList [linsert $newIndexList 0 all]
    }
    if {$nullFlag == &#34;TRUE&#34;} {
        set index [llength $newIndexList]
        set newIndexList [linsert $newIndexList $index null]
    }

}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: parseTestCaseFromLine</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Parses out testcase from a line.  Line normally comes </span>
<span class="comment-line">#              from completetest.lst and takes any one of the following </span>
<span class="comment-line">#              forms...</span>
<span class="comment-line">#                   1.init</span>
<span class="comment-line">#</span>
<span class="comment-line">#                   1.1.1.1</span>
<span class="comment-line">#                   1.1.1.2          ;# PD2-232530474 closed</span>
<span class="comment-line">#                   1.1.1.4  ;#assert</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: line - line to parse</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::parseTestCaseFromLine_852">proc <a href="mainLib.tcl-annot.html#::parseTestCaseFromLine">::parseTestCaseFromLine</a></a></strong><a name="::parseTestCaseFromLine"></a> { line } {

    set tc &#34;&#34;

    set line [string trim $line]

    set result [regexp {^([a-zA-Z0-9_\.-]+)\ *} $line ignore tc]
    
    return $tc

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: calcExecTime</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Adds up total execution time</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: durationList - List containing durations from previous</span>
<span class="comment-line">#                            run. Durations are in seconds.</span>
<span class="comment-line">#                FORMAT: { {1.1.1 10} {1.1.2 11} {testcase duration} }</span>
<span class="comment-line">#             targetList - List of testcases to sum up</span>
<span class="comment-line">#                FORMAT: { 1.init 1.1.1 1.1.2 1.2.1 }</span>
<span class="comment-line">#             stopOnMissing - Stop immediately and return 0 if can't find an target</span>
<span class="comment-line">#                             in duration list</span>
<span class="comment-line">#             defaulTimeSec - Default estimate of duration if </span>
<span class="comment-line">#                             a testcase does not have a duration in </span>
<span class="comment-line">#                             durationList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  total duration in seconds</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::calcExecTime_883">proc <a href="mainLib.tcl-annot.html#::calcExecTime">::calcExecTime</a></a></strong><a name="::calcExecTime"></a> { durationList targetList {stopOnMissing 0} {defaultTimeSec 0} } {

    set totalDuration 0

    foreach tc $targetList {
	set found 0
	;<span class="comment-line"># Find testcase tc in durationList</span>
	foreach tcDurationSet $durationList {
	    set testCaseId  [lindex $tcDurationSet 0]
	    set testCaseDur [lindex $tcDurationSet 1]
	    if [regexp $tc $testCaseId] {
		;<span class="comment-line"># Found It...update totalDuration and break to get next tc</span>
		;<span class="comment-line"># puts &#34;DEBUG: FOUND IT: $tc $testCaseId ($testCaseDur)&#34;</span>
		set totalDuration [expr $totalDuration + $testCaseDur];
		set found 1
		break;
	    }
	}
	if {$found == 0} {
	    if { $stopOnMissing } {
		puts &#34;ERROR: Could not find target $tc EXITING&#34;
		return 0
	    } else {
		puts &#34;WARNING: Could not find target $tc&#34;
	    }
	    ;<span class="comment-line"># We didn't find it.  Use a default duration</span>
	    set totalDuration [expr $totalDuration + $defaultTimeSec];
	    puts &#34;Warning: No duration for $tc.  Using default of $defaultTimeSec&#34;
	}
    }
    return $totalDuration
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: parseExecTimeFile</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Reads a file containing execution times, and builds a list</span>
<span class="comment-line">#              then returns it to calling procedure</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: filename - Filename of file containing execution time history.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  List of testcase duration in format... {{tc1 dur1} {tc2 dur2}}</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::parseExecTimeFile_927">proc <a href="mainLib.tcl-annot.html#::parseExecTimeFile">::parseExecTimeFile</a></a></strong><a name="::parseExecTimeFile"></a> { filename } {

    set durationList &#34;&#34;
    set fdin [open $filename &#34;r+&#34;]
    
    while {[gets $fdin line] != -1} {
	set result [regexp &#34;testcase:(.*)\ *duration:(.*)&#34; $line ignore tcNum tcDur]
	if { $result } {
	    lappend durationList &#34;$tcNum $tcDur&#34;
	}
    }
    if {[llength $durationList] == 0} {
	puts &#34;WARNING: No testcases found.&#34;
    }
 
    return $durationList
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: parseExecTimeFile</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Combine the testList array into a single list that contains ONLY </span>
<span class="comment-line">#              testcase numbers. Strips out all comments</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: testList - List of tests that we want to determine duration of</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  Simple list of testcases. {1.init 1.1.2 1.1.3.......cleanup} </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::combineAndStripTestList_957">proc <a href="mainLib.tcl-annot.html#::combineAndStripTestList">::combineAndStripTestList</a></a></strong><a name="::combineAndStripTestList"></a> { testList } {
    
    upvar $testList tl

    set totalDuration 0
    set newTcList &#34;&#34;

    ;<span class="comment-line"># Get array names for this test list.</span>
    set arrayIndexes [array names tl]

    ;<span class="comment-line"># Write ALL testcases to a file for parsing.  We use the same method</span>
    ;<span class="comment-line"># used by executeTestsToRun{} to pull out each testcase number.</span>
    ;<span class="comment-line"># We dump all testcases to a file, then parse each line by line</span>
    set pID [pid]
    set tmpFileName &#34;Tmp/calcExecDuration_$pID&#34;
    set fdin [open  $tmpFileName &#34;w+&#34;]
    foreach testListArray $arrayIndexes {	
	;<span class="comment-line"># Dump list into temp file</span>
	puts $fdin $tl($testListArray)
    }

    ;<span class="comment-line"># SEEK to top of file.</span>
    seek $fdin 0 start
    while {[gets $fdin line] != -1} {
	
	set tc [<a name="::parseTestCaseFromLine(1)"><a href="./mainLib.tcl.html#::parseTestCaseFromLine_852">::parseTestCaseFromLine</a></a> $line]
	if {$tc != &#34;&#34;} {
	    lappend newTcList $tc
	}
    }
    ;<span class="comment-line"># clean up</span>
    close $fdin
    catch {file delete -force &#34;$tmpFileName&#34;} reason

    return $newTcList
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: parseExecTimeFile</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Print seconds in a more readable hour/min/sec format</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: numSec - Total time in seconds to convert</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  formatted output dividing input into hours/min/sec</span>
<span class="comment-line">#               i.e. 6 hours, 59 minutes, 32 seconds</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::formatSeconds_1006">proc <a href="mainLib.tcl-annot.html#::formatSeconds">::formatSeconds</a></a></strong><a name="::formatSeconds"></a> { numSec } {

    if {! [string is integer -strict $numSec] } {
	return &#34;NA&#34;
    }

    set testSec  [expr $numSec % 60]
    set testMin  [expr $numSec / 60]
    set testHour [expr $testMin / 60]
    set testMin  [expr $testMin % 60]

    return &#34;$testHour hours, $testMin minutes, $testSec seconds&#34;

}

<strong><a name="::GetRegPath_1021">proc <a href="mainLib.tcl-annot.html#::GetRegPath">::GetRegPath</a></a></strong><a name="::GetRegPath"></a> { regType regSubType } {

    set thisDir [pwd]
    cd  &#34;..&#34;
    set regPath [pwd]
    cd  $thisDir
    switch $regType {
	functional {
	    set regPath &#34;$regPath/Functionaltest&#34; 
	}
	ixscriptmate { 
	    set regPath &#34;$regPath/ixScriptMate&#34; 
	}
	cli { 
	    if { $regSubType == &#34;uploadanddownload&#34; } {
		set regPath &#34;../CLItest/uploadanddownload&#34;
	    } else {
		set regPath &#34;../CLItest/upgradedowngrade&#34;
	    }
	}
	scalability { 
	    set regPath &#34;$regPath/Scalabilitytest&#34; 
	}
	snmp { 
	    set regPath &#34;$regPath/SnmpFunctionaltest&#34; 
	}
	xml { 
	    set regPath &#34;$regPath/XML_API&#34; 
	}
        fit {
            set regPath &#34;$regPath/FeatureInteraction&#34;
        }

	default { 
	    set regPath &#34;$regPath/Functionaltest&#34; 
	}
    }
    
    return &#34;$regPath&#34;
}

<strong><a name="::DetermineCfgRegTypeSubTypeFromPlatform_1062">proc <a href="mainLib.tcl-annot.html#::DetermineCfgRegTypeSubTypeFromPlatform">::DetermineCfgRegTypeSubTypeFromPlatform</a></a></strong><a name="::DetermineCfgRegTypeSubTypeFromPlatform"></a> { platform } {

    global regplatform

    if { ![info exists regplatform($platform)] } {
        puts &#34;Error: Could not find \&#34;$platform\&#34; name. Verify spelling and try again&#34;
        exit
    }

    set cfg         [lindex $regplatform($platform) 2]
    set regType     [lindex $regplatform($platform) 3]
    set regSubType  [lindex $regplatform($platform) 4]

    if { $regType  == &#34;&#34; } {
        set regType &#34;functional&#34;
    }

    if { $regSubType == &#34;&#34; } {
        set regSubType &#34;standard&#34;
    }

    if { [regexp -nocase &#34;rout&#34; $regSubType] } {
        set regSubType &#34;routing&#34;
    }

    return &#34;$cfg $regType $regSubType&#34;
}


<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CreateRegLogFilter</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Create Log filter for Regression for critical error </span>
<span class="comment-line">#              only. First checking is done for existance.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: At present no input argument</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument  </span>
<span class="comment-line">#   </span>
<span class="comment-line">##################################################################</span>
<strong><a name="::CreateRegLogFilter_1102">proc <a href="mainLib.tcl-annot.html#::CreateRegLogFilter">::CreateRegLogFilter</a></a></strong><a name="::CreateRegLogFilter"></a> {} {

global numDUT
global validstring

set validstring(1) &#34;not&#34;
set validstring(2) &#34;must&#34;

for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
   global DUT${dut}_CONNECT
   Login [set DUT${dut}_CONNECT]
   if {![regexp -nocase -all [CheckCmdIllegal &#34;show log config filter Regression&#34; NULL CheckCmdIllegal 0] &#34;legal&#34;]} { 
       SendACmd &#34;create log filter Regression&#34;
       SendACmd &#34;conf log filter Regression add events all severity error&#34;
       SendACmd &#34;conf log filter Regression add events all severity critical&#34;
       SendACmd &#34;conf log target console filter Regression&#34;
       SendACmd &#34;conf log target nvram filter Regression&#34;
       SendACmd &#34;enable log display&#34;
     }
}
unset validstring(1)
unset validstring(2)
}
<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure Name: _SetPartitionVars</span>
<span class="comment-line">#</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::_SetPartitionVars_1129">proc <a href="mainLib.tcl-annot.html#::_SetPartitionVars">::_SetPartitionVars</a></a></strong><a name="::_SetPartitionVars"></a> {args} {
    global DEFAULT_XSF_AUTO_CREATE DEFAULT_XSF_CLI_COMMON DEFAULT_XSF
    global DUTs_info
    parse_args _SetPartitionVars $args {
        dut &#34;1&#34;
    }

    if {![info exists DEFAULT_XSF($dut)]} {
        return
    }
    foreach cli $DEFAULT_XSF($dut) {
        if {[regexp -nocase &#34;partit&#34; $cli]} {
            puts &#34;Found DUT $dut parition cli $cli&#34;
            lappend DUTs_info(DUT$dut,partitionCli) &#34;$cli&#34;
        }
        if {[regexp -nocase &#34;reboo&#34; $cli]} {
            global DUT${dut}_Stacking_msma_slot
            if {[info exists DUT${dut}_Stacking_msma_slot]} {
                puts &#34;Found reboot Stack default.xsf - extend DUT $dut unc sw time 300 seconds&#34;
                set DUTs_info(DUT$dut,UncSwAdditionalTime) 300
            } else {
                puts &#34;Found reboot in default.xsf - extend DUT $dut unc sw time 120 seconds&#34;
                set DUTs_info(DUT$dut,UncSwAdditionalTime) 120
            }
        }
    }
}

<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure Name: CreateDefaultXsf </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Create  default.xsf which is used in following cases</span>
<span class="comment-line">#</span>
<span class="comment-line"># default.xsf =default.xsf file is executed if the switch comes up in an</span>
<span class="comment-line"># unconfigured state because the configuration file is missing, or the configuration</span>
<span class="comment-line"># file cannot be determined due to a corrupt NVRAM or other problems.</span>
<span class="comment-line"># This returns the switch to some basic configuration. When default.xsf is executed,</span>
<span class="comment-line"># the show switch command shows default.xsf as the booted configuration file.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dut</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::CreateDefaultXsf_1172">proc <a href="mainLib.tcl-annot.html#::CreateDefaultXsf">::CreateDefaultXsf</a></a></strong><a name="::CreateDefaultXsf"></a> {args} {
    global DEFAULT_XSF_AUTO_CREATE DEFAULT_XSF_CLI_COMMON DEFAULT_XSF
    global DEFAULT_XSF_ADD_MGMT DEFAULT_XSF_USER defaultRouter
    parse_args CreateDefaultXsf $args {
        dut &#34;1&#34;
        standby &#34;null&#34;
    }

    if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; !$DEFAULT_XSF_AUTO_CREATE} {
        return 1;
    }
    <span class="comment-line"># We are least going to set the basic from the common.cfg</span>
    set hitDefault 0
    <span class="comment-line"># Select the console variable - a DUT (normal) or a STDBY</span>
    set mode &#34;dut&#34;
    if {$standby != &#34;null&#34; &amp;&amp; [regexp -nocase &#34;\[0-9]&#34; $standby]} {
        set mode &#34;standby&#34;
        set DUTName [format %s%d STDBY $standby]
        global ${DUTName}_CONNECT ${DUTName}_IP ${DUTName}_MASK
        if {![info exists ${DUTName}_CONNECT]} {
            result_warning &#34;Skipping Standby $standby . Please set ${DUTName}_CONNECT in cfg&#34;
            return;
        }
        if {[info exists DEFAULT_XSF_ADD_MGMT] &amp;&amp; $DEFAULT_XSF_ADD_MGMT &amp;&amp; \
                ![info exists ${DUTName}_IP]} {
            result_warning &#34;Skipping Standby $standby . Please set ${DUTName}_IP in cfg&#34;
            return;
        }

    } else {
        set DUTName [format %s%d DUT $dut]
        global ${DUTName}_CONNECT ${DUTName}_IP ${DUTName}_MASK
    }

    Login [set ${DUTName}_CONNECT] -CheckOperational 0
    SendACmd &#34;&#34;
    EnableDebugMode
    <span class="comment-line">#</span>
    <span class="comment-line"># check to see if there is an existing default.xsf.  Save it. Copy back if failure</span>
    <span class="comment-line">#</span>
    set parameterList &#34;&#34;
    set parameterList &#34;default.xsf&#34;
    if {[regexp -nocase &#34;ok&#34; [CheckKeyValue &#34;ls&#34; $parameterList -reportResults 0]]} {
        set hitDefault 1
        SendACmd &#34;mv default.xsf default.auto&#34;
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># Add all common.cfg COMMON cli to the new default.xsf. Create a list to check against later</span>
    <span class="comment-line">#</span>
    set parameterList &#34;&#34;
    foreach cc $DEFAULT_XSF_CLI_COMMON {
        lappend parameterList &#34;{$cc} exist&#34;
        SendACmd &#34;!echo \&#34;$cc\&#34; &gt;&gt; /usr/local/cfg/default.xsf&#34;
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># Add all test bed cfg file 'all dut' cli to the default.xsf. Add to parameterlist for check</span>
    <span class="comment-line">#</span>
    if {[info exists DEFAULT_XSF_USER]} {
        foreach uc $DEFAULT_XSF_USER {
            lappend parameterList &#34;{$uc} exist&#34;
            SendACmd &#34;!echo \&#34;$uc\&#34; &gt;&gt; /usr/local/cfg/default.xsf&#34;
        }        
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># Add mgmt ipa and ipr. Add cli to parameterList for checking at the end</span>
    <span class="comment-line">#</span>
    if {[info exists DEFAULT_XSF_ADD_MGMT] &amp;&amp; $DEFAULT_XSF_ADD_MGMT} {
        if [info exist ${DUTName}_MASK] {
            set ipMask [set ${DUTName}_MASK]
        } else {
            set ipMask 24
        }
        lappend parameterList &#34;{configure mgmt ipaddress [set ${DUTName}_IP]/$ipMask} exist&#34;
        SendACmd &#34;!echo \&#34;configure mgmt ipaddress [set ${DUTName}_IP]/$ipMask\&#34; &gt;&gt; /usr/local/cfg/default.xsf&#34;
        lappend parameterList &#34;{configure iproute add default $defaultRouter vr vr-mgmt} exist&#34;
        SendACmd &#34;!echo \&#34;configure iproute add default $defaultRouter vr vr-mgmt\&#34; &gt;&gt; /usr/local/cfg/default.xsf&#34;
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># Add DUT specific cli from the test bed cfg to file and verification parameterList</span>
    <span class="comment-line">#</span>
    if {$mode == &#34;dut&#34;} {
        if {[info exists DEFAULT_XSF($dut)]} {
            set defcli [concat $DEFAULT_XSF_CLI_COMMON $DEFAULT_XSF($dut)]
            foreach c $DEFAULT_XSF($dut) {
                lappend parameterList &#34;{$c} exist&#34;
                SendACmd &#34;!echo \&#34;$c\&#34; &gt;&gt; /usr/local/cfg/default.xsf&#34;
            }
            regsub -all {[()]} $parameterList {\\&amp;} parameterList
        }
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># Check that all cli are in the new default.xsf.  If not mv default.auto back to default.xsf</span>
    <span class="comment-line">#</span>
    if {![regexp -nocase &#34;ok&#34; [CheckKeyValue &#34;!cat /usr/local/cfg/default.xsf&#34; $parameterList -reportResults 0]] \
         &amp;&amp; $hitDefault} {
        result_debug &#34;Failed to make default.xsf&#34;
        SendACmd &#34;mv default.auto default.xsf&#34;
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># logout to avoid multiTask first login expect session issues</span>
    <span class="comment-line">#</span>
    logout 
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CreateDefaultXsfAllDuts </span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::CreateDefaultXsfAllDuts_1281">proc <a href="mainLib.tcl-annot.html#::CreateDefaultXsfAllDuts">::CreateDefaultXsfAllDuts</a></a></strong><a name="::CreateDefaultXsfAllDuts"></a> {} {
    global whichDutNow
    set makeXsfList &#34;&#34;

    set initDut $whichDutNow
    for {set nDUT 1; global DUT${nDUT}_CONNECT} { [info exists DUT${nDUT}_CONNECT] } \
                                             {incr nDUT ; global DUT${nDUT}_CONNECT} {
        lappend makeXsfList &#34;CreateDefaultXsf -dut $nDUT&#34;
    }
    for {set nSBY 1; global STDBY${nSBY}_CONNECT} { [info exists STDBY${nSBY}_CONNECT] } \
                                             {incr nSBY ; global STDBY${nSBY}_CONNECT} {
        lappend makeXsfList &#34;CreateDefaultXsf -dut \&#34;null\&#34; -standby $nSBY&#34;
    }
    _setShowOutput -screen off -log off -res_fmt on
    MultiTask $makeXsfList
    _setShowOutput -screen on -log on -res_fmt on
    set connect [set DUT${initDut}_CONNECT]
    Login $connect  -masterCheck 0 -CheckOperational 0
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CreateAutoexecXsf </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Create  autoexec.xsf which is used in following cases</span>
<span class="comment-line">#</span>
<span class="comment-line"># autoexec.xsf = autoexec.xsf is executed after the configuration has been loaded.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: At present no input argument</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::CreateAutoexecXsf_1311">proc <a href="mainLib.tcl-annot.html#::CreateAutoexecXsf">::CreateAutoexecXsf</a></a></strong><a name="::CreateAutoexecXsf"></a> {} {

global numDUT
global switchPort2DefaultRouter;
global defaultRouter;
global tftpServerList;
global DUT1_IP
set tftpServerIP [lindex $tftpServerList 0];


 if { ([CompareRelease [GetVersion DUT${numDUT}] 12.1]&gt;=0 ) } {

        for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
           global DUT${dut}_CONNECT
           global DUT${dut}_IP;
           global DUT${dut}_MASK;
           set ipAddr [set DUT${dut}_IP]
           if [info exist DUT${dut}_MASK] {
                   set ipMask [set DUT${dut}_MASK]
            } else {
                   set ipMask 24
           }
           set virtualRouter [GetVrString $dut];
           set fd_cli [open &#34;Tmp/autoexec_$ipAddr.xsf&#34; &#34;w&#34;]
           if {[regexp -nocase $switchPort2DefaultRouter &#34;mgmt&#34;]} {
               puts $fd_cli    &#34;unconfigure mgmt ipaddress&#34;;
               puts $fd_cli    &#34;configure mgmt ipaddress $ipAddr/$ipMask&#34;;
           } else {
        	set gwPort [GetDUTPort $switchPort2DefaultRouter $dut]
                puts $fd_cli    &#34;configure default delete port $gwPort&#34;;
        	puts $fd_cli    &#34;enable port $gwPort&#34;;
        	sleep 5
        	puts $fd_cli   &#34;create vlan commvlan vr $virtualRouter&#34;;
        	puts $fd_cli   &#34;create vlan commvlan vr $virtualRouter&#34;;
        	puts $fd_cli    &#34;configure commvlan add port $gwPort&#34;;
        	puts $fd_cli    &#34;configure commvlan $ipAddr/$ipMask&#34;;
            }
               puts $fd_cli    &#34;configure ipr add default $defaultRouter vr $virtualRouter&#34;;
               close $fd_cli
               SendAFileToTftp tftpServerIP &#34;Tmp/autoexec_$ipAddr.xsf&#34;


                Login [set DUT${dut}_CONNECT]
                ConfigGatewayNetwork
                SendACmd &#34;tftp [lindex $tftpServerList 0] -v $virtualRouter -g -l autoexec.xsf -r autoexec_${ipAddr}.xsf_${DUT1_IP}&#34;
                UnconfigGatewayNetwork
        }
 }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: showConfigOnAll_DUTs </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  utility function </span>
<span class="comment-line">#</span>
<span class="comment-line"># Its purpose is to show config for all DUTs </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: At present no input argument</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::showConfigOnAll_DUTs_1371">proc <a href="mainLib.tcl-annot.html#::showConfigOnAll_DUTs">::showConfigOnAll_DUTs</a></a></strong><a name="::showConfigOnAll_DUTs"></a> {} {

global numDUT
    for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
           global DUT${dut}_CONNECT
           Login [set DUT${dut}_CONNECT]
           SendACmd &#34;show configuration&#34;
    }
}
<strong><a name="::RemoveAutoexecXsf_1380">proc <a href="mainLib.tcl-annot.html#::RemoveAutoexecXsf">::RemoveAutoexecXsf</a></a></strong><a name="::RemoveAutoexecXsf"></a> {} {
global numDUT
    for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
           global DUT${dut}_CONNECT
           Login [set DUT${dut}_CONNECT]
          SendACmd &#34;rm autoexec.xsf&#34;
    }

}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: downloadBootromOnAll_DUTs </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  utility function </span>
<span class="comment-line">#</span>
<span class="comment-line"># Its purpose is to downloadBootrom for all DUTs </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: At present no input argument</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::downloadBootromOnAll_DUTs_1400">proc <a href="mainLib.tcl-annot.html#::downloadBootromOnAll_DUTs">::downloadBootromOnAll_DUTs</a></a></strong><a name="::downloadBootromOnAll_DUTs"></a> { TFTPServerIP bootromFilename } {

global numDUT
global stackable
    for {set dut 1} {$dut &lt;= $numDUT} {incr dut} {
           global DUT${dut}_CONNECT
           Login [set DUT${dut}_CONNECT]
           if {[regexp -nocase &#34;$stackable&#34; [GetPlatform DUT${dut}]]} {
           DownloadBootrom $dut $TFTPServerIP $bootromFilename 
           }
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: dumpHeapTrace </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  utility function </span>
<span class="comment-line">#</span>
<span class="comment-line"># Its purpose is to enable HeapTracing and dump the info per test for all DUTs </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:   </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: At present no output argument</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::dumpHeapTrace_1423">proc <a href="mainLib.tcl-annot.html#::dumpHeapTrace">::dumpHeapTrace</a></a></strong><a name="::dumpHeapTrace"></a> {userid passwd} {
    global gHeapTracingProcess
    global numDUT MAIN
    global currentTestNumber
    global whichDutNow
    global heapTraceEnabled
    global DUTs_info
    global cfg
    global currentTestIndex
    global chassis stacking
    if { ([info exists gHeapTracingProcess] ) &amp;&amp; ($gHeapTracingProcess != &#34;no&#34;) } {
         <span class="comment-line"># remove empty spaces and comments from testcase like 8.1;#PDX</span>
         if { ![info exists currentTestNumber] } {
               set tempCurrentTestNumber &#34;main&#34;
         } else {
              set currentTestNumber [string trim $currentTestNumber]
              if {[regexp {(.*) *;.*} $currentTestNumber match match1]} {
                set tempCurrentTestNumber $match1
              } else {
                set tempCurrentTestNumber $currentTestNumber
              }
         }
         set tempCurrentTestNumber [string trim $tempCurrentTestNumber]
          <span class="comment-line"># enable heapTracing from pacman for non stacking </span>
          <span class="comment-line"># on msm a and msm B if chassis based or on DUT if stackables</span>
         for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
             global DUT${i}_CONNECT
             global DUT${i}_CONNECTB
             global DUT${i}_IP
             if {!([regexp -nocase &#34;$stacking&#34; [GetPlatform DUT${i}]])} {
                set heaptrcTime [clock seconds];
                Login [set DUT${i}_CONNECT]
                <span class="comment-line"># enable heaptracing only onces in a module regression</span>
                if { $heapTraceEnabled != &#34;yes&#34; } {
                     if {[regexp -nocase &#34;$chassis&#34; [GetPlatform DUT${i}]] == 1 } {
                          if { [info exists DUT1_CONNECTB] } {
                             enableHeapTrc $i &#34;B&#34;
                          }
                          enableHeapTrc $i
                     } else {
                          enableHeapTrc $i
                     }
                }
                <span class="comment-line"># mgmt should be configured for heaptrc tool to get data</span>
                Login [set DUT${i}_CONNECT]
                ConfigGatewayNetwork
                exSleep 10 ;
                <span class="comment-line">#       foreach exosProcess $gHeapTracingProcess {</span>
                <span class="comment-line">#           SendACmd &#34;debug epm configure process $exosProcess memory trace 1&#34;</span>
                <span class="comment-line">#       }</span>
                <span class="comment-line"># some libs required for heaptrc to decode exos sysmbol table is available on doc</span>
                <span class="comment-line"># and not available on regresssion servers hence using doc server to to heaptrc dumps</span>
                login_linux doc $userid $passwd 
                <span class="comment-line"># directory name manupulations</span>
                set heapTraceDir &#34;HeapTrc/$DUTs_info(DUT1,version)/$MAIN(feature_directory)/$cfg&#34;
                regsub -all {\.\.\/Functionaltest\/} $heapTraceDir {} heapTraceDir 
                regsub -all {\/cfg} $heapTraceDir {} heapTraceDir 
                regsub -all {\.cfg} $heapTraceDir {} heapTraceDir 
                if { $heapTraceEnabled != &#34;yes&#34; } {
                     linuxSendACmd &#34;mkdir -p $heapTraceDir&#34;
                }
                linuxSendACmd &#34;cd $heapTraceDir&#34;
                exSleep 4 
                if {[llength $gHeapTracingProcess] &gt;= 1} {
                   foreach exosProcess $gHeapTracingProcess {
                      set cmd &#34;/home/$userid/heaptrc [set DUT${i}_IP] $exosProcess &gt; DUT${i}_${exosProcess}_${currentTestIndex}_${tempCurrentTestNumber}.txt&#34;
                      linuxSendACmd $cmd 
                      exSleep 4 
                   }
                }
                linuxSendACmd &#34;cd&#34;
                Login [set DUT${whichDutNow}_CONNECT]
                UnconfigGatewayNetwork
             }
        }
        set heapTraceEnabled &#34;yes&#34;
   }
}
;<span class="comment-line"># Description: Generates summary file of execution durations</span>
;<span class="comment-line"># NOTE: calculateTestsToRuna assumes current directory contains completetests.lst</span>
;<span class="comment-line"># If standard list type is NOT given we just display basic Setup and CheckConn</span>
;<span class="comment-line"># times along with total run time.</span>
<strong><a name="::generateExecutionSummary_1505">proc <a href="mainLib.tcl-annot.html#::generateExecutionSummary">::generateExecutionSummary</a></a></strong><a name="::generateExecutionSummary"></a> { execTimeFileName listFile module \
        {setupDur 0} {checkConnDur 0} {totalTestDur 0} \
        {fileName &#34;execSummary.txt&#34;} } {

    global randomIndex

    set quickExecDuration &#34;NA&#34;
    set passExecDuration &#34;NA&#34;
    set allExecDuration &#34;NA&#34;

    ;<span class="comment-line"># If we use standard list type, calculate each.</span>
    if { ($listFile == &#34;quick&#34;) || ($listFile == &#34;pass&#34;) || ($listFile == &#34;all&#34;) } {

        if { ! [file exists &#34;completetests.lst&#34;] } {
            result_debug &#34;File completetests.lst not found in directory [pwd]&#34;
            return 0
        }

        set platform [GetPlatform]

        ;<span class="comment-line"># Format the Execution Time file into a {{testcase duration} .. } format</span>
        set formattedExecTimeFile [<a name="::parseExecTimeFile(1)"><a href="./mainLib.tcl.html#::parseExecTimeFile_927">::parseExecTimeFile</a></a> $execTimeFileName]

        ;<span class="comment-line"># Generate testcase arrays of each run time (quick/pass/all)</span>
        set testsToRunQuick [calculateTestToRun &#34;quick&#34; $platform]
        array set tests_to_runQ $testsToRunQuick
        ;<span class="comment-line"># Calculate duration for this list type</span>
        set quickExecDuration [<a name="::calcExecTime(1)"><a href="./mainLib.tcl.html#::calcExecTime_883">::calcExecTime</a></a> \
                $formattedExecTimeFile \
                [<a name="::combineAndStripTestList(1)"><a href="./mainLib.tcl.html#::combineAndStripTestList_957">::combineAndStripTestList</a></a> tests_to_runQ] ]

        if {($listFile == &#34;pass&#34;) || ($listFile == &#34;all&#34;) } {
            set testsToRunPass [calculateTestToRun &#34;pass&#34; $platform]
            array set tests_to_runP $testsToRunPass
            ;<span class="comment-line"># Calculate duration for this list type</span>
            set passExecDuration [<a name="::calcExecTime(2)"><a href="./mainLib.tcl.html#::calcExecTime_883">::calcExecTime</a></a> \
                    $formattedExecTimeFile \
                    [<a name="::combineAndStripTestList(2)"><a href="./mainLib.tcl.html#::combineAndStripTestList_957">::combineAndStripTestList</a></a> tests_to_runP] ]
        }
        if {$listFile == &#34;all&#34;} {
            set testsToRunAll [calculateTestToRun &#34;all&#34; $platform]
            array set tests_to_runA $testsToRunAll
            ;<span class="comment-line"># Calculate duration for this list type</span>
            set allExecDuration [<a name="::calcExecTime(3)"><a href="./mainLib.tcl.html#::calcExecTime_883">::calcExecTime</a></a> \
                    $formattedExecTimeFile \
                    [<a name="::combineAndStripTestList(3)"><a href="./mainLib.tcl.html#::combineAndStripTestList_957">::combineAndStripTestList</a></a> tests_to_runA] ]
        }
        if {$listFile == &#34;dev&#34;} {
            set testsToRunAll [calculateTestToRun &#34;dev&#34; $platform]
            array set tests_to_runA $testsToRunAll
            ;<span class="comment-line"># Calculate duration for this list type</span>
            set allExecDuration [<a name="::calcExecTime(4)"><a href="./mainLib.tcl.html#::calcExecTime_883">::calcExecTime</a></a> \
                    $formattedExecTimeFile \
                    [<a name="::combineAndStripTestList(4)"><a href="./mainLib.tcl.html#::combineAndStripTestList_957">::combineAndStripTestList</a></a> tests_to_runA] ]
        }
    }

    set execSummaryFileName &#34;[get_result_dir { $randomIndex }]/$fileName&#34;
    set fdout [open  $execSummaryFileName &#34;w+&#34;]

    puts $fdout &#34;----- Execution Time Summary For $module -----&#34;
    puts $fdout &#34;   SETUP: $setupDur  \t([<a name="::formatSeconds(1)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $setupDur])&#34;
    puts $fdout &#34;CHK_CONN: $checkConnDur  \t([<a name="::formatSeconds(2)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $checkConnDur])&#34;
    puts $fdout &#34;   QUICK: $quickExecDuration  \t([<a name="::formatSeconds(3)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $quickExecDuration])&#34;
    puts $fdout &#34;    PASS: $passExecDuration  \t([<a name="::formatSeconds(4)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $passExecDuration])&#34;
    puts $fdout &#34;     ALL: $allExecDuration  \t([<a name="::formatSeconds(5)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $allExecDuration])&#34;
    puts $fdout &#34;\nTOTAL CURRENT RUN:  $totalTestDur  ([<a name="::formatSeconds(6)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $totalTestDur])&#34;

    return 1
}


<strong><a name="::save_incrementally_run_data_1577">proc <a href="mainLib.tcl-annot.html#::save_incrementally_run_data">::save_incrementally_run_data</a></a></strong><a name="::save_incrementally_run_data"></a> {{tc1 &#34;&#34;}} {

  global fd_res
  global sourceFile
  global tStartTime
  global testDuration
  global randomIndex

  <span class="comment-line"># save report incrementally</span>
  set tEndTime [clock seconds]
  set testDuration [expr $tEndTime-$tStartTime]

  result_debug &#34;\n\n*** Time for [file tail [pwd]] Regression test = $testDuration seconds&#34;
  result_debug &#34;***    ( [<a name="::formatSeconds(7)"><a href="./mainLib.tcl.html#::formatSeconds_1006">::formatSeconds</a></a> $testDuration] )\n\n&#34;

  ;<span class="comment-line"># Write all buffered data into result file.</span>
  if {$fd_res != &#34;&#34;} {
      catch {flush $fd_res} result
      if {$result != &#34;&#34;} { result_error &#34;$result&#34; }
  }
  save_test_report &#34;[get_result_dir { $randomIndex }]/report.exr&#34;
  gen_text_report &#34;[get_result_dir { $randomIndex }]/report.exr&#34; &#34;[get_result_dir { $randomIndex }]/report.txt&#34; &#34;[file tail [pwd]]&#34; $sourceFile $tc1
}


<strong><a name="::executeTestsToRun_1602">proc <a href="mainLib.tcl-annot.html#::executeTestsToRun">::executeTestsToRun</a></a></strong><a name="::executeTestsToRun"></a> {testsToRun} {
    global numDUT
    global connect
    global script
    global MAIN
    global debugStart
    global lastInit
    global origFailCount
    global failCount
    global TestsRemaining
    global DUTs_info
    global licenseList
    global license_to_run
    global currentTestIndex
    global initFile
    global EX_REPORT_DATA_1
    global TrafficGen
    global MGMT_REG
    global pID
    global FAILLOCK DEBUGFAILLOCK
    set MGMT_REG(currentConnectionType) console; <span class="comment-line">#init to console so mgmt vlan can be cfg'd</span>
    set MGMT_REG(forceConsole) 0; <span class="comment-line"># init variable</span>
    set lastInit &#34;NULL&#34;
    set TestsRemaining $testsToRun
    set returnFlag &#34;testCompleted&#34;
    set currentTestIndex 1
    set licenseCheck &#34;n&#34;

<span class="comment-line">#if {$TrafficGen != &#34;&#34;} {</span>
<span class="comment-line">#       set testsToRun [SeperateEptIxiaTestcases $testsToRun $TrafficGen]</span>
<span class="comment-line">#}</span>

    <span class="comment-line">#Open skip file to write skip test cases</span>
    if {[set fd_main_skip [open &#34;[get_result_dir]/skipTestsList.txt&#34; &#34;a&#34;]] == -1} {
           return fd_main_skip
    }


    if {[info exists license_to_run]} {
       set index &#34;null&#34;
       set licenseCheck &#34;y&#34;
       set dutLicense $DUTs_info(DUT1,license)
       set licenseLevel [lsearch $licenseList $dutLicense]
       set givenLicenseLvl [lsearch $licenseList [string tolower [array names license_to_run]]]
       set index [lindex $licenseList $givenLicenseLvl]
      if {$givenLicenseLvl&lt;=$licenseLevel} {
          set flag &#34;allow&#34;
      } elseif {$givenLicenseLvl&gt;$licenseLevel} {
          set flag &#34;deny&#34;
      }
      set outlist [<a name="::combineAndStripTestList(5)"><a href="./mainLib.tcl.html#::combineAndStripTestList_957">::combineAndStripTestList</a></a> license_to_run]
    }

    ;<span class="comment-line"># For backward compatibility with previous eval command</span>
    ;<span class="comment-line"># we need to handle array like eval did, rather than using foreach</span>
    set pID [pid]
    set tmpFileName &#34;Tmp/testsToRun_$pID&#34;
    set fdin_ttr [open  $tmpFileName &#34;w+&#34;]

    puts $fdin_ttr $testsToRun

    set fdin_execTime [open $MAIN(timeFile) &#34;RDWR APPEND CREAT&#34;]
    ;<span class="comment-line"># Dump tests to run, so we can see what we intended to run.</span>
    flush $fdin_execTime

    flush $fdin_ttr
    seek $fdin_ttr 0 start

    <span class="comment-line"># Check if this automation should be run using telnet</span>
    <span class="comment-line">#   If the global MGMT_REG(useTelnetGlobalFlag) flag is set to 1, check to</span>
    <span class="comment-line">#   see if the mgmt interface is configured.  If it is not</span>
    <span class="comment-line">#   configure it.  After successful mgmt interface configuration</span>
    <span class="comment-line">#   set the MGMT_REG(currentConnectionType) global to telnet</span>
    <span class="comment-line">#</span>
    <span class="comment-line">#   The MGMT_REG(useTelnetLocalFlag) is used to only enable only in this</span>
    <span class="comment-line">#     proc.  MGMT_REG(useTelnetGlobalFlag) is set in common.cfg</span>
    if {$MGMT_REG(useTelnetGlobalFlag) &amp;&amp; $MGMT_REG(telnetNeedsConfig)} {
        result_debug &#34;@@@\nUsing Telnet over Mgmt Regression Mode\nConfigure all DUT mgmt vlans if required\n@@@&#34;
        _ConfigMgmtNetworkAll
        set MGMT_REG(useTelnetLocalFlag) 1
        set MGMT_REG(currentConnectionType) &#34;telnet&#34;
    }

    while {[gets $fdin_ttr line] != -1} {
      if {[string trim $line] == &#34;&#34;} {
          continue;
      }
      if {[info exists MAIN(regression_id)] &amp;&amp; $MAIN(regression_id) &gt; 1} {
           global my_db mysqlIP
           CheckAndPauseRegression -regression_id $MAIN(regression_id) \
              -feature_directory $MAIN(feature_directory) -db $my_db -host $mysqlIP \
              -admin_email &#34;sqaauto@extremenetworks.com&#34; -regCfg $MAIN(cfg)
           if {[info exists MAIN(was_paused)] &amp;&amp; $MAIN(was_paused)} {
               <span class="comment-line">#Clean the test bed configs after pause</span>
               CleanTestBedCfgs;
               if {$lastInit != &#34;NULL&#34;} {
                   if [catch {eval $lastInit} oops] {
                       puts &#34;Rerun of init after pause hit an exception&#34;
                   }
               }
           }
      }
      <span class="comment-line"># Set the last init file</span>
      if [regexp -nocase &#34;init&#34; $line] {
         set lastInit &#34;$line&#34;
      }
          set EX_REPORT_DATA_1 &#34;&#34;
      <span class="comment-line"># Remove the current test from the list of tests remaining to be run</span>
      set TestsRemaining [ldelete &#34;$TestsRemaining&#34; &#34;[string trim $line]&#34;];
      ;<span class="comment-line"># Tag START time</span>
      set timeStart [clock seconds];

      <span class="comment-line"># Set the debugStart for multipleLevelDebug</span>
      set debugStart 1

      global skipTestsOnFailure
      if {[info exists skipTestsOnFailure]} {
         if {[lsearch $skipTestsOnFailure $line] &gt;= 0} {
            result_debug &#34;SKIPPED TEST : $line&#34;
            continue;
         }
      }

      <span class="comment-line"># ---- If license level and testcases are not matching skip the tc</span>

      set origFailCount $failCount

      if {[string length $line] &amp;&amp; $licenseCheck != &#34;n&#34;} {
      set tfound &#34;false&#34;
      foreach tcase $outlist {
         if {[regexp -nocase $tcase $line]} {
             set tfound &#34;true&#34;
             break
          }
      }

      if { $tfound == &#34;true&#34; } {
         if {$flag == &#34;allow&#34;} {
            result_debug &#34;Executing the test case $line as it matches with given license&#34;
      } else {
            result_debug &#34;Skipping the test case $line as its not matching with given license&#34;
            <span class="comment-line">#puts &#34;test case is $line in main.tcl&#34;</span>
            puts $fd_main_skip &#34;$line&#34;
            continue;
      }
      } else {
           result_debug &#34;$line is not in given in license file&#34;
      }
      }

      global currentTestNumber
      global enableSaveConfigPerTest
      global enableAbortTestCondition
      global gHeapTracingProcess
      set currentTestNumber $line
      <span class="comment-line"># -------------------------------------------------</span>
      <span class="comment-line"># Change  the xterm prompt</span>
      <span class="comment-line"># -------------------------------------------------</span>
      set MAIN(CURRENTTESTCASE) [<a name="::parseTestCaseFromLine(2)"><a href="./mainLib.tcl.html#::parseTestCaseFromLine_852">::parseTestCaseFromLine</a></a> $line]
      SetTerminalTitle
      UpdateTrackDBTxt &#34;executing case: $MAIN(feature_directory) $MAIN(CURRENTTESTCASE)&#34;;<span class="comment-line"># tracking db location</span>

      if {[regexp {(.*) *;.*} $currentTestNumber match match1]} {
           set tempCurrentTestNumber $match1
      } else {
           set tempCurrentTestNumber $currentTestNumber
      }
      set tempCurrentTestNumber [string trim $tempCurrentTestNumber]
      if { ([info exists enableSaveConfigPerTest] ) &amp;&amp; ([CompareRelease [GetVersion DUT${numDUT}] 12.1]&gt;=0 ) &amp;&amp; ($enableSaveConfigPerTest == &#34;yes&#34;) } {
      for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
       global DUT${i}_CONNECT
       global DUT${i}_IP
       Login [set DUT${i}_CONNECT]
        SendACmd &#34;save configuration as-script perTest_${tempCurrentTestNumber}&#34; NULL NULL false
      }
     }
      if [catch {eval $line} reason] {
         set debugStart 0
         global errorInfo
         puts &#34;errorInfo: $errorInfo&#34;
         puts &#34;****ERROR REASON: $reason&#34;
         <span class="comment-line"># If a user lock on fail has come in from the queueing system</span>
         if {[info exists FAILLOCK] &amp;&amp; $FAILLOCK==&#34;yes&#34; &amp;&amp; \
                [info exists DEBUGFAILLOCK] &amp;&amp; $DEBUGFAILLOCK &gt; 0} {
             fix_report_level
             report_start_test &#34;0.0 User Lock Failed to continue $currentTestNumber&#34;
             report_end_test fail
             puts &#34;save incremental run data&#34;
             <a name="::save_incrementally_run_data(1)"><a href="./mainLib.tcl.html#::save_incrementally_run_data_1577">::save_incrementally_run_data</a></a>
             puts &#34;@@\n@@\nFAILLOCK HIT\n@@\n@@&#34;;
             return testCompleted
         }
         ;<span class="comment-line"># Write report out</span>
         report_start_test &#34;Failed to continue $currentTestNumber test - Reason: &lt;$reason&gt;&#34;
         result_error &#34;Failed to continue - Reason: $reason\n&#34;
         result_debug &#34;errorInfo: $errorInfo&#34;
         report_end_test
         close_result_file
         fix_report_level
         ;<span class="comment-line"># trim whitespace</span>
         set line [string trim $line]
         if { ! [regexp -nocase &#34;invalid command name\ *\&#34;$line\&#34;&#34; $reason] } {
            ;<span class="comment-line"># Clean up DUTs in case testcase ended abruptly</span>
            ;<span class="comment-line"># But NOT for bad testcase name passed in.  Saves some unconf time</span>

            for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
                global DUT${i}_CONNECT
                global DUT${i}_SETUP
                set connect [set DUT${i}_CONNECT]
                set script [set DUT${i}_SETUP]
                lappend connectList $connect
                lappend scriptList $script
            }
            if { [RunSetupScript $connectList $scriptList] == &#34;REGROUTER_FAILED&#34; } {
                set returnFlag &#34;REGROUTER_FAILED&#34;
            }
            unset connectList
            unset scriptList
            for {set i 1} {$i &lt;= $numDUT} {incr i 1} {
                set DUTName [format %s%d DUT $i]
                global ${DUTName}_CONNECT
                Login [set ${DUTName}_CONNECT]
                SendACmd &#34;clear log st&#34;
                SendACmd &#34;disable clipa&#34;
                SendACmd &#34;disable idletime&#34;
                SendACmd &#34;disable edp ports all&#34;
                SendACmd &#34;con edp advertisement-interval 60 holddown-interval 180&#34;
                global DUTs_info bcmStackable bcmPlatform
                if {[regexp -nocase $bcmPlatform $DUTs_info(DUT${i},platform)]} {
                   SendACmd &#34;clear platform system-dump&#34;
                }
                if {[info exists DUTs_info(DUT${i},coreFileTarget)]} {
                    SendACmd &#34;configure debug core-dumps $DUTs_info(DUT${i},coreFileTarget)&#34;
                }
            }
            set MAIN(CURRENTTESTCASE) &#34;&#34;
            set DUTs_info(DUT1,BaseConfigLoaded) 0
            <span class="comment-line"># Execute the last init file</span>
            if [regexp -nocase &#34;init&#34; $line] {
               set lastInit &#34;NULL&#34;
            } else {
               set MAIN(CURRENTTESTCASE) $lastInit
               set reInit [catch {eval $lastInit} reason]
            }
            
         }
      } else {
          CLIConnectMode -action &#34;disable&#34;;<span class="comment-line"># if in testcase telnet mode go to console</span>
      set debugStart 0
      <span class="comment-line"># Checking reason for -1, in case init returns before full run</span>
      if {$reason==-1 || $reason == &#34;testSkipped&#34;} {
         if {$reason == &#34;testSkipped&#34;} {
           if {[set fd_main_skip [open &#34;[get_result_dir]/skipTestsList.txt&#34;\
                 &#34;w&#34;]] == -1} {
              return -1
           }
           puts $fd_main_skip &#34;FeatureSkipped&#34;
           close $fd_main_skip
                 set tc [<a name="::parseTestCaseFromLine(3)"><a href="./mainLib.tcl.html#::parseTestCaseFromLine_852">::parseTestCaseFromLine</a></a> $line]
          <a name="::save_incrementally_run_data(2)"><a href="./mainLib.tcl.html#::save_incrementally_run_data_1577">::save_incrementally_run_data</a></a> $tc
          if {$MGMT_REG(useTelnetGlobalFlag) &amp;&amp; $MGMT_REG(forceConsole) == 1} {
              set MGMT_REG(currentConnectionType) console
              set MGMT_REG(forceConsole) 0
              set MGMT_REG(telnetNeedsConfig) 1
          }
         }
         return $reason
      }
<span class="comment-line">#     dumpHeapTrace &#34;autotest-sc&#34; &#34;glitterpen1&#34;; #Commented to optimize runtime;</span>
     incr currentTestIndex
      set tc [<a name="::parseTestCaseFromLine(4)"><a href="./mainLib.tcl.html#::parseTestCaseFromLine_852">::parseTestCaseFromLine</a></a> $line]
      if {$tc != &#34;&#34;} {
         ;<span class="comment-line"># Log END time</span>
         set timeEnd [clock seconds];
        global duration
         set duration [expr $timeEnd - $timeStart]

         ;<span class="comment-line"># write to testcase and duration to execTime.txt</span>
         ;<span class="comment-line"># Write out duration to Execution Time File</span>
         ;<span class="comment-line"># Add testcase: and duration: for easier parsing</span>
         result_debug &#34;testcase:$tc\tduration:$duration&#34;

         puts $fdin_execTime &#34;testcase:$tc\tduration:$duration&#34;
         flush $fdin_execTime
      }
      set MAIN(CURRENTTESTCASE) &#34;&#34;
      }

   if { ([info exists enableAbortTestCondition] ) &amp;&amp; \
                 ($enableAbortTestCondition ==&#34;testFailure&#34;) &amp;&amp; \
                 ( $origFailCount !=$failCount ) } {
            exit
   }
        set tc [<a name="::parseTestCaseFromLine(5)"><a href="./mainLib.tcl.html#::parseTestCaseFromLine_852">::parseTestCaseFromLine</a></a> $line]
      <a name="::save_incrementally_run_data(3)"><a href="./mainLib.tcl.html#::save_incrementally_run_data_1577">::save_incrementally_run_data</a></a> $tc
   }


   close $fdin_ttr

   close $fdin_execTime

   close $fd_main_skip

   catch {file delete -force &#34;$tmpFileName&#34;} reason

   return $returnFlag
}

;<span class="comment-line"># Execute the CLI tests based on testsToRun</span>
<strong><a name="::executeCLITestsToRun_1912">proc <a href="mainLib.tcl-annot.html#::executeCLITestsToRun">::executeCLITestsToRun</a></a></strong><a name="::executeCLITestsToRun"></a> {testsToRun regPath testtorunNo} {

    global NEWBUILD
    global OLDBUILD
    global sourceFile

    set returnFlag &#34;testCompleted&#34;

    if [regexp -nocase &#34;uploadanddownload&#34; $regPath] {
        set func &#34;CLICheck&#34;
    } else {
        set func &#34;UpgradeCheck&#34;
    }
    if [catch {$func $testsToRun $testtorunNo $NEWBUILD $OLDBUILD} reason] {
        report_start_test &#34;(2) Failed to continue test - Reason: &lt;$reason&gt;&#34;;
        result_error &#34;(2) Failed to continue - Reason: $reason\n&#34;;
        report_end_test;
        set returnFlag &#34;testCrashed&#34;;
    } else {
        set returnFlag &#34;testCompleted&#34;;
        incr testtorunNo;
    }

    <a name="::save_incrementally_run_data(4)"><a href="./mainLib.tcl.html#::save_incrementally_run_data_1577">::save_incrementally_run_data</a></a> $testtorunNo

    return $returnFlag
}
<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line">#  proc _verifyModuleNameArg</span>
<span class="comment-line">#</span>
<span class="comment-line">#     **** N O T E   to be called only from the main dir ****</span>
<span class="comment-line">#     This proc maintains the original ability to match short, regex</span>
<span class="comment-line">#     directory names.</span>
<span class="comment-line">#</span>
<span class="comment-line">#  args : In - module value to be compared with</span>
<span class="comment-line">#        Out - matched module dirctory full path</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
<strong><a name="::_verifyModuleNameArg_1949">proc <a href="mainLib.tcl-annot.html#::_verifyModuleNameArg">::_verifyModuleNameArg</a></a></strong><a name="::_verifyModuleNameArg"></a> {regPath module} {
    global regressionModules

    if {[regexp -nocase &#34;CLItest&#34; $regPath] &amp;&amp; ![regexp -nocase &#34;CLItest&#34; $module]} {
        set curDir [pwd]
        cd &#34;../CLItest/cli-ew&#34;
        set modules [glob -- *]
        set cliModules &#34;&#34;
        foreach moduleName $modules {
            if {[file isdir $moduleName]} {
                lappend cliModules $moduleName
            }
        }
        puts &#34;cliModules: $cliModules&#34;
        puts &#34;module: $module&#34;
        set matchCli 0
        foreach cliModule [lsort $cliModules] {
            set match &#34;&#34;
            set str &#34;&#34;
            if {[regexp -nocase &#34;(^$module.*)&#34; $cliModule match str]} {
                set module $str
                cd &#34;$curDir&#34;
                if [catch {file mkdir &#34;$regPath/$module&#34;} reason] {
                    puts &#34;DEBUG: unable to create $regPath/$module directory: $reason&#34;
                }
                return &#34;$regPath/$module&#34;
            }
        }
        cd &#34;$curDir&#34;
    } else {
        set modules [glob -- $regPath/*]
        set regressionModules &#34;&#34;
        foreach moduleName $modules {
           if {[file isdir $moduleName]} {
              lappend regressionModules $moduleName
           }
        }

        foreach regressionModule [lsort $regressionModules] {
           set match &#34;&#34;
           set str &#34;&#34;
           if {[regexp &#34;(^$regPath/$module)&#34; $regressionModule match str]} {
              return $str;
              break
           }
        }
    }
    puts &#34;\n\n!!!!! ERROR $regPath $module does not match any module directories !!!!!&#34;
    exit;
}
<span class="comment-line">#########################################################################</span>
<span class="comment-line"># procName: _getTestBedNumNodes</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Just get return the number of nodes in a test bed and</span>
<span class="comment-line">#     set the MAIN(NODECOUNT)</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::_getTestBedNumNodes_2007">proc <a href="mainLib.tcl-annot.html#::_getTestBedNumNodes">::_getTestBedNumNodes</a></a></strong><a name="::_getTestBedNumNodes"></a> {} {
    global MAIN

    set n 0
    set MAIN(DUTLIST) &#34;&#34;
    for {set nDUT 1; global DUT${nDUT}_CONNECT} { [info exists DUT${nDUT}_CONNECT] } \
                                             {incr nDUT ; global DUT${nDUT}_CONNECT} {
        incr n
        lappend MAIN(DUTLIST) $nDUT
    }
    set MAIN(NODECOUNT) $n
    return $n
}
<span class="comment-line">#########################################################################</span>
<span class="comment-line"># Procedure: _getTestBedStandbyNodes</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Just get return the number of standby nodes</span>
<span class="comment-line">#      set MAIN(STDBYCOUNT) </span>
<span class="comment-line">#</span>
<span class="comment-line">######################################################################### </span>
<strong><a name="::_getTestBedStandbyNodes_2028">proc <a href="mainLib.tcl-annot.html#::_getTestBedStandbyNodes">::_getTestBedStandbyNodes</a></a></strong><a name="::_getTestBedStandbyNodes"></a> {} {
    global MAIN

    set n 0
    set MAIN(STDBYLIST) &#34;&#34;
    for {set nSBY 1; global STDBY${nSBY}_CONNECT} { [info exists STDBY${nSBY}_CONNECT] } \
                                             {incr nSBY ; global STDBY${nSBY}_CONNECT} {
        lappend MAIN(STDBYLIST) $nSBY
        <span class="comment-line"># Make dummy DUT#_CONNECT and DUT#_IP to trick whichDutNow code.</span>
        <span class="comment-line">#   Login adds 100 to the STDBY#</span>
        set me [expr 100 + $nSBY]
        global DUT${me}_CONNECT DUT${me}_IP STDBY${nSBY}_IP CFG_PLATFORM;
        set DUT${me}_CONNECT  [set STDBY${nSBY}_CONNECT]
        set DUT${me}_IP       [set STDBY${nSBY}_IP]
        set CFG_PLATFORM($me) &#34;&#34;
        incr n
    }
    set MAIN(STDBYCOUNT) $n
    return $n
}

<span class="comment-line">#########################################################################</span>
<span class="comment-line"># Procedure: _commentHandler</span>
<span class="comment-line">#</span>
<span class="comment-line"># Set MAIN comment global OR other globals based on special formats passed</span>
<span class="comment-line">#       in.</span>
<span class="comment-line">#</span>
<span class="comment-line">#    Aug 2017:   no_analyzer in the comment - ANALYZE(bypass) to 1</span>
<span class="comment-line">#                xtermtitle  in comment - MAIN(XTERMTITLEON) to 1</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::_commentHandler_2059">proc <a href="mainLib.tcl-annot.html#::_commentHandler">::_commentHandler</a></a></strong><a name="::_commentHandler"></a> {comment} {
    global MAIN ANALYZE

    if {[regexp -nocase &#34;no_analyz&#34; $comment]} {
        set ANALYZE(bypass) 1
    }
    if {[regexp -nocase &#34;xtermtitle&#34; $comment]} {
        set MAIN(XTERMTITLEON) 1
    }
    if {[regexp -nocase {regId:([0-9]+) } $comment a rid]} {
        set MAIN(regression_id) $rid
    }
    set MAIN(comment) $comment
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 13:36.</cite>
</div>

</body>
</html>
