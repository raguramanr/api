
# File support for Spirent stc API.

#puts auto_path\t$auto_path
#package require SpirentTestCenter

#set ::auto_path [linsert $::auto_path 0 . ]
################################################################################
# Init STC Lab Server Environment Vars
################################################################################
proc stcInit {labserver} {
   global env   
   logcmd set env(STC_SERVER_ADDRESS) $labserver
   logcmd set env(STC_SESSION_NAME) __NEW_TEST_SESSION__
   #set env(STC_SESSION_NAME) 
   logcmd set env(STC_SESSION_SYNCFILES_ON_SEQ_COMPLETE) 1
   logcmd set env(STC_SESSION_TERMINATE_ON_DISCONNECT) 1
   #set env(STC_SESSION_ADDRESS) 2
   set env(IXIA_VERSION) n/a
   # set some ixia global variables to get past some weird code
   set ::checkOldGenSlotInChassis 0
}



proc logcmd {args} {
   global _DEBUG _DEBUGFILE
   if {![info exists _DEBUG]} {set _DEBUG 2}
   if {$_DEBUG > 0} {
      if {![info exists _DEBUGFILE]} {
         set _DEBUGFILE [open debug.[clock format [clock seconds] -format %m%d%y%H%M].log w]
      }
      if {$_DEBUG == 3} {puts $_DEBUGFILE "\#\# [clock format [clock seconds] -format %T]"}
      if {[llength $args] == 1} {
         eval puts $_DEBUGFILE $args
      } else {
         puts $_DEBUGFILE $args
      }
      ### temp
      flush $_DEBUGFILE
   }
   if {[llength $args] == 1} {
      set err [catch {eval uplevel $args} retval]
   } else {
      set err [catch {uplevel $args} retval]
   }
   if {$err} {
      if {$_DEBUG > 0} {
         puts $_DEBUGFILE "\#ERROR: Could not execute command:\n\
                          \#   \"$args\"\n\
                          \#Exiting with error:\n\
                          \#   $retval"
         flush $_DEBUGFILE
      }
      error "ERROR: Could not execute command:\n   $args\nExiting with error:\n   $retval"
   }
   if {$_DEBUG > 1} {
      if {$retval != {} } {
         regsub -all {\n} $retval "\n\# " dbgtxt
         puts $_DEBUGFILE "\# $dbgtxt"
         puts $_DEBUGFILE ""
      }
   }
   return $retval
}

proc ReservePorts {} {
   global ahSpirentPort
   global SPIRENTCH1
   global cfg ixiaMappingList
   global STCMAIN STCPORT STCPORTID
    
   # Blanco Work
   # Reserve a few ports.
   # Physical topology
   
   # Create the root project objec
   set hProject [logcmd stc::create project]
   set STCMAIN(project) $hProject
   # Configure automation options.
   logcmd stc::config system1.AutomationOptions -LogLevel ERROR
   
   foreach portMap $ixiaMappingList {
       set portId [lindex $portMap 0]
       set card [lindex $portMap 1]
       set port [lindex $portMap 2]
       puts "Set stc port //$SPIRENTCH1/$card/$port"
       set ahSpirentPort($portId) [logcmd stc::create port -under $hProject \
              -location //$SPIRENTCH1/$card/$port]
       lappend lstPorts $ahSpirentPort($portId)
   }
   
   # Create ports
if {0} {
   if {[regexp "std" $cfg]} {
      set ahSpirentPort(1) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/1]
      set ahSpirentPort(2) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/2]
      set ahSpirentPort(3) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/3]
      set ahSpirentPort(4) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/4]
      set ahSpirentPort(5) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/5]
      set ahSpirentPort(6) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/6]
      set ahSpirentPort(7) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/7]
      set ahSpirentPort(8) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/8]
      set ahSpirentPort(9) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/9]
      set ahSpirentPort(10) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/10]
      set ahSpirentPort(11) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/11]
      set ahSpirentPort(12) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/1/12]
      set lstPorts {}
      
      foreach i {1 2 3 4 5 6 7 8 9 10 11 12} {
         lappend lstPorts $ahSpirentPort($i)
      }
   } else {
      puts "rtr 5 node config $cfg" 
      set ahSpirentPort(10) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/1]
      set ahSpirentPort(11) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/2]
      set ahSpirentPort(7) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/3]
      set ahSpirentPort(8) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/4]
      set ahSpirentPort(5) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/5]
      set ahSpirentPort(6) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/6]
      set ahSpirentPort(3) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/7]
      set ahSpirentPort(4) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/8]
      set ahSpirentPort(9) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/9]
      set ahSpirentPort(1) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/10]
      set ahSpirentPort(2) [logcmd stc::create port -under $hProject -location //$SPIRENTCH1/2/11]
      set lstPorts {}
      
      foreach i {1 2 3 4 5 6 7 8 9 10 11} {
         lappend lstPorts $ahSpirentPort($i)
      }
   }
}  

 
   # Attach ports. (One command takes care of three) 
   # Connect to a chassis, reserve ports, and create the mapping between the 
   #   physical ports and their logical representation in the test configuration.
   puts "[clock format [clock seconds] -format %m-%d-%Y%l:%M:%S%p] Attaching Ports ..."
   logcmd stc::perform attachPorts -portList $lstPorts -autoConnect TRUE
   
   # Subscribe to realtime results
   logcmd stc::subscribe -Parent $hProject -ConfigType Analyzer -resulttype AnalyzerPortResults
   logcmd stc::subscribe -Parent $hProject -ConfigType Generator -resulttype GeneratorPortResults

   foreach i [lsort -dictionary [array names ahSpirentPort]] {
       set phyList [getPhyObject $ahSpirentPort($i)]
       set STCPORTID($i,port) $ahSpirentPort($i)
       puts "phyList $phyList"
       set pLen [llength $phyList]
       #set myPhy [lindex $phyList [expr $pLen - 1]]
       set myPhy [lindex $phyList 0]
       set STCPORTID($i,speed) [string toupper [logcmd stc::get $myPhy -LineSpeedStatus]]
       set STCPORT($ahSpirentPort($i),speed) $STCPORTID($i,speed)
       puts "Got port speed $STCPORTID($i,speed)"      
   }

   # configure analyzers to NOT use signature filter
   foreach port $lstPorts {
      logcmd stc::config [logcmd stc::get $port -children-Analyzer] -FilterOnStreamId FALSE
   }

   # set phy mode fiber if needed
   if {[info exist ::phyMode]} {
      if {[llength [join $::phyMode { }]] == 1} {
         switch [string tolower $::phyMode] {
            copper {}
            fiber  {
               foreach port [lsort -dictionary [array names ahSpirentPort]] {
                  set FiberClient [logcmd stc::create "EthernetFiber" \
                                      -under $ahSpirentPort($port) \
                                      -LineSpeed $STCPORTID($port,speed) \
                                      -AutoNegotiation "TRUE" \
                                      -AutoNegotiationMasterSlave "MASTER" \
                                      -FlowControl "FALSE" \
                                      -DataPathMode "NORMAL" \
                                      -Mtu "1500" \
                                      -PortSetupMode "PORTCONFIG_ONLY" \
                                      -Active "TRUE" \
                                      -LocalActive "TRUE" \
                                      -Name "Fiber client $port" ]
                  logcmd stc::config $ahSpirentPort($port) -ActivePhy-targets $FiberClient                 
               }
            }
            default { error "Unexpected phyMode '$::phyMode' should be 'copper', 'fiber' or '<port> <mode> ...'"}
         }
      } else {
         set a 0
         foreach {port mode} [join $::phyMode { }] {
            switch [string tolower $mode] {
               a {}
               copper {}
               fiber  {
                  set FiberClient [logcmd stc::create "EthernetFiber" \
                                      -under $ahSpirentPort($port) \
                                      -LineSpeed $STCPORTID($port,speed) \
                                      -AutoNegotiation "TRUE" \
                                      -AutoNegotiationMasterSlave "MASTER" \
                                      -FlowControl "FALSE" \
                                      -DataPathMode "NORMAL" \
                                      -Mtu "1500" \
                                      -PortSetupMode "PORTCONFIG_ONLY" \
                                      -Active "TRUE" \
                                      -LocalActive "TRUE" \
                                      -Name "Fiber client $port" ]
                  logcmd stc::config $ahSpirentPort($port) -ActivePhy-targets $FiberClient                 
               }
               default { error "Unexpected phyMode '$::phyMode' should be 'copper', 'fiber' or '<port> <mode> ...'"}
            }
            incr a
         }
      }
   }
   logcmd stc::apply
}

proc hMapPortIdToSpirentPort {lstIxiaPortIds} {
   global ahSpirentPort
   
   set lsthPorts {}
   
   foreach iIxiaPortId $lstIxiaPortIds {
      if {[string is integer $iIxiaPortId]} {
         lappend lsthPorts $ahSpirentPort($iIxiaPortId)
      } else {
         lappend lsthPorts $iIxiaPortId
      }
   }
   
   return $lsthPorts
}

proc stcGetPortPhy {portId} {

    return [logcmd stc::get [hMapPortIdToSpirentPort $portId] -ActivePhy]

}

proc stcGetMedia {portId} {
    set phy [logcmd stc::get [hMapPortIdToSpirentPort $portId] -ActivePhy]
    if {[regexp -nocase "iber" $phy]} {
        return "FIBER"
    } elseif {[regexp -nocase "opper" $phy]} {
        return "COPPER"
    } else {
        return "DEFAULT"
    }
}

proc  nl_resetIxiaPort { {portId "1"} } {
    #Stop generator before making changes.
    set hand [hMapPortIdToSpirentPort $portId]
    set hGenerator [logcmd stc::get $hand -children-Generator]
    logcmd stc::perform GeneratorStop -GeneratorList $hGenerator
    # Delete all streamblocks on tx port
    deleteAllStreams $hand
    # Delete all devices on the port
    cleanupBgp $portId
    # clear all the stats
    ixClearStats $portId
}

proc setStreamAdvanceMode {{portId 1}} {
    puts "setStreamAdvanceMode $portId ignored on STC"
}
proc SaveToDatabase {} {
   logcmd stc::perform SaveToTccCommand -FileName config.tcc
}

################################################################## 
# Procedure Name: GetFrameContentsFromStreamblock
#   
# Description: Retrieve streamblock header information
#               
# Input args:
#              handle to a Spirent streamblock
#                                
# Output args: string contain header and attribute value pairs
#              
# Typical usage: 
##              
#
# Category: setup
##################################################################            
proc GetFrameContentsFromStreamblock {hStreamblock} {
   
   set szFrameContents ""
   
   # Retrieve headers from streamblock.
   foreach hChild [logcmd stc::get $hStreamblock -children] {
      GetObjectAttributes $hChild szFrameContents
   }
   
   return [string trimleft $szFrameContents \n]
}

proc GetObjectAttributes {hParent szFrameContentsName} {
   upvar $szFrameContentsName szFrameContents
   
   # Ignore the following objects.
   if {[regexp -nocase modifier|vntags $hParent]} { return }
   
   # Retrieve attribute/value pairs.
   set lstElements [logcmd stc::get $hParent]
   set szAttributes ""
   foreach {szAttribute szValue} $lstElements {
      if {![regexp -nocase -- -parent|-Active|-Name|-children $szAttribute]} {
         append szAttributes " $szAttribute $szValue"
      }
   }
   
   if {![string equal $szAttributes ""]} {
      append szFrameContents \n[lindex [split $hParent :] 0]: " $szAttributes"
   }
   
   # Retrieve children objects from parent.
   set lsthChildren [logcmd stc::get $hParent -children]
   
   foreach hChild $lsthChildren {
      GetObjectAttributes $hChild szFrameContents
   }
   return $szFrameContents
}

#proc MapIxiaPortId {portId chasName cardName portName} {
#  upvar $chasName chas
#  upvar $cardName card
#  upvar $portName port

#  set chas 1
#  set card 1
#  set port 1
#}
##################################################################    
# Procedure Name: stcCheckTxDone
# Description:
#     	 Check if trafficcneter transmission is done as expected no. of frames.
# Input args: {$txPortId} {targetTxNum}
# Output args: None
# Typical usage: 
#	ixiaCheckTxDone -txPortId 1
# Category: VerifyTraffic
##################################################################
proc ixiaCheckTxDone {txChasisId txCard txPort numFrames txPortId} {
   puts "[lindex [info level 0] 0] : $txChasisId $txCard $txPort $numFrames $txPortId"
   return [stcCheckTxDone -txPortId $txPortId]
}

proc stcCheckTxDone { args } {
   
   parse_args stcCheckTxDone $args {
      txPortId "1"
      maxWait "360"
   }
   
   
   set hGenerator [logcmd stc::get [hMapPortIdToSpirentPort $txPortId] -children-Generator]
   set genState [logcmd stc::get $hGenerator -State]
   
   set endtime [expr [clock seconds] + $maxWait]
   while {$genState != "STOPPED"} {
      result_debug "Waiting for STC Traffic to Complete.  Current State: $genState"
      exSleep 1
      set genState [logcmd stc::get $hGenerator -State]
      if {[clock seconds] >= $endtime} {
         result_error "The TestCenter port did not finish transmission in $maxWait seconds"
         stc::perform GeneratorStop -GeneratorList $hGenerator
         return
      }
   }
}

###############################################################################
# Procedure:   getIpV4MaskWidth
#
# Description: This proc gets ip mask as input and calculates the maskWidth.
#
# Arguments:   ip mask - ipV4 format.
#
# Returns      mask width.
###############################################################################
proc getIpV4MaskWidth2 {ipV4Mask} {
   scan $ipV4Mask "%d.%d.%d.%d" b1 b2 b3 b4
   
   set result  [expr ($b4 | $b3 << 8 | $b2 << 16 | $b1 << 24) ^ 0xFFFFFFFF]
   
   for {set mask  0} { $mask < 32} {incr mask} {
      if { [expr $result >> $mask] == 0} {
         break;
      }
   }
   set mask [expr 32 - $mask]
   
   return $mask
}
########################################################################
# Procedure: incrIpv6Field
#
# Description: Increments the specified byte of IPv6 address
#
#
# Argument(s):
#   ipAddress       IPv6 address whose byte to be incremented
#   byteNum         the byte field to be incremented
#   amount             increment the field by this number
#
########################################################################
proc incrIpv6Field {ipv6Address {byteNum 16} {amount 1}} {
   set ipv6Address [regsub :: $ipv6Address [string repeat ":0" [expr 8-[llength [split $ipv6Address :]]+1]]:]
   set byteIndex [expr round($byteNum/2.0) - 1]
   return [join [lreplace [split $ipv6Address :] $byteIndex $byteIndex [format %x [expr 0x[lindex [split $ipv6Address :] $byteIndex]+$amount]] ] :]
   
}

################################################################################
# Default MAC address based on portId
################################################################################
proc GetDefaultPortIdMAC {args} {
   
   array set arg $args
   
   switch -exact -- $arg(-portId) {
      "port1" - 
      "1" {
         return "00:A1:F1:00:00:01"
      }
      "port2" -
      "2" {
         return "00:A1:F2:00:00:01"
      }
      "port3" -
      "3" {
         return "00:A1:F3:00:00:01"
      }
      "port4" -
      "4" {
         return "00:A1:F4:00:00:01"
      }
      "port5" -
      "5" {
         return "00:A2:F1:00:00:01"
      }
      "port6" -
      "6" {
         return "00:A2:F2:00:00:01"
      }
      "port7" -
      "7" {
         return "00:A2:F3:00:00:01"
      }
      "port8" -
      "8" {
         return "00:A2:F4:00:00:01"
      }
      "port9" -
      "9" {
         return "00:A3:F1:00:00:01"
        }
      "port10" -
      "10" {
         return "00:A3:F2:00:00:01"
      }
      "port11" -
      "11" {
         return "00:A3:F3:00:00:01"
      }
      "port12" -
      "12" {
         return "00:A3:F4:00:00:01"
      }
      default { error "Could not get default MAC address for port \"$arg(-portId)\""}
   }
}

# from CheckArp.tcl
proc EnableProtocolServer {portIdList ipAddressList {taglist "none"} {pingEnable "false"} \
                          {gwIpList "0.0.0.0"} {nwrangelist "none"} {numAddr 1} {netMask 24} } {

   if {$nwrangelist == "none" } {
      if {[llength $portIdList] != [llength $ipAddressList]} {
         result_error "Number of list elements do not match."
         return 0
      }    
   }

   foreach portId $portIdList tag $taglist gwIp $gwIpList ipAddr $ipAddressList {
      if {$nwrangelist == "none" } {
         set tag $taglist 
      }
      if {$gwIp == ""} {set gwIp "$ipAddr"}       
      set devhandle [AddIpAddress $portId $ipAddr -tag $tag -netMask $netMask -gwIpAddr $gwIp]
      logcmd stc::config $devhandle -EnablePingResponse $pingEnable
   }
   logcmd stc::apply
   return 1 
}

proc DisableProtocolServer {portIdList ipAddressList} {
   foreach portId $portIdList ipAddress $ipAddressList {
      set devlist [logcmd stc::get [hMapPortIdToSpirentPort $portId] -affiliationport-Sources]
      foreach dev $devlist {
         set items [concat [logcmd stc::get $dev -children-ipv4if] [logcmd stc::get $dev -children-ipv6if]]
         puts $items
         set ipaddrs {}
         foreach item $items {lappend ipaddrs [logcmd stc::get $item -address]}
         puts $ipaddrs
         foreach ipaddr $ipaddrs {
            if {$ipaddr == $ipAddress} {
               logcmd stc::config $dev -active false
            }
         }
      }
   }
}

proc SaveAndSetProtocolServer {portId ipAddr gwIpAddr objName args} {
    puts "Don't save proto server on Spirent"
    return
}


proc RestoreProtocolServer {portIdList ipAddressList arpEnable {pingEnable ""}} {
   if {[llength $portIdList] != [llength $ipAddressList]} {
      result_error "Number of list elements do not match."
      return
   }
   foreach portId $portIdList ipAddress $ipAddressList {
      set devlist [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-router]
      foreach dev $devlist {
         set ipaddr [logcmd stc::get [logcmd stc::get $dev -children-ipv4if] -address]
         if {$ipaddr == $ipAddress} {
            logcmd stc::config $dev -active true
         }
      }
   }
}
  
# do not set protocol gateway in this proc so make it do nothing
proc SetGwIpAddr {portId gIpAddr args} {
   return
}

# return 1 because the Delte IP address code will determine if one needs to be deleted
proc GetIpAddress {portId ipAddr args} {
   return 1
}

# not used so do nothing
proc GetProtocolServerInfo {portId args} {
   return
}

# not used so do nothing
proc SetProtocolServerInfo {portId args} {
   return
}

# not used so do nothing
proc GetGwIpAddr {portId} {
   return n/a
}

proc getIxiaCardType {id} {
   return n/a
}

proc ixiaCapturedFramesTimeStamp {{ch 1} {cd 1} {pt 1} {fd_res "NULL"} {fd_in "NULL"}} {
   set portId $pt
   StopPortsCapture $portId
   set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-capture]
   set pktCount [logcmd stc::get $hCapture -PktCount]
   result_debug "pktCount $pktCount"
   set packetCaptureTimestamps {}
   for {set i 0} {$i < $pktCount} {incr i} {
      array set returnList [logcmd stc::perform CaptureGetFrameCommand -CaptureProxyId $hCapture -FrameIndex $i]
      lappend packetCaptureTimestamps $returnList(-Timestamp)
   }      
   return $packetCaptureTimestamps
}

proc ixiaConf_clearStat {{cardNo 1} {chid 1}} {
   # always assume we will clear stats on all ports
   logcmd stc::perform ResultClearAllTraffic -PortList [getPortList]
}

proc ixServer_read {channel} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}

proc SetupIxiaConnections {} { return }

proc ixDisconnectTclServer {{serverName ""}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixInitialize {serverName} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixConnectToTclServer {serverName} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixLogin {userName} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixLogout {} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixTakeOwnership {txRxList {takeType ""}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixPortTakeOwnership {chassis lm port {takeType ""}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return 0
}
proc ixClearOwnership {{txRxList "" } {takeType ""}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixPortClearOwnership {chassis lm port {takeType ""}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return 0
}
proc ixCheckOwnership {txRxList} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixConnectToChassis {chassisList {cableLength cable3feet}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixGetChassisID {chassisName} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return n/a
}
proc ixDisconnectFromChassis {args} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStartTransmit {PortList} {
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList [uplevel "set $PortList"]]]
   StartPortsTransmit $ports
#   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc startTx {PortList} {
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList [uplevel "set $PortList"]]]
   StartPortsTransmit $ports
#   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStartPortTransmit {chassis lm port} {
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList [uplevel "set $PortList"]]]
   StartPortsTransmit $ports
#   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStopTransmit {PortList} {
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList [uplevel "set $PortList"]]]
   StopPortsTransmit $ports
#   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStartCapture {PortList} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStopCapture {PortList} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStartPortCapture {chassis lm port} {
      result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc stopPortCapture {chassis lm port} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc startPortCapture {chassis lm port} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixStopPortCapture {chassis lm port {groupId 710} {create create} {destroy destroy}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixClearStats {PortList} {
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList "$PortList"]]
   logcmd stc::perform ResultClearAllTraffic -PortList $ports
   
   return
}
proc ixClearPortStats {chassis lm port} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc zeroPortStats {chassis lm port} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixSetPacketStreamMode {TxRxArray {write nowrite}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixSetPortPacketStreamMode {chassis lm port {write nowrite}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixWritePortsToHardware {PortArray args} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc writeConfigToHardware {PortArray args} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}

proc ixWriteConfigToHardware {PortArray args} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}

proc ixCheckTransmitDone {PortArray} {

   set maxWait 10

   set endtime [expr [clock seconds] + $maxWait]
   puts $PortArray
   puts [uplevel "set $PortArray"]
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList [uplevel "set $PortArray"]]]
   set generators {}
   foreach port $ports { 
      lappend generators [logcmd stc::get [hMapPortIdToSpirentPort $port] -children-Generator]
   }
   while {1} {
      if {[clock seconds] > $endtime} { break }
      set done 1
      foreach hGenerator $generators {
         if {[logcmd stc::get $hGenerator -State] != "STOPPED"} { set done 0 ; break }
      }
      if {$done == 1} { break }
   }
   stc::perform GeneratorStop -GeneratorList $generators
   #  result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}

proc ixCheckPortTransmitDone {chassis lm port} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixCheckLinkState {PortArray {message messageOn}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixRequestStats {TxRxArray} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixEnableArpResponse { mapType PortMap } {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixEnablePortArpResponse { mapType chassis lm port {write write}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixDisableArpResponse { PortMap } {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixTransmitArpRequest {TxRxArray} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixDisablePortArpResponse {chassis lm port {write write}} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixTransmitPortArpRequest {chassis lm port} {
   result_debug "[lindex [info level 0] 0] : Not Supported by Spirent TestCenter"
   return
}
proc ixiaStartCaptureCards {{numIxiaCd 1} {startCardNum 1} {chid 1}} {
   StartPortsCapture [getPortList] 
}
proc ixiaStopCaptureCards {{numIxiaCd 1} {startCardNum 1} {chid 1}} {
  StopPortsCapture [getPortList] 
}
proc ixiaStopTxCards {{numIxiaCd 1} {startCardNum 1} {chid 1}} {
   StartPortsTransmit [getPortList]
}
proc ixTransmitIgmpJoin {PortList} {
   set notsure [getPortsFromChassCardPortList [uplevel "set $PortList"]]
   set ports [hMapPortIdToSpirentPort [getPortsFromChassCardPortList [uplevel "set $PortList"]]]
   puts [uplevel "set $PortList"]
   puts "NOTSURE:  $ports"
   puts "PORTS:    $ports"
   startIgmp $ports
}

proc StartPortsCapture {portIdList} {
   # Enable capture on each of the ports.
   foreach iPortId $portIdList {
      # Get the capture object. (Automatically created)
      if {[string is integer $iPortId]} {set iPortId [hMapPortIdToSpirentPort $iPortId]}
      set hCapture [logcmd stc::get $iPortId -children-capture]
      
      # check to see if capture is already running if so, do nothing
      if {[logcmd stc::get $hCapture -CaptureState] == "RUNNING"} { 
         puts "CAPTURE ALREADY RUNNING"
         continue 
      }

      # Configure capture options.
      logcmd stc::config $hCapture -mode REGULAR_MODE -srcMode TX_RX_MODE
      
      # Start capturing on the port.
      logcmd stc::perform CaptureStart -captureProxyId $hCapture
   }
}

proc StopPortsCapture {portIdList} {
   # Enable capture on each of the ports.
   foreach iPortId $portIdList {
      # Get the capture object. (Automatically created)
      if {[string is integer $iPortId]} {set iPortId [hMapPortIdToSpirentPort $iPortId]}
      set hCapture [logcmd stc::get $iPortId -children-capture]
      
      # Stop capturing on the port.
      logcmd stc::perform CaptureStop -captureProxyId $hCapture
      set TIMESTAMP [clock format [clock seconds] -format %m%d%y%H%M]
      logcmd stc::perform CaptureDataSave -captureProxyId $hCapture -FileName "/tmp/capture-$TIMESTAMP.pcap" -FileNameFormat PCAP
      
   }
}

proc GetCapturedFrames {portId {fd_res "NULL"} {packThreshold 200} {retCount 0}} {
   # Get the capture object.
   StopPortsCapture $portId
   set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-capture]
   set pktCount [logcmd stc::get $hCapture -PktCount]
   result_debug "pktCount $pktCount"
   if {$pktCount > $packThreshold} {
      set pktCount $retCount
      if {$retCount == 0} {
         result_debug "High number of packets ($pktCount) captured. \
                    Return without getting any packets"
         return
      }
   }

   set packetCaptureData {}
   for {set i 0} {$i < $pktCount} {incr i} {
      array set returnList [logcmd stc::perform CaptureGetFrameCommand -CaptureProxyId $hCapture -FrameIndex $i]
      # handle werid capture when in 10mbs mode, for some reason the preamble is 2 bytes shorter
      if {[string match 5555555555D5* $returnList(-PacketData)]} {
         set szFrameContents [string range $returnList(-PacketData) 12 end]
      } else {
         set szFrameContents [string range $returnList(-PacketData) 16 end]
      }
      #set szFrameContents [string range $returnList(-PacketData) 0 end]
      set szFrameContents [scan $szFrameContents  [string repeat "%2s" [expr [string length $szFrameContents]/2]]]
      lappend packetCaptureData $szFrameContents
   }
   return $packetCaptureData   
}

proc GetCapturedFramesTimeStampIndexed {indexes portId} {
   StopPortsCapture $portId
   set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-capture]
   set packetCaptureTimestamps {}
   foreach i $indexes {
      array set returnList [logcmd stc::perform CaptureGetFrameCommand -CaptureProxyId $hCapture -FrameIndex $i]
      lappend packetCaptureTimestamps [expr round($returnList(-RawTimestamp)/ 400000000.0)]
      puts "REAL TIMESTAMP : $returnList(-Timestamp)"
   }      
   return $packetCaptureTimestamps
}

proc StartPortsTransmit {portIdList} {
   set idList {}
   foreach iPortId $portIdList {
      # Retrieve the generator object for the port.
      if {[string is integer $iPortId]} {set iPortId [hMapPortIdToSpirentPort $iPortId]}
      lappend idList [logcmd stc::get $iPortId -children-Generator]
   }
   # Start the generator.
   logcmd stc::perform GeneratorStart -GeneratorList $idList

   # Can't use this since rate tests are calculated after this call. There would be no rates
   #       if the traffic had completed.
   # Wait for traffic to stop.  Maximum wait time is 300 seconds.
   #  stc::perform GeneratorWaitForStop -GeneratorList $hGenerator -WaitTimeout 300
}

proc StopPortsTransmit {portIdList} {
   set idList {}
   foreach iPortId $portIdList {
   # Retrieve the generator object for the port.
      if {[string is integer $iPortId]} {set iPortId [hMapPortIdToSpirentPort $iPortId]}
      lappend idList [logcmd stc::get $iPortId -children-Generator]
   }
   # Start the generator.
   logcmd stc::perform GeneratorStop -GeneratorList $idList

   # Can't use this since rate tests are calculated after this call. There would be no rates
   #       if the traffic had completed.
   # Wait for traffic to stop.  Maximum wait time is 300 seconds.
   #  stc::perform GeneratorWaitForStop -GeneratorList $hGenerator -WaitTimeout 300
}

############################################################################################
# Ixia library commands to be overwritten
############################################################################################

#
# sample usage
#   stat getRate statAllStats $chasisId $card $port
#   set rateSent [stat cget -bytesSent]
#
proc port {cmd args} {
   switch [string tolower $cmd] {
      get {  set ::_stc_portId [lindex $args 2] ;# puts "FOUND PORT ID $::_stc_portId from $args" }
      getrate {
         # get port from argument (this is the port "id", no need to translate)
         # set port to global as target
         set ::_stc_ccp $args
         set ::_stc_portId [lindex $args 3]
         return 0
      }
      cget {
         foreach arg [string tolower $args] {
            switch $arg {
               -macaddress { return [uniqMac [lindex $::_stc_ccp 0] [lindex $::_stc_ccp 1] [lindex $::_stc_ccp 2]] }
               -speed { 
                    switch [string toupper [logcmd stc::get [getPhyObject [hMapPortIdToSpirentPort $::_stc_portId]] -LineSpeedStatus]] {
                        SPEED_10M   { return 10 }
                        SPEED_100M  { return 100 }
                        SPEED_1G    { return 1000 }
                        SPEED_2500M { return 2500 }
                        SPEED_5G    { return 5000 }
                        SPEED_10G   { return 10000 }
                        SPEED_25G   { return 25000 }
                        SPEED_40G   { return 40000 }
                        SPEED_25G   { return 25000 }
                        SPEED_50G   { return 50000 }
                        SPEED_100G  { return 100000 }
                        default     { return 1000 }
                    }
               }
               -linkstate {
                  set state [string tolower [logcmd stc::get [getPhyObject $::_stc_portId] -LinkStatus]]
                  if {$state == "up"} {return 1} else {return 0}
               }
               default { error "STC does not support Port cget $arg" }
            }
         }
      }  
   }
}
proc stat {cmd args} {
   
   switch [string tolower $cmd] {
      get -
      getrate {
         # get port from argument (this is the port "id", no need to translate)
         # set port to global as target
         set ::_stc_portId [lindex $args 3]
      }
      cget {
         switch [set item [lindex $args 0]] {
            -bytesSent {
               return [logcmd stc::get $::_stc_portId.Generator.GeneratorPortResults -GeneratorOctetCount]
            }
            -bytesReceived {
               return [logcmd stc::get $::_stc_portId.Analyzer.AnalyzerPortResults -TotalOctetCount]
            }
            -framesSent {
               return [logcmd stc::get $::_stc_portId.Generator.GeneratorPortResults -GeneratorFrameCount]
               error "stat \"$item\" not supported BUT needs to be"
            }
            -framesReceived {
               return [logcmd stc::get $::_stc_portId.Analyzer.AnalyzerPortResults -TotalFrameCount]
            }
            -bitsReceived {
               return [expr wide([logcmd stc::get $::_stc_portId.Analyzer.AnalyzerPortResults -TotalOctetCount]*8)]
            }
            -oversize {
               error "stat \"$item\" not supported BUT needs to be"
            }
            -vlanTaggedFramesRx {
               error "stat \"$item\" not supported BUT needs to be"
            }
            -rxArpRequest {
               error "stat \"$item\" not supported BUT needs to be"
            }
            -userDefinedStat1 {
               if {[set filtres [logcmd stc::get [set ana [logcmd stc::get $::_stc_portId -children-Analyzer]]\
                                    -children-FilteredStreamResults]] == {}} {
                  logcmd stc::subscribe -parent project1 -resulttype FilteredStreamResults -configType Analyzer \
                     -viewAttributeList FrameRate -resultParent $::_stc_portId -interval 1
                  set ana [logcmd stc::get $::_stc_portId -children-Analyzer]
                  set timeout [expr [clock seconds] + 5]
                  while {[set filtres [logcmd stc::get $ana -children-FilteredStreamResults]] == {}} {
                     after 1000
                     if {$timeout < [clock seconds]} { 
                        return [logcmd stc::get $::_stc_portId.Analyzer.AnalyzerPortResults -TotalFrameRate] 
                     }
                  }
               }
               set timeout [expr [clock seconds] + 10]
               while {[set darate [logcmd stc::get $filtres -FrameRate]] == 0} {
                  after 1000
                  if {$timeout < [clock seconds]} { return $darate }
               }
               return $darate
               # return [logcmd stc::get $::_stc_portId.Analyzer.AnalyzerPortResults -TotalFrameRate]
            }
            -rxPingReply {
               error "stat \"$item\" not supported BUT needs to be"
            }
            -counterVal {
               error "stat \"$item\" not supported BUT needs to be"
            }
            -ixTclProtocolVersion {
               return n/a
            }
            default { error "stat \"$item\" not supported"}
         }
      }
   }
}

proc version {cmd args} {

   switch [string tolower $cmd] {
      get {}
      cget {
         switch [lindex $args 0] {
            -productVersion { return n/a }
         }
      }
   }
}

proc map {args} { return }
proc protocol {args} { return }
proc ipV6 {args} { return }
proc stream {args} { return }
proc captureBuffer {args} { return }
proc mldServer {args} { return }

proc ixStopPortTransmit {chas card port} {

    StopPortsTransmit $port
}

proc MapIxiaPortId {  {portId 1}
                      {chasisIdName  1}
                      {cardName  1}
                      {portName  1} } {

   upvar $chasisIdName chasisId $cardName card $portName port
   set port [hMapPortIdToSpirentPort $portId]
   set loc [split [logcmd stc::get $port -Location] /]
   set chasisId [lindex [split [lindex $loc 2] .] end]
   set card [lindex $loc 3]

   return $port
}

proc GetNumIxiaCd {{totalPorts 0}} {
   return n/a
}


##################################################################
# Procedure Name: ixiaConf_2Ports_Dhcp
# Description:
#       Set up an ixia port to send DHCP packets based on given
#       opCode and optionCodeList parameters
# Input args: args
# Output args: none
# Typical usage:
#       set frameSent [ixiaConf_2Ports_Dhcp -numIxiaCd $numIxiaCd \
#              -txChas $chasisId -txCard $card -txPort $port -startCardNum $startCardNum \
#              -rxChas $chasisId -rxCard $card -rxPort $rxPo \
#              -sMacAddr $sourceMac -dMacAddr $destMac \
#              -numFrames $numFrames -streamType $streamType -fcsError $fcsError \
#              -saMode $saMode -daMode $daMode -opCode $opCode \
#              -optionCodeList $optionCodeList -clientHwAddr $clientHwAddr ]
# Category: SendTraffic
##################################################################
proc ixiaConf_2Ports_Dhcp {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args ixiaConf_2Ports_Dhcp $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "n/a"
      txCard "n/a"
      txPort "port1"
      rxChas "n/a"
      rxCard "n/a"
      rxPort "port2"
      sMacAddr "00 00 86 52 55 CB"
      dMacAddr "ff ff ff ff ff ff"
      sIpAddr "0.0.0.0"
      dIpAddr "255.255.255.255"
      srcPort "68"
      dstPort "67"
      numFrames "1"
      dataPattern "0000"
      streamType "stopStream"
      fcsError "good"
      saMode "idle"
      daMode "idle"
      chid "1"
      clientHwAddr "00 00 86 52 55 CB"
      clientIpAddr "0.0.0.0"
      yourIpAddr "0.0.0.0"
      opCode "dhcpBootRequest"
      optionCodeList "{dhcpMessageType dhcpDiscover}"
      dontTx "0"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
   }

   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
   
   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   set time1 [clock seconds]
   
   set streamType       stopStream
   set patternOffset    32
   set macBroadcast     {ff ff ff ff ff ff}
   set preambleSize     8

   # Config streams for validation traffic
   set wkTag $wTag
   set wkTagNo $tagNo
   set portNo 0
   set portList {}
   set counter 0
   set txPorts {}
   lappend portList $txPort $rxPort
   if {$direction == "2Way"} {lappend portList $rxPort $txPort}

   foreach {txPort rxPort} $portList {
      set dataoffset 0
      set pktoffsets {}
      if { $wkTag == "true" } {
         set wTag "true"
         set tagNo [lindex $wkTagNo $portNo]
         incr portNo
         if { $tagNo == "" } {set tagNo [lindex $wkTagNo 0]}
         if { $tagNo == 0 || $tagNo == "none" } {set wTag "false"}
         result_debug "wTag = $wTag, tagNo = $tagNo"
      }

      #Stop generator before making changes.
      logcmd stc::perform GeneratorStop -GeneratorList $txPort
      
      # Delete all streamblocks on tx port
      deleteAllStreams $txPort
      
      # initialize streamblock arguments
      set stream_args {-insertSig FALSE -frameconfig {}}

      # $fcsError
      if {$fcsError == "good"} {
         lappend stream_args -EnableFcsErrorInsertion false
      } else {
         lappend stream_args -EnableFcsErrorInsertion true
      }
      # Create basic stream
      lappend stream_args -frameLengthMode AUTO -EqualRxPortDistribution "FALSE"
      set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
      
      set eth_args {}
      
      # get mac addresses
      set srcAddr  [GetDefaultPortIdMAC -portId $txPort]
      set destAddr [GetDefaultPortIdMAC -portId $rxPort]
      if { $sMacAddr == "default" } {
         lappend eth_args -srcMac [set sMacAddr $srcAddr]
      } else {
         lappend eth_args -srcMac [join $sMacAddr :]
      }
      lappend eth_args -dstMac [join $dMacAddr :]

      logcmd stc::get $hStreamBlock
      
      # Ether stuff
      lappend eth_args -etherType 0800
      set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                        -name sb1_eth $eth_args]
      incr dataoffset 14 ; lappend pktoffsets sb1_eth $dataoffset
      set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag $wTag -tagNo $tagNo -tagCfi $tagCfi\
                      -tagMode $tagMode -tagRepeat $tagRepeat -protocolTagId null]
      if {$vlanlen > 0} {incr dataoffset $vlanlen  ; lappend pktoffsets sb1_vlans $dataoffset}
      
      set hIpv4 [logcmd stc::create ipv4:IPv4 -under $hStreamBlock -name sb1_ip \
                    -sourceAddr $sIpAddr -destAddr $dIpAddr -ttl 1 -identification 0]
      
      logcmd stc::config $hIpv4 -protocol 17
 #      set hUdp [logcmd stc::create udp:Udp -under $hStreamBlock -name sb_udp\
 #         -destPort $dstPort -sourcePort $srcPort -checksum 0x7fff]
      set hUdp [logcmd stc::create udp:Udp -under $hStreamBlock -name sb_udp\
                   -destPort 67 -sourcePort 68]
      incr dataoffset 8
      set hDhcp [logcmd stc::create dhcp:Dhcpclientmsg -under $hStreamBlock -name sb_dhcp\
                    -clientAddr $clientIpAddr -clientMac [join $clientHwAddr :]\
                    -elapsed 7680 -haddrLen 6 -hardwareType 1 \
                    -hops 0 -messageType [getDhcpOpCode $opCode]\
                    -xid 1 -yourAddr $yourIpAddr -xid 1266680334]
      set hOpt [logcmd stc::create options -under $hDhcp]
      set idx 0
      foreach {opt val} $optionCodeList {
         set hDhcpOpt [logcmd stc::create DHCPOption -under $hOpt]
         switch -glob [string tolower $opt] {
            *messagetype* {
               set opt_$idx [logcmd stc::create messageType -under $hDhcpOpt -code [getDhcpOpCode $val]]
            }
            *clientid* {
               set opt_$idx [logcmd stc::create clientIdHW -under $hDhcpOpt -idtype [lindex $val 0]\
                                -clientHWA [join [lrange $val 1 end] :] -optionLength [format %02x [llength $val]]]
            }
            *requestedipaddr* {
               set opt_$idx [logcmd stc::create reqAddr -under $hDhcpOpt -reqAddr $val]
            }
            *svridentifier* {
               set opt_$idx [logcmd stc::create serverId -under $hDhcpOpt -reqAddr $val]
            }
            *hostname* {
               binary scan $val H* hexval
               set len [format %02x [string length $val]]
               set opt_$idx [logcmd stc::create hostName -under $hDhcpOpt -value $hexval -length $len]
            }
            *paramrequest* {
               set len [format %02x [expr [string length [join $val {}]]/2]]
               set opt_$idx [logcmd stc::create paramReqList -under $hDhcpOpt -value [join $val {}] -length $len]
            }
            default {error "Unsupported DHCP Option Type $opt=$val"}
         }
         incr idx
      }
      set hDhcpOpt [logcmd stc::create DHCPOption -under $hOpt]
      logcmd stc::create endOfOptions -under $hDhcpOpt
      logcmd stc::get $hStreamBlock
#       for {set i 0} {$i < $idx} {incr i} {
#          logcmd stc::get [subst $[subst opt_$idx]]
#       }

      set gen_args {}
      lappend gen_args -loadunit PERCENT_LINE_RATE -FixedLoad 50
      lappend gen_args -DurationMode BURSTS -BurstSize $numFrames -duration 1
      set hGeneratorConfig [eval logcmd stc::config $txPort.Generator.GeneratorConfig $gen_args]
      stc::apply
   }
   logcmd stc::apply

   logcmd stc::perform ResultClearAllTraffic -PortList "$txPort $rxPort"
   if {$dontTx==0} {
      StartPortsTransmit $txPort
   }
   if {[string tolower $streamType] != "contpacket" && $dontTx==0} {
      stcCheckTxDone -txPortId $txPort
   }
   if {$dontTx==0} {
      return [getFrameContents $hStreamBlock arp]
   } else {
      return ""
   }

}

proc getDhcpOpCode {string} {
   switch -glob [string tolower $string] {
      *boot*     -
      *discover* { return 1 }
      *offer*    { return 2 }
      *request*  { return 3 }
      *decline*  { return 4 }
      *ack*      { return 5 }
      *neg*      { return 6 }
      *release*  { return 7 }
      *info*     { return 8 }
      default { error "Could not translate DHCP message type '$string'" }
   }
}


################################################################## 
# Procedure Name: ixiaConf_2Ports_ip   
# Description: 
#	Set up an ixia port to send IP packets (tcp/udp/icmp/igmp)		     
# Input args: args
# Output args: none
# Typical usage: 
#	 set frameSent [ixiaConf_2Ports_ip -numIxiaCd $numIxiaCd \
#             -txChas $chasisId -txCard $card -txPort $port -startCardNum $startCardNum \
#             -rxChas $ch -rxCard $c -rxPort $rxPort \
#             -ipProtocol $protocol -sMacAddr $sourceMac -dMacAddr $destMac \
#             -sIpAddr $sourceIp -dIpAddr $destIp -dDutIpAddr $gatewayIp -ttl $ttl \
#             -pSrcPort $sourcePort -pDstPort $destPort \
#             -frameSizeType $frameSizeType -frameSizeMIN $frameSizeMIN  -frameSizeMAX $frameSizeMAX \
#	      -goodChecksum $goodChecksum -numFrames $numFrames -frameSize $frameSize \
#	      -frameRate $frameRate -dataPattern $dataPattern -streamType $streamType \
#	      -fcsError $fcsError -wTag $wTag -tagNo $tag -TOS $TOS -userPriority $userPriority \
#	      -percentage $percentage -priority $priority -ipOptions $ipOptions -direction $direction \
#             -saMode $saMode -daMode $daMode -ipSaMode $ipSaMode -ipDaMode $ipDaMode -dIpMask $dIpMask sIpMask $sIpMask \
#             -dontFrag $dontFrag -tcpSeqNum $tcpSeqNum -tcpSynFlag $tcpSynFlag -tcpFinFlag $tcpFinFlag \
#             -tcpRstFlag $tcpRstFlag -tcpAckFlag $tcpAckFlag -sequence $sequence -type $type -code $code \
#             -id $id -applyFilter $applyFilter -maxResponseTime $maxResponseTime -groupAddr $groupAddr \
#             -udfEnable $udfEnable -udfInitval $udfInitval -udfOffset $udfOffset -udfCountertype $udfCountertype ]   
# Category: SendTraffic
##################################################################
proc ixiaConf_2Ports_ip {args} {
   puts "[lindex [info level 0] 0] : $args"

   
   parse_args ixiaConf_2Ports_ip $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "n/a"
      txCard "n/a"
      txPort "port1"
      rxChas "n/a"
      rxCard "n/a"
      rxPort "port2"
      ipProtocol "ip"
      pSrcPort "00"
      pDstPort "00"
      sMacAddr "default"
      dMacAddr "00 e0 2b 00 00 01"
      sIpAddr "127.0.0.1"
      dIpAddr "127.0.0.1"
      dDutIpAddr "127.0.0.1"
      sIpMask "255.255.255.0"
      dIpMask "255.255.255.0"
      sClass "classC"
      dClass "classC"
      ttl "64"
      goodChecksum "true"
      ipOptions ""
      ipTotalLength "20"
      TOS "default"
      numFrames "1"
      frameSize "64"
      frameSizeType "sizeFixed"
      frameSizeMAX "1518"
      frameSizeMIN "64"
      frameRate "default"
      dataPattern "0000"
      frameType "08 00"
      streamType "stopStream"
      fcsError "good"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
      protocolTagId "null"
      userPriority "0"
      applyFilter "0"
      percentage "100"
      priority "0"
      sendArp "false"
      numArpFrames "2"
      saMode "idle"
      daMode "idle"
      saCount ""
      daCount ""
      ipSaMode "ipIdle"
      ipDaMode "ipIdle"
      ipSaCount ""
      ipDaCount ""
      dontFrag "true" 
      lastFrag "true"
      fragmentOffset "0"
      tcpSynFlag "false"
      tcpFinFlag "false"
      tcpRstFlag "false"
      tcpAckFlag "false"
      tcpPushFlag "false"
      tcpUrgFlag "false"
      tcpSeqNum "000000000"
      type "8"
      code "0"
      id "0"
      sequence "0"
      maxResponseTime "100"
      igmpMode "Fixed"
      igmpRepeatCount ""
      groupAddr "224.0.0.1"
      chid "1"
      ipApplication "ip"
      ripCommand "ripRequest"
      ripVersion "2"
      ripAuthen ""
      ripAuthenType "2"
      ripNumRoute "1"
      ripRouteFamilyId {2}
      ripRouteIp {0.0.0.0}
      ripRouteTag {00}
      ripRouteMask {0.0.0.0} 
      ripRouteNextHop {0.0.0.0}
      ripRouteMetric {16}
      udfEnable "false"
      udfInitval "00"
      udfOffset "0"
      udfCountertype "c8"
      udfContinuousCount "false"
      protoOffsetEnable "false"
      protoOffset "14"
      userDefTag ""
      clearStats "yes"
      dontTx "0"
      lengthOverride ""
   }

   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
   set ipoffset 14
   set dataoffset 0
   set disableContents 0

   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   #result_debug "\n*** date=$date"
   set time1 [clock seconds]
   
   set enableUDF4DVMRP 0
   # a hack to set dvmrp message
   if {$ipProtocol == "dvmrp" } { 
      set ipProtocol "ip"
      set enableUDF4DVMRP 1
   }
   
   set enablepimdm 0
   if {$ipProtocol == "pim-dm" } { 
      set ipProtocol "ip"
      set enablepimdm 1
   }
   
   set patternOffset          30    ;# offset1 for filterPallette pattern1
   set macBroadcast           {FF FF FF FF FF FF}
   set preambleSize           8


   if { $sendArp == "true" } {
      set numLearnFrames 2
   }

   # Config streams for validation traffic
   set counter 0
   set chid $txChas
   set c $txCard
   set p $txPort
#   set txSpeed 100
   set txSpeed [getPortSpeed $txPort]
           
   #Stop generator before making changes.
   logcmd stc::perform GeneratorStop -GeneratorList $txPort
   
   # Delete all streamblocks on tx port
   deleteAllStreams $txPort
   
   
   # initialize streamblock arguments
   set stream_args {-insertSig FALSE -EqualRxPortDistribution FALSE -EnableHighSpeedResultAnalysis FALSE}
   
   # $fcsError
   if {$fcsError == "good"} {
      lappend stream_args -EnableFcsErrorInsertion false
   } else {
      lappend stream_args -EnableFcsErrorInsertion true
   }

   # Pattern work : $dataPattern (ixia has "nonRepeat" .. not sure what that means)
   if {[string length $dataPattern] <= 4} {
      lappend stream_args -ConstantFillPattern 0x$dataPattern -frameconfig {}
   } else {
      lappend stream_args -ConstantFillPattern 0 -frameconfig {}
   }

   # Create basic stream
   set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
   
   # Create Ethernet part of stream
   # $sMacAddr
   set eth_args {}
   if {$sMacAddr == "default"} {
      set sMacAddr [GetDefaultPortIdMAC -portId $txPort]
   }
   lappend eth_args -srcMac [join $sMacAddr :]

   # $dMacAddr
   lappend eth_args -dstMac [join $dMacAddr :]

   # $frameType
   lappend eth_args -etherType [join $frameType {}]

   set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                     -name sb1_eth $eth_args]
   incr dataoffset 14
   
   # handle other various UDFs
   if {$udfEnable == "true"} {
      if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
      foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
         if {[set place [expr $udfOffs - $dataoffset]] < 0} {
            switch $place {
               -2 {
                  # ethernet type 
                  set hRangeModifer1 [logcmd stc::create RangeModifier \
                                         -under $hStreamBlock \
                                         -ModifierMode INCR \
                                         -Mask ffff \
                                         -StepValue 1 \
                                         -Data [join $initVal {}] \
                                         -RecycleCount $recycleCount \
                                         -RepeatCount 0 \
                                         -DataType NATIVE \
                                         -EnableStream false \
                                         -OffsetReference "sb1_eth.etherType"]
               }
            }
            foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
         }
      }
   }

   modifyMacAddrs -stream $hStreamBlock -saMode $saMode -daMode $daMode -saCount $saCount \
      -daCount $daCount -sMacAddr $sMacAddr -dMacAddr $dMacAddr -numFrames $numFrames


   # Kludge to get the first mac address      
   if {[llength $dMacAddr]>2} {
      set dMacAdd $dMacAddr
   } else {
      set dMacAdd [lindex $dMacAddr $counter]
   }
   
   if {$counter==0} {
      if {[llength $dMacAddr]>2} {set dMacAddToFilter $dMacAddr} else {set dMacAddToFilter [lindex $dMacAddr 1]}
   } else {
      set dMacAddToFilter [lindex $dMacAddr 0]
   }
   
   set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag $wTag -tagNo $tagNo -tagCfi $tagCfi \
                   -tagMode $tagMode -tagRepeat $tagRepeat -protocolTagId $protocolTagId -tagPriority $userPriority \
                   -protoOffsetEnable $protoOffsetEnable -userDefTag $userDefTag]
   incr dataoffset $vlanlen
   incr ipoffset $vlanlen


   set hIpv4 [logcmd stc::create ipv4:IPv4 -under $hStreamBlock -name sb1_ip \
                 -sourceAddr $sIpAddr -destAddr $dIpAddr -ttl $ttl -identification 0]
   incr dataoffset 20
   
   set disableContents [modifyIpAddrs -stream $hStreamBlock -sIpAddr $sIpAddr -dIpAddr $dIpAddr -ipSaMode $ipSaMode\
                           -ipDaMode $ipDaMode -ipSaCount $ipSaCount -ipDaCount $ipDaCount -numFrames $numFrames]

   # disable IP ID field auto increment
   set hRangeModifier [logcmd stc::create RangeModifier \
                          -under $hStreamBlock \
                          -ModifierMode INCR \
                          -Mask 65535 \
                          -StepValue "1" \
                          -Data 0 \
                          -RecycleCount 65535 \
                          -DataType NATIVE \
                          -EnableStream false \
                          -RepeatCount 0 \
                          -OffsetReference "sb1_ip.identification"]
   
   if {$goodChecksum == "false"} { 
      logcmd stc::config $hIpv4 -checksum 65535
   }
   
   if {$TOS == "default"} { set TOS 0}
   set hTosDiffserv [logcmd stc::create tosDiffserv -under $hIpv4]
   
   set hTOS [logcmd stc::create tos -under $hTosDiffserv -precedence [expr ($TOS & 0xE0) >> 5] \
                -dBit [expr ($TOS & 0x10) >> 4] \
                -tBit [expr ($TOS & 0x8) >> 3] \
                -rBit [expr ($TOS & 0x4) >> 2] \
                -mBit [expr ($TOS & 0x2) >> 1]]

   # Offset 12 is assumed to be always etherType field of the IP header
   if {[string length $ipOptions] > 0} {
      # Set the ip header length - 
      set ipOptions [getAdjustedOptions $ipOptions]
      puts "IP OPTIONS $ipOptions"
      set len [expr 5+([string length $ipOptions]/8)]
      logcmd stc::config $hIpv4 -ihl $len
      set chksum [getIPv4Checksum -ilh $len -optionstr [join $ipOptions {}] -length [expr $frameSize - $ipoffset - 4] \
                     -sourceAddr $sIpAddr -destAddr $dIpAddr -ttl $ttl -tos $TOS -protocol [getIpProtocol $ipProtocol]]
      puts [format %04x $chksum]
      logcmd stc::config $hIpv4 -checksum [expr $chksum + 0]

      set options [logcmd stc::create custom:Custom -under $hStreamBlock -pattern [join $ipOptions {}]]
      incr dataoffset [expr [string length [join $ipOptions {}]]/2]
   }
   
   if {$ipTotalLength != "default" & $lengthOverride != "" } {
       logcmd stc::config $hIpv4 -destPrefixLength $ipTotalLength
   }
   set ipdataoffset $dataoffset

   puts "$udfOffset $udfInitval $udfCountertype"
   #kludge get frame contents fails if the udf are in there
   # doing UDF offset for IP here not under the switch statement below
   if {$udfEnable == "true"} {
      if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
      if {[llength $udfOffset] == 1} {set udfInitval [join $udfInitval {}]}
      foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
         set place [expr $udfOffs - $ipdataoffset]
         if {$place >= -20 & $place < 0} {
   puts "$udfOffset $udfInitval $udfCountertype"
            set disableContents 1
            modifyOtherIPFields $hStreamBlock $hIpv4 $initVal $place $counterType $numFrames
            foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
         }
      }
   }

   # Note: setting IPV4 protocol explicitly just incase there are are ipOptions (using custom header)
   switch [string tolower $ipProtocol] {
      "tcp"  {         
         logcmd stc::config $hIpv4 -protocol 6
         foreach var {tcpSynFlag tcpFinFlag tcpRstFlag tcpAckFlag tcpPushFlag tcpUrgFlag} {
            switch [subst $[subst $var]] {
               1 -
               true  { set $var 1 }
               0 -
               false { set $var 0 }
               default { error "Unacceptable value for $var = '[subst $[subst $var]]'"}
            }
         }
         set hTcp [eval logcmd stc::create tcp:Tcp -under $hStreamBlock -name tcp\
                      -destPort [expr $pDstPort+0] -sourcePort [expr $pSrcPort+0]\
                      -seqNum $tcpSeqNum -synBit $tcpSynFlag -finBit $tcpFinFlag\
                      -rstBit $tcpRstFlag -ackBit $tcpAckFlag -pshBit $tcpPushFlag -urgBit $tcpUrgFlag\
                      -checksum 0]
         incr dataoffset 20
      }
      "udp" {
         if {$ipApplication != "rip"} {
            logcmd stc::config $hIpv4 -protocol 17
            set hUdp [logcmd stc::create udp:Udp -under $hStreamBlock -name sb_udp\
                         -destPort [expr $pDstPort+0] -sourcePort [expr $pSrcPort+0] -checksum 0]
            incr dataoffset 8
            # check if s/d port are being incremented via udf
            if {$udfEnable == "true"} {
               if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
               foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
                  set place [expr $udfOffs - $dataoffset]
                  if {$place >= -8 & $place < 0} {
                     switch $place {
                        -8 {
                           # do source ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 0xffff \
                                                  -StepValue 1 \
                                                  -Data [expr [string trimleft $initVal 0]+0] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb_udp.sourcePort"]
                        }
                        -6 {
                           # do dest ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 0xFFFF\
                                                  -StepValue 1 \
                                                  -Data [expr [string trimleft $initVal 0]+0] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb_udp.destAddr"]
                        }
                        default { # error "Unsupported UDF in IP address of L2 packet offset = $place"
                     }
                     }
                     foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
                  }
               }
            }
         }
      }
      "ip" {
         logcmd stc::config $hIpv4 -protocol 255
      }
      "58" -
      "icmp" {
         logcmd stc::config $hIpv4 -protocol 1
         set hUdp [logcmd stc::create icmp:IcmpEchoRequest -under $hStreamBlock -name icmp\
                      -code $code -type $type -identifier $id -seqNum $sequence]
         incr dataoffset 10
         if {$udfEnable == "true"} {
            if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
            foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
               set place [expr $udfOffs - $dataoffset]
               if {$place >= -8 & $place < 0} {
                  switch $place {
                     -8 {
                        # checksum
                        set hRangeModifer1 [logcmd stc::create RangeModifier \
                                               -under $hStreamBlock \
                                               -ModifierMode INCR \
                                               -Mask 0xffff \
                                               -StepValue 1 \
                                               -Data [expr [string trimleft $initVal 0]+0] \
                                               -RecycleCount $recycleCount \
                                               -RepeatCount 0 \
                                               -DataType NATIVE \
                                               -EnableStream false \
                                               -OffsetReference "icmp.checksum"]
                     }
                     default { error "unsupported icmp offset for udf" }
                  }
                  foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
                  set disableContents 1
               }
            }
         }
       }
      "igmp" {
         logcmd stc::config $hIpv4 -protocol 2
         switch -exact -- [format %i $type] {
            "17" -
            "18" {
               # IGMPv1 Report
               set hIgmp [logcmd stc::create igmp:Igmpv1 -under $hStreamBlock -groupAddress $groupAddr -type [format %02x $type] -name sb_igmp]
               incr dataoffset 8
               foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
                  if {[set place [expr $udfOffs - $dataoffset]] < 0} {
                     puts "IGMPv1 UDFs : place $place offset $udfOffs init $initVal type $counterType"
                     switch $place {
                        -8 {
                           logcmd stc::config $hIgmp -type 0x[lindex $initVal 0] -unused 0x[lindex $initVal 1]
                        }
                     }
                     foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
                  }
               }
            }
            "22" -
            "23" {
               # IGMPv2 Report
               set igmpchecksum [getIGMPv2Checksum -type $type -groupAddress $groupAddr -maxreaptime $maxResponseTime]
               set hIgmp [logcmd stc::create igmp:Igmpv2 -under $hStreamBlock -groupAddress $groupAddr \
                             -maxRespTime $maxResponseTime -type [format %02x $type] -name sb_igmp]
               incr dataoffset 8
            }
            "34" {
               # IGMPv3 Report
               set hIgmp [logcmd stc::create igmp:Igmpv3Report -under $hStreamBlock -numGrpRecords 1 -type [format %02x $type] -name sb_igmp]
               set grpRecordsObj [logcmd stc::create grpRecords -under $hIgmp]
               set grpRecord [logcmd stc::create GroupRecord -under $grpRecordsObj -mcastAddr $groupAddr -recordType 1]
               set srcListGroup [logcmd stc::create addrList -under $grpRecord -name sourceList]
               set src(1) [logcmd stc::create Ipv4Addr -under $srcListGroup -name addr1 -value 0.0.0.0]
               incr dataoffset 20
               foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
                  if {[set place [expr $udfOffs - $dataoffset]] < 0} {
                     puts "IGMPv3 UDFs : place $place offset $udfOffs init $initVal type $counterType"
                     switch $place {
                        -20 {
                           logcmd stc::config $hIgmp -type 0x$initVal
                        }
                        -13 {
                           logcmd stc::config $grpRecord -recordType 0x[lindex $initVal 1] -auxDataLen 0x[lindex $initVal 2]\
                              -numSource 0x[lindex $initVal 3][lindex $initVal 2]
                        }
                        -9 {
                           logcmd stc::config $grpRecord -numSource 0x[lindex $initVal 0]
                           logcmd stc::config $grpRecord -mcastAddr [int2ip 0x[join [lrange $initVal 1 end] {}]00]
                        }
                        -5 {
                           set temp [logcmd stc::get $grpRecord -mcastAddr]
                           logcmd stc::config $grpRecord -mcastAddr [int2ip [expr [ip2int $temp] + 0x[lindex $initVal 0]]]
                           logcmd stc::config $src(1) -value [int2ip 0x[join [lrange $initVal 1 end] {}]00]
                        }
                        -1 {
                           set temp [logcmd stc::get $src(1) -value]
                           logcmd stc::config $src(1) -value [int2ip [expr [ip2int $temp] + 0x[lindex $initVal 0]]]
                        }
                     }
                     foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
                  }
               }
            }
            default { error "IGMP type of $type not supported" }
         }
         if {$igmpMode != "Fixed"} {
            if {$igmpRepeatCount == {}} {set igmpRepeatCount $numFrames}
            set hRangeModifer1 [logcmd stc::create RangeModifier \
                                   -under $hStreamBlock \
                                   -ModifierMode INCR \
                                   -Mask 255.255.255.255 \
                                   -StepValue 0.0.0.1 \
                                   -Data $groupAddr \
                                   -RecycleCount $igmpRepeatCount \
                                   -RepeatCount 0 \
                                   -DataType NATIVE \
                                   -EnableStream false \
                                   -OffsetReference "sb_igmp.groupAddress"]
            set hRangeModifer1 [logcmd stc::create RangeModifier \
                                   -under $hStreamBlock \
                                   -ModifierMode DECR \
                                   -Mask 0xffff \
                                   -StepValue 1 \
                                   -Data $igmpchecksum \
                                   -RecycleCount $igmpRepeatCount \
                                   -RepeatCount 0 \
                                   -DataType NATIVE \
                                   -EnableStream false \
                                   -OffsetReference "sb_igmp.checksum"]
         }
      }
      default {
         if {[string is integer $ipProtocol]} {
            logcmd stc::config $hIpv4 -protocol $ipProtocol
         } else {
            error "Unsupported ipProtocol = $ipProtocol"
         }
      }
   }
   

   if  { $ipApplication == "rip" } {
      logcmd stc::config $hIpv4 -protocol 17
      set riphdr [logcmd stc::create custom:Custom -under $hStreamBlock -name sb_rip \
                     -pattern [set riphex [makeRipHeader -ripCommand $ripCommand \
                                  -ripVersion $ripVersion -ripAuthen $ripAuthen \
                                  -ripNumRoute $ripNumRoute -ripRouteFamilyId $ripRouteFamilyId \
                                  -ripRouteIp $ripRouteIp -ripRouteTag $ripRouteTag \
                                  -ripRouteMask $ripRouteMask -ripRouteNextHop $ripRouteNextHop \
                                  -ripRouteMetric $ripRouteMetric -destPort [expr $pDstPort+0] \
                                              -sourcePort [expr $pSrcPort+0] -checksum 0]]]
      
      incr dataoffset [expr [string length $riphex]/2]
      set ipProtocol rip
   }

   if { $enableUDF4DVMRP } {
      logcmd stc::config $hIpv4 -protocol 2
   }
   
   if {$enablepimdm} {
      logcmd stc::config $hIpv4 -protocol 67
   }
   
   if {$udfEnable == "true"} {
      set inter 0
      foreach udfOffs $udfOffset {
         if {$udfOffs != 12} {
            continue
         }
         logcmd stc::config $hEthernet -etherType [join [lindex $udfInitval $inter] ""]
         
      }	
   }
   
   # adjust packet size
   # Size work : frameSizeType frameSizeMAX frameSizeMIN frameSize
   switch [string tolower $frameSizeType] {
      "sizerandom" {
         set stream_args [list -FixedFrameLength "64" -frameLengthMode RANDOM -maxFrameLength $frameSizeMAX\
                             -MinFrameLength [adjustStcPacketSize $frameSizeMIN $dataoffset]]
      }
      "sizefixed" {
         puts "FRAME : $frameSize -- OFFSET : $dataoffset  CALC : [adjustStcPacketSize $frameSize $dataoffset]"
         set stream_args [list -frameLengthMode FIXED -FixedFrameLength [adjustStcPacketSize $frameSize $dataoffset]]
      }
      default { error "Unsupported frameSizeType = $frameSizeType" }
   }
   eval logcmd stc::config $hStreamBlock $stream_args

   if {[string length $dataPattern] > 4} {
      set patternlen [expr $frameSize - $dataoffset - 5]
      set streampattern [createFillStr $dataPattern $patternlen]
      set fill [logcmd stc::create custom:Custom -under $hStreamBlock -pattern $streampattern]
   }
   
   if {$udfEnable == "true" & [llength $udfOffset] > 0} {
      set udflen [InsertUDFs $hStreamBlock $dataoffset $dataPattern $udfOffset $udfInitval $udfCountertype $numFrames $streamType]
      incr dataoffset $udflen
   }

   # configure generator
   configGen $txPort $streamType $frameSize $frameRate $percentage $txSpeed $numFrames
   
   stc::apply
   if {$clearStats == "yes" } {
      logcmd stc::perform ResultClearAllTraffic -PortList "$txPort $rxPort"
   }
  
   if {$dontTx==0} {
       StartPortsTransmit $txPort
   }
   if {![string match cont* $streamType] && $dontTx==0} {
      stcCheckTxDone -txPortId $txPort
   }

   if {($dontTx==0 & $disableContents==0) } {
      return [getFrameContents $hStreamBlock $ipProtocol $ipoffset]
   } else {
      return ""
   }
}


# Procedure Name: ixiaConf_2Ports_ipv6
# Description:
#       Set up an ixia port to send IP packets (tcp/udp/icmpv6)
# Input args: args
# Output args: none
# Typical usage:
#        set frameSent [ixiaConf_2Ports_ipv6 -numIxiaCd $numIxiaCd \
#               -txChas $chasisId -txCard $card -txPort $port          \
#               -startCardNum $startCardNum -rxChas $ch -rxCard $c  \
#               -rxPort $rxPort -ipProtocol $protocol -sMacAddr $sourceMac \
#               -dMacAddr $destMac -sIpAddr $sourceIp -dIpAddr $destIp  \
#               -pSrcPort $sourcePort -pDstPort $destPort  \
#               -frameSizeType $frameSizeType -nHeader $nHeader \
#               -goodChecksum $goodChecksum -numFrames $numFrames \
#               -frameSize $frameSize -frameRate $frameRate        \
#               -dataPattern $dataPattern -streamType $streamType \
#               -fcsError $fcsError -wTag $wTag -tagNo $tag  \
#               -userPriority $userPriority -percentage $percentage  \
#               -priority $priority  -direction $direction -saMode $saMode  \
#               -daMode $daMode -ipSaMode $ipSaMode -ipDaMode $ipDaMode  \
#               -tcpSeqNum $tcpSeqNum -tcpSynFlag $tcpSynFlag             \
#               -tcpFinFlag $tcpFinFlag  -tcpRstFlag $tcpRstFlag  \
#               -tcpAckFlag $tcpAckFlag -sequence $sequence \
#               -type $type -code $code -id $id -applyFilter $applyFilter  \
#               -maxResponseTime $maxResponseTime -groupAddr $groupAddr \
#               -udfEnable $udfEnable -udfInitval $udfInitval -udfOffset $udfOffset \
#               -udfCountertype $udfCountertype ]
# Category: SendTraffic
##################################################################

proc ixiaConf_2Ports_ipv6 {args} {
   puts "[lindex [info level 0] 0] : $args"
   
   parse_args ixiaConf_2Ports_ipv6 $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "n/a"
      txCard "n/a"
      txPort "port1"
      rxChas "n/a"
      rxCard "1"
      rxPort "2"
      ipProtocol "ipV6"
      nHeader "tcp"
      pSrcPort "0"
      pDstPort "0"
      sMacAddr "default"
      dMacAddr "00 e0 2b 00 00 01"
      sIpAddr "3555:5555:6666:6666:7777:7777:8888:8888"
      dIpAddr "FE80:0:0:0:201:3FF:FE00:100"
      dDutIpAddr "default"
      sIpMask "ffff:ffff:ffff:ffff:0000:0000:0000:0000"
      dIpMask "ffff:ffff:ffff:ffff:0000:0000:0000:0000"
      trafficClass "3"
      flowLabel "0"
      hopLimit "255"
      numFrames "1"
      frameSize "128"
      frameSizeType "sizeFixed"
      frameRate "default"
      dataPattern "0000"
      frameType "86 DD"
      streamType "stopStream"
      fcsError "good"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
      userPriority "0"
      applyFilter "0"
      percentage "100"
      priority "0"
      saMode "idle"
      daMode "idle"
      saCount ""
      daCount ""
      ipSaMode "ipV6Idle"
      ipDaMode "ipV6Idle"
      ipSaCount ""
      ipDaCount ""
      tcpSynFlag "false"
      tcpFinFlag "false"
      tcpRstFlag "false"
      tcpAckFlag "false"
      tcpPushFlag "false"
      tcpUrgFlag "false"
      tcpSeqNum "0"
      type "8"
      code "0"
      id "0"
      sequence "0"
      maxResponseTime "100"
      chid "1"
      udfEnable "false"
      udfInitval "00"
      udfOffset "0"
      udfCountertype "c8"
      udfContinuousCount "false"
      udfUpdown "uuuu"
      udfRepeat "1"
      udfStep "1"
      clearStats "yes"
      dontTx "0"
      invalidUdpChk "0"
   }
   
   global spawn_id
   global one2oneArray
   global preambleSize
   set ipoffset 14
   set dataoffset 0
   set disableContents 0
   
   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   result_debug "\n*** date=$date"
   set time1 [clock seconds]
   
   set enableUDF4DVMRP 0
   if {$ipProtocol == "dvmrp" } {
      set ipProtocol "ipV6"
      set enableUDF4DVMRP 1
   }
   
   set enablepimdm 0
   if {$ipProtocol == "pim-dm" } {
      set ipProtocol "ipV6"
      set enablepimdm 1
   }
   
   set macBroadcast     {ff ff ff ff ff ff}
   set patternOffset		30
   set preambleSize		8
   
   # Config streams for validation traffic
   
   set ipoffset 14
   set counter 0
   set dataoffset 0
   set portList {}
   set txPorts  {}
   set dataPattern [join $dataPattern {}]

   lappend portList $txPort $rxPort
   if {$direction == "2Way"} {lappend portList $rxPort $txPort}
   
   foreach {txPort rxPort} $portList {
      logcmd stc::perform GeneratorStop -GeneratorList $txPort
      
      # Delete all streamblocks on tx port
      deleteAllStreams $txPort
      
      # initialize streamblock arguments
      set stream_args {-insertSig FALSE}
      
      # Size work : frameSizeType frameSizeMAX frameSizeMIN frameSize
      switch [string tolower $frameSizeType] {
         "sizerandom" {
            lappend stream_args -FixedFrameLength "128" -frameLengthMode RANDOM -maxFrameLength 1500 \
               -MinFrameLength 128 -EnableHighSpeedResultAnalysis "FALSE" -EqualRxPortDistribution "FALSE"
         }
         "sizefixed" {
            lappend stream_args -frameLengthMode FIXED -FixedFrameLength $frameSize -EqualRxPortDistribution "FALSE"
         }
         default { error "Unsupported frameSizeType = $frameSizeType"
         }
      }
      
      set txSpeed [getPortSpeed $txPort]
      
      # $fcsError
      if {$fcsError == "good"} {
         lappend stream_args -EnableFcsErrorInsertion false
      } else {
         lappend stream_args -EnableFcsErrorInsertion true
      }
      
      
      # Pattern work : $dataPattern (ixia has "nonRepeat" .. not sure what that means)
      if {[string length $dataPattern] <= 4} {
         lappend stream_args -ConstantFillPattern 0x$dataPattern -frameconfig {}
      } else {
         lappend stream_args -ConstantFillPattern 0 -frameconfig {}
      }
    
      # Create basic stream
      set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
      
      set eth_args {}
      if {$sMacAddr == "default"} {
         lappend eth_args -srcMac [join [GetDefaultPortIdMAC -portId $txPort] :]
      } else {
         lappend eth_args -srcMac [join $sMacAddr :]
      }
      
      # $dMacAddr
      if {$dMacAddr == "default"} {
         lappend eth_args -dstMac [join [GetDefaultPortIdMAC -portId $rxPort] :]
      } else {
         lappend eth_args -dstMac [join [lindex $dMacAddr $counter] :]
      }
      
      # $frameType
      lappend eth_args -etherType [join $frameType {}]
      
      set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                        -name sb1_eth $eth_args]
      incr dataoffset 14
      
      modifyMacAddrs -stream $hStreamBlock -saMode $saMode -daMode $daMode -saCount $saCount \
          -daCount $daCount -sMacAddr $sMacAddr -dMacAddr $dMacAddr -numFrames $numFrames
      
      
      # Kludge to get the first mac address DON'T think this is necessary
      if {[llength $dMacAddr]>2} {
         set dMacAdd $dMacAddr
      } else {
         set dMacAdd [lindex $dMacAddr $counter]
      }
      
      if {$counter==0} {
         if {[llength $dMacAddr]>2} {set dMacAddToFilter $dMacAddr} else {set dMacAddToFilter [lindex $dMacAddr 1]}
      } else {
         set dMacAddToFilter [lindex $dMacAddr 0]
      }
      
      set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag [lindex $wTag $counter]\
                      -tagNo [lindex $tagNo $counter] -tagCfi $tagCfi\
                      -tagMode $tagMode -tagRepeat $tagRepeat -tagPriority $userPriority]
      incr dataoffset $vlanlen
      incr ipoffset $vlanlen
      if {$counter == 0} {
         set sip [lindex [split $sIpAddr /] 0] ;  set dip [lindex [split $dIpAddr /] 0]
      } else {
         set sip [lindex [split $dIpAddr /] 0] ;  set dip [lindex [split $sIpAddr /] 0]
      }
      
      

      set hIpv6 [logcmd stc::create ipv6:IPv6 -under $hStreamBlock -name sb1_ip \
                    -trafficClass $trafficClass -flowLabel $flowLabel \
                    -sourceAddr $sip -destAddr $dip -hopLimit $hopLimit\
                    -nextHeader [getIpv6NextHeaderValue $nHeader]]
      incr dataoffset 40
      
      if {![string match -nocase *idle* $ipSaMode]} {
         set disableContents 1
         switch -glob [string tolower $ipSaMode] {
            *inc* { set mode INCR }
            *dec* { set mode DECR }
            default { set mode INCR }
         }
         if {$ipSaCount == {}} {set ipSaCount $numFrames}
         # Use modifier to generate multiple streams.
         result_debug "\nCreating Modifier on Stream Block"
         set hRangeModifer1 [logcmd stc::create RangeModifier \
                                -under $hStreamBlock \
                                -ModifierMode $mode \
                                -Mask ::FFFF:FFFF \
                                -StepValue ::1 \
                                -Data $sIpAddr \
                                -RecycleCount $ipSaCount \
                                -RepeatCount 0 \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "sb1_ip.sourceAddr"]
      }
      
      if {![string match -nocase *idle* $ipDaMode]} {
         set disableContents 1
         switch -glob [string tolower $ipDaMode] {
            *inc* { set mode INCR }
            *dec* { set mode DECR }
            default { set mode INCR }
         }
         if {$ipDaCount == {}} {set ipDaCount $numFrames}     
         # Use modifier to generate multiple streams.
         result_debug "\nCreating Modifier on Stream Block"
         set hRangeModifer1 [logcmd stc::create RangeModifier \
                                -under $hStreamBlock \
                                -ModifierMode $mode \
                                -Mask ::FFFF:FFFF \
                                -StepValue ::1 \
                                -Data $dIpAddr \
                                -RecycleCount $ipDaCount \
                                -RepeatCount 0 \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "sb1_ip.destAddr"]
      }
      
      if {$udfEnable == "true"} {
         if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
         foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
            if {[set place [expr $udfOffs - $dataoffset]] < 0} {
puts "PLACE : $place"
               switch $place {
                  -34 {
                     # do next header
                     set hRangeModifer1 [logcmd stc::create RangeModifier \
                                            -under $hStreamBlock \
                                            -ModifierMode INCR \
                                            -Mask 0xFF \
                                            -StepValue 1 \
                                            -Data 0x[join $initVal {}] \
                                            -RecycleCount $recycleCount \
                                            -RepeatCount 0 \
                                            -DataType NATIVE \
                                            -EnableStream false \
                                            -OffsetReference "sb1_ip.nextHeader"]
                  }
                  default { error "Unsupported UDF in IP address of L2 packet offset = $place"}
               }
               foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
            }
         }
      }

      switch [string tolower $nHeader] {
         "tcp"  {
            logcmd stc::config $hIpv6 -nextHeader 6
            foreach var {tcpSynFlag tcpFinFlag tcpRstFlag tcpAckFlag tcpPushFlag tcpUrgFlag} {
               switch [subst $[subst $var]] {
                  1 -
                  true  { set $var 1 }
                  0 -
                  false { set $var 0 }
                  default { error "Unacceptable value for $var = '[subst $[subst $var]]'"}
               }
            }
            set hTcp [eval logcmd stc::create tcp:Tcp -under $hStreamBlock -name tcp\
                         -destPort [expr $pDstPort+0] -sourcePort [expr $pSrcPort+0]\
                         -seqNum $tcpSeqNum -synBit $tcpSynFlag -finBit $tcpFinFlag\
                         -rstBit $tcpRstFlag -ackBit $tcpAckFlag -pshBit $tcpPushFlag -urgBit $tcpUrgFlag\
                         -checksum 0]
            incr dataoffset 20
        }
         "udp" {
            logcmd stc::config $hIpv6 -nextHeader 17
            set hUdp [logcmd stc::create udp:Udp -under $hStreamBlock -name sb_udp\
                         -destPort [expr $pDstPort+0] -sourcePort [expr $pSrcPort+0]]
            incr dataoffset 8
            # check if s/d port are being incremented via udf
            if {$udfEnable == "true"} {
               if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
               foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
                  if {[set place [expr $udfOffs - $dataoffset]] < 0} {
                     set disableContents 1
                     switch $place {
                        -8 {
                           # do source ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 0xffff \
                                                  -StepValue 1 \
                                                  -Data [expr [string trimleft $initVal 0]+0] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb_udp.sourcePort"]
                        }
                        -6 {
                           # do dest ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 0xFFFF\
                                                  -StepValue 1 \
                                                  -Data [expr [string trimleft $initVal 0]+0] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb_udp.destAddr"]
                        }
                        default { error "Unsupported UDF in IP address of L2 packet offset = $place"}
                     }
                     foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
                  }
               }
            }
         }
         "58" -
         "icmpv6" {
            logcmd stc::config $hIpv6 -nextHeader 1
            set hUdp [logcmd stc::create icmp:Icmpv6EchoRequest -under $hStreamBlock -name icmp\
                         -code $code -type $type -identifier $id $seqNum $sequence]
            incr dataoffset 10
         }
      }
      
      if { $enableUDF4DVMRP } {
         logcmd stc::config $hIpv6 -nextHeader 2
      }
      
      if {$enablepimdm} {
         logcmd stc::config $hIpv6 -nextHeader 67
      }
      
      if {[string length $dataPattern] > 4} {
         set patternlen [expr $frameSize - $dataoffset - 4]
         puts "DATAPATTERN $dataPattern"
         puts "LENGTH : $patternlen"
         set streampattern [createFillStr $dataPattern $patternlen]
         set fill [logcmd stc::create custom:Custom -under $hStreamBlock -pattern $streampattern]
      }
      
      if {$udfEnable == "true"} {
         set inter 0
         foreach udfOffs $udfOffset {
            if {$udfOffs != 12} {
               continue
            }
            logcmd stc::config $hEthernet -etherType [join [lindex $udfInitval $inter] ""]
            
         }	
      }
      
      puts "UDFOFFSET : $udfOffset"

      if {$udfEnable == "true" & [llength $udfOffset] > 0} {
         set udflen [InsertUDFs $hStreamBlock $dataoffset $dataPattern $udfOffset $udfInitval $udfCountertype $numFrames $streamType]
         incr dataoffset $udflen
      }
      
      # adjust packet size
      # Size work : frameSizeType frameSizeMAX frameSizeMIN frameSize
      switch [string tolower $frameSizeType] {
         "sizerandom" {
            set stream_args [list -FixedFrameLength "64" -frameLengthMode RANDOM -maxFrameLength $frameSizeMAX\
                                -MinFrameLength [adjustStcPacketSize $frameSizeMIN $dataoffset]]
         }
         "sizefixed" {
            set stream_args [list -frameLengthMode FIXED -FixedFrameLength [adjustStcPacketSize $frameSize $dataoffset]]
         }
         default { error "Unsupported frameSizeType = $frameSizeType"
         }
      }
      eval logcmd stc::config $hStreamBlock $stream_args
      # configure generator
      configGen $txPort $streamType $frameSize $frameRate $percentage $txSpeed $numFrames

      lappend txPorts $txPort
      incr counter
   }

   if {$clearStats == "yes" } {
      logcmd stc::perform ResultClearAllTraffic -PortList "$txPort $rxPort"
   }
   
   if {$dontTx==0} {
      StartPortsTransmit $txPorts
   }
   
   if {[string tolower $streamType] != "contpacket" && $dontTx==0} {
      foreach txPort $txPorts {
         stcCheckTxDone -txPortId $txPort
      }
   } elseif {[string tolower $streamType]  == "contpacket" && $dontTx==0} {
      # doing rate based traffic so clear stats to get accurate rates
      logcmd stc::perform ResultClearAllTraffic -PortList "$txPort $rxPort"
   }      
   
   if {$dontTx==0 & $disableContents==0} {
         return [getFrameContents $hStreamBlock $ipProtocol]
   }
}



##################################################################
# Procedure Name: ixiaConf_2Ports
#
# Description:
# Ixia control - TX from a port & RX from another port.
# Uni-direction or bi-direction.
#
#
# Input args:
#      numIxiaCd :              Number of Ixia cards involved (1-16)
#                       for statistics & capture purpose
#          startCardNum :       Starting Ixia card slot number (1-16)
#      direction :              uni-direction (1Way) or bi-direction (2Way)
#      txChas :                 TX Ixia chassis id
#      txCard :                 TX Ixia card number
#      txPort :                 TX Ixia port number
#      rxChas :                 RX Ixia chassis id
#      rxCard :                 RX Ixia card number
#      rxPort :                 RX Ixia port number
#      inSaMac :                Input source MAC address
#      inDaMac :                Input destination MAC address
#      numFrames :              Number of frames to send per Ixia port
#      frameSize :              Frame size
#      dataPattern :    Packet data pattern
#      streamType :             advance, contBurst, contPacket, firstLoopCount,
#                                               gotofirst, stopStream (Note: see Ixia manual)
#      patternOffset :  For "filterPallette" (Note: see Ixia manual)
#      fcsError :               good, alignErr, bad, dribbleErr, none
#                                               (Note: see Ixia manual)
#      wTag :                   With Tag (true, false)
#          tagNo :                      Tag number
#      priority :               Priority for the packet
#      protocol :               mac, ip, ipx
#      saMode :                 contDecrement, contIncrement, ctrRandom,
#                                               decrement, idle, increment (Note: see Ixia manual)
#      daMode :                 contDecrement, contIncrement, ctrRandom,
#                                               decrement, idle, increment (Note: see Ixia manual)
#      percentage :             For TX speed - Percentage of the line rate
#      sendLearn :              To send learning frames? (true, false)
#      numLearnFrames : Number of the learning frames
#      chid :                   Ixia chassis id
#      userStatFltrSA1          MAC address filter for user stat 1
#      userStatFltrDA1          MAC address filter for user stat 1
# Output args: none
# Typical usage:
#   set frameSent [ixiaConf_2Ports -numIxiaCd $numIxiaCd \
#                  -txChas $txChasisId -txCard $txCard -txPort $txPort -direction "2Way" \
#                  -rxChas $rxChasisId -rxCard $rxCard -rxPort $rxPort -sendLearn $sendLearn \
#                  -protocol $protocol -numFrames $numFrames -frameSize $frameSize \
#                  -frameSizeType $frameSizeType -frameSizeMIN $frameSizeMIN  -frameSizeMAX $frameSizeMAX \
#                  -dataPattern $dataPattern -streamType $streamType -fcsError $fcsError]
#
#
#
# Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput
#                          VerifyTraffic)
# Category: SendTraffic
##################################################################

proc ixiaConf_2Ports {args} {
   puts "[lindex [info level 0] 0] : $args"

   parse_args ixiaConf_2Ports $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "n/a"
      txCard "n/a"
      txPort "port1"
      rxChas "n/a"
      rxCard "n/a"
      rxPort "port2"
      inSaMac "default"
      inDaMac "default"
      numFrames "1"
      frameSizeType "sizeFixed"
      frameSizeMAX "1518"
      frameSizeMIN "64"
      frameSize "64"
      dataPattern "0000"
      ethernetType "noType"
      frameType "08 00"
      streamType "stopStream"
      patternOffset "32"
      fcsError "good"
      priority "0"
      protocol "mac"
      saMode "idle"
      daMode "idle"
      saCount ""
      daCount ""
      percentage "100"
      sendLearn "false"
      numLearnFrames "1"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
      tagPriority "0"
      protocolTagId "null"
      chid "1"
      userDefinedStat1SA "00:00:00:00:00:00"
      userDefinedStat1DA "00:00:00:00:00:00"
      rate               "null"
      udfEnable "false"
      udfInitval "00"
      udfOffset "0"
      udfCountertype "c8"
      udfContinuousCount "false"
      udfRepeat "1"
      protoOffsetEnable "false"
      protoOffset "14"
      userDefTag ""
      dontTx "0"
      ZeroStats "yes"
   }
   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
   
   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   set time1 [clock seconds]
   
   set macBroadcast     {ff ff ff ff ff ff}
   set preambleSize     8


   #-----------------------------------------------------------------
   # Config streams for validation traffic
   set wkTag $wTag
   set wkTagNo $tagNo
   set portNo 0
   set portList {}
   set counter 0
   set txPorts {}
   lappend portList $txPort $rxPort
   if {$direction == "2Way"} {lappend portList $rxPort $txPort}
   
   foreach {txPort rxPort} $portList {
      set dataoffset 0
      set pktoffsets {}
      if { $wkTag == "true" } {
         set wTag "true"
         set tagNo [lindex $wkTagNo $portNo]
         incr portNo
         if { $tagNo == "" } {set tagNo [lindex $wkTagNo 0]}
         if { $tagNo == 0 || $tagNo == "none" } {set wTag "false"}
         result_debug "wTag = $wTag, tagNo = $tagNo"
      }
      
      #Stop generator before making changes.
      logcmd stc::perform GeneratorStop -GeneratorList $txPort
      
      # Delete all streamblocks on tx port
      deleteAllStreams $txPort
      
      # initialize streamblock arguments
      set stream_args {-insertSig FALSE}
      
      # Size work : frameSizeType frameSizeMAX frameSizeMIN frameSize
      switch [string tolower $frameSizeType] {
         "sizerandom" {
            lappend stream_args -FixedFrameLength "128" -frameLengthMode RANDOM -maxFrameLength $frameSizeMAX \
               -MinFrameLength $frameSizeMIN -EnableHighSpeedResultAnalysis "FALSE" -EqualRxPortDistribution "FALSE"
         }
         "sizefixed" {
            lappend stream_args -frameLengthMode FIXED -FixedFrameLength $frameSize -EqualRxPortDistribution "FALSE"
         }
         default { error "Unsupported frameSizeType = $frameSizeType"
         }
      }
      
      set txSpeed [getPortSpeed $txPort]
      
      set eth_args {}
      # get mac addresses
      set srcAddr  [GetDefaultPortIdMAC -portId $txPort]
      set destAddr [GetDefaultPortIdMAC -portId $rxPort]
      if {$direction == "2Way"} {
         if {($txPort == $rxPort)} {
            if { $inSaMac == "default" } {
               lappend eth_args -srcMac [set sMacAddr $srcAddr]
            } else {
               lappend eth_args -srcMac [set sMacAddr [join $inDaMac :]]
            }
            if { $inDaMac == "default" } {
               lappend eth_args -dstMac [set dMacAddr $destAddr]
            } else {
               lappend eth_args -dstMac [set dMacAddr [join $inSaMac :]]
            }   
         } else {
            if { $inSaMac == "default" } {
               lappend eth_args -srcMac [set sMacAddr $srcAddr]
            } else {
               lappend eth_args -srcMac [set sMacAddr [join $inSaMac :]]
            }
            if { $inDaMac == "default" } {
               lappend eth_args -dstMac [set dMacAddr $destAddr]
            } else {
               lappend eth_args -dstMac [set dMacAddr [join $inDaMac :]]
            }
         }
      } else {
         if { $inSaMac == "default" } {
            lappend eth_args -srcMac [set sMacAddr $srcAddr]
         } else {
            lappend eth_args -srcMac [set sMacAddr [join $inSaMac :]]
         }
         if { $inDaMac == "default" } {
            lappend eth_args -dstMac [set dMacAddr $destAddr]
         } else {
            lappend eth_args -dstMac [set dMacAddr [join $inDaMac :]]
         }
      }         
      # $fcsError
      if {$fcsError == "good"} {
         lappend stream_args -EnableFcsErrorInsertion false
      } else {
         lappend stream_args -EnableFcsErrorInsertion true
      }
      
      # Pattern work : $dataPattern (ixia has "nonRepeat" .. not sure what that means)
      if {[string length $dataPattern] <= 4} {
         lappend stream_args -ConstantFillPattern 0x$dataPattern -frameconfig {}
      } else {
         lappend stream_args -ConstantFillPattern 0 -frameconfig {}
      }
      
      # Create basic stream
      set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
      
      
      switch $ethernetType {
         ethernetII -
         noType {
            lappend eth_args -etherType [join $frameType {}]
            set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                              -name sb1_eth $eth_args]
            incr dataoffset 14 ; lappend pktoffsets sb1_eth $dataoffset
            set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag $wTag -tagNo $tagNo -tagCfi $tagCfi\
                            -tagMode $tagMode -tagRepeat $tagRepeat -protocolTagId $protocolTagId -tagPriority $tagPriority \
                            -protoOffsetEnable $protoOffsetEnable -userDefTag $userDefTag]
            if {$vlanlen > 0} {incr dataoffset $vlanlen  ; lappend pktoffsets sb1_vlans $dataoffset}
         }
         ieee8022 {
            set hEthernet [eval logcmd stc::create ethernet:Ethernet8022 -under $hStreamBlock \
                              -name sb1_eth $eth_args]
            incr dataoffset 14; lappend pktoffsets sb1_eth $dataoffset
            set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag $wTag -tagNo $tagNo -tagCfi $tagCfi\
                            -tagMode $tagMode -tagRepeat $tagRepeat -protocolTagId $protocolTagId -tagPriority $tagPriority \
                            -protoOffsetEnable $protoOffsetEnable -userDefTag $userDefTag]
            if {$vlanlen > 0} {incr dataoffset $vlanlen  ; lappend pktoffsets sb1_vlans $dataoffset}
            set hLlc [eval logcmd stc::create llcheader -under $hEthernet \
                              -name sb1_llc]
            
            incr dataoffset 3 ; lappend pktoffsets sb1_llc $dataoffset
         }
         ieee8023snap {
            set hEthernet [eval logcmd stc::create ethernet:EthernetSnap -under $hStreamBlock \
                              -name sb1_eth $eth_args]
            incr dataoffset 14 ; lappend pktoffsets sb1_eth $dataoffset
            set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag $wTag -tagNo $tagNo -tagCfi $tagCfi\
                            -tagMode $tagMode -tagRepeat $tagRepeat -protocolTagId $protocolTagId -tagPriority $tagPriority \
                            -protoOffsetEnable $protoOffsetEnable -userDefTag $userDefTag]
            if {$vlanlen > 0} {incr dataoffset $vlanlen  ; lappend pktoffsets sb1_vlans $dataoffset}
            set hLlc [eval logcmd stc::create llcheader -under $hEthernet \
                              -name sb1_llc]
            incr dataoffset 3 ; lappend pktoffsets sb1_llc $dataoffset
            set hSnap [eval logcmd stc::create snapheader -under $hEthernet \
                              -name sb1_snap]
            incr dataoffset 5 ; lappend pktoffsets sb1_snap $dataoffset
         }
         default { error "Ethernet Type not supported $ethernetType" }
      }

      modifyMacAddrs -stream $hStreamBlock -saMode $saMode -daMode $daMode -saCount $saCount \
         -daCount $daCount -sMacAddr $sMacAddr -dMacAddr $dMacAddr -numFrames $numFrames
      
      # Kludge to get the first mac address DON'T think this is necessary
      if {[llength $dMacAddr]>2} {
         set dMacAdd $dMacAddr
      } else {
         set dMacAdd [lindex $dMacAddr $counter]
      }
      
      

      puts $pktoffsets
      if {$udfEnable == "true"} {
         if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
         foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
            if {[set place [expr $udfOffs - $dataoffset]] < 0} {
               insertUdfInHeader $hStreamBlock $pktoffsets $initVal $udfOffs $counterType
               foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
            }
         }
      }                     
      
      switch [string tolower $protocol] {
         ip {
            set hIpv4 [logcmd stc::create ipv4:IPv4 -under $hStreamBlock -name sb1_ip \
                          -protocol 255 -identification 0]
            # disable IP ID field auto increment 
            set hRangeModifier [logcmd stc::create RangeModifier \
                                   -under $hStreamBlock \
                                   -ModifierMode INCR \
                                   -Mask 65535 \
                                   -StepValue "1" \
                                   -Data 0 \
                                   -RecycleCount 65535 \
                                   -DataType NATIVE \
                                   -EnableStream false \
                                   -RepeatCount 0 \
                                   -OffsetReference "sb1_ip.identification"]
            incr dataoffset 20 ; lappend pktoffsets sb1_ip $dataoffset
            # check if s/d IP addresses are being incremented via udf
            if {$udfEnable == "true"} {
               if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
               foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
                  if {[set place [expr $udfOffs - $dataoffset]] < 0} {
                     switch $place {
                        -14 {
                           # do source ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 0xffff \
                                                  -StepValue 1 \
                                                  -Data 0x[join $initVal {}] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb1_ip.fragOffset"]
                        }
                        -8 {
                           # do source ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 255.255.255.255 \
                                                  -StepValue 0.0.0.1 \
                                                  -Data [int2ip 0x[join $initVal {}]] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb1_ip.sourceAddr"]
                        }
                        -4 {
                           # do dest ip
                           set hRangeModifer1 [logcmd stc::create RangeModifier \
                                                  -under $hStreamBlock \
                                                  -ModifierMode INCR \
                                                  -Mask 255.255.255.255 \
                                                  -StepValue 0.0.0.1 \
                                                  -Data [int2ip 0x[join $initVal {}]] \
                                                  -RecycleCount $recycleCount \
                                                  -RepeatCount 0 \
                                                  -DataType NATIVE \
                                                  -EnableStream false \
                                                  -OffsetReference "sb1_ip.destAddr"]
                        }
                        default { error "Unsupported UDF in IP address of L2 packet offset = $place"}
                     }
                     foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
                  }
               }
            }
         }
         mac {
            logcmd stc::config $hEthernet -etherType [join $dataPattern {}]
         }
         ipx {
            if {$ethernetType == "noType" || $ethernetType == "ethernetII"} {
               logcmd stc::config $hEthernet -etherType 8137
            }
         }
         default { error "Protocol not supported : $protocol" }
      }
      if {$udfEnable == "true" & [llength $udfOffset] > 0} {
         set udflen [InsertUDFs $hStreamBlock $dataoffset $dataPattern $udfOffset $udfInitval $udfCountertype $numFrames $streamType]
         incr dataoffset $udflen 
      }

      if {[string length $dataPattern] > 4} {
         set patternlen [expr $frameSize - $dataoffset - 5]
         set streampattern [createFillStr $dataPattern $patternlen]
         set fill [logcmd stc::create custom:Custom -under $hStreamBlock -pattern $streampattern]
      }
      
      # configure generator
      configGen $txPort $streamType $frameSize $rate $percentage $txSpeed $numFrames
      lappend txPorts $txPort
      incr counter
   }

   if {$ZeroStats == "yes" } {
      logcmd stc::perform ResultClearAllTraffic -PortList $txPorts
   }
   
   if {$dontTx==0} {
      StartPortsTransmit $txPorts
   }

   if {[string tolower $streamType] != "contpacket" && $dontTx==0} {
      foreach txPort $txPorts {
         stcCheckTxDone -txPortId $txPort
      }
   }
   
   if {$dontTx==0} {
      # return the last packet created (this really only useful for 1-way traffic)
      return [getFrameContents $hStreamBlock $protocol]
   }
}



################################################################## 
# Procedure Name: ixiaConf_2Ports_arp   
# Description: 
#	Set up an ixia port to send ARP packets (request or reply)		     
# Input args: args
# Output args: none
# Typical usage: 
#	set frameSent [ixiaConf_2Ports_arp -numIxiaCd $numIxiaCd \
#             -txChas $chasisId -txCard $card -txPort $port -startCardNum $startCardNum \
#             -rxChas $chasisId -rxCard $card -rxPort $rxPo \
#             -operation $type -sMacAddr $sourceMac -dMacAddr $destMac \
#             -sIpAddr $sourceIp -dIpAddr $destIp -numFrames $numFrames \
#	      -wTag $wTag -tagNo $tag -frameSize $frameSize -streamType $streamType \
#	      -arpSaMode $arpSaMode -arpDaMode $arpDaMode -percentage $percentage \
#	      -arpSaRepeat $arpSaRepeat -arpDaRepeat $arpDaRepeat]   
# Category: SendTraffic
##################################################################
proc ixiaConf_2Ports_arp {args} {
puts "[lindex [info level 0] 0] : $args"
   parse_args ixiaConf_2Ports_arp $args {
      numIxiaCd "1"
      startCardNum "1"
      direction "1Way"
      txChas "n/a"
      txCard "n/a"
      txPort "port1"
      rxChas "n/a"
      rxCard "n/a"
      rxPort "port2"
      sMacAddr "default"
      dMacAddr "ff ff ff ff ff ff"
      sIpAddr "127.0.0.1"
      dIpAddr "127.0.0.1"
      arpSaMode "arpIdle"
      arpDaMode "arpIdle"
      operation "arpRequest"
      goodChecksum "true"
      numFrames "1"
      frameSize "64"
      frameRate "default"
      dataPattern "0000"
      streamType "stopStream"
      fcsError "good"
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
      userPriority "0"
      percentage "0.01"
      saMode "idle"
      daMode "idle"
      chid "1"
      arpSaRepeat "1"
      arpDaRepeat "1"
      srcHwAddr "default"
      srcHwAddrMode "arpIdle"
      srcHwAddrRepeat "1"
      destHwAddr "default"
      destHwAddrMode "arpIdle"
      destHwAddrRepeat "1"   
      udfEnable "false"
      udfInitval "00"
      udfOffset "0"
      udfCountertype "c8"
      udfContinuousCount "false"
      dontTx "0"
   }
   global spawn_id
   global one2oneArray
   global macBroadcast
   global preambleSize
#   protocolStackSetDefault

   set date [clock format [clock seconds] -format "%m-%d-%Y %I.%M.%S%p"]
   #result_debug "\n*** date=$date"
   set time1 [clock seconds]
   set patternOffset				32
   set macBroadcast					{ff ff ff ff ff ff}
   set preambleSize					8

   #-----------------------------------------------------------------
   # Config streams for validation traffic
   set wkTag $wTag
   set wkTagNo $tagNo
   set portNo 0
   set portList {}
   lappend portList $txPort $rxPort
   if {$direction == "2Way"} {lappend portList $rxPort $txPort}
   #-----------------------------------------------------------------
   # Config streams for validation traffic

   foreach {txPort rxPort} $portList {
      set dataoffset 0
      if { $wkTag == "true" } {
         set wTag "true"
         set tagNo [lindex $wkTagNo $portNo]
         incr portNo
         if { $tagNo == "" } {set tagNo [lindex $wkTagNo 0]}
         if { $tagNo == 0 || $tagNo == "none" } {set wTag "false"}
         result_debug "wTag = $wTag, tagNo = $tagNo"
      }

      #Stop generator before making changes.
      logcmd stc::perform GeneratorStop -GeneratorList $txPort
      
      # Delete all streamblocks on tx port
      set lsthStreamblocks [logcmd stc::get $txPort -children-StreamBlock]
      foreach hStreamblock $lsthStreamblocks {
         logcmd stc::delete $hStreamblock
      }
      logcmd stc::apply
      
      # initialize streamblock arguments
      set stream_args {-insertSig FALSE}

      lappend stream_args -frameLengthMode FIXED -FixedFrameLength $frameSize -EqualRxPortDistribution "FALSE"
   
      set txSpeed [getPortSpeed $txPort]

      # $fcsError
      if {$fcsError == "good"} {
         lappend stream_args -EnableFcsErrorInsertion false
      } else {
         lappend stream_args -EnableFcsErrorInsertion true
      }

      # Pattern work : $dataPattern (ixia has "nonRepeat" .. not sure what that means)
      if {[string length $dataPattern] <= 4} {
         lappend stream_args -ConstantFillPattern 0x$dataPattern -frameconfig {}
      } else {
         lappend stream_args -ConstantFillPattern 0 -frameconfig {}
      }
    
      # Create basic stream
      set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]

      set eth_args {}
      if {$sMacAddr == "default"} {
         set sMacAddr [GetDefaultPortIdMAC -portId $txPort]
      }
      lappend eth_args -srcMac [join $sMacAddr :]
      
      
      # $dMacAddr
      if {$dMacAddr == "default"} {
         set dMacAddr [GetDefaultPortIdMAC -portId $rxPort]
      }
      lappend eth_args -dstMac [join $dMacAddr :]
      
      set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                        -name sb1_eth $eth_args]
      incr dataoffset 14

      modifyMacAddrs -stream $hStreamBlock -saMode $saMode -daMode $daMode \
         -sMacAddr $sMacAddr -dMacAddr $dMacAddr -numFrames $numFrames

      set vlanlen [addVlans -stream $hStreamBlock -ethobj $hEthernet -wTag $wTag -tagNo $tagNo -tagCfi $tagCfi \
                      -tagMode $tagMode -tagRepeat $tagRepeat -tagPriority $userPriority]
      incr dataoffset $vlanlen
     
      if {$srcHwAddr=="default"} {
         set srcHwAddr $sMacAddr
      }
      
      if {$destHwAddr=="default"} {
         set destHwAddr $dMacAddr
      }

      switch $operation {
         arpRequest {set op 1}
         arpReply   {set op 2}
         default    {error "Unsupported ARP opertation type: $operation"}
      }
      set hArp [logcmd stc::create arp:ARP -under $hStreamBlock -name sb1_arp -operation $op \
                   -senderHwAddr [join $srcHwAddr :] -targetHwAddr [join $destHwAddr :] \
                   -senderPAddr $sIpAddr -targetPAddr $dIpAddr]

      incr dataoffset 28
      if {$arpSaMode != "arpIdle"} {
         set hRangeModifier [logcmd stc::create RangeModifier \
                                -under $hStreamBlock \
                                -ModifierMode INCR \
                                -Mask "255.255.255.255" \
                                -StepValue "0.0.0.1" \
                                -Data $sIpAddr \
                                -RecycleCount $arpSaRepeat \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "sb1_arp.senderPAddr"]
      }
      if {$arpDaMode != "arpIdle"} {
         set hRangeModifier [logcmd stc::create RangeModifier \
                                -under $hStreamBlock \
                                -ModifierMode INCR \
                                -Mask "255.255.255.255" \
                                -StepValue "0.0.0.1" \
                                -Data $dIpAddr \
                                -RecycleCount $arpDaRepeat \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "sb1_arp.targetPAddr"]
      }
      
      if {$srcHwAddrMode != "arpIdle"} {
         # Use modifier to generate multiple streams.
         set hRangeModifier [logcmd stc::create RangeModifier \
                                -under $hStreamBlock \
                                -ModifierMode INCR \
                                -Mask "00:00:FF:FF:FF:FF" \
                                -StepValue "00:00:00:00:00:01" \
                                -Data [join $srcHwAddr :] \
                                -RecycleCount $srcHwAddrRepeat \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "sb1_arp.senderHwAddr"]
      }
      if {$destHwAddrMode != "arpIdle"} {
         # Use modifier to generate multiple streams.
         set hRangeModifier [logcmd stc::create RangeModifier \
                                -under $hStreamBlock \
                                -ModifierMode INCR \
                                -Mask "00:00:FF:FF:FF:FF" \
                                -StepValue "00:00:00:00:00:01" \
                                -Data [join $destHwAddr :] \
                                -RecycleCount $destHwAddrRepeat \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "sb1_arp.targetHwAddr"]
      }
      if {$udfEnable == "true"} {
         if {$streamType == "continuous"} {set recycleCount 0} else {set recycleCount $numFrames}
         foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
            set counterByteLen [getCounterByteLen $counterType]
            if {[set place [expr $udfOffs - $dataoffset]] < 0} {
               switch $place {
                  -28 {
                     set hRangeModifer1 [logcmd stc::create RangeModifier \
                                            -under $hStreamBlock \
                                            -ModifierMode INCR \
                                            -Mask [makeMaskOffset 2 $counterByteLen] \
                                            -StepValue [makeStepValue 2 $counterByteLen] \
                                            -Data [makeDataValue 2 $counterByteLen $initVal] \
                                            -RecycleCount $recycleCount \
                                            -RepeatCount 0 \
                                            -DataType NATIVE \
                                            -EnableStream false \
                                            -OffsetReference "sb1_arp.hardware"]
                  }
               }  
               foreach var { udfOffset udfInitval udfCountertype } { set $var [eval lrange $$var 1 end] }
            }
         }
      }
      if {[string length $dataPattern] > 4} {
         set patternlen [expr $frameSize - $dataoffset - 5]
         set streampattern [createFillStr $dataPattern $patternlen]
         set fill [logcmd stc::create custom:Custom -under $hStreamBlock -pattern $streampattern]
      }

      if {$udfEnable == "true" & [llength $udfOffset] > 0} {
         set udflen [InsertUDFs $hStreamBlock $dataoffset $dataPattern $udfOffset $udfInitval $udfCountertype $numFrames $streamType]
         incr dataoffset $udflen
      }
   }

   logcmd stc::apply
   
   logcmd stc::perform ResultClearAllTraffic -PortList "$txPort $rxPort"
   
   set gen_args {}
   # Rate work:  $txSpeed $frameSize $percentage
   if { $frameRate == "default" } {
      set frameRate [decideFrameRate $txSpeed $frameSize $percentage]
      if {$frameRate < 1} {
         set percentage [decidePercentage $txSpeed $frameSize 1]
      }
   } else {
      set percentage [decidePercentage $txSpeed $frameSize $frameRate]
   }
   if {$percentage > 100} {set percentage 100}
   lappend gen_args -loadunit PERCENT_LINE_RATE -FixedLoad $percentage
   
   # Count work: $numFrames $streamType (replaces "decideLoopCount $numFrames $streamType")
    switch [string tolower $streamType] {
      "stopstream" { lappend gen_args -DurationMode BURSTS -BurstSize $numFrames -duration 1 }
      "contpacket" -
      "continuous" { lappend gen_args -DurationMode CONTINUOUS }
      default { error "Unsupported streamType = $streamType" }
   }
   set hGeneratorConfig [eval logcmd stc::config $txPort.Generator.GeneratorConfig $gen_args]
   
   # Apply changes.
   logcmd stc::apply
   
   if {$dontTx==0} {
      StartPortsTransmit $txPort
   }
   if {[string tolower $streamType] != "contpacket" && $dontTx==0} {
      stcCheckTxDone -txPortId $txPort
   }
   
   if {$dontTx==0} {
      return [getFrameContents $hStreamBlock arp]
   } else {
      return ""
   }
}


proc configGen {txPort streamType frameSize frameRate percentage txSpeed numFrames} {

   # reset gen to default config before modifying
   logcmd stc::config $txPort.Generator.GeneratorConfig -AdvancedInterleaving FALSE -BurstSize 1 \
      -Duration 30 -DurationMode CONTINUOUS -FixedLoad 10 \
      -InterFrameGap 12 -InterFrameGapUnit BYTES -JumboFrameThreshold 1518 \
      -LoadMode FIXED -LoadUnit PERCENT_LINE_RATE -OversizeFrameThreshold 9018 \
      -RandomLengthSeed 10900842 -RandomMaxLoad 100 -RandomMinLoad 10 \
      -SchedulingMode PORT_BASED -StepSize 1 -TimestampLatchMode START_OF_FRAME \
      -UndersizeFrameThreshold 64
   logcmd stc::apply

   # set new args
   set gen_args {}
   if { ![string is double $frameRate] } {
      set frameRate [getRateFromPct $percentage $frameSize $txSpeed]
   }

   # Count work: $numFrames $streamType (replaces "decideLoopCount $numFrames $streamType")
   switch -glob [string tolower $streamType] {
      stop* { 
         lappend gen_args -DurationMode BURSTS -BurstSize $numFrames -duration 1 \
            -loadunit FRAMES_PER_SECOND -FixedLoad [getRateFromPct 10 $frameSize $txSpeed]
      }
      cont*  { 
         lappend gen_args -DurationMode CONTINUOUS -duration 30
         lappend gen_args -loadunit FRAMES_PER_SECOND -FixedLoad $frameRate
      }
      default { error "Unsupported streamType = $streamType" }
   }
   lappend gen_args -SchedulingMode PORT_BASED 
   set hGeneratorConfig [eval logcmd stc::config $txPort.Generator.GeneratorConfig $gen_args]
   # Apply changes.
   logcmd stc::apply
}

proc adjustUdpTcpPacketContents { hexlist ipoffset } {

   #pad with zero if
   set mainhex [lrange $hexlist [expr $ipoffset+12] end-2]
   lappend mainhex 00 00
   set len [expr [llength $mainhex]-8]
   if {[set pad [expr [set length [llength $mainhex]] % 4]] > 0} {
      for {set i 0} {$i < $pad} {incr i} { lappend mainhex 00}
   }

   # sum up the mainhex 
   set sum 0
   for {set i 0} {$i < $length} {incr i 4} {
      set tmp "0x[join [lrange $mainhex $i [expr {$i + 3}]] {}]"
      set sum [expr {$sum + $tmp}]
   }

   # add on the protocol and UDP length
   set tmp  0x[lindex $hexlist [expr $ipoffset + 9]][format %04X $len]
   set sum [expr $sum + $tmp]
 
   set sumx [expr ($sum & 0x0000ffff) + (($sum >> 16) & 0x0000ffff) + (($sum >> 32) & 0x0000ffff)]
   set sumx [expr ($sumx & 0x0000ffff) + (($sumx >> 16) & 0x0000ffff)]
   set sum [string toupper [format %04x [expr {$sumx ^ 0xffff}]]]
   return [lreplace $hexlist end-1 end [string range $sum 0 1] [string range $sum 2 3]]
}

proc getFrameContents {streamobj protocol {ipoffset 14}} {
   package require crc32
   logcmd stc::perform GetPreviewData -StreamBlock $streamobj
   set szFrameContents [string toupper [string range "[logcmd stc::get [logcmd stc::get $streamobj -children-PreviewData] -HexData]" 16 end]]
   set szFrameContents [scan $szFrameContents  [string repeat "%2s" [expr [string length $szFrameContents]/2]]]
   if {$protocol == "udp" | $protocol == "tcp"} {set szFrameContents [adjustUdpTcpPacketContents $szFrameContents $ipoffset]}
   set crc [crc::crc32 -format %08X [binary format H* [join $szFrameContents {}]]]
   set crc [list [string range $crc 6 7] [string range $crc 4 5] [string range $crc 2 3] [string range $crc 0 1]]
   eval lappend szFrameContents $crc
   result_debug "$szFrameContents"
   # attempted udp hack
   return $szFrameContents
}

# return that the port is not 8 or 82 (fiber ports in Ixia world)
proc getIxiaPortType {port } {
   return 1
}

proc dec2bin {int} {
   return [format %llb $int]
}

proc int2bits {int cnt} {
   set bin [string trimleft [string map {
      0 {000} 1 {001} 2 {010} 3 {011} 4 {100} 5 {101} 6 {110} 7 {111}
   } [format %o $int]] 0]
   if {$bin == {}} {set bin 0}
   return [format %0${cnt}s $bin]
}


proc InsertStaticUDFs {streamblockHndl dataoffset pattern udfOffset udfInitval udfCountertype recycleCount streamtype} {

}

proc InsertUDFs {streamblockHndl dataoffset pattern udfOffset udfInitval udfCountertype recycleCount streamtype} {
   puts "[lindex [info level 0] 0] : $streamblockHndl {$dataoffset} {$pattern} {$udfOffset} {$udfInitval} {$udfCountertype} {$recycleCount} {$streamtype}"

   # make the custom header 
   set highoffset [lindex $udfOffset 0]
   if {[string is integer [lindex $udfCountertype 0]]} {
      set highbitcnt [lindex $udfCountertype 0]
   } else {
      set highbitcnt [string range [lindex $udfCountertype 0] 1 end]
   }
puts "HIGHBITCNT : $highbitcnt"
puts "UDFOFFSET  : $udfOffset"
   if {[llength $udfOffset] > 1} {
      foreach i $udfOffset j $udfCountertype { 
         if {$highoffset < $i} {set highoffset $i}
         if {$highbitcnt < [string range $j 1 end]} {set highbitcnt $j}
      }
   }
   set udflen 0
   foreach ctr $udfCountertype { incr udflen [getCounterByteLen $ctr]}
puts "UDFLEN     : $udflen"
   set hdrlen [expr $highoffset+$udflen -$dataoffset]
   set customHeader [logcmd stc::create custom:Custom -under $streamblockHndl -pattern [createFillStr $pattern $hdrlen] -Name udf_field]

   foreach udfOffs $udfOffset initVal $udfInitval counterType $udfCountertype {
      if {$streamtype == "continuous"} {set recycleCount 0}
      set mask [makeMask [getCounterByteLen $counterType]]
      set hRangeModifer [logcmd stc::create RangeModifier \
                            -under $streamblockHndl \
                            -StepValue 1 \
                            -Mask $mask \
                            -Data [join $initVal ""] \
                            -DataType BYTE \
                            -RecycleCount $recycleCount \
                            -offset [expr $udfOffs-$dataoffset] \
                            -OffsetReference "udf_field.pattern"]
   }
   return $hdrlen
}
 
proc createFillStr {fill length} {
   incr length $length
   set fill [join $fill {}]
   while {[string length $fill] < $length} {
      append fill $fill
   }
   set fill [string range $fill 0 $length]
   return $fill
}

proc makeMask {length} {
   set mask {}
   for {set i 0} {$i < $length} {incr i} {append mask ff}
   return $mask
}

proc makeMaskOffset {fieldlen incrlen} {
   set retmask [makeMask $incrlen]
   for {set i 1} {$i <= [expr $fieldlen-$incrlen]} {incr i} {append retmask 00}
   return $retmask
}

proc getCounterByteLen {countertype} {
   if {[string is integer $countertype]} {
      return [expr $countertype/8]
   } else {
      return [expr [string range $countertype 1 end]/8]
   }
}

proc makeDataValue {fieldlen incrlen value} {
   return [makeStepValue $fieldlen $incrlen 0x$value]
}

proc makeStepValue {fieldlen incrlen {incr 1}} {
   return [format %0[expr $fieldlen*2]X [expr $incr << [expr ($fieldlen-$incrlen)*8]]]
}

proc getIPv4Header { object ipoffset } {

   set pktbytelist [getFrameContents $object ip $ipoffset]
   set iphdr [lrange $pktbytelist $ipoffset [expr ((0x[lindex $pktbytelist $ipoffset] & 0x0F)*4)+$ipoffset]]
   return $iphdr
}

proc getIPv4Checksum.old {hexstr {options {}}} {
   set hexstr [string replace [join $hexstr {}] 20 23 0000]
   set length [expr [string length $hexstr]/2]
   set sum 0
   for {set i 0} {$i < $length} {incr i 4} {
      set tmp "0x[string range $hexstr $i [expr {$i + 3}]]"
      set sum [expr {$sum + $tmp}]
      if {$sum > 0xffff} {
         set sum [expr {($sum & 0xffff) + 1}]
      } 
   }
#    set sumx [expr ($sum & 0x0000ffff) + (($sum >> 16) & 0x0000ffff) + (($sum >> 32) & 0x0000ffff)]
#    set sum [string toupper [format %04x [expr {$sumx ^ 0xffff}]]]
   
   set sum [expr {$sum ^ 0xffff}]     
   return $sum
}


proc getAdjustedOptions {hexstr} {
   set zeros [expr 8 - [string length [join $hexstr {}]]%8]
   if {$zeros == 8} {set zeros 0}
   for {set i 0} {$i < [expr $zeros/2]} {incr i 2} {
      lappend hexstr 00
   }
   return $hexstr
}

proc getIPv4Checksum {args} {

   set arg(-ilh)        5
   set arg(-sourceaddr) 0.0.0.0
   set arg(-destaddr)   0.0.0.0
   set arg(-ttl)        255
   set arg(-id)         0
   set arg(-protocol)   0
   set arg(-optionstr)  {}
   set arg(-tos)        0
   set arg(-length)     64 

   array set arg [string tolower $args]

   set ip {}
   append ip 4[format %01x $arg(-ilh)][format %02x $arg(-tos)][format %04x $arg(-length)]
   append ip [format %04x $arg(-id)]0000
   append ip [format %02x $arg(-ttl)][format %02x $arg(-protocol)]0000
   append ip [format %08x [ip2int $arg(-sourceaddr)]]
   append ip [format %08x [ip2int $arg(-destaddr)]]
   append ip $arg(-optionstr)
puts "IP STRING $ip"
   set length [expr [string length $ip]/2]
   set sum 0
   for {set i 0} {$i < $length} {incr i 4} {
      set tmp "0x[string range $ip $i [expr {$i + 3}]]"
      set sum [expr {$sum + $tmp}]
      if {$sum > 0xffff} {
         set sum [expr {($sum & 0xffff) + 1}]
      } 
   }
#    set sumx [expr ($sum & 0x0000ffff) + (($sum >> 16) & 0x0000ffff) + (($sum >> 32) & 0x0000ffff)]
#    set sum [string toupper [format %04x [expr {$sumx ^ 0xffff}]]]
   
   set sum [expr {$sum ^ 0xffff}]     
   return $sum
   
}
proc getIGMPv2Checksum {args} {

   set arg(-type)         0x11
   set arg(-groupaddress) 225.0.0.1
   set arg(-maxreaptime)  100

   array set arg [string tolower $args]

   set igmp {}
   append igmp [format %02x $arg(-type)][format %02x $arg(-maxreaptime)]0000
   append igmp [format %08x [ip2int $arg(-groupaddress)]]
   set length [string length $igmp]
   set sum 0
   for {set i 0} {$i < $length} {incr i 4} {
      set tmp "0x[string range $igmp $i [expr {$i + 3}]]"
      #puts "[format %04x $sum] + $tmp = ..."
      set sum [expr {$sum + $tmp}]
      if {$sum > 0xffff} {
         set sum [expr {($sum & 0xffff) + 1}]
      }
      # puts [format %04x $sum]
   }
   set sum [expr {$sum ^ 0xffff}]     
   return $sum
   
}

proc ip2int {ip} {
   foreach {a b c d} [split $ip .] {}
   set a1 [format %u [expr $a<<24]]
   return [expr {$a1 + ($b << 16) + ($c << 8) + $d}]
}

proc int2ip {int} {
   if {[llength [split $int .]] == 1} {
      set x [format %08x $int]
      set oper 255
      for {set i 0} {$i <= 6} {incr i 2} {
         set ip($i) [expr int(0x[string range $x $i [expr $i+1]])]
      }
      return $ip(0).$ip(2).$ip(4).$ip(6)
   }
   return $int
}

proc cleanRoute { ip mask } {
   set temp [expr [ip2int $ip] >> (32-$mask)]
   return [int2ip [expr $temp <<  (32-$mask)]]
}

proc getIpProtocol {name} {
   switch [string tolower $name] {
      "tcp"  { return 6 }
      "udp" { return 17 }
      "ip" { return 255 }
      "icmp" { return 1 }
      default {
         if {[string is integer $name]} {return $name} else {error "Unrecognized IPv4 protocol $name"}
      }
   }  
}
proc getIpv6NextHeaderValue {name} {
   if {[string is integer $name]} {return $name}
   switch [string tolower $name] {
      "tcp"  { return 6 }
      "udp" { return 17 }
      "ip" { return 255 }
      "icmp" { return 1 }
      "icmpv6" { return 58 }
      "igmp" { return 2 }
      "ipv6nonextheader" { return 59 }
      "ipv6hopbyhopoptions" { return 0 }
      default {
         if {[string is integer $name]} {return $name} else {error "Unrecognized IPv6 next header $name"}
      }
   }  
}

proc deleteAllStreams {portlist} {
   foreach port $portlist {
      set lsthStreamblocks [logcmd stc::get $port -children-StreamBlock]
      foreach hStreamblock $lsthStreamblocks {
         logcmd stc::delete $hStreamblock
      }
   }
   logcmd stc::apply
}

proc getPortSpeed {port} {
   global STCPORT
   #set myPhy [logcmd stc::get $port -ActivePhy]
   #puts "\n!!\n!!\n!!\nGot active phy $myPhy\n!!\n!!\n!!";
   #switch -regexp $myPhy {
   #    ethernet10gigcopper {
   #        set txSpeed [logcmd stc::get [logcmd stc::get $port -children-ethernet10gigcopper] -LineSpeedStatus]
   #    }
   #    ethernet10gigfiber {
   #        set txSpeed [logcmd stc::get [logcmd stc::get $port -children-ethernet10gigfiber] -LineSpeedStatus]
   #    }
   #    ethernetcopper {
   #        set txSpeed [logcmd stc::get [lindex [logcmd stc::get $port -children-ethernetcopper] 0] -LineSpeedStatus]
   #    }
   #    ethernetfiber {
   #        set txSpeed [logcmd stc::get [lindex [logcmd stc::get $port -children-ethernetfiber] 0] -LineSpeedStatus]
   #    }
   #    default {
   #        set txSpeed [logcmd stc::get [lindex [logcmd stc::get $port -children-ethernetcopper] 0] -LineSpeedStatus]
   #    }
   #}
   #set phyList [getPhyObject $port]
   #set pLen [llength $phyList]
   #set myPhy [lindex $phyList [expr $pLen - 1]]
   #set myPhy [lindex $phyList 0]
   #set txSpeed [string toupper [logcmd stc::get $myPhy -LineSpeedStatus]]
   #Port speed is identified at systemsetup
   switch $STCPORT($port,speed) {
      SPEED_100G { set txSpeed 100000 }
      SPEED_50G { set txSpeed 50000 }
      SPEED_40G { set txSpeed 40000 }
      SPEED_25G { set txSpeed 25000 }
      SPEED_10G { set txSpeed 10000 }
      SPEED_5G { set txSpeed 5000 }
      SPEED_2500M { set txSpeed 2500 }
      SPEED_1G { set txSpeed 1000 }
      SPEED_10M { set txSpeed 10 }
      SPEED_100M { set txSpeed 100 }
      default  { error "Port speed not supported \"$txSpeed\""}
   }
   return $txSpeed
}

proc modifyIpAddrs {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args modifyIpAddrs $args {
      stream {}
      numFrames ""
      sIpAddr ""
      dIpAddr ""
      sIpMask "255.255.255.0"
      dIpMask "255.255.255.0"
      ipSaMode "ipIdle"
      ipDaMode "ipIdle"
      ipSaCount ""
      ipDaCount ""
   }

   set sbitems [logcmd stc::get $stream -children]
   set ipobj [lindex $sbitems [lsearch $sbitems *ipv4*]]
   if {$sIpAddr == {}} {
      set sIpAddr [logcmd stc::get $ipobj -sourceAddr]
   }
   if {$dIpAddr == {}} {
      set dIpAddr [logcmd stc::get $ipobj -destAddr]
   }
   set disableContents 0
   if { $ipSaMode != "ipIdle" } {
      set disableContents 1
      switch -glob [string tolower $ipSaMode] {
         *inc* { set mode INCR }
         *dec* { set mode DECR }
         *rand* { set mode SHUFFLE }
         default { error "Unsupported stream modifier ipSaMode = $ipSaMode"}
      }
      if {$ipSaCount == {}} {set ipSaCount $numFrames}
      # Use modifier to generate multiple streams.
      result_debug "\nCreating Modifier on Stream Block"
      set hRangeModifer1 [logcmd stc::create RangeModifier \
                             -under $stream \
                             -ModifierMode $mode \
                             -Mask 255.255.255.255 \
                             -StepValue 0.0.0.1 \
                             -Data $sIpAddr \
                             -RecycleCount $ipSaCount \
                             -RepeatCount 0 \
                             -DataType NATIVE \
                             -EnableStream false \
                             -OffsetReference "sb1_ip.sourceAddr"]
   }
   if {($ipDaMode != "ipIdle")} {
      set disableContents 1
      switch -glob [string tolower $ipDaMode] {
         *inc* { set mode INCR }
         *dec* { set mode DECR }
         *rand* { set mode SHUFFLE }
         default { error "Unsupported stream modifier ipDaMode = $ipDaMode"}
      }
      if {$ipDaCount == {}} {set ipDaCount $numFrames}
      # Use modifier to generate multiple streams.
      result_debug "\nCreating Modifier on Stream Block"
      set hRangeModifer1 [logcmd stc::create RangeModifier \
                             -under $stream \
                             -ModifierMode $mode \
                             -Mask 255.255.255.255 \
                             -StepValue 0.0.0.1 \
                             -Data $dIpAddr \
                             -RecycleCount $ipDaCount \
                             -RepeatCount 0 \
                             -DataType NATIVE \
                             -EnableStream false \
                             -OffsetReference "sb1_ip.destAddr"]
   }
   return $disableContents
}

proc modifyMacAddrs {args} {

   parse_args ixiaConf_2Ports_arp $args {
      stream {}
      saMode "idle"
      daMode "idle"
      saCount ""
      daCount ""
      sMacAddr ""
      dMacAddr ""
      numFrames 1
   }
  
   set sbitems [logcmd stc::get $stream -children]
   set ethobj [lindex $sbitems [lsearch $sbitems *ethernet*]]
   if {$sMacAddr == {}} {
      set sMacAddr [logcmd stc::get $ethobj -srcMac]
   }
   if {$dMacAddr == {}} {
      set dMacAddr [logcmd stc::get $ethobj -dstMac]
   }

   if {$saMode != "idle"} {
      switch -glob [string tolower $saMode] {
         *inc* { set mode INCR }
         *dec* { set mode DECR }
         *rand* { set mode SHUFFLE }
         default { error "Unsupported stream modifier saMode = $saMode"}
      }
      # Use modifier to generate multiple streams.
      if {$saCount == ""} {set saCount $numFrames}
      
      set hRangeModifier [logcmd stc::create RangeModifier \
                             -under $stream \
                             -ModifierMode $mode \
                             -Mask "00:00:FF:FF:FF:FF" \
                             -StepValue "00:00:00:00:00:01" \
                             -Data [join $sMacAddr :] \
                             -RecycleCount $saCount \
                             -RepeatCount 0 \
                             -DataType NATIVE \
                             -EnableStream false \
                             -OffsetReference "sb1_eth.srcMac"]
   }
   
   if {$daMode != "idle"} {
      switch -glob [string tolower $daMode] {
         *inc* { set mode INCR }
         *dec* { set mode DECR }
         *rand* { set mode SHUFFLE }
         default { error "Unsupported stream modifier saMode = $saMode"}
      }
      # Use modifier to generate multiple streams.
      if {$daCount == ""} {set daCount $numFrames}
      set hRangeModifier [logcmd stc::create RangeModifier \
                             -under $stream \
                             -ModifierMode INCR \
                             -Mask "00:00:FF:FF:FF:FF" \
                             -StepValue "00:00:00:00:00:01" \
                             -Data [join $dMacAddr :] \
                             -RecycleCount $daCount \
                             -RepeatCount 0 \
                             -DataType NATIVE \
                             -EnableStream false \
                             -OffsetReference "sb1_eth.dstMac"]
   }
}

proc addVlans {args} {
   puts "[lindex [info level 0] 0] $args"
   parse_args addVlans $args {
      stream {}
      ethobj {}
      wTag "false"
      tagNo "002"
      tagCfi "resetCFI"
      tagMode "vIdle"
      tagRepeat "1"
      tagPriority "1"
      protocolTagId "null"
      protoOffsetEnable "false"
      userDefTag ""
   }
   
   set length 0
   regsub -all " " $userDefTag "" userDefTag
   if {[lindex $wTag 0] == "true" } {
      # Add only ONE vlan here
      # Add a Vlan container object
      set hVlanContainer [logcmd stc::get $ethobj -children-vlans]
      if {$hVlanContainer == {}} { set hVlanContainer [logcmd stc::create vlans -under $ethobj]}
      
      # Add a Vlan header to the container object.  This is required 
      # since there can be multiple VLANs 
      # as in Q-in-Q.
      if {$tagCfi == "resetCFI"} {set tagCfi 0} else {set tagCfi 1}
      if {$protocolTagId != "null"} {
#         set vlanHeaderHandle [logcmd stc::create Vlan -under $hVlanContainer -pri [int2bits $tagPriority 3] \
#                                  -cfi $tagCfi -id [format %i 0x$tagNo] -type [expr $protocolTagId]]
         set vlanHeaderHandle [logcmd stc::create Vlan -under $hVlanContainer -pri [int2bits $tagPriority 3] \
                                  -cfi $tagCfi -id $tagNo -type [expr $protocolTagId]]
      } else {
#         set vlanHeaderHandle [logcmd stc::create Vlan -under $hVlanContainer -pri [int2bits $tagPriority 3] \
#                                  -cfi $tagCfi -id [format %i 0x$tagNo]]
         set vlanHeaderHandle [logcmd stc::create Vlan -under $hVlanContainer -pri [int2bits $tagPriority 3] \
                                  -cfi $tagCfi -id $tagNo]
      }
      if {$tagMode != "vIdle"} {
         set hRangeModifier [logcmd stc::create RangeModifier \
                                -under $stream \
                                -ModifierMode INCR \
                                -StepValue "1" \
                                -Mask 0xFFFF \
                                -Data [format %i $tagNo] \
                                -RecycleCount $tagRepeat \
                                -DataType NATIVE \
                                -EnableStream false \
                                -OffsetReference "[logcmd stc::get $ethobj -name].vlans.[logcmd stc::get $vlanHeaderHandle -name].id"]
      }
      incr length 4
   } elseif {$protoOffsetEnable == "true"} {
      # Add one or more vlans here
      # Add a Vlan container object.
      set hVlanContainer [logcmd stc::create vlans -under $ethobj]
      
      # Add a Vlan header to the container object.  This is required 
      # since there can be multiple VLANs 
      # as in Q-in-Q. 
      set i 0
      set vlanInfoList [split $userDefTag ""]
      puts "UDT $userDefTag"
      set udtl [llength $vlanInfoList]
      set udtTop [expr $udtl - 3]
      for {set i 0} {$i < $udtl} {incr i 8} {
         set vlanTagType [join [lrange $vlanInfoList $i [expr $i+3]] ""]
         puts "vlanTagType $vlanTagType  vlanInfoList len = [llength $vlanInfoList]"
         if {[expr $i+5] <= $udtl} {
             puts "vlanPrio = [string range [int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+4] [expr $i+5]] ""]] 8] 0 2]"
             set vlanPrio [string range [int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+4] [expr $i+5]] ""]] 8] 0 2]
             puts "cfi [string index [int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+4] [expr $i+5]] ""]] 8] 3]"
             set cfi [string index [int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+4] [expr $i+5]] ""]] 8] 3]
         }
         if {[expr $i+7] <= $udtl} {
             puts "vlanid set vlanId [bits2int "[string range [int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+4] [expr $i+5]] ""]] 8] 4 7][int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+6] [expr $i+7]] ""]] 8]"]"
             set vlanId [bits2int "[string range [int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+4] [expr $i+5]] ""]] 8] 4 7][int2bits [expr 0x[join [lrange $vlanInfoList [expr $i+6] [expr $i+7]] ""]] 8]"]
         }
         set vlanHeaderHandle [logcmd stc::create Vlan -under $hVlanContainer -pri $vlanPrio -cfi $cfi -id $vlanId -type $vlanTagType]
         if {$tagMode != "vIdle"} {
            set hRangeModifier [logcmd stc::create RangeModifier \
                                   -under $stream \
                                   -ModifierMode INCR \
                                   -StepValue "1" \
                                   -Data $vlanId \
                                   -RecycleCount $tagRepeat \
                                   -DataType NATIVE \
                                   -EnableStream false \
                                   -OffsetReference "[logcmd stc::get $ethobj -name].vlans.[logcmd stc::get $vlanHeaderHandle -name].id"]
         }
         incr length 4
      }
   } 
   return $length
}

proc getPortList {} {
   global ahSpirentPort
   set portlist {}
   foreach {item value} [array get ahSpirentPort] {lappend portlist $value}
   return $portlist
}

proc adjustStcPacketSize {len offset} {
   if {[set i [expr $len - $offset]] < 4} {
      return [expr $offset + 4]
   }
   return $len
}

proc makeRipHeader {args} {

   parse_args makeRipHeader $args {
      ripCommand "ripRequest"
      ripVersion "2"
      ripAuthen ""
      ripAuthenType "2"
      ripNumRoute "1"
      ripRouteFamilyId {2}
      ripRouteIp {0.0.0.0}
      ripRouteTag {00}
      ripRouteMask {0.0.0.0} 
      ripRouteNextHop {0.0.0.0}
      ripRouteMetric {16}
      destPort 520
      sourcePort 520
      checksum 0
      length 0
   }

   # handle errors in test case


   set hexstring {}

   # make UDP
   append hexstring [format %04x $sourcePort]
   append hexstring [format %04x $destPort]
   append hexstring [format %04x [expr 8+4+($ripNumRoute*20)]]
   append hexstring 0000
   
   switch $ripCommand {
      ripRequest { append hexstring 01 }
      ripResponse { append hexstring 02 }
      default { append hexstring [format %02x $ripCommand]}
   }
   append hexstring [format %02x $ripVersion]
   append hexstring 0000
   for {set index 0} {$index < $ripNumRoute } {incr index} {

      # handle error in test case
      set tag 0x[lindex $ripRouteTag $index] ; if {![string is integer $tag]} {set tag 0}
      set nhop [lindex $ripRouteNextHop $index] ; if {[llength [split $nhop .]] != 4} {set nhop 0.0.0.0}
      
      append hexstring [format %04x [lindex $ripRouteFamilyId $index]]
      append hexstring [format %04x $tag]
      append hexstring [format %08x [ip2int [lindex $ripRouteIp $index]]]
      append hexstring [format %08x [ip2int [lindex $ripRouteMask $index]]]
      append hexstring [format %08x [ip2int $nhop]]
      append hexstring [format %08x [lindex $ripRouteMetric $index]]
   }
   append hexstring 0000
   return $hexstring
}


proc modifyOtherIPFields {sb ipobject initvalue offset bitcount count} {
   set bitlen [string range $bitcount 1 end]
   set origbitlen $bitlen
   set initvalue [join $initvalue {}]
   set mask [makeMask [getCounterByteLen $bitlen]]
   while {$bitlen > 0} {
      switch $offset {
         -20 {
            # Version
            set val 0x[string range $initvalue 0 0]
            set fieldcount [expr $count >> ($bitlen-4)]
            if {[string length [string range $mask 1 end]] > 0} {set repeatcount 0x[string range $mask 1 end]} else {set repeatcount 0}
            if {$fieldcount == 0} {
               # no incrementing
               logcmd stc::config $ipobject -version $val
            } else {
               #increment the version field
               set hRangeModifer1 [logcmd stc::create RangeModifier \
                                      -under $sb \
                                      -ModifierMode INCR \
                                      -Mask 0xF \
                                      -StepValue 1 \
                                      -Data $val \
                                      -RecycleCount $fieldcount \
                                      -RepeatCount $repeatcount \
                                      -DataType NATIVE \
                                      -EnableStream false \
                                      -OffsetReference "[stc::get $ipobject -name].version"]
            }
            
            # IHL
            set val 0x[string range $initvalue 1 1]
            set fieldcount [expr $count >> ($bitlen-8)]
            if {[string length [string range $mask 2 end]] > 0} {set repeatcount 0x[string range $mask 2 end]} else {set repeatcount 0}
            if {$fieldcount == 0} {
               # no incrementing
               logcmd stc::config $ipobject -ihl $val
            } else {
               set hRangeModifer1 [logcmd stc::create RangeModifier \
                                      -under $sb \
                                      -ModifierMode INCR \
                                      -Mask 0xF \
                                      -StepValue 1 \
                                      -Data $val \
                                      -RecycleCount $fieldcount \
                                      -RepeatCount $repeatcount \
                                      -DataType NATIVE \
                                      -EnableStream false \
                                      -OffsetReference "[stc::get $ipobject -name].ihl"]
            }
            set offset -19
            set initvalue [string range $initvalue 2 end]
            set mask [string range $mask 2 end]
            incr bitlen -8
         }
         -19 {
            # TOS
            set val 0x[string range $initvalue 0 1]
            set fieldcount [expr $count >> ($bitlen-8)]
            if {[string length [string range $mask 2 end]] > 0} {set repeatcount 0x[string range $mask 2 end]} else {set repeatcount 0}
            if {$fieldcount == 0} {
               # no incrementing
               logcmd stc::config $ipobject -ihl $val
            } else {
               set hRangeModifer1 [logcmd stc::create RangeModifier \
                                      -under $sb \
                                      -ModifierMode INCR \
                                      -Mask 0xFF \
                                      -StepValue 1 \
                                      -Data $val \
                                      -RecycleCount $fieldcount \
                                      -RepeatCount $repeatcount \
                                      -DataType NATIVE \
                                      -EnableStream false \
                                      -OffsetReference "[stc::get $ipobject -name].tosDiffserv.tos"]
            }
            set offset -18
            set initvalue [string range $initvalue 2 end]
            set mask [string range $mask 2 end]
            incr bitlen -8   
         }
         -18 {
            # Total Length
            # handle incr only first byte
            switch $bitlen {
               8  {set val 0x[string range $initvalue 0 end]00; set fieldcount [expr $count && 0xff]; set step 0x0100}
               default {set val 0x[string range $initvalue 0 3]; set fieldcount [expr $count >> ($bitlen-16)] ; set step 1}
            }
            if {[string length [string range $mask 4 end]] > 0} {set repeatcount 0x[string range $mask 4 end]} else {set repeatcount 0}
            if {$fieldcount == 0} {
               # no incrementing
               logcmd stc::config $ipobject -ihl $val
            } else {
               set hRangeModifer1 [logcmd stc::create RangeModifier \
                                      -under $sb \
                                      -ModifierMode INCR \
                                      -Mask 0xFFFF \
                                      -StepValue $step \
                                      -Data $val \
                                      -RecycleCount $fieldcount \
                                      -RepeatCount $repeatcount \
                                      -DataType NATIVE \
                                      -EnableStream false \
                                      -OffsetReference "[stc::get $ipobject -name].totalLength"]
            }
            set offset -16
            set initvalue [string range $initvalue 4 end]
            set mask [string range $mask 4 end]
            incr bitlen -16   
         }
         -14 {
            # Fragment offset
            set fieldcount [expr $count && 0x1FFF ]
            set val 0x$initvalue
             if {$fieldcount == 0} {
               # no incrementing
               logcmd stc::config $ipobject -fragOffset $val
            } else {
               set hRangeModifer1 [logcmd stc::create RangeModifier \
                                      -under $sb \
                                      -ModifierMode INCR \
                                      -Mask 0x1FFF \
                                      -StepValue 1 \
                                      -Data $val \
                                      -RecycleCount $fieldcount \
                                      -RepeatCount 0 \
                                      -DataType NATIVE \
                                      -EnableStream false \
                                      -OffsetReference "[stc::get $ipobject -name].fragOffset"]
            }
            incr bitlen -16              
         }
         default {error "Unsupported offset into IP field $offset"}
      }
   }
}

proc insertUdfInHeader { hStreamBlock headerstring udfInitval udfOffset udfCountertype } {
   set udfInitval [join $udfInitval {}]
   set countersize [string range $udfCountertype 1 end]
   foreach {hdr offset} $headerstring {
      puts "$hdr $offset"
      if {$udfOffset < $offset} {
         set loc [expr $offset - $udfOffset]
         puts "The LOC : $loc"
         switch -glob $hdr {
            ???_llc  {
               set iloc 0
               for {set i $countersize} {$i > 0} {incr i -8} { 
                  lappend off_rep_val $loc [expr (1 << ($i -8)) -1] [string range $udfInitval $iloc [expr $iloc+1]]
                  incr iloc 2 ; incr loc -1
               }
               puts $off_rep_val
               array set llcfield [list 3 dsap 2 ssap 1 control]
               foreach {off rep val} $off_rep_val {
                  if {[info exist llcfield($off)]} {
                     set hRangeModifer1 [logcmd stc::create RangeModifier \
                                            -under $hStreamBlock \
                                            -ModifierMode INCR \
                                            -Mask ff \
                                            -StepValue 1 \
                                            -Data $val \
                                            -RecycleCount 0 \
                                            -RepeatCount $rep \
                                            -DataType NATIVE \
                                            -EnableStream false \
                                            -OffsetReference "sb1_eth.llcheader.$llcfield($off)"]                  
                  } else {
                     puts "WARNING, UDF offset went beyond end of LLC"
                  }
               }
            }
            ???_snap {
               switch $loc {
                  2 {
                     set hRangeModifer1 [logcmd stc::create RangeModifier \
                                            -under $hStreamBlock \
                                            -ModifierMode INCR \
                                            -Mask ffff \
                                            -StepValue 1 \
                                            -Data $udfInitval \
                                            -RecycleCount 0 \
                                            -RepeatCount 0 \
                                            -DataType NATIVE \
                                            -EnableStream false \
                                            -OffsetReference "sb1_eth.snapheader.EthernetType"]                  
                    

                  }
               }
            }
            default { error "No Match $hdr" }
         }
      } 
   }
}


##################################################################
# Procedure Name: icetMakeExternalPeer
#
# Description:  Setup an external BGP peer on the ixia protocol
#               server. Internal proc not exposed out of lib.
#
#
# Input args: args
# Output args: none
# Typical usage:
#      set returnCode [icetMakeExternalPeer -myIp $myIp -dutIp $dutIp -asNumber $asNum \
#          -ipNetworkList $ipNetworkListValue \
#          -fromPrefixList $fromPrefixListValue -thruPrefixList $thruPrefixListValue -numRoutesList $numRoutesListValue \
#          -txPortId $txPortId -communityList $communityListValue -clusterList $clusterListValue -asTypeList $asTypeListValue \
#          -medList $medListValue -asPathList $asPathListValue -originProtocolList $originProtocolListValue \
#          -localPrefList $localPrefListValue \
#          -routeFlapDropTimeList $routeFlapDropTimeListValue \
#          -routeFlapTimeList $routeFlapTimeListValue -routesToFlapFromList $routesToFlapFromListValue \
#          -routesToFlapToList $routesToFlapToListValue -linkFlapDropTime $linkFlapDropTimeValue \
#          -linkFlapTime $linkFlapTimeValue]
#
#
# Category Types (SetupSwitch,GetSwitchInfo,SendTraffic,CaptureTraffic,
#                 SetupTestTool,VerifySwitchOutput,Utility,VerifyTraffic)
# Category: SetupTestTool
##################################################################
proc icetMakeExternalPeer {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args icetMakeExternalPeer $args {
      deviceHndl ""
      dutIp "1.1.1.1"
      dutAsNumber 1
      myIp "1.1.1.2"
      asNumber "9999"
      ipNetworkList ""
      fromPrefixList ""
      thruPrefixList ""
      localPrefList ""
      numRoutesList ""
      originProtocolList ""
      txPortId  "1"
      communityList ""
      expcomList ""
      clusterList ""
      asTypeList ""
      mode ""
      asPathList ""
      medList ""
      atomicaggregateList ""
      routeFlapDropTimeList ""
      routeFlapTimeList ""
      routesToFlapFromList ""
      routesToFlapToList ""
      linkFlapDropTime ""
      linkFlapTime ""
      extendedcommunity "false"
      extendedcommunityList ""
      graceRestart ""
      graResTime ""
      graStaleTime ""
      4byteAs "false"
      neighborType "external"
      nextHopList ""
      originatorId ""
   }
   
   result_debug "myIp=($myIp) dutIp=($dutIp)"
   
   set index [llength $ipNetworkList]
   result_debug "index = $index";
   if {[llength $fromPrefixList]!=$index || [llength $thruPrefixList]!=$index || [llength $numRoutesList]!=$index} {
      result_debug "Error in input args:fromPrefixList,thruPrefixList,numRoutesList,ipNetworkList should be same length"
      return -1
   }
# !!!!! no setting for ext/int (maybe inherits from route adv)
#   bgp4Neighbor config  -type  bgp4NeighborExternal
#   bgp4Neighbor config  -enable true
   append bgpAttributes " -BgpSessionIpAddress INTERFACE_IP"
#   bgp4Neighbor config -localIpAddress $myIp
#   bgp4Neighbor config -rangeCount 1
   append bgpAttributes " -DutIpv4Addr $dutIp"
#   bgp4Neighbor config -dutIpAddress $dutIp
   if {![regexp -nocase "false" $4byteAs]} {

      append bgpAttributes " -Enable4ByteAsNum true -AsNum4Byte $asNumber -asNum 23456 -dutasNum 23456 -DutAsNum4Byte $dutAsNumber"
#      catch [bgp4Neighbor config -enable4ByteAsNumber $4byteAs] resultCatch  
#      if  [regexp "type.*enable" $resultCatch] {
#         return -1
#      }
   } else {
      append bgpAttributes " -AsNum $asNumber -DutAsNum $dutAsNumber"
#      bgp4Neighbor config -localAsNumber $asNumber
   }
   # add link flap
   if {$linkFlapDropTime!=""} {
      puts "NEED to add Link Flapping"
#      bgp4Neighbor config -enableLinkFlap true
#      bgp4Neighbor config -linkFlapDropTime $linkFlapDropTime
#      bgp4Neighbor config -linkFlapTime $linkFlapTime
   } else {
#      bgp4Neighbor config -enableLinkFlap false
   }
   if {$graceRestart !=""} {
      append bgpAttributes " -GracefulRestart true -RestartDelay $graStaleTime -RestartTime $graResTime"
#      bgp4Neighbor config -enableGracefulRestart  true
#      bgp4Neighbor config -restartTime $graResTime
#      bgp4Neighbor config -staleTime   $graStaleTime
   }
   set bgpRouterConfigHndl [eval "logcmd stc::create BgpRouterConfig -under $deviceHndl [subst $bgpAttributes]"] 
   for {set i 0} {$i<$index} {incr i} {
      set ipNetwork [lindex $ipNetworkList $i]
      set fromPrefix [lindex $fromPrefixList $i]
      set thruPrefix [lindex $thruPrefixList $i]
      set numRoutes [lindex $numRoutesList $i]
      set nextHop [lindex $nextHopList $i]
      set origId [lindex $originatorId $i]
      #set ecom [lindex $extendedcommunity $i]
      set ecom $extendedcommunity
      if {[regexp -nocase $ecom "true"]} {
         set extcom [lindex $extendedcommunityList $i]
      } else {
         set extcom ""
      }
      result_debug "ipNetwork $ipNetwork"
      result_debug "fromPrefix $fromPrefix"
      result_debug "thruPrefix $thruPrefix"
      result_debug "numRoutes $numRoutes"
      result_debug "ecom $ecom"
      result_debug "extcom $extcom"
      

#      bgp4RouteItem config -networkAddress $ipNetwork
#      bgp4RouteItem config -fromPrefix $fromPrefix
#      bgp4RouteItem config -thruPrefix $thruPrefix
#      bgp4RouteItem config -numRoutes $numRoutes
      if {[llength $localPrefList]!=0} {
         set localPref [lindex $localPrefList $i]
         if {$localPref!="" || $neighborType == "internal"} {
            if {$localPref == ""} {set localPref 1}
            result_debug "localPref $localPref"
#!!!!  no option i can find to enable
#            bgp4RouteItem config -enableLocalPref 1
#            bgp4RouteItem config -localPref $localPref
            append ipv4RouteAttrs " -LocalPreference $localPref"						
         }
      }
      
      #---newely added for mode
      
      if {$mode != ""} {
         set modeType [lindex $mode $i]
         if {$modeType == {}} {set modeType [lindex $mode 0]}
         result_debug "modeType $modeType"
         append ipv4RouteAttrs " -RouteSubAfi $modeType"						
#          if {$modeType == "unicast"} {
#             bgp4RouteItem config -enableIncludeMulticast false
#             bgp4RouteItem config -enableProperSafi false
#             bgp4RouteItem config -enableTraditionalNlriUpdate true
#          } else {
#             bgp4RouteItem config -enableIncludeMulticast true
#             bgp4RouteItem config -enableProperSafi true
#             bgp4RouteItem config -enableTraditionalNlriUpdate false
#          }
      }
      
      if {$nextHop!=""} {
         result_debug "the nexthop $nextHop"
         append ipv4RouteAttrs " -NextHop $nextHop"						
#           bgp4RouteItem config -nextHopIpAddress $nextHop
#           bgp4RouteItem config -nextHopMode 1
#           bgp4RouteItem config -nextHopSetMode bgpRouteNextHopSetManually
      } else {
         append ipv4RouteAttrs " -NextHop $myIp"						
#          bgp4RouteItem config -nextHopIpAddress $myIp
      }
#       bgp4RouteItem config -enableNextHop 1
#       bgp4RouteItem config -nextHopIpAddress $myIp
      if {$origId !=""} {
         append ipv4RouteAttrs " -OriginatorId $origId"						
#          bgp4RouteItem config -enableOriginatorId true
#          bgp4RouteItem config -originatorId $origId
      } else {
         append ipv4RouteAttrs " -origin EGP"
      }
#!!!! not sure what this is
#      append ipv4RouteAttrs " -OriginatorId [lindex $originProtocolList $i]"
      
#      bgp4RouteItem config -originProtocol [lindex $originProtocolList $i]
#      bgp4RouteItem config -enableRouteRange true
      if {[llength $communityList] != 0} {
         # --- 65535:65281 = NO_EXPORT
         set community1 [lindex $communityList $i]
         if {[llength $expcomList] != 0} {
            set expcom [lindex $expcomList $i]
         } else {
            set expcom "null"
         }
         
         if {($community1 != "null") && ($expcom == "null")} {
            result_debug "community1 $asNumber$community1"
            set coms {}
            foreach com $community1 {lappend coms [formatBgpCommunity $community1]}
            set coms [join $coms ,]
           #  append ipv4RouteAttrs " -Community $asNumber:$community1"						
            append ipv4RouteAttrs " -Community $coms"						
#            bgp4RouteItem config -enableCommunity  1
#            bgp4RouteItem config -communityList $community1
         } elseif {($community1 != "null") && ($expcom != "null") } {
            result_debug "community1 $community1"
            result_debug "expcom $expcom"
            #expcom = 1 (NO_EXPORT)
            #expcom = 2 (NO_ADVERTISE)
            #expcom = 3 (NO_EXPORT_SUBCONFED)
            if {$expcom ==1} {
#               bgp4RouteItem config -enableCommunity  1
               append ipv4RouteAttrs " -Community {[formatBgpCommunity $community1],65535:65281}"
#               bgp4RouteItem config -communityList "$community1 65535:65281"
            } elseif {$expcom ==2} {
#               bgp4RouteItem config -enableCommunity  1
               append ipv4RouteAttrs " -Community {[formatBgpCommunity $community1],65535:65282}"
#               bgp4RouteItem config -communityList "$community1 65535:65282"
            } else {
#               bgp4RouteItem config -enableCommunity  1
               append ipv4RouteAttrs " -Community {[formatBgpCommunity $community1],65535:65283}"
#               bgp4RouteItem config -communityList "$community1 65535:65283"
            }
         }
      }
      if {[llength $clusterList] != 0} {
         set cluster1 [lindex $clusterList $i]
         if {$cluster1 != "null"} {
            result_debug "cluster1 $cluster1"
#            bgp4RouteItem config -enableCluster 1
#            bgp4RouteItem config -clusterList $cluster1
            append ipv4RouteAttrs " -clusterIdList [int2ip $cluster1]"
         }
      }
#      bgp4RouteItem config -enableASPath  1
#      bgp4AsPathItem setDefault
      if {[llength $asPathList]!=0} {
         set aslist [lindex $asPathList $i]
         set asSegmentTypes [lindex $asTypeList $i]
         if {$aslist!=""} {
            append ipv4RouteAttrs " -AsPathSegmentType {$asSegmentTypes}"
            append ipv4RouteAttrs " -AsPath {$aslist}"
#             set indice 0
# #            bgp4RouteItem clearASPathList
#             foreach asType $asSegmentTypes {
#                bgp4AsPathItem config -enableAsSegment true
#                bgp4AsPathItem config -asSegmentType $asType
#                if {[llength $asSegmentTypes]>1} {
#                   bgp4AsPathItem config -asList [lindex $aslist $indice]
#                } else {
#                   bgp4AsPathItem config -asList $aslist
#                }
#                incr indice
#                if {[bgp4RouteItem addASPathItem]} {
#                   result_debug "Error Adding AS_PATH item"
#                }
#             }
         } else {
            append ipv4RouteAttrs " -AsPath [concat $aslist 257 ]"
#             bgp4AsPathItem config -enableAsSegment false
#             bgp4AsPathItem config -asPathSeqList [list $asNumber 257 ]
#             bgp4RouteItem clearASPathList    ;# for ixia 3.5 version and above
         }
      } else {
         append ipv4RouteAttrs " -AsPath $asNumber"
#         bgp4AsPathItem config -enableAsSegment false
#         bgp4RouteItem clearASPathList    ;# for ixia 3.5 version and above
      }
      if {[llength $medList]!=0} {
         set med [lindex $medList $i]
         if {$med!=""} {
            result_debug "med $med"
            append ipv4RouteAttrs " -Med $med"
#             bgp4RouteItem config -enableMED 1
#             bgp4RouteItem config -med $med
         }
      }
      # add ATomic aggregate
      if {[llength $atomicaggregateList]!=0} {
         set aggregate [lindex $atomicaggregateList $i]
         if {$aggregate == 1} {
#            bgp4RouteItem config -enableAtomicAggregate true
            append ipv4RouteAttrs " -AtomicAggregatePresent true"
         } else {
#            bgp4RouteItem config -enableAtomicAggregate false
            append ipv4RouteAttrs " -AtomicAggregatePresent false"
         }
      }
      # add route flap
      set routeFlapDropTime [lindex $routeFlapDropTimeList $i]
      if {($routeFlapDropTime!="") && ($routeFlapDropTime!="null")} {
         result_debug "-Do route Flap"
         set routeFlapTime [lindex $routeFlapTimeList $i]
         set routesToFlapFrom [lindex $routesToFlapFromList $i]
         set routesToFlapTo [lindex $routesToFlapToList $i]
         puts "NEED to add route Flapping here"
#          bgp4RouteItem config -enableRouteFlap 1
#          bgp4RouteItem config -routeFlapDropTime $routeFlapDropTime
#          bgp4RouteItem config -routeFlapTime $routeFlapTime
#          bgp4RouteItem config -routesToFlapFrom $routesToFlapFrom
#          bgp4RouteItem config -routesToFlapTo $routesToFlapTo
      } else {
#         bgp4RouteItem config -enableRouteFlap 0
      }
#       set rr [expr $i +1]
#       if {[bgp4Neighbor addRouteRange routeRange$rr]} {
#          result_debug "Error Adding Route item"
#       }

      #---newely added for extended community
#       set param ""
#       set valueLst ""
#       set extcommunity ""
#       set ipv4RouteAttrs {}
      if {($ecom == "true") && ($extcom != "null")} {
         # clear routes from device not needed because device is new
         set ex {}
         foreach extcommunity $extcom {

            set param    [split $extcommunity :]
            set subType  [string toupper [lindex $param 0]]
            set value    [join [lrange $param 1 end] :]
            

#             set param ""
#             set valueLst ""
#             set param [split $extcommunity :]
#             if {[lindex $param 0] == "rt"} {
#                bgp4ExtendedCommunity config -subType 2
#             } else {
#                bgp4ExtendedCommunity config -subType 3
#             }
             if {[regexp {[0-9]+\.} [lindex $param 1]]} {
                set type 0x01
#                 bgp4ExtendedCommunity config -type 1
#                 set ipLst [split [lindex $param 1] "."]
#                 foreach ip $ipLst {
#                    set value1 [dectohex $ip]
#                    if {[string length $value1] == 1} {
#                       lappend valueLst "0$value1"
#                    } elseif {[string length $value1] == 2} {
#                       lappend valueLst "$value1"
#                    }
#                 }
#                 set value2 [dectohex [lindex $param 2]]
#                 lappend valueLst [conVal2Byte 2 $value2]
             } else {
                regexp {[0-9]+} [lindex $param 1] val
                set value1 [dectohex $val]
                set value2 [dectohex [lindex $param 2]]
                if [regexp -nocase "L" [lindex $param 1]] {
                   set type 0x02
#                    bgp4ExtendedCommunity config -type 2
#                    lappend valueLst [conVal2Byte 4 $value1]
#                    lappend valueLst [conVal2Byte 2 $value2]
                } else {
                   set type 0x00
#                    bgp4ExtendedCommunity config -type 0
#                    lappend valueLst [conVal2Byte 2 $value1]
#                    lappend valueLst [conVal2Byte 4 $value2]
                }
             }
            
            lappend ex $type:$subType:$value
         }
         append ipv4RouteAttrs " -ExtendedCommunity {[join $ex ,]}"
      }

      set hBgpIpv4Route [eval "logcmd stc::create BgpIpv4RouteConfig  -under $bgpRouterConfigHndl \
                               [subst $ipv4RouteAttrs]"]

      logcmd stc::config [logcmd stc::get $hBgpIpv4Route -children-Ipv4NetworkBlock] \
         -NetworkCount $numRoutes -StartIpList $ipNetwork -PrefixLength $fromPrefix
   }
   logcmd stc::apply
   return 0
}

proc icetMakeInternalPeer {args} {
   append args " -neighborType internal"
   return [eval icetMakeExternalPeer $args]
}


proc icetMakeInternalPeerx {args} {
   parse_args icetMakeInternalPeer $args {
     myIp "1.1.1.2"
     dutIp "1.1.1.1"
     asNumber "9999"
     ipNetworkList ""
     fromPrefixList ""
     thruPrefixList ""
     numRoutesList ""
     originProtocolList ""
     txPortId  "1"
     localPrefList ""
     communityList ""
     expcomList ""
     clusterList ""
     asTypeList ""
     mode ""
     asPathList ""
     medList ""
     nextHopList ""
     routeFlapDropTimeList ""
     routeFlapTimeList ""
     routesToFlapFromList ""
     routesToFlapToList ""
     linkFlapDropTime ""
     linkFlapTime ""
     originatorId ""
     extendedcommunity "false"
     extendedcommunityList ""
     4byteAs "false"
   }

   set index [llength $ipNetworkList]
   puts "index = $index";
   if {[llength $fromPrefixList]!=$index || [llength $thruPrefixList]!=$index || [llength $numRoutesList]!=$index} {
      result_debug "Error in input args:fromPrefixList,thruPrefixList,numRoutesList,ipNetworkList should be same length"
      return -1
   }

   for {set i 0} {$i < $index} {incr i} {
#        set ipNetwork [lindex $ipNetworkList $i]
#        set fromPrefix [lindex $fromPrefixList $i]
#        set thruPrefix [lindex $thruPrefixList $i]
#        set numRoutes [lindex $numRoutesList $i]
#        set nextHop [lindex $nextHopList $i]
#        set origId [lindex $originatorId $i]
#        #set ecom [lindex $extendedcommunity $i]
#        set ecom $extendedcommunity
#        if {[regexp -nocase $ecom "true"]} {
#          set extcom [lindex $extendedcommunityList $i]
#        } else {
#          set extcom ""
#        }
#        result_debug "ipNetwork $ipNetwork"
#        result_debug "fromPrefix $fromPrefix"
#        result_debug "thruPrefix $thruPrefix"
#        result_debug "numRoutes $numRoutes"
#        result_debug "ecom $ecom"
#        result_debug "extcom $extcom"

 #---newely added for extended community
      set param ""
      set valueLst ""
      set extcommunity ""
#       if {($ecom == "true") && ($extcom != "null")} {
#          puts "#############*********** coming here ########*********"
#          bgp4RouteItem clearExtendedCommunityList
#          bgp4ExtendedCommunity setDefault
#          foreach extcommunity $extcom {
#             set param ""
#             set valueLst ""
#             set param [split $extcommunity :]
#             if {[lindex $param 0] == "rt"} {
#                bgp4ExtendedCommunity config -subType 2
#             } else {
#                bgp4ExtendedCommunity config -subType 3
#             }
#             if {[regexp {[0-9]+\.} [lindex $param 1]]} {
#                bgp4ExtendedCommunity config -type 1
#                set ipLst [split [lindex $param 1] "."]
#                foreach ip $ipLst {
#                   set value1 [dectohex $ip]
#                   if {[string length $value1] == 1} {
#                      lappend valueLst "0$value1"
#                   } elseif {[string length $value1] == 2} {
#                      lappend valueLst "$value1"
#                   }
#                }
#                set value2 [dectohex [lindex $param 2]]
#                lappend valueLst [conVal2Byte 2 $value2]
#             } else {
#                regexp {[0-9]+} [lindex $param 1] val
#                set value1 [dectohex $val]
#                set value2 [dectohex [lindex $param 2]]
#                if [regexp -nocase "L" [lindex $param 1]] {
#                   bgp4ExtendedCommunity config -type 2
#                   lappend valueLst [conVal2Byte 4 $value1]
#                   lappend valueLst [conVal2Byte 2 $value2]
#                } else {
#                   bgp4ExtendedCommunity config -type 0
#                   lappend valueLst [conVal2Byte 2 $value1]
#                   lappend valueLst [conVal2Byte 4 $value2]
#                }
#             }
            
#             set valueLst [join $valueLst]
#             result_debug "value list is $valueLst"
#             bgp4ExtendedCommunity config -value  "$valueLst"
#             bgp4RouteItem addExtendedCommunity
#          }
#       }
#        bgp4RouteItem setDefault
#        bgp4RouteItem config -asPathSetMode bgpRouteAsPathNoInclude
#        bgp4RouteItem config -networkAddress $ipNetwork
#        bgp4RouteItem config -fromPrefix $fromPrefix
#        bgp4RouteItem config -thruPrefix $thruPrefix
#        bgp4RouteItem config -numRoutes $numRoutes
#---newely added for mode

#       if {$mode != ""} {
#        set modeType [lindex $mode $i]
#        result_debug "modeType $modeType"
#        if {$modeType == "unicast"} {
#            bgp4RouteItem config -enableIncludeMulticast false
#            bgp4RouteItem config -enableProperSafi false
#            bgp4RouteItem config -enableTraditionalNlriUpdate true
#           } else {
#            bgp4RouteItem config -enableIncludeMulticast true
#            bgp4RouteItem config -enableProperSafi true
#            bgp4RouteItem config -enableTraditionalNlriUpdate false
#       }
#       }

#       bgp4RouteItem config -enableNextHop 1
#        if {$nextHop!=""} {
#           result_debug "the nexthop $nextHop"
#           bgp4RouteItem config -nextHopIpAddress $nextHop
#           bgp4RouteItem config -nextHopMode 1
#           bgp4RouteItem config -nextHopSetMode bgpRouteNextHopSetManually
#        } else {
#           bgp4RouteItem config -nextHopIpAddress $myIp
#        }
#        if {$origId !=""} {
#           bgp4RouteItem config -enableOriginatorId true
#           bgp4RouteItem config -originatorId $origId
#        }
#        set localPref [lindex $localPrefList $i]
#        if {$localPref==""} {
#           set $localPref 0
#        }
#        result_debug "localPref $localPref"
#        bgp4RouteItem config -enableLocalPref 1
#        bgp4RouteItem config -localPref $localPref
#        bgp4RouteItem config -originProtocol [lindex $originProtocolList $i]
#        bgp4RouteItem config -enableRouteRange true
#        if {[llength $communityList] != 0} {
#            # --- 65535:65281 = NO_EXPORT
#            set community1 [lindex $communityList $i]
#            if {[llength $expcomList] != 0} {
#            set expcom [lindex $expcomList $i]
#            } else {
#            set expcom "null"
#           }

#            if {($community1 != "null") && ($expcom == "null")} {
#                result_debug "community1 $community1"
#                bgp4RouteItem config -enableCommunity  1
#                bgp4RouteItem config -communityList $community1
#            } elseif {($community1 != "null") && ($expcom != "null") } {
#             result_debug "community1 $community1"
#             result_debug "expcom $expcom"
#             #expcom = 1 (NO_EXPORT)
#             #expcom = 2 (NO_ADVERTISE)
#             #expcom = 3 (NO_EXPORT_SUBCONFED)
#               if {$expcom ==1} {
#                bgp4RouteItem config -enableCommunity  1
#                bgp4RouteItem config -communityList "$community1 65535:65281"
#                } elseif {$expcom ==2} {
#                bgp4RouteItem config -enableCommunity  1
#                bgp4RouteItem config -communityList "$community1 65535:65282"
#               } else {
#                bgp4RouteItem config -enableCommunity  1
#                bgp4RouteItem config -communityList "$community1 65535:65283"
#             }
#          }
#        }
#        if {[llength $clusterList] != 0} {
#            set cluster1 [lindex $clusterList $i]
#            if {$cluster1 != "null"} {
#                result_debug "cluster1 $cluster1"
#                bgp4RouteItem config -enableCluster 1
#                bgp4RouteItem config -clusterList $cluster1
#            }
#        }

       bgp4RouteItem config -enableASPath  1
       bgp4AsPathItem setDefault
       if {[llength $asPathList]!=0} {
          set aslist [lindex $asPathList $i]
          set asSegmentTypes [lindex $asTypeList $i]
          if {$aslist!=""} {
             set indice 0
             bgp4RouteItem clearASPathList
             foreach asType $asSegmentTypes {
                result_debug "the asType $asType and asList $aslist"
                bgp4AsPathItem config -enableAsSegment true
                bgp4AsPathItem config -asSegmentType $asType
                if {[llength $asSegmentTypes]>1} {
                   bgp4AsPathItem config -asList [lindex $aslist $indice]
                } else {
                   bgp4AsPathItem config -asList $aslist
                }
                incr indice
                if {[bgp4RouteItem addASPathItem]} {
                   result_debug "Error Adding AS_PATH item"
                }
             }
          } else {
             bgp4AsPathItem config -enableAsSegment false
              bgp4AsPathItem config -asPathSeqList [list $asNumber 257 ]
#              if {[bgp4RouteItem addASPathItem]} {
#                 result_debug "Error Adding AS_PATH item"
#              }
             bgp4RouteItem clearASPathList    ;# for ixia 3.5 version and above
          }
          #result_debug "AS_PATH ($aslist)"
       } else {
             bgp4AsPathItem config -enableAsSegment false
          bgp4AsPathItem config -asPathSeqList [list $asNumber 257 ]
#          if {[bgp4RouteItem addASPathItem]} {
#             result_debug "Error Adding AS_PATH item"
#          }
         bgp4RouteItem                clearASPathList    ;# for ixia 3.5 version and above
       }

#        if {[llength $medList]!=0} {
#            set med [lindex $medList $i]
#            if {$med!=""} {
#                result_debug "med $med"
#                bgp4RouteItem config -enableMED 1
#                bgp4RouteItem config -med $med
#            }
#        }
       # add route flap
#        set routeFlapDropTime [lindex $routeFlapDropTimeList $i]
#        if {($routeFlapDropTime!="") && ($routeFlapDropTime != "null")} {
#            result_debug "-Do route Flap"
#            set routeFlapTime [lindex $routeFlapTimeList $i]
#            set routesToFlapFrom [lindex $routesToFlapFromList $i]
#            set routesToFlapTo [lindex $routesToFlapToList $i]
#            bgp4RouteItem config -enableRouteFlap 1
#            bgp4RouteItem config -routeFlapDropTime $routeFlapDropTime
#            bgp4RouteItem config -routeFlapTime $routeFlapTime
#            bgp4RouteItem config -routesToFlapFrom $routesToFlapFrom
#            bgp4RouteItem config -routesToFlapTo $routesToFlapTo
#        } else {
#            bgp4RouteItem config -enableRouteFlap 0
#        }
#        set rr [expr $i +1]
#        if {[bgp4Neighbor addRouteRange routeRange$rr]} {
#            result_debug "Error Adding Route item"
#        }
# }
#    bgp4Neighbor config  -type  bgp4NeighborInternal
#    bgp4Neighbor config  -enable true
#    if {![regexp -nocase "false" $4byteAs]} {
#       bgp4Neighbor config -enable4ByteAsNumber $4byteAs
#    }
#    bgp4Neighbor config -localIpAddress $myIp
#    bgp4Neighbor config -rangeCount 1
#    bgp4Neighbor config -dutIpAddress $dutIp

   # add link flap
#    if {$linkFlapDropTime!=""} {
#        bgp4Neighbor config -enableLinkFlap true
#        bgp4Neighbor config -linkFlapDropTime $linkFlapDropTime
#        bgp4Neighbor config -linkFlapTime $linkFlapTime
#    } else {
#        bgp4Neighbor config -enableLinkFlap false
#    }

}
proc extrMakeIsisRouter {args} {
   parse_args extrMakeIsisRouter $args {
      interfaceId ""
      interfaceIp ""
      ipMask ""
      areaId ""
      level "isisLevel2"
      helloIntervalL1 10
      deadIntervalL1 30
      helloIntervalL2 10
      deadIntervalL2 30
      networkType "isisBroadcast"
      metric 10
      routeMetric 10
      routeOrigin ""
      numNetworks 0
      prefix ""
      networkIp ""
      routerId ""
      routerLocalId "1"
      txPortId  "1"
      dutIp ""
   }
   

   result_debug "inside extrMakeIsisRouter"
   result_debug "interfaceId: $interfaceId"
   result_debug "interfaceIp: $interfaceIp"
   result_debug "ipMask: $ipMask"
   result_debug "areaId: $areaId"
   result_debug "level: $level"
   result_debug "prefix: $prefix"
   result_debug "networkIp: $networkIp"
   result_debug "routerId: $routerId"
   result_debug "routeOrigin: $routeOrigin"
   
   set txPortId [hMapPortIdToSpirentPort $txPortId]
   logcmd stc::perform SetupPortsCommand -PortList $txPortId -Mtu 1492
   array set cmdResults [logcmd stc::perform DeviceCreateCommand -ParentList [logcmd stc::get system1 -children-project] \
                            -port $txPortId -IfStack "Ipv4If EthIIIf" -IfCount "1 1"]
   set deviceHndl $cmdResults(-ReturnList)
   logcmd stc::config $deviceHndl -RouterId [makeRouterId $routerId]
   logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv4If]  -Address $interfaceIp -Gateway $dutIp -PrefixLength 24 
   logcmd stc::config [logcmd stc::get $deviceHndl -children-EthIIIf] -SourceMac [join $routerId :]

   # not setting area id, causes test case 5.7.3 to fail, removed  "-Area1 $areaId -Area2 {} -Area3 {}"
   set isisAttributes "-under $deviceHndl -IpVersion IPv4"

#    isisRouter config -enable true
#    isisRouter config -routerId $routerId
   append isisAttributes " -SystemId [join $routerId :]"
#    isisRouter config -areaAddressList $areaId
#    isisInterface setDefault
#    isisInterface config -enable true
#    isisInterface config -connectToDut true
#    isisInterface config -ipAddress $interfaceIp
#    isisInterface config -ipMask $ipMask
#   isisInterface config -metric $metric
#   isisInterface config -interfaceId $interfaceId
#   append isisAttributes " -CircuitId [join $interfaceId :]"
#   isisInterface config -networkType $networkType
   switch -glob [string tolower $networkType] {
      *broadcast {
         append isisAttributes " -NetworkType BROADCAST"
      }
      *p* {
         append isisAttributes " -NetworkType P2P"
      }
      default { error "Unsupported ISIS network type $networkType" }
   }
#   isisInterface config -level $level
##   isisInterface config -enableTrafficEngineering false
#   append isisAttributes " -"
##   isisInterface config -trafficEngineeringMetric2 10
#   append isisAttributes " -TeRouterId "
#   isisInterface config -administrativeGroup {0.0.0.0}
#    append isisAttributes " -MtId 0.0.0.0"
#    isisInterface config -maxBandwidth 0.0
#    append isisAttributes " -"
#    isisInterface config -maxReservableBandwidth 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority0 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority1 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority2 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority3 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority4 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority5 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority6 0.0
#    append isisAttributes " -"
#    isisInterface config -unreservedBandwidthPriority7 0.0
#    append isisAttributes " -"
   switch $level {
      isisLevel1 {
         append isisAttributes " -Level LEVEL1"
         append isisAttributes " -L1Metric 10 -L1WideMetric 10"
         append isisAttributes " -HelloInterval $helloIntervalL1"
         set level LEVEL1
      }
      isisLevel2 {
         append isisAttributes " -Level LEVEL2"
         append isisAttributes " -L2Metric 10 -L2WideMetric 10"
         append isisAttributes " -HelloInterval $helloIntervalL2"
         set level LEVEL2
      }
      default { error "Unsupported ISIS Level Type $level"}
   }
   append isisAttributes " -MetricMode NARROW_AND_WIDE"
   
#   isisInterface config -priorityLevel1 0
#   append isisAttributes " -L1Metric 0 -L1WideMetric 0"
#   isisInterface config -helloIntervalLevel1 $helloIntervalL1
#   append isisAttributes " -HelloInterval $helloIntervalL1"
#   isisInterface config -deadIntervalLevel1 $deadIntervalL1
#   append isisAttributes " -"
#   isisInterface config -extendedDefaultMetric1 10
#   append isisAttributes " -"
#   isisInterface config -trafficEngineeringMetric1 10
#   append isisAttributes " -"
#   isisInterface config -priorityLevel2 0
   append isisAttributes " -RouterPriority 0"
#   isisInterface config -helloIntervalLevel2 $helloIntervalL2
#   isisInterface config -deadIntervalLevel2 $deadIntervalL2
#   isisInterface config -extendedDefaultMetric2 10

   set isisRouterConfig [eval "logcmd stc::create IsisRouterConfig [subst $isisAttributes]"]
   set idx 0
   set isisLsp   [logcmd stc::create IsisLspConfig -under $isisRouterConfig -level $level -SystemId [join $routerId :]]
   while {[llength $networkIp] > $idx} {
      set myIp [lindex $networkIp $idx]
      set rMetric [lindex $routeMetric $idx]
      set prefx [lindex $prefix $idx]
      set routeOrg [lindex $routeOrigin $idx]
      set noOfNetworks [lindex $numNetworks $idx]
      switch -glob [string tolower $routeOrg] {
         *internal {set routeOrg internal}
         *external {set routeOrg external}
         default   {set routeOrg internal}
      }
      if {$rMetric == {}} {set rMetric 1}

#       isisRouteRange config -enable true
#       isisRouteRange config -routeOrigin $routeOrg
#       isisRouteRange config -metric $rMetric
#       isisRouteRange config -numberOfNetworks $noOfNetworks
#       isisRouteRange config -prefix $prefx
#       isisRouteRange config -networkIpAddress $myIp
#       isisRouter addRouteRange [format "routeRange%02d" $rangeId]
#       isisRouteRange setDefault
#       incr rangeId
      set isisRoute [logcmd stc::create Ipv4IsisRoutesConfig -under $isisLsp -RouteType $routeOrg -Metric $rMetric -MetricType $routeOrg]
      logcmd stc::config [logcmd stc::get $isisRoute -children-Ipv4NetworkBlock] -NetworkCount $noOfNetworks -StartIpList [cleanRoute $myIp $prefx] -PrefixLength $prefx
      set routerId [split [incrMac [join $routerId :]] :]
      incr idx
   }
   # Add route for router IP
#   set isisRoute [logcmd stc::create Ipv4IsisRoutesConfig -under $isisLsp -RouteType $routeOrg -Metric $rMetric -MetricType $routeOrg]
#   logcmd stc::config [logcmd stc::get $isisRoute -children-Ipv4NetworkBlock] -NetworkCount 1 -StartIpList $interfaceIp -PrefixLength 32
   
   logcmd stc::apply
}

proc uniqMac {chas card port} {
   puts "$chas $card $port"
   return [format "00 10 49 %02x %02x %02x" [lindex [split $chas .] end] $card [string range $port 4 end]]
}

proc makeRouterId {id} {

   if {[llength [split [join $id :] .:]] != 4} {
      set idlist [split [join $id :] .:]
      for {set i 2} {$i <= 5} {incr i} {lappend ilist [expr 0+0x[lindex $idlist $i]]}
      return [join $ilist .]
   } else {
      return $id
   }
}

proc incrMac { macaddr {val 00:00:00:00:00:01} } {
  set x [split $macaddr :.]
  set y [split $val :.]
  set c 0
  for { set i 5 } { $i >= 0 } { incr i -1 } {
     set z($i) [ expr 0x[lindex $x $i] + 0x[lindex $y $i] + $c ]
     if { $z($i) > 255 } {
        set c 1
        set z($i) [ expr ($z($i) & 0xff) ]
     } else {
        set c 0
     }
  }
  return [format "%02x.%02x.%02x.%02x.%02x.%02x" $z(0) $z(1) $z(2) $z(3) $z(4) $z(5)]
}

proc EnableIsisFilterOutHello {portIdList} {
   result_debug "STC NOT filtering ISIS hello packets"
   return
}
proc DisableIsisFilterOutHello {portIdList} {
   result_debug "STC NOT Disable ISIS route range"
   return
}
proc disIsisRouteRange {portId RouteRangeNo} {
   result_debug "STC NOT Disable ISIS route range"
   return
}
proc enableIsisRouteRange {portId RouteRangeNo} {
   result_debug "STC NOT Disable ISIS route range"
   return
}
proc disIsisAttach {portId} {
   result_debug "STC NOT Disable ISIS attach"
   return
}
proc startIsis {txPortIdList} {
   startBgp $txPortIdList
}
proc stopIsis {txPortIdList} {
   stopBgp $txPortIdList
}
proc cleanupIsis  {txPortIdList} {
   cleanupBgp $txPortIdList
}
proc cleanupBgp {txPortIdList} {
   foreach txPortId $txPortIdList {
      set txPortId [hMapPortIdToSpirentPort $txPortId]
      foreach emulatedDevice [logcmd stc::get $txPortId -affiliationport-Sources] {
         logcmd stc::delete $emulatedDevice							
      }
   }
}

proc setupOSPFIntraRouter {args} {
   return [eval setupOSPFRouter $args]
}

proc overWriteProcs.x {libdir overwritedir} {

   # save cur dir
   set retdir [pwd]

   # remove libdir from autopath
   set loc [lsearch $::auto_path $libdir]
   if {$loc >= 0} {
      set ::auto_path [lreplace $::auto_path $loc $loc]
   } else {
      error "Could not remove lib dir from auto_path : $libdir"
   }

   # go to spirent dir and create index (just as a means to discover all procs)
   cd $overwritedir
   auto_mkindex .
   set dir spirent
   source tclIndex
   set proclist [array names auto_index]
   set f [open [file join $libdir tclIndex] r]

   puts "The following procedures will be sourced from the spirent library:"
   foreach p $proclist { puts "  $p" }
   set filestoremove {}
   set ff [open tclIndex a]
   while {![eof $f]} {
      set line [gets $f]
      if {[lindex $line 0] == "set"} {
         unset auto_index
         eval $line
         set tofind [array names auto_index]
         if {[set loc [lsearch $proclist $tofind]] < 0} {
            puts $ff [linsert $line [lsearch $line {$dir}] ".."]
         }
      }
   }
   close $ff
   close $f
   exit
}

proc uniq {{val 0}} {
   incr val;
   proc uniq "{val $val}" [info body uniq]
   return $val
}

proc checkIxiaCardAndExecTest {testNo time1 {ixiaport "1"}} {
   return
}

proc makeIpv6Gateway {addr} {

   return [join [lreplace [split $addr :] end end 1] :]

}

proc setupLDPInterface {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args setupLDPInterface $args {
      dutIp ""
      interfaceIp ""
      interfaceMask "24"
      routerId ""
      discoveryMode "ldpInterfaceBasic"
      advMode "ldpInterfaceDownstreamUnsolicited"
      numNetworks "0"
      networkIp   "0.0.0.0"
      networkMask "24"
      networkIncrement "ldpAdvertiseFecRangeIncrement"
      networkLabelstart "16"
      protocol "ospf"
      txPortId  "1"
   }

   set txPortId [hMapPortIdToSpirentPort $txPortId]
   cleanupLdp $txPortId
   
   array set cmdResults [logcmd stc::perform DeviceCreateCommand -ParentList \
                            [logcmd stc::get system1 -children-project] -port $txPortId \
                            -IfStack "Ipv4If EthIIIf" -IfCount "1 1" -active false]
   set deviceHndl $cmdResults(-ReturnList)
   logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv4If] -Address $interfaceIp \
      -Gateway $dutIp -PrefixLength $interfaceMask
   logcmd stc::config $deviceHndl -RouterId $routerId
   
   set ldpAttributes "-under $deviceHndl -dutIp $dutIp -helloInterval 5 -RecoveryTime 120 -DirectedHelloInterval 5 \                      -KeepAliveInterval 10 -LabelMin $networkLabelstart"

   switch $advMode {
      ldpInterfaceDownstreamUnsolicited { append ldpAttributes " -LabelAdvertisementMode DOWNSTREAM_UNSOLICITED" }
      default { append ldpAttributes " -LabelAdvertisementMode DOWNSTREAM_ON_DEMAND" }
   }
   switch $discoveryMode {
      ldpInterfaceBasic { append ldpAttributes " -HelloType LDP_DIRECTED_HELLO" }
      default { append ldpAttributes " -HelloType LDP_TARGETED_HELLO" }
   }
   
   set ldpRouterConfig [eval "logcmd stc::create LdpRouterConfig [subst $ldpAttributes]"]
   set ldpLspR [logcmd stc::create ipv4PrefixLsp -under ldpRouterConfig -FecType LDP_FEC_TYPE_HOST_ADDR]
   logcmd stc::config [logcmd stc::get $ldpLspR -children-Ipv4NetworkBlock] -NetworkCount 1 \
      -StartIpList $interfaceIp -PrefixLength 32
   
   set ldpLsp [logcmd stc::create ipv4PrefixLsp -under ldpRouterConfig -FecType LDP_FEC_TYPE_PREFIX]
   set idx 0
   while {[llength $networkIp] > $idx} {
      set myIp [cleanRoute [lindex $networkIp $idx] $prefx]
      set prefx [lindex $prefix $idx]
      set noOfNetworks [lindex $numNetworks $idx]
      logcmd stc::config [logcmd stc::get $ldpLsp -children-Ipv4NetworkBlock] -NetworkCount $noOfNetworks \
                  -StartIpList $myIp -PrefixLength $prefx
   }
}


proc startLdp {args} {
   parse_args startLdp $args {
      txPortIdList ""
      protocol ""
   }
   # start everthing
   startBgp $txPortIdList
}

proc stopLdp {txPortIdList} {
   #stop everything
   stopBgp $txPortIdList

}

proc  setupISISRouterV6 {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args  setupISISRouterV6 $args {
      dutIp ""
      interfaceMacList ""
      interfaceIpList ""
      interfaceIpv6List ""  
      maskIpv6List "64"
      maskList "255.255.255.0"
      areaIdList "0"
      levelList "isisLevel2"
      helloIntervalL1List "10"
      deadIntervalL1List "30"
      helloIntervalL2List "10"
      deadIntervalL2List "30"
      networkTypeList "isisBroadcast"
      metricList "10"
      routeOriginList ""
      numNetworksList "0"
      prefixList ""
      networkIpList ""
      routeMetricList "10"
      routerIdList ""
      txPortId  "1"
      ipType "v4"
   }
   set iTxPortId $txPortId
   set txPortId [MapIxiaPortId $txPortId cha car por]

   set netIp [lindex $networkIpList 0]
   
   if {[string tolower $ipType] != "v6"} {
      set interfaceIpList $interfaceIpList
   } else {
      set interfaceIpList $interfaceIpv6List
   }
   if {[llength $interfaceMacList] > 0} {
      set macAddr [lindex $interfaceMacList 0]
      if {$macAddr == "default"} {
         #        set macAddr [port cget -MacAddress]
         set macAddr [GetPortIdMac $iTxPortId ":"]
      }
   } else {
      set macAddr [GetPortIdMac $iTxPortId ":"]
   }
   puts "ISISv6 MAC: $macAddr"
   set routerId $macAddr

   for {set i 0} {$i<[set count [llength $interfaceIpList]]} {incr i} {
      set interfaceId $macAddr
      set interfaceIp [lindex $interfaceIpList $i]
      set mask [getIndexOrZero $maskList $i]
      if {$count == 1} { set areaId [join $areaIdList {}]} else { set areaId [join [getIndexOrZero $areaIdList $i] {}] }
      set level [getIndexOrZero $levelList $i]
      set helloIntervalL1 [getIndexOrZero $helloIntervalL1List $i]
      set deadIntervalL1 [getIndexOrZero $deadIntervalL1List $i]
      set helloIntervalL2 [getIndexOrZero $helloIntervalL2List $i]
      set deadIntervalL2 [getIndexOrZero $deadIntervalL2List $i]
      set networkType [getIndexOrZero $networkTypeList $i]
      set metric [getIndexOrZero $metricList $i]
      set numNetworks [getIndexOrZero $numNetworksList $i]
      set prefix [getIndexOrZero $prefixList $i]
      set networkIp [getIndexOrZero $networkIpList $i]
      set routeOrigin [getIndexOrZero $routeOriginList $i]
      set routeMetric [getIndexOrZero $routeMetricList $i]
      set routerId [getIndexOrZero $routerIdList $i]
      if {[string length $routerId] == 0} {
         set routerId $interfaceId
      }
      set routerLocalId [expr ($i + 1)]
      set linkLocalAddr "fe80::[expr 1+$iTxPortId+$i]"
      set isisAttributes {}
      # Create interface
      if {[regexp -nocase "v4" $ipType]} {
         logcmd stc::perform SetupPortsCommand -PortList $txPortId -Mtu 1492
         array set cmdResults [logcmd stc::perform DeviceCreateCommand \
                                  -ParentList [logcmd stc::get system1 -children-project] \
                                  -port $txPortId -IfStack "Ipv4If EthIIIf" -IfCount "1 1"]
         set deviceHndl $cmdResults(-ReturnList)
         logcmd stc::config $deviceHndl -RouterId [makeRouterId $routerId]
         logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv4If]  -Address $interfaceIp \
            -Gateway $dutIp -PrefixLength [getPrefixLen $mask] 
         logcmd stc::config [logcmd stc::get $deviceHndl -children-EthIIIf] -SourceMac $macAddr
         lappend isisAttributes -under $deviceHndl -ipVersion IPv4
      } else {
         logcmd stc::perform SetupPortsCommand -PortList $txPortId -Mtu 1492         
         array set cmdResults [logcmd stc::perform DeviceCreateCommand \
                                  -ParentList [logcmd stc::get system1 -children-project] \
                                  -port $txPortId -IfStack "Ipv6If EthIIIf" -IfCount "1 1"]
         set deviceHndl $cmdResults(-ReturnList)
         logcmd stc::config [logcmd stc::get $deviceHndl -children-EthIIIf] -SourceMac $macAddr
         logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv6If] \
            -Address $interfaceIp -PrefixLength 64 -gateway [makeIpv6Gateway $interfaceIp]
         logcmd stc::create Ipv6If -under $deviceHndl \
            -stackedonendpoint-Targets [lindex [logcmd stc::get $deviceHndl -children-EthIIIf] 0] \
            -toplevelif-Sources $deviceHndl -Address $linkLocalAddr
         lappend isisAttributes -under $deviceHndl -ipVersion IPv6
      }
      # get next mac
      set macAddr [incrMac $macAddr]
#       foreach j {1 2 3} val $areaId {
#          puts "$j : $val"
#          lappend isisAttributes -Area${j} $val
#       }
      lappend isisAttributes -Area1 [join $areaId {}] -Area2 {} -Area3 {}
      lappend isisAttributes -SystemId [join $routerId :]
      switch -glob [string tolower $networkType] {
         *broadcast {
            lappend isisAttributes -NetworkType BROADCAST
         }
         *p* {
            lappend isisAttributes -NetworkType P2P
         }
         default { error "Unsupported ISIS network type $networkType" }
      }
      switch $level {
         isisLevel1 {
            lappend isisAttributes -Level LEVEL1
            lappend isisAttributes -L1Metric $metric -L1WideMetric $metric
            lappend isisAttributes -HelloInterval $helloIntervalL1
            set level LEVEL1
         }
         isisLevel2 {
            lappend isisAttributes -Level LEVEL2
            lappend isisAttributes -L2Metric $metric -L2WideMetric $metric
            lappend isisAttributes -HelloInterval $helloIntervalL2
            set level LEVEL2
         }
         default { error "Unsupported ISIS Level Type $level"}
      }
      lappend isisAttributes -MetricMode NARROW_AND_WIDE
      lappend isisAttributes -RouterPriority 0
      set isisRouterConfig [eval logcmd stc::create IsisRouterConfig $isisAttributes]
      set idx 0
      set isisLsp   [logcmd stc::create IsisLspConfig -under $isisRouterConfig -level $level -SystemId [join $routerId :]]
      while {[llength $networkIp] > $idx} {
         set myIp [lindex $networkIp $idx]
         set rMetric [lindex $routeMetric $idx]
         set prefx [lindex $prefix $idx]
         set routeOrg [lindex $routeOrigin $idx]
         set noOfNetworks [lindex $numNetworks $idx] ; if {$noOfNetworks == {}} {set noOfNetworks 1}
         switch -glob [string tolower $routeOrg] {
            *internal {set routeOrg internal}
            *external {set routeOrg external}
         }
         set isisRoute [logcmd stc::create Ipv6IsisRoutesConfig -under $isisLsp -RouteType $routeOrg -WideMetric $rMetric]
         logcmd stc::config [logcmd stc::get $isisRoute -children-Ipv6NetworkBlock] -NetworkCount $noOfNetworks -StartIpList $myIp -PrefixLength $prefx
         set routerId [split [incrMac [join $routerId :]] :]
         incr idx
      }
   }
}




proc getIndexOrZero {list idx} {
   if {[llength $list] > 1} { return [lindex $list $idx] } else { return [lindex $list 0] }
}



proc SendBSRFragment1 {args} {
   puts "[lindex [info level 0] 0] : $args"

   parse_args SendBSRFragment  $args {
      txPortId "1"
      sourceMac "00 15 62 3E 88 C6"
      DestMac  "01 00 5E 00 00 0D"
      sourceIP "127.0.0.1"
      destIP   "224.0.0.13"
      
   }
   set txPort [hMapPortIdToSpirentPort $txPortId]

   logcmd stc::perform GeneratorStop -GeneratorList $txPort
   
   # Delete all streamblocks on tx port
   deleteAllStreams $txPort
   
   # Stream
   set stream_args {-insertSig FALSE -EnableHighSpeedResultAnalysis FALSE}
   lappend stream_args -EnableFcsErrorInsertion false
   lappend stream_args -ConstantFillPattern 0 -frameconfig {}
   lappend stream_args -frameLengthMode AUTO -EqualRxPortDistribution "FALSE"
   set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
   
   # Ethernet
   set eth_args {}
   lappend eth_args -srcMac [join $sourceMac :]
   lappend eth_args -dstMac [join $DestMac :]
   set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                     -name sb1_eth $eth_args]
   
   #IPv4
   set hIpv4 [logcmd stc::create ipv4:IPv4 -under $hStreamBlock -name sb1_ip \
                 -sourceAddr $sourceIP -destAddr $destIP -ttl 1 -identification 20252\
                 -protocol 103]
#   set hFlangs [logcmd stc::create flags -under $hIpv4 -dfBit 0 -mfBit 1]
   set pattern [join {24 00 93 33 16 32 00 00 01 00 29 01 01 02 01 00 00 20 E1 01 01 01 BB 91 00 00 01 00 06 01 3A 01 00 92 00 00 01 00 06 01 EF 01 00 15 00 00 01 00 06 01 2E 01 00 93 00 00 01 00 06 01 C3 01 00 00 00 00 01 00 06 01 02 01 00 93 00 00 01 00 06 01 49 01 00 56 00 00 01 00 06 01 F0 01 00 57 00 00 01 00 06 01 BD 01 00 00 00 00 01 00 06 01 E4 01 00 57 00 00 01 00 06 01 23 01 00 94 00 00 01 00 06 01 6A 01 00 58 00 00 01 00 06 01 91 01 00 57 00 00 01 00 06 01 D8 01 00 0B 00 00 01 00 06 01 17 01 00 95 00 00 01 00 06 01 5E 01 00 56 00 00 01 00 06 01 85 01 00 55 00 00 01 00 06 01 CC 01 00 06 00 00 01 00 06 01 0B 01 00 93 00 00 01 00 06 01 B2 01 00 58 00 00 01 00 06 01 F9 01 00 1D 00 00 01 00 06 01 38 01 00 93 00 00 01 00 06 01 7F 01 00 59 00 00 01 00 06 01 ED 01 00 15 00 00 01 00 06 01 2C 01 00 94 00 00 01 00 06 01 C1 01 00 03 00 00 01 00 06 01 47 01 00 58 00 00 01 00 06 01 E2 01 00 10 00 00 01 00 06 01 21 01 00 95 00 00 01 00 06 01 68 01 00 59 00 00 01 00 06 01 D6 01 00 0B 00 00 01 00 06 01 15 01 00 93 00 00 01 00 06 01 5C 01 00 57 00 00 01 00 06 01 83 01 00 58 00 00 01 00 06 01 CA 01 00 06 00 00 01 00 06 01 09 01 00 95 00 00 01 00 06 01 B0 01 00 5A 00 00 01 00 06 01 F7 01 00 1A 00 00 01 00 06 01 36 01 00 93 00 00 01 00 06 01 7D 01 00 59 00 00 01 00 06 01 EB 01 00 16 00 00 01 00 06 01 2A 01 00 92 00 00 01 00 06 01 51 01 00 59 00 00 01 00 06 01 DF 01 00 57 00 00 01 00 06 01 1E 01 00 93 00 00 01 00 06 01 45 01 00 94 00 00 01 00 06 01 E0 01 00 0F 00 00 01 00 06 01 3F 01 00 94 00 00 01 00 06 01 66 01 00 57 00 00 01 00 06 01 D4 01 00 08 00 00 01 00 06 01 13 01 00 92 00 00 01 00 06 01 5A 01 00 59 00 00 01 00 06 01 81 01 00 59 00 00 01 00 06 01 C8 01 00 06 00 00 01 00 06 01 07 01 00 91 00 00 01 00 06 01 F5 01 00 18 00 00 01 00 06 01 34 01 00 92 00 00 01 00 06 01 7B 01 00 57 00 00 01 00 06 01 E9 01 00 12 00 00 01 00 06 01 28 01 00 95 00 00 01 00 06 01 DD 01 00 59 00 00 01 00 06 01 1C 01 00 95 00 00 01 00 06 01 43 01 00 94 00 00 01 00 06 01 3D 01 00 91 00 00 01 00 06 01 64 01 00 58 00 00 01 00 06 01 D2 01 00 0B 00 00 01 00 06 01 11 01 00 92 00 00 01 00 06 01 58 01 00 58 00 00 01 00 06 01 9F 01 00 56 00 00 01 00 06 01 C6 01 00 02 00 00 01 00 06 01 05 01 00 94 00 00 01 00 06 01 F3 01 00 19 00 00 01 00 06 01 32 01 00 93 00 00 01 00 06 01 79 01 00 59 00 00 01 00 06 01 E7 01 00 13 00 00 01 00 06 01 26 01 00 95 00 00 01 00 06 01 DB 01 00 57 00 00 01 00 06 01 1A 01 00 91 00 00 01 00 06 01 41 01 00 93 00 00 01 00 06 01 CF 01 00 5A 00 00 01 00 06 01 0E 01 00 91 00 00 01 00 06 01 3B 01 00 94 00 00 01 00 06 01 62 01 00 59 00 00 01 00 06 01 D0 01 00 09 00 00 01 00 06 01 2F 01 00 91 00 00 01 00 06 01 56 01 00 55 00 00 01 00 06 01 9D 01 00 56 00 00 01 00 06 01 C4 01 00 57 00 00 01 00 06 01 03 01 00 94 00 00 01 00 06 01 F1 01 00 19 00 00 01 00 06 01 30 01 00 93 00 00 01 00 06 01 77 01 00 58 00 00 01 00 06 01 BE 01 00 57 00 00 01 00 06 01 E5 01 00 12 00 00 01 00 06 01 24 01 00 95 00 00 01 00 06 01 D9 01 00 59 00 00 01 00 06 01 18 01 00 93 00 00 01 00 06 01 CD 01 00 57 00 00 01 00 06 01 0C 01 00 93 00 00 01 00 06 01 39 01 00 92 00 00 01 00 06 01 60 01 00 58 00 00 01 00 06 01 A7 01 00 59 00 00 01 00 06 01 EE 01 00 5A 00 00 01 00 06 01 2D 01 00 93 00 00 01 00 06 01 54 01 00 58 00 00 01 00 06 01 9B 01 00 56 00 00 01 00 06 01 C2 01 00 58 00 00 01 00 06 01 01 01 00 92 00 00 01 00 06 01 8F 01 00 58 00 00 01 00 06 01 75 01 00 57 00 00 01 00 06 01 BC 01 00 57 00 00 01 00 06 01 E3 01 00 10 00 00 01 00 06 01 22 01 00 93 00 00 01 00 06 01 D7 01 00 58 00 00 01 00 06 01 16 01 00 94 00 00 01 00 06 01 CB 01 00 58 00 00 01 00 06 01 0A 01 00 93 00 00 01 00 06 01 F8 01 00 56 00 00 01 00 06 01 37 01 00 94 00 00 01 00 06 01 A5 01 00 58 00 00 01 00 06 01 EC 01 00 55 00 00 01 00 06 01 2B 01 00 91 00 00 01 00 06 01 99 01 00 57 00 00 01 00 06 01 C0 01 00 58 00 00 01 00 06 01 1F 01 00 92 00 00 01 00 06 01 46 01 00 94 00 00 01 00 06 01 8D 01 00 58 00 00 01 00 06 01 73 01 00 57 00 00 01 00 06 01 BA 01 00 57 00 00 01 00 06 01 E1 01 00 58 00 00 01 00 06 01 20 01 00 94 00 00 01 00 06 01 AE 01 00 59 00 00 01 00 06 01 D5 01 00 56 00 00 01 00 06 01 14 01 00 94 00 00 01 00 06 01 C9 01 00 59 00 00 01 00 06 01 08 01 00 95 00 00 01 00 06 01 4F 01 00 58 00 00 01 00 06 01 F6 01 00 55 00 00 01 00 06 01 35 01 00 93 00 00 01 00 06 01 A3 01 00 59 00 00 01 00 06 01 EA 01 00 58 00 00 01 00 06 01 29 01 00 94 00 00 01 00 06 01 97 01 00 58 00 00 01 00 06 01 DE 01 00 10 00 00 01 00 06 01 1D 01 00 94 00 00 01 00 06 01 44 01 00 92 00 00} {}]
   set custom [logcmd stc::create custom:Custom -under $hStreamBlock -name sb1_custom \
                  -pattern $pattern]
   set gen_args {}
   lappend gen_args -loadunit PERCENT_LINE_RATE -FixedLoad 50
   lappend gen_args -DurationMode BURSTS -BurstSize 1 -duration 1
   set hGeneratorConfig [eval logcmd stc::config $txPort.Generator.GeneratorConfig $gen_args]
   stc::apply
   logcmd stc::perform ResultClearAllTraffic -PortList "$txPort"
   StartPortsTransmit $txPort
   
   result_debug "pim frame sent:24 00 93 33 16 32 00 00 01 00 29 01 01 02 01 00 00 20 E1 01 01 01 BB 91 00 00 01 00 06 01 3A 01 00 92 00 00 01 00 06 01 EF 01 00 15 00 00 01 00 06 01 2E 01 00 93 00 00 01 00 06 01 C3 01 00 00 00 00 01 00 06 01 02 01 00 93 00 00 01 00 06 01 49 01 00 56 00 00 01 00 06 01 F0 01 00 57 00 00 01 00 06 01 BD 01 00 00 00 00 01 00 06 01 E4 01 00 57 00 00 01 00 06 01 23 01 00 94 00 00 01 00 06 01 6A 01 00 58 00 00 01 00 06 01 91 01 00 57 00 00 01 00 06 01 D8 01 00 0B 00 00 01 00 06 01 17 01 00 95 00 00 01 00 06 01 5E 01 00 56 00 00 01 00 06 01 85 01 00 55 00 00 01 00 06 01 CC 01 00 06 00 00 01 00 06 01 0B 01 00 93 00 00 01 00 06 01 B2 01 00 58 00 00 01 00 06 01 F9 01 00 1D 00 00 01 00 06 01 38 01 00 93 00 00 01 00 06 01 7F 01 00 59 00 00 01 00 06 01 ED 01 00 15 00 00 01 00 06 01 2C 01 00 94 00 00 01 00 06 01 C1 01 00 03 00 00 01 00 06 01 47 01 00 58 00 00 01 00 06 01 E2 01 00 10 00 00 01 00 06 01 21 01 00 95 00 00 01 00 06 01 68 01 00 59 00 00 01 00 06 01 D6 01 00 0B 00 00 01 00 06 01 15 01 00 93 00 00 01 00 06 01 5C 01 00 57 00 00 01 00 06 01 83 01 00 58 00 00 01 00 06 01 CA 01 00 06 00 00 01 00 06 01 09 01 00 95 00 00 01 00 06 01 B0 01 00 5A 00 00 01 00 06 01 F7 01 00 1A 00 00 01 00 06 01 36 01 00 93 00 00 01 00 06 01 7D 01 00 59 00 00 01 00 06 01 EB 01 00 16 00 00 01 00 06 01 2A 01 00 92 00 00 01 00 06 01 51 01 00 59 00 00 01 00 06 01 DF 01 00 57 00 00 01 00 06 01 1E 01 00 93 00 00 01 00 06 01 45 01 00 94 00 00 01 00 06 01 E0 01 00 0F 00 00 01 00 06 01 3F 01 00 94 00 00 01 00 06 01 66 01 00 57 00 00 01 00 06 01 D4 01 00 08 00 00 01 00 06 01 13 01 00 92 00 00 01 00 06 01 5A 01 00 59 00 00 01 00 06 01 81 01 00 59 00 00 01 00 06 01 C8 01 00 06 00 00 01 00 06 01 07 01 00 91 00 00 01 00 06 01 F5 01 00 18 00 00 01 00 06 01 34 01 00 92 00 00 01 00 06 01 7B 01 00 57 00 00 01 00 06 01 E9 01 00 12 00 00 01 00 06 01 28 01 00 95 00 00 01 00 06 01 DD 01 00 59 00 00 01 00 06 01 1C 01 00 95 00 00 01 00 06 01 43 01 00 94 00 00 01 00 06 01 3D 01 00 91 00 00 01 00 06 01 64 01 00 58 00 00 01 00 06 01 D2 01 00 0B 00 00 01 00 06 01 11 01 00 92 00 00 01 00 06 01 58 01 00 58 00 00 01 00 06 01 9F 01 00 56 00 00 01 00 06 01 C6 01 00 02 00 00 01 00 06 01 05 01 00 94 00 00 01 00 06 01 F3 01 00 19 00 00 01 00 06 01 32 01 00 93 00 00 01 00 06 01 79 01 00 59 00 00 01 00 06 01 E7 01 00 13 00 00 01 00 06 01 26 01 00 95 00 00 01 00 06 01 DB 01 00 57 00 00 01 00 06 01 1A 01 00 91 00 00 01 00 06 01 41 01 00 93 00 00 01 00 06 01 CF 01 00 5A 00 00 01 00 06 01 0E 01 00 91 00 00 01 00 06 01 3B 01 00 94 00 00 01 00 06 01 62 01 00 59 00 00 01 00 06 01 D0 01 00 09 00 00 01 00 06 01 2F 01 00 91 00 00 01 00 06 01 56 01 00 55 00 00 01 00 06 01 9D 01 00 56 00 00 01 00 06 01 C4 01 00 57 00 00 01 00 06 01 03 01 00 94 00 00 01 00 06 01 F1 01 00 19 00 00 01 00 06 01 30 01 00 93 00 00 01 00 06 01 77 01 00 58 00 00 01 00 06 01 BE 01 00 57 00 00 01 00 06 01 E5 01 00 12 00 00 01 00 06 01 24 01 00 95 00 00 01 00 06 01 D9 01 00 59 00 00 01 00 06 01 18 01 00 93 00 00 01 00 06 01 CD 01 00 57 00 00 01 00 06 01 0C 01 00 93 00 00 01 00 06 01 39 01 00 92 00 00 01 00 06 01 60 01 00 58 00 00 01 00 06 01 A7 01 00 59 00 00 01 00 06 01 EE 01 00 5A 00 00 01 00 06 01 2D 01 00 93 00 00 01 00 06 01 54 01 00 58 00 00 01 00 06 01 9B 01 00 56 00 00 01 00 06 01 C2 01 00 58 00 00 01 00 06 01 01 01 00 92 00 00 01 00 06 01 8F 01 00 58 00 00 01 00 06 01 75 01 00 57 00 00 01 00 06 01 BC 01 00 57 00 00 01 00 06 01 E3 01 00 10 00 00 01 00 06 01 22 01 00 93 00 00 01 00 06 01 D7 01 00 58 00 00 01 00 06 01 16 01 00 94 00 00 01 00 06 01 CB 01 00 58 00 00 01 00 06 01 0A 01 00 93 00 00 01 00 06 01 F8 01 00 56 00 00 01 00 06 01 37 01 00 94 00 00 01 00 06 01 A5 01 00 58 00 00 01 00 06 01 EC 01 00 55 00 00 01 00 06 01 2B 01 00 91 00 00 01 00 06 01 99 01 00 57 00 00 01 00 06 01 C0 01 00 58 00 00 01 00 06 01 1F 01 00 92 00 00 01 00 06 01 46 01 00 94 00 00 01 00 06 01 8D 01 00 58 00 00 01 00 06 01 73 01 00 57 00 00 01 00 06 01 BA 01 00 57 00 00 01 00 06 01 E1 01 00 58 00 00 01 00 06 01 20 01 00 94 00 00 01 00 06 01 AE 01 00 59 00 00 01 00 06 01 D5 01 00 56 00 00 01 00 06 01 14 01 00 94 00 00 01 00 06 01 C9 01 00 59 00 00 01 00 06 01 08 01 00 95 00 00 01 00 06 01 4F 01 00 58 00 00 01 00 06 01 F6 01 00 55 00 00 01 00 06 01 35 01 00 93 00 00 01 00 06 01 A3 01 00 59 00 00 01 00 06 01 EA 01 00 58 00 00 01 00 06 01 29 01 00 94 00 00 01 00 06 01 97 01 00 58 00 00 01 00 06 01 DE 01 00 10 00 00 01 00 06 01 1D 01 00 94 00 00 01 00 06 01 44 01 00 92 00 00"
   
   
   result_debug "Source IP:$sourceIP  Destination IP:$destIP"
   
   
}

proc SendBSRFragment2 {args} {
   puts "[lindex [info level 0] 0] : $args"

   parse_args SendBSRFragment  $args {
      txPortId "1"
      sourceMac "00 15 62 3E 88 C6"
      DestMac  "01 00 5E 00 00 0D"
      sourceIP "127.0.0.1"
      destIP   "224.0.0.13"
      
   }
   set txPort [hMapPortIdToSpirentPort $txPortId]
   
   logcmd stc::perform GeneratorStop -GeneratorList $txPort
   
   # Delete all streamblocks on tx port
   deleteAllStreams $txPort

   # Stream
   set stream_args {-insertSig FALSE -EnableHighSpeedResultAnalysis FALSE}
   lappend stream_args -EnableFcsErrorInsertion false
   lappend stream_args -ConstantFillPattern 0 -frameconfig {}
   lappend stream_args -frameLengthMode AUTO -EqualRxPortDistribution "FALSE"
   set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
   # Ethernet
   set eth_args {}
   lappend eth_args -srcMac [join $sourceMac :]
   lappend eth_args -dstMac [join $DestMac :]
   set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                     -name sb1_eth $eth_args]
   
   #IPv4
   set hIpv4 [logcmd stc::create ipv4:IPv4 -under $hStreamBlock -name sb1_ip \
                 -sourceAddr $sourceIP -destAddr $destIP -ttl 1 -identification 20254\
                 -protocol 103]
#   set hFlangs [logcmd stc::create flags -under $hIpv4 -dfBit 0 -mfBit ]
   set custom [logcmd stc::create custom:Custom -under $hStreamBlock -name sb1_custom \
                  -pattern [join [list 24 00 01 35 16 32 00 00 01 00 29 01 01 02 01 00 00 20 E1 01 01 01 BB 2A 00 00 01 00 06 01 71 01 00 56 00 00 01 00 06 01 B8 01 00 59 00 00 01 00 06 01 3E 01 00 94 00 00 01 00 06 01 AC 01 00 56 00 00 01 00 06 01 D3 01 00 57 00 00 01 00 06 01 12 01 00 94 00 00 01 00 06 01 C7 01 00 59 00 00 01 00 06 01 06 01 00 95 00 00 01 00 06 01 4D 01 00 58 00 00 01 00 06 01 F4 01 00 55 00 00 01 00 06 01 33 01 00 95 00 00 01 00 06 01 A1 01 00 57 00 00 01 00 06 01 E8 01 00 59 00 00 01 00 06 01 27 01 00 94 00 00 01 00 06 01 6E 01 00 58 00 00 01 00 06 01 95 01 00 59 00 00 01 00 06 01 DC 01 00 0E 00 00 01 00 06 01 1B 01 00 93 00 00 01 00 06 01 42 01 00 93 00 00 01 00 06 01 89 01 00 56 00 00 01 00 06 01 0F 01 00 93 00 00 01 00 06 01 B6 01 00 56 00 00 01 00 06 01 3C 01 00 92 00 00 01 00 06 01 AA 01 00 59 00 00 01 00 06 01 D1 01 00 56 00 00 01 00 06 01 10 01 00 92 00 00 01 00 06 01 C5 01 00 02 00 00 01 00 06 01 04 01 00 94 00 00 01 00 06 01 4B 01 00 58 00 00 01 00 06 01 F2 01 00 58 00 00 01 00 06 01 31 01 00 94 00 00 01 00 06 01 E6 01 00 57 00 00 01 00 06 01 25 01 00 95 00 00 01 00 06 01 6C 01 00 59 00 00 01 00 06 01 93 01 00 57 00 00 01 00 06 01 DA 01 00 0B 00 00 01 00 06 01 19 01 00 93 00 00 01 00 06 01 40 01 00 92 00 00 01 00 06 01 87 01 00 56 00 00 01 00 06 01 CE 01 00 07 00 00 01 00 06 01 0D 01 00 93 00 00 01 00 06 01 B4 01 00 5A 00 00] {}]]
   
   
   set gen_args {}
   lappend gen_args -loadunit PERCENT_LINE_RATE -FixedLoad 50
   lappend gen_args -DurationMode BURSTS -BurstSize 1 -duration 1
   set hGeneratorConfig [eval logcmd stc::config $txPort.Generator.GeneratorConfig $gen_args]
   stc::apply
   logcmd stc::perform ResultClearAllTraffic -PortList "$txPort"
   StartPortsTransmit $txPort
   
   
   result_debug "Sent pim Frame:24 00 01 35 16 32 00 00 01 00 29 01 01 02 01 00 00 20 E1 01 01 01 BB 2A 00 00 01 00 06 01 71 01 00 56 00 00 01 00 06 01 B8 01 00 59 00 00 01 00 06 01 3E 01 00 94 00 00 01 00 06 01 AC 01 00 56 00 00 01 00 06 01 D3 01 00 57 00 00 01 00 06 01 12 01 00 94 00 00 01 00 06 01 C7 01 00 59 00 00 01 00 06 01 06 01 00 95 00 00 01 00 06 01 4D 01 00 58 00 00 01 00 06 01 F4 01 00 55 00 00 01 00 06 01 33 01 00 95 00 00 01 00 06 01 A1 01 00 57 00 00 01 00 06 01 E8 01 00 59 00 00 01 00 06 01 27 01 00 94 00 00 01 00 06 01 6E 01 00 58 00 00 01 00 06 01 95 01 00 59 00 00 01 00 06 01 DC 01 00 0E 00 00 01 00 06 01 1B 01 00 93 00 00 01 00 06 01 42 01 00 93 00 00 01 00 06 01 89 01 00 56 00 00 01 00 06 01 0F 01 00 93 00 00 01 00 06 01 B6 01 00 56 00 00 01 00 06 01 3C 01 00 92 00 00 01 00 06 01 AA 01 00 59 00 00 01 00 06 01 D1 01 00 56 00 00 01 00 06 01 10 01 00 92 00 00 01 00 06 01 C5 01 00 02 00 00 01 00 06 01 04 01 00 94 00 00 01 00 06 01 4B 01 00 58 00 00 01 00 06 01 F2 01 00 58 00 00 01 00 06 01 31 01 00 94 00 00 01 00 06 01 E6 01 00 57 00 00 01 00 06 01 25 01 00 95 00 00 01 00 06 01 6C 01 00 59 00 00 01 00 06 01 93 01 00 57 00 00 01 00 06 01 DA 01 00 0B 00 00 01 00 06 01 19 01 00 93 00 00 01 00 06 01 40 01 00 92 00 00 01 00 06 01 87 01 00 56 00 00 01 00 06 01 CE 01 00 07 00 00 01 00 06 01 0D 01 00 93 00 00 01 00 06 01 B4 01 00 5A 00 00"
   result_debug "Source IP:$sourceIP  Destination IP:$destIP"
   
   
}


################################################################## 
# Procedure Name: nl_ixCreatePortIfs
#   
# Description: Configure port interfaces.  Each interface (or supplicant)
#              has a MAC and IP address. Before you can configure supplicants
#              and supTable, you need to create the "virtual" interfaces
#              representing these supplicants.
# 
# Input args: -portInfoList: List of ports to create interfaces on
#                 <portId> <startIp> <gw> <numSupplicants> <vlanId*>
#                    *vlanId is optional 
#             -startMacAddr: First 3 octets of MAC.  Last three are 
#                            generated as card:port:count  
#               *If 6 octets are given, we just increment starting from there
#
# Output args: None
#
#  Typical Usage:
#    lappend portInfoList "1 10.1.1.1 10.1.1.254 8"
#    lappend portInfoList "2 10.1.1.1 10.1.1.254 1"
#    nl_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr "00 00 01"
#    nl_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr "00 00 01 11 22 33"
#
##################################################################
proc nl_ixDestroyPortIfs {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args nl_setupPortInterfaces $args {
      portInfoList "1"
   }
   set portlist {} 
   foreach i $portInfoList { lappend portlist [lindex $i 0] }
   cleanupBgp $portlist
}

proc nl_ixCreatePortIfs {args} {
   puts "[lindex [info level 0] 0] : $args"
   parse_args nl_setupPortInterfaces $args {
      portInfoList "1  10.1.1.1  10.1.1.254  1"
      startMacAddr "00 00 01"    ;# Last 3 octets are CARD:PORT:COUNT 
      protocolServer "disable"
   }
   
   set portList [list]
   
   ;# List of port intf {{<port> <IP> <MAC>} ... }
   set ifInfoList [list]
   
   ;# Configure interfaces for each port
   foreach port $portInfoList {
      
      set portId [lindex $port 0]
      set txPort [hMapPortIdToSpirentPort $portId]

      puts "TX Port $txPort   Port ID $portId"
      
      set portStartIpAddr [lindex $port 1]
      set portGwIpAddr [lindex $port 2]
      set numSupplicants [lindex $port 3]
      set vlanId [lindex $port 4]
      
      result_debug "portStartIpAddr:$portStartIpAddr  \
		portGwIpAddr:$portGwIpAddr numSupplicants:$numSupplicants" 
      
      
      set incrOctet 4
       
      # cleanup all devices on port
      cleanupBgp $txPort
     
      set ipAddressForThisInterface $portStartIpAddr
      
      set gCount 1
      for {set count 1} {$count <= $numSupplicants} {incr count} {
         
         if {[string length $startMacAddr] == 8} {
            ;# Normal case
            set curMac "$startMacAddr [format "%02x %02x %02x" $ca $po $gCount]"
         } else {
            set curMac [IncMacByOne $startMacAddr " "]
            set startMacAddr $curMac
         }
         set ifInfoEntry [list $portId $ipAddressForThisInterface $curMac]
         lappend ifInfoList $ifInfoEntry
         
         result_debug "ipAddressForThisInterface: $ipAddressForThisInterface MAC: $curMac"
 
         # create device
         if {$vlanId == ""} {
            array set cmdResults [logcmd stc::perform DeviceCreateCommand -ParentList [logcmd stc::get system1 -children-project]\
                                     -port $txPort -IfStack "Ipv4If EthIIIf" -IfCount "1 1"]
            set deviceHndl $cmdResults(-ReturnList)
         } else {
            array set cmdResults [logcmd stc::perform DeviceCreateCommand -ParentList [logcmd stc::get system1 -children-project]\
                                     -port $txPort -IfStack "Ipv4If VlanIf EthIIIf" -IfCount "1 1 1"]
            set deviceHndl $cmdResults(-ReturnList)
            logcmd stc::config [logcmd stc::get $deviceHndl -children-VlanIf] -VlanId $vlanId
         }
         logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv4If] -Address $ipAddressForThisInterface -Gateway $portGwIpAddr -prefixLength 24
         logcmd stc::config [logcmd stc::get $deviceHndl -children-EthIIIf] -SourceMac [join $curMac :]

         if {$protocolServer == "enable"} {
            logcmd stc::config $deviceHndl -EnablePingResponse TRUE 
         }
         set ipAddressForThisInterface [incrIpField $ipAddressForThisInterface $incrOctet]
         incr gCount
      }
   }
   result_debug "Writing portList $portList to hardware."
   
   
   ;# Dump some info for debugging.
   ;# nl_ixDumpInterfaceInfo
   
   return $ifInfoList
}

proc EnableProtocolServerV6 {portIdList ipAddressList {tag "none"} {pingEnable "false"} {gwIpList "0::0"}} {

   for {set i 0} {$i < [llength $portIdList]} {incr i} {
      set iPortId [lindex $portIdList $i]
      set portId [hMapPortIdToSpirentPort $iPortId]
      set ipAddress [lindex $ipAddressList $i]
      set gwIp [lindex $gwIpList $i]
      if {$gwIp == ""} {set gwIp "0.0.0.0"} 
      set linkLocalAddr "fe80::[expr 1+$iPortId+$i]"
      if {$tag == "none"} {
         array set cmdResults [logcmd stc::perform DeviceCreateCommand \
                                  -ParentList [logcmd stc::get system1 -children-project] \
                                  -port $portId -IfStack "Ipv6If EthIIIf" -IfCount "1 1"]
         set deviceHndl $cmdResults(-ReturnList)
      } else {
         array set cmdResults [logcmd stc::perform DeviceCreateCommand \
                                  -ParentList [logcmd stc::get system1 -children-project] \
                                  -port $portId -IfStack "Ipv6If VlanIf EthIIIf" -IfCount "1 1 1"]
         set deviceHndl $cmdResults(-ReturnList)
         logcmd stc::config [logcmd stc::get $deviceHndl -children-VlanIf] -VlanId $tag
      }
      logcmd stc::config [logcmd stc::get $deviceHndl -children-EthIIIf] -SourceMac [GetDefaultPortIdMAC -portId $portId]
      logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv6If] \
         -Address $ipAddress -PrefixLength 64 -gateway [makeIpv6Gateway $ipAddress]
      logcmd stc::create Ipv6If -under $deviceHndl \
         -stackedonendpoint-Targets [lindex [logcmd stc::get $deviceHndl -children-EthIIIf] 0] \
         -toplevelif-Sources $deviceHndl -Address $linkLocalAddr
      logcmd stc::config $deviceHndl -EnablePingResponse $pingEnable
   }
}

proc EnableProtocolServerMultipleV6 {portIdList ipAddressList {tagList "none"} {pingEnable "false"} {gwIpList "0::0"}} {

   EnableProtocolServerV6 $portIdList $ipAddressList $tagList $pingEnable $gwIpList

}

proc DisableProtocolServerMultipleV6 {portId ipAddressList} {

   if {[llength $ipAddressList] > 0} {
      DisableProtocolServer $portId $ipAddressList
   } else {
      result_debug "ipaddress list is empty"
      return 0
   }
   return 1
}


proc getPortsFromChassCardPortList { list } {
   set newlist {}
   foreach itms $list {
      foreach chass card port [split $itms ,] {}
      lappend newlist $port
   }
   return $newlist
}

proc SetPortFilter {portId filter offset} {
#grant
   global STCMAIN
   puts "[lindex [info level 0] 0] : Port=$portId Filter=$filter Offset=$offset"
   if {[string is integer $portId]} {set portId [hMapPortIdToSpirentPort $portId]}
   set hAnalyzer [logcmd stc::get $portId -children-Analyzer]
   set hFilter [logcmd stc::get $hAnalyzer -children-Analyzer32BitFilter]
   if {$hFilter == {}} {
      set hFilter [logcmd stc::create Analyzer32BitFilter -under $hAnalyzer]
   }
   set mask {} ; set filt {}
   foreach num [split [join $filter {}] {}] zero [split 00000000 {}] {
      if {$num == {}} {
         append mask $zero
         append filt $zero
      } else {
         append mask f
         append filt $num
      }
   }
   logcmd stc::perform AnalyzerStopCommand -AnalyzerList $hAnalyzer
puts "Filter in $filter rebuilt - $filt"
   logcmd stc::config $hFilter -LocationType START_OF_FRAME -Offset $offset -Mask 0x$mask \
      -StartOfRange 0x$filt -EndOfRange 0x$filt

#   set STCMAIN(filter) [logcmd stc::subscribe -Parent $STCMAIN(project) \
#        -resultParent $portId \
#        -configType analyzer \
#        -resultType FilteredStreamResults]

   logcmd stc::apply
   logcmd stc::perform AnalyzerStartCommand -AnalyzerList $hAnalyzer

   return
}
proc GetNumFilteredFramesReceived {portId} {
    global STCMAIN
    set fCount 0
    if {[string is integer $portId]} {set portId [hMapPortIdToSpirentPort $portId]}
#    set hAnalyzer [logcmd stc::get $portId -children-Analyzer]
#    puts "Children of project port then analyzer"

#    puts [logcmd stc::get $STCMAIN(project) -children]
#    puts [logcmd stc::get $portId -children]
#    puts [logcmd stc::get $hAnalyzer -children]

#    set fobj [logcmd stc::get $hAnalyzer -children-AnalyzerPortResults]
#    if {$fobj!={}} {
#        puts "Frame count filter [logcmd stc::get $fobj -UserDefinedFrameCount1]"
#        return [logcmd stc::get $fobj -UserDefinedFrameCount1]
#    }
    set c [logcmd stc::get $portId.Analyzer.AnalyzerPortResults -TotalFrameCount]
    if {$c>0} {
        puts "Found count $c"
        return $c
    }
    puts "Could not locate filter obj"
    return 0
}

proc DisablePortFilter {portIds} {
   foreach portId $portIds {
   if {[string is integer $portId]} {set portId [hMapPortIdToSpirentPort $portId]}
   set hAnalyzer [logcmd stc::get $portId -children-Analyzer]
   logcmd stc::perform AnalyzerStopCommand -AnalyzerList $hAnalyzer
   set hFilter [logcmd stc::get $hAnalyzer -children-Analyzer32BitFilter]
   if {$hFilter != {}} {
      logcmd stc::delete $hFilter
   }
#   logcmd stc::config $hFilter -LocationType START_OF_FRAME -Offset 0 -Mask -0xFFFFFFFF \
#      -StartOfRange 0 -EndOfRange 0xFFFFFFFF
   logcmd stc::apply
   logcmd stc::perform AnalyzerStartCommand -AnalyzerList $hAnalyzer
   }
   return
}


proc GetCapturedFrms {portId maxPkts {verb "yes"}} {
   if {[string is integer $portId]} {set portId [hMapPortIdToSpirentPort $portId]}
   return [GetCapturedFrames $portId NULL 200 $maxPkts]
}

proc formatBgpCommunity {i} {
   if {[llength [split $i :]] > 1} { return $i }
   set val0 [expr $i & 0xffff]
   set val1 [expr ($i & 0xffff0000) >> 16]
   return $val1:$val0
}

proc setupRipngPeer {args} {
   result_debug  "[lindex [info level 0] 0] : $args"
   global TrafficGen
   parse_args setupRipngPeer $args {
      routerIp "3333::24"
      mask "64"
      sourceMac "none"
      vlanId "0"
      txPortId 1
      updateInterval 30
      updateIntervalOffset 5
      enableInterfaceMetric "false"
      response "0"
      rangeIpList ""
      metricList ""
      prefixList ""
      nexthopList ""
      tagList ""
      numRouteList ""
   }

   cleanupRipng $txPortId *	
   set txPortIndex $txPortId
   set txPortId [hMapPortIdToSpirentPort $txPortId]
   array set cmdResults [logcmd stc::perform DeviceCreateCommand -ParentList [logcmd stc::get system1 -children-project] -port $txPortId -IfStack "Ipv6If EthIIIf" -IfCount "1 1"]
   set linkLocalAddr "fe80::[expr 1+$txPortIndex]"
   
   # Get DUT IPv6 address corresponding to the Tester IPv6 address
   set paramList ""
   set dutPrefixList [lrange [split $routerIp :] 0 end-1]
   for {set i [expr [llength $dutPrefixList]-1]} {$i > 0} {incr i -1} {
      if {([lindex $dutPrefixList $i] != "0") && ([lindex $dutPrefixList $i] != "00") && ([lindex $dutPrefixList $i] != "000") && ([lindex $dutPrefixList $i] != "0000") && ([lindex $dutPrefixList $i] != "")} {
         break;
      }
   }
   set dutPrefix [join  [lrange $dutPrefixList 0 $i] :]
   lappend paramList "\{$dutPrefix\} 0"
   set ipAddr1 [GetKeyValue "show conf" $paramList]
   set paramList ""
   lappend paramList "\{$dutPrefix\} 1"
   set ipv6Address [GetKeyValue "show conf" $paramList]
   set ipAddr2 [lindex [split  $ipv6Address /] 0]
   set prefixLength [lindex [split $ipv6Address /] 1] 
   set gatewayIpv6Addr "$ipAddr1$ipAddr2"
   set deviceHndl $cmdResults(-ReturnList)
   if {$prefixLength == ""} { set prefixLength 64 }
   logcmd stc::config [logcmd stc::get $deviceHndl -children-Ipv6If] -Address $routerIp \
      -prefixLength $prefixLength -Gateway [makeIpv6Gateway $routerIp]
   logcmd stc::create Ipv6If -under $deviceHndl \
      -stackedonendpoint-Targets [lindex [logcmd stc::get $deviceHndl -children-EthIIIf] 0]\
      -toplevelif-Sources $deviceHndl -Address $linkLocalAddr
   stc::apply
   set ripRouterAttrs "-under $deviceHndl -RipVersion NG -DutIpv6Addr ff02::9"
   if {$updateInterval != ""} {
      append ripRouterAttrs  " -UpdateInterval $updateInterval"
   }
   if {$updateIntervalOffset != ""} {
      append ripRouterAttrs  " -UpdateJitter $updateIntervalOffset"
   }
   set ripRouterConfig [eval "logcmd stc::create RipRouterConfig [subst $ripRouterAttrs]"] 
   logcmd stc::apply
   set idx 0 
   while {[llength $rangeIpList] > $idx} {    
      # Extract the information from the table and set the route ranges 
      set myIp [lindex $rangeIpList $idx]
      set prefix [lindex $prefixList $idx]
      set numRoutes [lindex $numRouteList $idx]
      set metric [lindex $metricList $idx]
      set nextHop [lindex $nexthopList $idx]
      set routeTag [lindex $tagList $idx]
      incr idx
      set ipv6RouteAttrs "-under $ripRouterConfig"
      if {$metric != ""} {
         append ipv6RouteAttrs  " -Metric $metric"
      }
      if {($nextHop != "") && ($nextHop != "::") && ($nextHop != "0:0:0:0:0:0:0:0")} {
         #	append ipv6RouteAttrs  " -NextHop $nextHop"
      }
      if {$routeTag != ""} {
         append ipv6RouteAttrs  " -RouteTag $routeTag"
      }
      
      set ripv6Route [eval "logcmd stc::create RipngRouteParams [subst $ipv6RouteAttrs]"]
      set ipv6BlockAttrs "-StartIpList $myIp"
      if {$prefix != ""} {
         append ipv6BlockAttrs  " -PrefixLength $prefix"
      }
      if {$numRoutes != ""} {
         append ipv6BlockAttrs  " -NetworkCount $numRoutes"
      }
      eval "logcmd stc::config [lindex [logcmd stc::get $ripv6Route -children-Ipv6NetworkBlock] 0] [subst $ipv6BlockAttrs]"
      logcmd stc::apply
   }									
   logcmd stc::apply
}

proc startRipng {txPortIdList} {
   
   set pList "";
   set globalDeviceList ""
   foreach txPortId $txPortIdList {
      set txPortId [hMapPortIdToSpirentPort $txPortId]
      set deviceList [logcmd stc::get $txPortId -affiliationport-Sources]
      result_debug "startRipng: Device List - $deviceList"
      set globalDeviceList [concat $globalDeviceList $deviceList]				
   }
   
   logcmd stc::perform DeviceStartCommand -DeviceList $globalDeviceList
}

proc stopRipng {txPortIdList} {
   
   set pList "";
   set globalDeviceList ""
   foreach txPortId $txPortIdList {
      set txPortId [hMapPortIdToSpirentPort $txPortId]
      set deviceList [logcmd stc::get $txPortId -affiliationport-Sources]
      result_debug "stopRipng: Device List - $deviceList"
      set globalDeviceList [concat $globalDeviceList $deviceList]				
   }
   
   if {[catch {logcmd stc::perform DeviceStopCommand -DeviceList $globalDeviceList} retCode]} {
      error "stopRipng: Spirent device start failed."
   } 
}

proc cleanupRipng {txPortIdList routerIp} {
   foreach txPortId $txPortIdList {
      set txPortId [hMapPortIdToSpirentPort $txPortId]
      foreach emulatedDevice [logcmd stc::get $txPortId -affiliationport-Sources] {
         set ipv6IfList [logcmd stc::get $emulatedDevice -children-Ipv6If]
         foreach ipv6If $ipv6IfList {
            if {$ipv6If != ""} {
               if {[logcmd stc::get $ipv6If -Address] ==  $routerIp | $routerIp == "*"} {
                  logcmd stc::delete $emulatedDevice
                  break
               }
            }
         }
      }									
      
   }			
}

proc getPhyObject {portId} {
   if {[set obj [logcmd stc::get $portId -children-EthernetFiber]] == {}} {
      set obj [logcmd stc::get $portId -children-ethernetcopper]
   }
   return $obj
}

proc EnableFlowControl {portIdList mode {maxWait 15}} {

   puts " Setting ports - $portIdList to flow control mode : $mode"
   foreach portId [hMapPortIdToSpirentPort $portIdList] {
      set phyObj [getPhyObject $portId]
      set attrib "-Duplex Full -AlternateSpeeds SPEED_1G"
      switch [string tolower $mode] {
         asymmetric {
            append attrib " -FlowControl false"
            append attrib " -AutoNegotiationMasterSlaveEnable false"
            append attrib " -PortSetupMode PORTCONFIG_ONLY"
         }
         symmetric  {
            append attrib " -FlowControl false"
            append attrib " -AutoNegotiationMasterSlaveEnable true"
            append attrib " -PortSetupMode REGISTERS_ONLY"
         }
         none       {
            append attrib " -FlowControl false"
            append attrib " -AutoNegotiationMasterSlaveEnable false"
            append attrib " -PortSetupMode PORTCONFIG_ONLY"
         }
         both       {
            append attrib " -FlowControl true"
            append attrib " -AutoNegotiationMasterSlaveEnable true"
            append attrib " -PortSetupMode REGISTERS_ONLY"
         }
      }
      eval logcmd stc::config $phyObj $attrib
      stc::apply
      if {$maxWait == 0} {
         continue
      }
      set maxWaitCounter $maxWait
      
      while { $maxWaitCounter } {
         set state [string tolower [logcmd stc::get [getPhyObject $portId] -LinkStatus]]
         if {$state == "up"} {
            result_debug "FOUND LINK UP for portId:$portId!"
            break
         } else {
            result_debug "Waiting for portId:$portId linkUp.."
            sleep 1
            incr maxWaitCounter -1
         }
      }
      
      if {$maxWaitCounter == 0} {
         result_warning "WARNING: No linkUp for Spirent portId:$portId"
      }
   }
}

proc ixiaUserDefinedStat1 {{portId 1} {fd_res "NULL"} {fd_in "NULL"}} {
   
   global spawn_id
   
   after 1000
   MapIxiaPortId $portId ch cd pt
   set portId [hMapPortIdToSpirentPort $portId]
   
   if {$fd_res != "NULL"} {puts $fd_res "--- ($ch $cd $pt)"}
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }
   
   StopPortsCapture $portId
   stat get statAllStats $ch $cd $pt
   set frReceived [stat cget -userDefinedStat1]
   set frSent [stat cget -framesSent]
   puts "Frames sent = $frSent"
   if {$fd_res!="NULL"} {puts $fd_res "Frames sent = $frSent"}
   puts "Total frames received = [stat cget -framesReceived] (not used)"
   puts "Filtered frames UDS1 received = $frReceived"
   if {$fd_res!="NULL"} {puts $fd_res "Filtered frames UDS1 received = $frReceived"}
   if { $fd_in != "NULL" } {
      puts $fd_in "$frSent"
      puts $fd_in "$frReceived"
   } else {
      set SentReceivedPackets "$frSent $frReceived"
      return $SentReceivedPackets
   }
}

proc sendIgmpv3BadReport {args} {
   parse_args sendIgmpv3BadReport $args {
      igmpMsgType "34"
      reportType "1"
      hostIp "137.1.1.1"
      srcIpAddr "137.1.1.1"
      groupAddr "232.1.1.1"
      txPortId  "1"
      numSource "1"
      numGroup "1"
      streamType "stopStream"
   }

   set txPort [hMapPortIdToSpirentPort $txPortId]
   #Stop generator before making changes.
   logcmd stc::perform GeneratorStop -GeneratorList $txPort
   
   # Delete all streamblocks on tx port
   deleteAllStreams $txPort
   
   
   # initialize streamblock arguments
   set stream_args {-insertSig FALSE -EqualRxPortDistribution FALSE -EnableHighSpeedResultAnalysis FALSE}
   lappend stream_args -ConstantFillPattern 0 -frameconfig {}
   # Create basic stream
   set hStreamBlock [eval logcmd stc::create streamBlock -under $txPort $stream_args]
   set sMacAddr [GetDefaultPortIdMAC -portId $txPort]
   lappend eth_args -srcMac [join $sMacAddr :]

   set destMacMulticast [GetMulticastMac $groupAddr]
   lappend eth_args -dstMac [join $destMacMulticast :]

   set hEthernet [eval logcmd stc::create ethernet:EthernetII -under $hStreamBlock \
                     -name sb1_eth $eth_args]
   incr dataoffset 14
   set ipoffset 14
   set hIpv4 [logcmd stc::create ipv4:IPv4 -under $hStreamBlock -name sb1_ip \
                 -sourceAddr $hostIp -destAddr $groupAddr -ttl 64 -identification 0 -protocol 2]
   incr dataoffset 20
   set hRangeModifier [logcmd stc::create RangeModifier \
                          -under $hStreamBlock \
                          -ModifierMode INCR \
                          -Mask 65535 \
                          -StepValue "1" \
                          -Data 0 \
                          -RecycleCount 65535 \
                          -DataType NATIVE \
                          -EnableStream false \
                          -RepeatCount 0 \
                          -OffsetReference "sb1_ip.identification"]
   set hIgmp [logcmd stc::create igmp:Igmpv3Report -under $hStreamBlock \
                 -numGrpRecords $numGroup -type [format %02x $igmpMsgType] -name sb_igmp]
   set grpRecordsObj [logcmd stc::create grpRecords -under $hIgmp]
   set grpRecord [logcmd stc::create GroupRecord -under $grpRecordsObj -mcastAddr $groupAddr -recordType $reportType]
   incr dataoffset 16
   set srcListGroup [logcmd stc::create addrList -under $grpRecord -name sourceList]
   set srcIpAddr1 [lindex $srcIpAddr 0]
   set srcIpAddr2 [lindex $srcIpAddr 1] 
   if {$numSource != 0 } {
      incr dataoffset 4
      set src(1) [logcmd stc::create Ipv4Addr -under $srcListGroup -name addr1 -value $srcIpAddr1]
      if {$srcIpAddr2 != {} } {
         set src(2) [logcmd stc::create Ipv4Addr -under $srcListGroup -name addr1 -value $srcIpAddr2]
         incr dataoffset 4
      }
   }
   set framesize [expr $dataoffset + 4]
#   if {$dataoffset > 64} {set framesize $dataoffset}
   set stream_args [list -frameLengthMode FIXED -FixedFrameLength $framesize]
   eval logcmd stc::config $hStreamBlock $stream_args
   result_debug "Send an IGMPv3 report of type $igmpMsgType for source $srcIpAddr and \
              group $groupAddr"
   # configure generator
   configGen $txPort stopStream $framesize 1 1 1000 1
   stc::apply
   logcmd stc::perform ResultClearAllTraffic -PortList "$txPort"
   StartPortsTransmit $txPort
   stcCheckTxDone -txPortId $txPort
   return [getFrameContents $hStreamBlock 2 $ipoffset]
  
}
