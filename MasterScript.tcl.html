<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>MasterScript.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#MasterScript.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>MasterScript.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="MasterScript.tcl-annot.html">annotations</a> | <a href="MasterScript.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

package require Tclx

<strong><a name="::::print_usage_5">proc <a href="MasterScript.tcl-annot.html#::::print_usage">::::print_usage</a></a></strong> {} {
    puts &#34;\r&#34;
    puts {Usage: QLoadImage.tcl -cfg &lt;cfg.cfg&gt; -platformList | -pl &lt;platforms&gt; -platformImageList | -pil &lt;paths&gt; -qId &lt;regQID&gt; -bootrom &lt;bootrom&gt; -partition | -p &lt;pri|sec&gt; -subversion &lt;subversion&gt;}
    puts {      [&lt;cfg&gt;]: f48_std.cfg}
    puts {      [&lt;platformList&gt; | &lt;pl&gt;]: list of platforms ie &#34;Mariner Aspen Everest x460&#34;       }
    puts {      [&lt;platformImageList&gt; | &lt;pil&gt;]: list of images &#34;/tftp2/bd10K-12.4.0.20.xos /tftp2/bd10K-12.4.0.20.xos&#34;}
    puts {      [&lt;commonPath&gt; | &lt;cp&gt;]: common path for images root /home/autotest-sc/images}
    puts {      [qId]: regression Q ID if any -  SC_######_###### or RTP_######_######}
    puts {      [reboot | r] : yes,y | no,n Default is no}                                                 
    puts {         (Script verifies the platform before download image)}
    puts {      [&lt;bootrom&gt;]: bootver (assume in root of your location share)}
    puts {      [&lt;partition | p] which partition to download to. Default is secondary}
    puts {      [&lt;xmod&gt;]: a list of xmods the need to be downloaded. Just the name 'ssh' '8900diags'}
    puts {      [&lt;randomIndex&gt;] default is unknown .  seed for result directory}
    puts {      [&lt;subversion&gt;]: subversion variable if any, used for private testing}
    puts {          }
    puts {      -------------      Currently supported Platforms s of 1/1/2010 ------------------}
    puts {           Mariner Aspen Aspennapa Cougar Lynx LynxG Manhattan Everest}
    puts {           Manhattan10G Melange Melange10G Olympic Torino Voyager Pathfinder }
    puts {           Panther Stacking Sonoma x650 x480 NWI Jaguar i386 x430 x870 viper}
    puts {}
    puts {          }
    puts {         (Typical Usage:) }
    puts {      (./QLoadImage.tcl -cfg exos1243.cfg -platformList &#34;Aspen x480&#34; -platformImageList &#34;./aspen.xos ./summit.xos&#34;) | -reboot &lt;yes|no&gt; }
    puts &#34;\r&#34;
}

set tftpServerLogin       &#34;extreme&#34;
set tftpServerPasswd      &#34;extreme&#34;
set tftpServerTftpboot    &#34;/tftpboot&#34;
global xmod

<span class="comment-line"># checking command parameters</span>
if {$argc&lt;2} {
    puts &#34;Not enough parameters&#34;
    <a name="::::print_usage(1)"><a href="./summarize.tcl.html#::::print_usage_2">::::print_usage</a></a>
    exit
}

set LIB_PATH &#34;../Lib&#34;
lappend auto_path $LIB_PATH

source ../Lib/parse_args.tcl
source ../Lib/mainLib.tcl
source ../Lib/downLoadCode.tcl
puts &#34;auto_path 111 ---------- $auto_path&#34;
<span class="comment-line">##################################################################################</span>
<span class="comment-line">#  Parse Args</span>
<span class="comment-line">##################################################################################</span>
<a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> QLoadImage $argv {
    cfg     &#34;NULL&#34;
    platformList	&#34;NULL&#34;
    platformImageList	&#34;NULL&#34;
    pl                  &#34;NULL&#34;
    pil                 &#34;NULL&#34;
    relmanbuild         &#34;NULL&#34;
    rmb                 &#34;NULL&#34;
    commonPath          &#34;NULL&#34;
    cp                  &#34;NULL&#34;
    qId                 &#34;NULL&#34;
    bootrom             &#34;NULL&#34;
    partition           &#34;NULL&#34;
    p                   &#34;NULL&#34;
    xmod                &#34;NULL&#34;
    subversion          &#34;NULL&#34;
    randomIndex         &#34;unknown&#34;
    in                  &#34;sc&#34;
    unc                 &#34;no&#34;
    reboot              &#34;no&#34;
    r                   &#34;NULL&#34;
    build               &#34;NULL&#34;
}

global DUTs_info whichDutNow


puts &#34;QLoadImage.tcl  -cfg $cfg \n \
    -platformList $platformList \n \
    -platformImageList $platformImageList \n \
    -pl $pl \n \
    -pil $pil \n \
    -relmanbuild $relmanbuild \n \
    -rmb $rmb \n \
    -commonPath $commonPath \n \
    -cp $cp \n \
    -qId $qId \n \
    -bootrom $bootrom \n \
    -partition $partition \n \
    -p $p \n \
    -xmod $xmod \n \
    -subversion $subversion \n \
    -randomIndex $randomIndex \n \
    -in $in \n \
    -unc $unc \n \
    -reboot $reboot \n \
    -r $r \n \
    -build $build&#34;


set module &#34;QLoadImage&#34;
set harness &#34;tcl&#34;
set TRYFAILSAFE true
<a name="::::gen_index(1)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;../Lib&#34;
<span class="comment-line">##################################################################################</span>
<span class="comment-line">#  Source the config files</span>
<span class="comment-line">##################################################################################</span>
set sourceFile &#34;&#34;
<span class="comment-line">#if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {</span>
<span class="comment-line">#    puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;</span>
<span class="comment-line">#    puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;</span>
 <span class="comment-line">#   exit -1</span>
<span class="comment-line">#}</span>
if [catch {source &#34;../Util/runReg.cfg&#34;} rea] {
    puts &#34;*** WARNING: Unable to source queuing system runReg.cfg:$rea..... ***&#34;
    puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
    exit -1
}
if [catch {source &#34;../main/runReg.cfg&#34;} rea] {
    puts &#34;*** WARNING: Unable to source queuing system main runReg.cfg:$rea..... ***&#34;
    puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
    exit -1
}
if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
    puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
    puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
    exit -1
}
if {$cfg != &#34;null&#34;} {
    set sourceFile $cfg
    if {([regexp -nocase &#34;^short&#34; $sourceFile]&amp;&amp;[regexp -nocase {/} $sourceFile]) || \
    [regexp -nocase &#34;^pt&#34; $sourceFile]} {
        set sourceFile [format %s/%s/%s $regType $module $sourceFile]
        set sourceFile [string trim $sourceFile];
        puts &#34;Using config file: ($sourceFile)&#34;
    } elseif {![regexp -nocase &#34;^cfg&#34; $sourceFile] &amp;&amp; ![regexp -nocase {/} $sourceFile]} {
        if {[file exists $sourceFile]==0} {
            set sourceFile [format %s/%s cfg $sourceFile]
            set sourceFile [string trim $sourceFile];
            puts &#34;Using config file: ($sourceFile)&#34;
        }
    }
}
if {[file exists $sourceFile] == 0} {
    puts &#34;Cannot find config file: $sourceFile\n&#34;
    exit
}
catch {source $sourceFile} reason

set MAIN(cfg) [file tail $sourceFile]
    set curAutoRoot [<a name="::_setCurrentAutoDir(1)"><a href="./filetools.tcl.html#::_setCurrentAutoDir_149">::_setCurrentAutoDir</a></a>]
    set MAIN(autoRoot) $curAutoRoot;<span class="comment-line"># More portable</span>
    set MAIN(feature_directory) &#34;QLoadImage&#34;
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Set xterm title</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    <a name="::SetTerminalTitle(1)"><a href="./queueLib.tcl.html#::SetTerminalTitle_5146">::SetTerminalTitle</a></a> -add $qId
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Translate shortened names (platformList  &lt;-&gt; pl  etc)</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>

<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Translate shortened names (platformList  &lt;-&gt; pl  etc)</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
if {$pl != &#34;NULL&#34;} {
    set platformList $pl
}
if {$pil != &#34;NULL&#34;} {
    set platformImageList $pil
}

 if {$cp != &#34;NULL&#34;} {
        set commonPath $cp
    }
    if {$rmb != &#34;NULL&#34;} {
        set relmanbuild $rmb
    }
    if {$relmanbuild != &#34;NULL&#34;} {
        set build $relmanbuild
    }

<span class="comment-line"># We will use bootPart as the partition that needs to be loaded for image to download</span>
<span class="comment-line">#   targetPart is the location for the image to be downloaded to</span>
<span class="comment-line">#   In other lib procs partition is the same as bootPart</span>
if {$p!=&#34;NULL&#34;} {
    set partition $p
}
if {[regexp -nocase &#34;sec&#34; $partition]} {
    set bootPart primary
    set targetPart secondary
} elseif {[regexp -nocase &#34;pri&#34; $partition]} {
    set bootPart secondary
    set targetPart primary
} else {
    set bootPart primary
    set targetPart secondary
}
<span class="comment-line"># Reboot verify and short var setup</span>
if {$r!=&#34;NULL&#34;} {
    set reboot $r
}
set reboot [string tolower $reboot]
if {[regexp -nocase &#34;y&#34; $reboot]} {
    set reboot &#34;yes&#34;
} elseif {[regexp -nocase &#34;n&#34; $reboot]} {
    set reboot &#34;no&#34;
} else {
    set reboot no
}


    set MAIN(qId) $qId
    set MAIN(reboot) $reboot
    set MAIN(bootPart) $bootPart
    set MAIN(targetPart) $targetPart
    set MAIN(build) $build




<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Get DUT count info</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    _getTestBedNumNodes;<span class="comment-line"># Define MAIN(DUTLIST)  MAIN(NODECOUNT)</span>
    set dut $MAIN(NODECOUNT)


<span class="comment-line"># ----- This is necessary to get an absolute path for logging</span>
set REG_PATH [pwd]
set MAIN(REG_PATH) [pwd]
set MAIN(feature_type) &#34;QLoadImage&#34;;<span class="comment-line">#</span>

<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Load expect and source Libraries</span>

<span class="comment-line"># ----- load {expect52.dll}</span>
load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
log_user 0

lappend auto_path [file join $env(HOME) &#34;ixia/lib/mpexpr-1.0&#34;]
lappend auto_path [file join $env(HOME) &#34;ixia/lib/ixTcl1.0&#34;]
lappend auto_path [file join $env(HOME) &#34;ixia/lib/dp4.0&#34;]

 <span class="comment-line"># -- Make sure directory structure exists in main folder</span>
    <a name="::_createSupportDirectories(1)"><a href="./filetools.tcl.html#::_createSupportDirectories_50">::_createSupportDirectories</a></a> -dirList &#34;Report Result Tmp Log&#34;

<a name="::::gen_index(2)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> .

<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Register with tracking db and check for conflicts</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    set MAIN(TrackInit) [<a name="::OpenTrackingPort(1)"><a href="./resource_track.tcl.html#::OpenTrackingPort_7">::OpenTrackingPort</a></a> -cfg &#34;[file tail $cfg]&#34; -script_name &#34;QLoadImage&#34; ]

<span class="comment-line"># ------------------------------------------------------------------------</span>

<span class="comment-line">############################################################</span>

set tStartTime [clock seconds]
    set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
    set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]

    set filesToDelete   &#34;&#34;
    set imageNotFound   0
    set romNotFound     0
    set passCount       0
    set failCount       0
    set skipCount       0
    set testDuration    0
    set testHour        0
    set testMin         0
    set testSec         0
    set resultDir        &#34;NULL&#34;;<span class="comment-line"># NULL forces creation of a new resultDir (also global resultDir)</span>
    set MAIN(RESULTPATH) &#34;Result&#34;
    set MAIN(RESULTDIR)  &#34;null&#34;;<span class="comment-line"># all script results file will be posted here while running</span>
    set MAIN(REPORTDIR)  &#34;null&#34;;<span class="comment-line"># ResultDir is renamed to this at the very end.</span>
    set skipCopy        1
    set numDUT  1
    set ReportLoginError &#34;no&#34;
    set at              &#34;download&#34;


global currentTestNumber
set MAIN(CURRENTTESTCASE) QLoadImage
puts &#34;QLoadImage.tcl CUR DIR: [pwd]&#34;
<span class="comment-line">#let's create result directory</span>
<a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> $randomIndex
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Setup input variables based on the args passed in.  </span>
<span class="comment-line"># ------------------------------------------------------------------------</span>


    if {$relmanbuild != &#34;NULL&#34;} {
        set flist [<a name="::getCfgFamilies(1)"><a href="./mysqlLib.tcl.html#::getCfgFamilies_1831">::getCfgFamilies</a></a> $MAIN(cfg)]
        set flist [string trim $flist &#34;\{|\}&#34;]
        set flist [split $flist &#34; &#34;]
        puts &#34;flist $flist&#34;
        set platformList &#34;&#34;
        set platformImageList &#34;&#34;
        foreach f $flist {
            lappend platformList $f
            set fp [<a name="::RelManGetImagePath(1)"><a href="./LocateImage.tcl.html#::RelManGetImagePath_243">::RelManGetImagePath</a></a> -buildtag $relmanbuild -family $f]
            lappend platformImageList $fp
            if {[regexp -nocase &#34;invalid&#34; $fp]} {
                puts &#34;Attempt to find family $f on the database go invalid path&#34;
                set errorInfo &#34;&#34;
                puts stderr 1
                flush stderr
                exit 1
            }
        }
    }



if {$platformList == &#34;NULL&#34; &amp;&amp; $pl == &#34;NULL&#34;} {
    puts &#34;*** WARNING: Both platform list variables can not be empty:$rea..... ***&#34;
    exit -1
}
if {$platformImageList == &#34;NULL&#34; &amp;&amp; $pil == &#34;NULL&#34;} {
    puts &#34;*** WARNING: Both platform image path lists variables can not be empty:$rea..... ***&#34;
    exit -1
}
set xmodString &#34;&#34;

  set xmodString &#34;&#34;
    set MAIN(DOWNLOADXMODS) 0
    if {$xmod != &#34;NULL&#34;} {
        set xmodString &#34;Xmods to Load: &#34;
        puts &#34;We are loading xmods along with the xos images&#34;
        set MAIN(DOWNLOADXMODS) 1
        foreach xm $xmod {
            append xmodString &#34;$xm &#34;
        }
    }



<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># Setup download specific variables.</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
    if {[llength $platformList] &lt; 1} {
        puts &#34;*** WARNING: The platform list is empty.  Enter ..... ***&#34;
        exit -1
    }
    if {[llength $platformImageList] &lt; 1} {
        puts &#34;*** WARNING: The platform image path list is empty.  You must enter the ..... ***&#34;
        exit -1
    }
    if {[llength $platformImageList] != [llength $platformList]} {
        puts &#34;*** WARNING: The platform image path list MUST equal the platform list  ..... ***&#34;
        exit -1
    }
    foreach pFile $platformImageList {
        if {![file exists $pFile]} {
            puts &#34;*** WARNING: File $pFile does not exist.  It cannot be downloaded  ..... ***&#34;
            exit -1
        }
    }
    foreach p $platformList {
        if {[lsearch $DEVREG(server,allPlatforms) $p] &lt; 0 &amp;&amp; [lsearch $IMAGEFAMILIES $p] &lt; 0} {
            puts &#34;*** WARNING: $p is not a legal platform OR image family.  ..... ***&#34;
            exit -1
        }
    }


<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
puts &#34;\n==========================================================================\n\
       Load Image to test bed DUTs\n\
       Platforms: $platformList\n\
       PlatformImages: $platformImageList\n\
       $xmodString\n\
      ==========================================================================&#34;
<span class="comment-line"># ------------------------------------------------------------------------</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>

<span class="comment-line">##############################################################################</span>
<span class="comment-line">##  Get information about the DUT</span>
<span class="comment-line">##############################################################################</span>
set fd_res [<a name="::open_result_file(1)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;Setup&#34;]

<span class="comment-line">################################################################################################################</span>
<span class="comment-line"># --------------------------------------------------------</span>
    <span class="comment-line"># Gather DUTs_info variables that are not Software Related</span>
    <span class="comment-line">#   - loop to get the DUT count and build multitask procs</span>
    <span class="comment-line"># --------------------------------------------------------</span>
    <a name="::::_initDUTs_infoArray(1)"><a href="./swConf.tcl.html#::::_initDUTs_infoArray_11">::::_initDUTs_infoArray</a></a>;
    set numDUT $MAIN(NODECOUNT);<span class="comment-line"># _initDUTs_infoArray sets this</span>
    set getInfoList &#34;&#34;
    set pduProcs &#34;&#34;
    set pduList &#34;&#34;
    foreach dut $MAIN(DUTLIST) {
        set DUTs_info(DUT$dut,loginQuick)  10;<span class="comment-line"># set expect timeout to 10 second</span>
        set DUTs_info(DUT$dut,qloadInitLogin) 1;
        set DUTs_info(DUT$dut,imageBooted) &#34;NULL&#34;
        puts &#34;***** DUT${dut}_CONNECT=[set DUT${dut}_CONNECT] ***** &#34;
        puts &#34;***** numDUT=$dut ***** &#34;
        _SetPartitionVars -dut $dut;<span class="comment-line"># Get port info from cfg file</span>
        if {[<a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0] == 0} {
            <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n!!\n!!\n!!\nCould not pre-check DUT $dut for download.\n\
                  Lets see if powerCycle recovers it\n!!\n!!\n!!&#34;
            lappend pduList &#34;$dut&#34;
            lappend pduProcs &#34;PowerCycleDUT $dut YES false&#34;
            continue;<span class="comment-line"># If device is hung. Hope for powercycler below.</span>
        }
        set DUTs_info(DUT$dut,qloadInitLogin) 0;
        <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable log display&#34;
        <span class="comment-line">#SendACmd &#34;use image $MAIN(bootPart)&#34;</span>
        lappend getInfoList  &#34;_get_HW_DUTs_info -dut $dut -checkOperational 0&#34;
        set DUTs_info(DUT$dut,loginQuick)  10;
    }
    if {[llength $pduList] &gt; 0} {
        <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;-------------- No console on DUT $pduList --------------&#34;
        <a name="::_setShowOutput(1)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt on
        <a name="::MultiTask(1)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $pduProcs
        <a name="::_setShowOutput(2)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    }
    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;-------------- Gather DUT Information --------------&#34;
    <a name="::_setShowOutput(3)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt on
    <a name="::MultiTask(2)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $getInfoList
    <a name="::_setShowOutput(4)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    <a name="::::_printMultiTaskOutput(1)"><a href="./swConf.tcl.html#::::_printMultiTaskOutput_3651">::::_printMultiTaskOutput</a></a>;<span class="comment-line"># show the output in order + in result file</span>
<span class="comment-line"># ----------------------------------------------------------------------------</span>
<span class="comment-line"># Prepare for download.</span>
<span class="comment-line">#    - If PDU+noSkip global  on all DUTs don't check anything..straight to the setup script</span>
<span class="comment-line">#    - If partial PDU or skip - unc all none PDU to bootPart. Then setup script</span>
<span class="comment-line">#</span>
<span class="comment-line"># ----------------------------------------------------------------------------</span>
    foreach dut $MAIN(DUTLIST) {
        set DUTs_info(DUT$dut,loginQuick)  0;
        if {$MAIN(bootPart) == $DUTs_info(DUT$dut,imageBooted)} {
            set wayToBootPart($dut) &#34;null&#34;
        } elseif {[regexp -nocase &#34;sec&#34; $MAIN(bootPart)]} {
            set wayToBootPart($dut) &#34;unconfigSw&#34;
        } elseif {[info exists POWERCYCLE_DUT(1)] &amp;&amp; [info exists SWDEVSERVER] &amp;&amp; $SWDEVSERVER} {
            if {[regexp -nocase &#34;$SKIPPCTOBOOTROM&#34; $DUTs_info(DUT$dut,sysType)]} {
                set wayToBootPart($dut) &#34;unconfigSw&#34;
            } elseif {[info exists SKIPPCTOBOOTROMFLAG] &amp;&amp; $SKIPPCTOBOOTROMFLAG} {
                set wayToBootPart($dut) &#34;unconfigSw&#34;
            } elseif {[info exists swidSwapList]} {
                set wayToBootPart($dut) &#34;setupScript&#34;
            } else {
                set wayToBootPart($dut) &#34;setupScript&#34;
            }
        } else {
            set wayToBootPart($dut) &#34;unconfigSw&#34;
        }
    }
    <span class="comment-line"># ----------------------------------------------------------------------------</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># Run either setupscript or cli unconfigure switch if powercycle not available.</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># ----------------------------------------------------------------------------</span>
    <a name="::::_multiRunSetupScript(1)"><a href="./swConf.tcl.html#::::_multiRunSetupScript_442">::::_multiRunSetupScript</a></a>

    <span class="comment-line"># Old get_DUTs is going away once json version is available... and forked.</span>
    if {[set rc [<a name="::::get_DUTs_info(1)"><a href="./swConf.tcl.html#::::get_DUTs_info_881">::::get_DUTs_info</a></a>]] != 0} {
        <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
        <a name="::close_result_file(1)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;
        return -1;
    }

    <span class="comment-line"># ------------------------------------------------------------------------</span>
    <span class="comment-line"># Verify that all DUTs are on the boot parition</span>
    <span class="comment-line">#      Just in case powercycle to bootrom didn't work</span>
    <span class="comment-line"># ------------------------------------------------------------------------</span>
    set reTryBoot &#34;&#34;
    for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
        if {$MAIN(bootPart) != $DUTs_info(DUT$i,imageBooted)} {
            set wayToBootPart($i) &#34;unconfigSw&#34;
            <a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${i}_CONNECT] -masterCheck 0 -CheckOperational 0
            <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image $MAIN(bootPart)&#34;
            lappend reTryBoot $i
        }
    }
    if {[llength $reTryBoot] &gt; 0} {
        <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUTS $reTryBoot were not on the correct boot partition. Recover.&#34;
        <a name="::::_multiRunSetupScript(2)"><a href="./swConf.tcl.html#::::_multiRunSetupScript_442">::::_multiRunSetupScript</a></a> -dutListIn $reTryBoot
    }

<a name="::close_result_file(2)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;



set fd_res [<a name="::open_result_file(2)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;QLoadImage&#34;]
<span class="comment-line">###################################################################################################################################</span>


<span class="comment-line"># Init arrays inwhich platforms (lower) are the keys.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Then:  tftp image from the local regserver path to the tftp server.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Note: for the queueing system /var/spool/regression/imagesQueued/&lt;mod&gt;/file</span>
<span class="comment-line"># ------------------------------------------------------------------------</span>
set q 0;
set goodImageHit 0;
set goodXImageHit 0;

<span class="comment-line"># IMAGEFAMILYSYSTYPES($iFamily)  DEVREG(platImageType,$lowerPlat) IMAGEFAMILIES</span>
<span class="comment-line">#  DEVREG(server,allPlatforms)</span>
<span class="comment-line"># Initialize the TftpFile for all supported image Families</span>
foreach ifam $IMAGEFAMILIES {
    set TftpFile($ifam)  &#34;NULL&#34;
    set platType($ifam)  &#34;NULL&#34;
    set XmodPathList($ifam) &#34;&#34;
}

<span class="comment-line"># -------------------------------------------------------------------------</span>
<span class="comment-line"># Figure out thePlat from the cfgs</span>
<span class="comment-line"># -------------------------------------------------------------------------</span>
set xmodPlatforms &#34;&#34;
set xmodPairs {}
set xmodByPlat(null) &#34;&#34;
for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
    <span class="comment-line">#  Determine if this platform requires the xmods #</span>
    <span class="comment-line">#  The REQUIRED_XMOD variable is set in the common.cfg</span>
    <span class="comment-line">#  In download we do not know which image is going to install</span>
    <span class="comment-line">#  so we will ignore the versions and hope the user passed</span>
    <span class="comment-line">#  in the xmods appropriately</span>
    <span class="comment-line">#  REQUIRED_XMOD(8900diags,SysTypes) $manhattanBlade</span>
    <span class="comment-line">#  REQUIRED_XMOD(8900diags,SupportStartRelease) &#34;16.2&#34;</span>
    <span class="comment-line">#  REQUIRED_XMOD(8900diags,SupportEndRelease) &#34;null&#34;</span>
    set xmodDUT($i) 0
    if {$MAIN(DOWNLOADXMODS)} {
        <span class="comment-line"># -- Loop through submitted platforms to match dut number SysName and hwList</span>
        <span class="comment-line">#      This is required b/c we don't know which duts support the xmod</span>
        foreach thePlat $platformList {
            set thePlatLower [string tolower $thePlat]
            if {[lsearch $DEVREG(server,allPlatforms) $thePlat] &gt;= 0} {
                set imageFam $DEVREG(platImageType,[string tolower $thePlat])
                puts &#34;Convert platform $thePlat to image family $imageFam&#34;
            } elseif {[lsearch $IMAGEFAMILIES $thePlat] &gt;= 0} {
                set imageFam $thePlatLower
            } else {
                puts &#34;Unrecognized image $thePlat: Should be $IMAGEFAMILIES\nOR\n$DEVREG(server,allPlatforms)\n&#34;
                exit;
            }
            <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Searching for xmod download for $thePlat - family $imageFam&#34;
            if {![info exists xmodByPlat($imageFam)]} {
                set xmodByPlat($imageFam) &#34;&#34;
            }
            if {[lsearch -exact -nocase $DEVREG(server,allPlatforms) $thePlat]&gt;=0 ||
                       [lsearch $IMAGEFAMILIES $thePlat] &gt;= 0} {
                if {[regexp -nocase &#34;$IMAGEFAMILYSYSTYPES($imageFam)&#34; &#34;$DUTs_info(DUT${i},sysType)&#34;]} {
                    <span class="comment-line"># On a DUT that matches rdureg alias, loop through passed xmods</span>
                    <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;XMOD check matched the platform $thePlat / family $imageFam&#34;
                    foreach xm $xmod {
                        <span class="comment-line"># check the hwList and systype to see if xmod should be loaded here</span>
                        if {[regexp -nocase $REQUIRED_XMOD($xm,SysTypes) \
                              $DUTs_info(DUT${i},hwList)] ||
                              [regexp -nocase $REQUIRED_XMOD($xm,SysTypes) \
                              $DUTs_info(DUT${i},platform)]} {
                            <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Enable xmod vars $imageFam $xm&#34;
                            set xmodTftpFiles($imageFam,$xm) &#34;NULL&#34;
                            lappend xmodPlatforms $imageFam
                            lappend xmodByPlat($imageFam) [string trim $xm]
                            lappend xmodPairs &#34;$i $xm&#34;
                            set xmodDUT($i) 1
                        }
                    }
                }
            }
        }
    }
}
<span class="comment-line"># ----------------------------------------------------------------------------</span>
<span class="comment-line"># Match the plats and images and move them to the tftp server</span>
<span class="comment-line"># ----------------------------------------------------------------------------</span>
set q 0
foreach thePlat $platformList {
    set thePlatLower [string tolower $thePlat]
    if {[lsearch $DEVREG(server,allPlatforms) $thePlat] &gt;= 0} {
        set imageFam $DEVREG(platImageType,[string tolower $thePlat])
        puts &#34;Convert platform $thePlat to image family $imageFam&#34;
    } elseif {[lsearch $IMAGEFAMILIES $thePlat] &gt;= 0} {
        set imageFam $thePlat
    } else {
        puts &#34;Unrecognized image $thePlat&#34;
        exit;
    }
    set Md5Sum($imageFam)    0
    set platImage [lindex $platformImageList $q]
    if {[regexp -nocase {\.xos$} [string trim $platImage]]} {
        set platType($imageFam) xos
        set xosFile($imageFam) [string trimright [lindex $platformImageList $q] &#34;.xos&#34;]
    } elseif {[regexp -nocase {\.lst$} [string trim $platImage]]} {
        set platType($imageFam) lst
        set xosFile($imageFam) [string trimright [lindex $platformImageList $q] &#34;.lst&#34;]
    }
    set ImagePath($imageFam) [lindex $platformImageList $q]
    if {$MAIN(DOWNLOADXMODS)} {
        puts &#34;In DUT xmod search&#34;
        foreach xm $xmod {
            if {[info exists xmodByPlat($imageFam)]} {
                if {[lsearch $xmodByPlat($imageFam) [string trim $xm]]&gt;=0} {
                    set xf $xosFile($imageFam)-${xm}.xmod
                    lappend XmodPathList($imageFam) $xm
                    lappend XmodPathList($imageFam) $xf
                    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n@@@\n@@@\nappending xmod XmodPathList($imageFam) \&#34;$xm $xosFile($imageFam)-${xm}.xmod\&#34;&#34;
                }
            } else {
                puts &#34;missed xmod by plat $xm info does not exist for $imageFam&#34;
            }
        }
    }
    <span class="comment-line"># ------------------------------------------------------------------</span>
    <span class="comment-line"># If the file exists, tftp it from the regserver path to tftp server</span>
    <span class="comment-line"># ------------------------------------------------------------------</span>
    if {[file exists $ImagePath($imageFam)]} {
        set tftpFile [file tail $ImagePath($imageFam)]
        set goodImageHit 1;
        set pid [pid]
        set TftpFile($imageFam) [format %d%d$imageFam%s $pid $q $tftpFile]
        set fd_out [open &#34;Tmp/tmp_$pid$tStartTime&#34; &#34;w&#34;];
        puts $fd_out &#34;put $ImagePath($imageFam) $TftpFile($imageFam)&#34;
        puts $fd_out &#34;quit&#34;
        close $fd_out
        <span class="comment-line"># If the tftp server is mounted to this regression server, just cp the file</span>
        if {$TFTPMOUNT != &#34;NULL&#34; &amp;&amp; [file exists $TFTPMOUNT/default_do_not_erase]} {
            if {[catch {exec cp -L $ImagePath($imageFam) $TFTPMOUNT/$TftpFile($imageFam)} reason]} {
                puts &#34;Error to TFTP: Cannot copy $ImagePath($imageFam) to \
                     $TFTPMOUNT/$TftpFile($imageFam) ...$reason&#34;;
                foreach TFTPServerIP $tftpServerList {
                    puts &#34;Putting $ImagePath($imageFam) onto tftp Server $TFTPServerIP \
                           as $TftpFile($imageFam)&#34;
                    if {[catch {exec /usr/bin/tftp $TFTPServerIP &lt; ./Tmp/tmp_$pid$tStartTime} reason]} {
                        puts &#34;error: $reason&#34;
                        <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                        exit -1
                    }
                }
            } else {
                puts &#34;Copy $ImagePath($imageFam) to $TFTPMOUNT/$TftpFile($imageFam)&#34;
            }
        } else {
            foreach TFTPServerIP $tftpServerList {
                puts &#34;Putting $ImagePath($imageFam) onto tftp Server $TFTPServerIP as $TftpFile($imageFam)&#34;
                if {[catch {exec /usr/bin/tftp $TFTPServerIP &lt; ./Tmp/tmp_$pid$tStartTime} reason]} {
                    puts &#34;error: $reason&#34;
                    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                    exit -1
                }
            }
        }
        file delete ./Tmp/tmp_$pid$tStartTime
    } else {
        puts &#34;ImagePath($imageFam) $ImagePath($imageFam) does not exist&#34;
        exit -1
    }
    <span class="comment-line"># ------------------------------------------------------------------</span>
    <span class="comment-line"># If the xmod is passed and file exists, tftp it from the regserver path to tftp server</span>
    <span class="comment-line"># ------------------------------------------------------------------</span>
    set xmodSent &#34;&#34;
    if {$MAIN(DOWNLOADXMODS)} {
        puts &#34;Look for xmod source file - list: $XmodPathList($imageFam)&#34;
        foreach {xm XmodPath} $XmodPathList($imageFam) {
            puts &#34;-- xm $xm : XmodPath = $XmodPath&#34;
            set tftpXFile [file tail $XmodPath]
            set goodXImageHit 1;
            set pid [pid]
            set TftpXFile($imageFam) [format %d%d$imageFam%s $pid $q $tftpXFile]
            set xmodTftpFiles($imageFam,$xm) $TftpXFile($imageFam)
            set fd_out [open &#34;Tmp/tmp_X$pid$tStartTime&#34; &#34;w&#34;];
            puts $fd_out &#34;put $XmodPath $TftpXFile($imageFam)&#34;
            puts $fd_out &#34;quit&#34;
            close $fd_out
            <span class="comment-line"># If the tftp server is mounted to this regression server, just cp the file</span>
            if {$TFTPMOUNT != &#34;NULL&#34; &amp;&amp; [file exists $TFTPMOUNT/default_do_not_erase]} {
                if {[catch {exec cp -L $XmodPath \
                           $TFTPMOUNT/$TftpXFile($imageFam)} reason]} {
                    puts &#34;Error to TFTP: Cannot copy $XmodPath to \
                               $TFTPMOUNT/$TftpXFile($imageFam) ...$reason&#34;;
                    foreach TFTPServerIP $tftpServerList {
                        puts &#34;Putting $XmodPath onto tftp Server $TFTPServerIP \
                                    as $TftpXFile($imageFam)&#34;
                        if {[catch {exec /usr/bin/tftp $TFTPServerIP \
                                          &lt; ./Tmp/tmp_X$pid$tStartTime} reason]} {
                            puts &#34;xmod tftp error: $reason&#34;
                            <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                            exit -1
                        }
                    }
                } else {
                    puts &#34;Copy $XmodPath to $TFTPMOUNT/$TftpXFile($imageFam)&#34;
                }
            } else {
                foreach TFTPServerIP $tftpServerList {
                    puts &#34;Putting $XmodPath onto tftp Server \
                               $TFTPServerIP as $TftpXFile($imageFam)&#34;
                    if {[catch {exec /usr/bin/tftp $TFTPServerIP \
                                          &lt; ./Tmp/tmp_X$pid$tStartTime} reason]} {
                        puts &#34;xmod tftp error: $reason&#34;
                        <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
                        exit -1
                    }
                }
            }
            file delete ./Tmp/tmp_X$pid$tStartTime
        }
    } elseif {$MAIN(DOWNLOADXMODS) &amp;&amp; [llength $xmodPlatforms] == 0} {
        puts &#34;XmodPath $XmodPath does not exist&#34;
        <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
        exit -1
    }
    incr q
}
puts &#34;@@@@\n@@@@\nALL FILE COPIES SHOULD BE DONE NOW\n@@@@\n@@@@&#34;
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Do some prep for download:</span>
<span class="comment-line">#   Match image families passed in to DUT sysType</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
    global DUT${i}_Stacking_msma_slot;<span class="comment-line"># For determining if Stack</span>
    set DUTs_info(DUT$i,filetodownload) &#34;NULL&#34;
    set DUTs_info(DUT$i,fileToVerify)   &#34;NULL&#34;
    set DUTs_info(DUT$i,bpeFileToVerify) &#34;NULL&#34;
    <span class="comment-line"># image family of THIS DUT</span>
    set dutImageFamily [<a name="::GetImageFamilyFromSysType(1)"><a href="./platform.tcl.html#::GetImageFamilyFromSysType_580">::GetImageFamilyFromSysType</a></a> $DUTs_info(DUT$i,sysType)]
    <span class="comment-line"># ---------------------------------------------------</span>
    <span class="comment-line"># Special cases that change the imageFamily go here</span>
    <span class="comment-line"># ---------------------------------------------------</span>
    if {[info exists DUT${i}_Stacking_msma_slot] &amp;&amp; [set DUT${i}_Stacking_msma_slot] &gt; 0} {
        if {[regexp -nocase &#34;480&#34; $DUTs_info(DUT$i,hwList)]} {
            set dutImageFamily summitx480
        }
    }

    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n#####--------! ! ! ! ! ! ! ! ! ! ! ! ! -------#######\n\
                      Platform for DUT$i is $DUTs_info(DUT$i,platform) -- $DUTs_info(DUT$i,sysType)&#34;
    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nAssigning DUT$i image to $dutImageFamily :\n\
                      $TftpFile($dutImageFamily)&#34;
    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------------------------------------------#######&#34;
    <span class="comment-line">#</span>
    <span class="comment-line"># Set the per DUT main image download variables</span>
    <span class="comment-line">#</span>
    if {$platType($dutImageFamily) == &#34;lst&#34;} {
        set DUTs_info(DUT$i,filetodownload) $TftpFile($dutImageFamily)
        if {[catch {exec tar -tf $ImagePath($dutImageFamily)} out]} {
            puts &#34;\n@@\n@@\nFailed to inspect the tar file\n$out\n@@\n@@&#34;
        } else {
            set lines [split $out &#34;\n&#34;]
            foreach line $lines {
                if {[regexp -nocase &#34;vpex&#34; $line]} {
                    puts &#34;Setting BPE verify to [file tail $line]&#34;
                    set DUTs_info(DUT$i,bpeFileToVerify) [file tail $line]
                } elseif {[regexp -nocase &#34;xos&#34; $line]} {
                    puts &#34;Setting lst xos to verify [file tail $line]&#34;
                    set DUTs_info(DUT$i,fileToVerify) [file tail $line]
                } else {
                    puts &#34;No need to verify [file tail $line]&#34;
                }
            }
        }
    } else {
        set DUTs_info(DUT$i,filetodownload) $TftpFile($dutImageFamily)
        set DUTs_info(DUT$i,fileToVerify) $TftpFile($dutImageFamily)
    }
    if {[lsearch $filesToDelete $TftpFile($dutImageFamily)] &lt; 0} {
        lappend filesToDelete $TftpFile($dutImageFamily)
    }


    if {$xmodDUT($i)} {
        <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n#####------------------------------------------#######&#34;
        foreach xmPart $xmodPairs {
            <span class="comment-line"># if index 0 is not equal to this dut continue</span>
            if {[lindex $xmPart 0] != $i} {continue;}
            set xm [lindex $xmPart 1]
            <span class="comment-line"># set xmodFile $xosFile($dutImageFamily)-${xm}.xmod</span>
            set xmodFile $xmodTftpFiles($dutImageFamily,$xm)
            set DUTs_info(DUT$i,${xm}_imagename) $xmodFile
            <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34; XMOD $DUTs_info(DUT$i,${xm}_imagename)&#34;
            if {[lsearch $filesToDelete $xmodFile] &lt; 0} {
                lappend filesToDelete $xmodFile
            }
        }
        <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;#####------------------------------------------#######&#34;
    }
    lappend multiDownList &#34;_qloadSingleDut -dut $i&#34;
}

<span class="comment-line">##############################################################################</span>
<span class="comment-line">#  Open Result file after get_DUT_info</span>
<span class="comment-line">##############################################################################</span>
;<span class="comment-line"># create the report directory</span>
set optionalPath &#34;&#34;
<span class="comment-line">#create_report_directory yes $optionalPath</span>
<a name="::create_report_directory(1)"><a href="./result.tcl.html#::create_report_directory_890">::create_report_directory</a></a> $sourceFile yes $optionalPath &#34;&#34; $subversion $qId


if {$imageNotFound||$romNotFound} {
    set dlOK 1
} else {
    puts &#34;\nDownload the tftpimage $multiDownList\n&#34;
    <a name="::_setShowOutput(5)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log off -res_fmt on
    <a name="::MultiTask(3)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $multiDownList
    <a name="::_setShowOutput(6)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    <a name="::::_printMultiTaskOutput(2)"><a href="./swConf.tcl.html#::::_printMultiTaskOutput_3651">::::_printMultiTaskOutput</a></a>;<span class="comment-line"># show the output in order + in result file</span>
}

<span class="comment-line">#   _setMultiTaskVar DUTs_info(DUT$dut,dlReqD) 0</span>
<span class="comment-line">#   _setMultiTaskVar DUTs_info(DUT$dut,qloadStatus) 1</span>


set passCheck 1

for { set i 1 } { $i &lt;= $MAIN(NODECOUNT) } {incr i } {
    if {$DUTs_info(DUT$i,filetodownload) == &#34;NULL&#34;} {continue;}
    set showSwitchOutput &#34;&#34;
    <a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${i}_CONNECT] -masterCheck 0 -CheckOperational 0
    lappend showSwitchOutput &#34;{Slot.*$targetPart|Switch.*$targetPart|MM.*$targetPart|MSM.*$targetPart} \
                  {$DUTs_info(DUT$i,fileToVerify)} inLine exists&#34;
    if {$xmodDUT($i)} {
        foreach xmPart $xmodPairs {
            <span class="comment-line"># if index 0 is not equal to this dut break</span>
            if {[lindex $xmPart 0] != $i} {continue;}
            set xm [lindex $xmPart 1]
            <span class="comment-line">#DUTs_info(DUT$i,${xm}_imagename)</span>
            lappend showSwitchOutput &#34;{Slot.*$targetPart|Switch.*\
               $targetPart|MM.*$targetPart|MSM.*$targetPart} \
               {$DUTs_info(DUT$i,${xm}_imagename)} inLine exists&#34;
        }
    }
    if {$DUTs_info(DUT$i,bpeFileToVerify) != &#34;NULL&#34;} {
        lappend showSwitchOutput &#34;{Slot.*$targetPart|Switch.*\
           $targetPart|MM.*$targetPart|MSM.*$targetPart} \
           {$DUTs_info(DUT$i,bpeFileToVerify)} inLine exists&#34;
    }
    if {[<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show version image&#34; $showSwitchOutput -time {s: 1 i: 3 d: 8 f: 8 r} -comment \
              &#34;check the partion file name is $DUTs_info(DUT$i,filetodownload)&#34;]==&#34;error&#34;} {
        set passCheck 0
    }
    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable log display&#34;
}

if { $reboot == &#34;yes&#34; &amp;&amp; $passCheck } {
    for { set i 1 } { $i &lt;= $dut } {incr i } {
        <a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set i]\_CONNECT]
        <a name="::EnableDebugMode(1)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
        <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!rm -rf /scratch/intern/*&#34;
        if {[regexp -nocase &#34;pri&#34; $targetPart]} {
            <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image pri&#34;
        } else {
            <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use image sec&#34;
        }
    }
    set rebootList &#34;&#34;
    for { set i 1 } { $i &lt;= $dut } {incr i } {
        <a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set i]\_CONNECT]
        lappend rebootList &#34;CheckReboot $i -masterCheck 0 -save no&#34;
    }
    <a name="::MultiTask(4)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $rebootList
    <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Checking the partition and image installed.&#34;

    for { set i 1 } { $i &lt;= $dut } {incr i } {
        <a name="::Login(6)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set i]\_CONNECT]
        <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show switch&#34;
    }
}
<span class="comment-line"># --------------------------------------------------------------------------------------------</span>
<span class="comment-line"># Remove files from tftp -- removed as another point of failure and cronjob cleans tftpserver</span>
<span class="comment-line"># --------------------------------------------------------------------------------------------</span>

<span class="comment-line"># Remove files from tftp before exit</span>
foreach TFTPServerIP $tftpServerList {
    <a name="::login_linux(1)"><a href="./linux.tcl.html#::login_linux_16">::login_linux</a></a> $TFTPServerIP $tftpServerLogin $tftpServerPasswd
    foreach dlFile $filesToDelete {
        catch {<a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;/bin/rm $tftpServerTftpboot/$dlFile&#34; NULL NULL true 1}
    }
    <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Clear the current TftpServer expect session&#34;
    <a name="::_ClearExpectSession(1)"><a href="./logout.tcl.html#::_ClearExpectSession_215">::_ClearExpectSession</a></a>
}



<span class="comment-line"># Verify that the images downloaded correctly.</span>

sleep 5

set tEndTime [clock seconds]
set testDuration [expr $tEndTime-$tStartTime]
set finaltime &#34;$testDuration&#34;
set testSec  [expr $testDuration % 60]
set testMin  [expr $testDuration / 60]
set testHour [expr $testMin / 60]
set testMin  [expr $testMin % 60]


if {[llength $testMin] == 1 } {
   set testMin [format &#34;%02d&#34; $testMin]
}

if {[llength $testSec] == 1 } {
   set testSec [format &#34;%02d&#34; $testSec]
}


if {!$passCheck} {
    <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Download via QLoadImage FAILED&#34;
    set Qloadstat &#34;FAILED&#34;
    set Ccstat &#34;ABORT&#34;
    set ttime &#34;$testHour:$testMin:$testSec&#34;
    regsub -all {cfg/|} $cfg &#34;&#34; cfg  
    set filetype &#34;2Node&#34;
    if {[regexp -nocase &#34;ipr&#34; $cfg]  } {
       set filetype &#34;5Node&#34;
    }
 
    set reportme [open &#34;$filetype.txt&#34; a+]
    puts $reportme &#34;[format &#34;| %*s| %*s | %*s| %*s     |&#34; 35 $cfg 15 $Qloadstat 20 $Ccstat 16 $ttime]&#34;
    puts $reportme &#34;+-[string repeat - 35]+-[string repeat - 15]-+[string repeat - 20]-+[string repeat - 23]&#34;
    close $reportme
    exit

} else {
    <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Download via QLoadImage PASSED&#34;
    set Qloadstat &#34;OK&#34;
    set dlOK 0
}

<a name="::close_result_file(3)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>

<span class="comment-line">#create_report_directory $sourceFile yes $optionalPath &#34;&#34; $subversion $qId</span>
<a name="::gen_text_report(1)"><a href="./report.tcl.html#::gen_text_report_602">::gen_text_report</a></a> &#34;[<a name="::get_result_dir(2)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> { $randomIndex }]/report.exr&#34; &#34;stdout&#34; &#34;[file tail [pwd]]&#34; $sourceFile

<span class="comment-line">#move the complete result directory to report directory</span>
<a name="::move_result_directory(1)"><a href="./result.tcl.html#::move_result_directory_1006">::move_result_directory</a></a>

puts &#34;\n\n*** Time for Downloading $cfg Code = $testDuration seconds - Returning Download Status: $dlOK&#34;
puts &#34;***    ( $testHour hours, $testMin minutes, $testSec seconds )\n\n&#34;

set errorInfo &#34;&#34;

<span class="comment-line">#####################################################################################################################</span>
;<span class="comment-line">#########STarting checkConnection after successfull image download </span>
<span class="comment-line">####################################################################################################################</span>
<span class="comment-line">#!/usr/bin/tclsh</span>

global curAutoRoot
global MAIN env
set skipCC 0
global skipCC
set MAIN(initFile) &#34;NULL&#34;
set TRYFAILSAFE &#34;true&#34;
<span class="comment-line">#</span>
<span class="comment-line"># EY-07-17-2012: Catch source command in case of failure.</span>
if {[catch {source ../Lib/mainLib.tcl} res]} {
    puts &#34;*** WARNING: Unable to source mainLib.tcl: ***&#34;;
    puts &#34;$res&#34;;
    return -1;
}
if {[catch {source ../main/runReg.cfg} res]} {
    puts &#34;*** WARNING: Unable to source runReg.cfg: ***&#34;;
    puts &#34;$res&#34;;
    return -1;
}

<span class="comment-line">#</span>
<span class="comment-line"># EY-07-17-2012: common.cfg is sourced later in the script.</span>
<span class="comment-line">#source cfg/common.cfg</span>

package require Tclx



if {$tcl_platform(platform) == &#34;windows&#34;} {
      load &#34;expect52.dll&#34;
} else {
  load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
}
global cfg
<span class="comment-line">#set cfg &#34;p2_stack_x460_G2_16mp_std.cfg&#34;</span>
set curLocation [pwd]
set curDirList [split [string trim [string trim $curLocation &#34;..&#34;] &#34;/&#34;] &#34;/&#34;]
set v 0;
set pathList &#34;&#34;
set curAutoRoot &#34;&#34;
foreach cd $curDirList {
    if {$cd == &#34;main&#34; || $cd == &#34;Lib&#34; || $cd == &#34;Util&#34;} {
        for {set x 0} {$x&lt;$v} {incr x} {
            lappend pathList [lindex $curDirList $x]
        }
        set curAutoRoot &#34;/[join $pathList &#34;/&#34;]&#34;
    } else {
        incr v;
    }
}

set LIB_PATH &#34;./../Lib&#34;
set auto_path_temp &#34;&#34;
foreach var $auto_path {
   set var1 [split $var &#34;/&#34;]
   if {![regexp -nocase &#34;ixia&#34; $var1]} {
      lappend auto_path_temp $var
   }
}

set auto_path $auto_path_temp
lappend auto_path $LIB_PATH
puts &#34;DEBUG: Appending $LIB_PATH to autopath:$auto_path&#34;

<a name="::::gen_index(3)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;./../Lib&#34;
set TrafficGen &#34;ixia&#34;

<span class="comment-line"># checking command parameters </span>
if {$argc&lt;1} {
      puts &#34;Not enough parameters&#34;
      <span class="comment-line">#</span>
      <span class="comment-line"># EY-07-17-2012: Return unique error code.</span>
      return -2;
}
global  TrafficGen

set cfgFile &#34;&#34;
set harness &#34;tcl&#34;
set passCount 0
set failCount 0
set skipCount 0

<span class="comment-line">#</span>
<span class="comment-line"># EY-07-17-2012: Clean-up error messages and return a unique error code.</span>
puts &#34;PWD [pwd]&#34;
if [catch {source &#34;cfg/common.cfg&#34;} rea] {
      puts &#34;*** WARNING: Unable to source common.cfg:                    ***&#34;;
      puts &#34;$rea&#34;;
      puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
      return -3;
}


if {$cfg != &#34;null&#34;} {
      if {![regexp -nocase &#34;^cfg&#34; $cfg] } {
      	    set cfgFile [format %s/%s cfg $cfg]
      	    set cfgFile [string trim $cfgFile];
      } else {
          set cfgFile $cfg
      }
}
<span class="comment-line">#Handle verbos short values</span>
if {$v != &#34;null&#34;} {
    set verbose $v
}
set VERBOSE &#34;no&#34;
switch -nocase -regexp $verbose {
    y.* {
        <span class="comment-line"># VERBOSE will be a global used in SystemSetup</span>
        set VERBOSE yes
    }
    n.* {
        set VERBOSE no
    } default {
        set VERBOSE no
    }
}

set clean &#34;yes&#34;
set c &#34;null&#34;
set TrafficGen &#34;ixia&#34;
set poweron 0
set p &#34;null&#34;
set verbose &#34;no&#34;
set v &#34;null&#34;
set defxsf 0
set dx  0

<span class="comment-line"># Handle poweron short values</span>
if {$p != &#34;null&#34;} {
    set poweron $p
}
<span class="comment-line"># Handle clean short values</span>
if {$c != &#34;null&#34;} {
    set clean $c
}
switch -nocase -regexp $clean {
    y.* {
        set clean yes
    }
    n.* {
        set clean no
    }
    c.* {
        set clean cli
    } default {
        set clean yes
    }
}

puts &#34;Using config file: ($cfgFile)&#34;
set sourceFile $cfgFile

<span class="comment-line">#</span>
<span class="comment-line"># EY-07-17-2012: Clean-up error messages and return a unique error code.</span>
if {[file exists $cfgFile] == 0} {
    puts &#34;*** ERROR: Cannot find config file: $cfgFile&#34;;
    return -4;
}

puts &#34;************** ABOUT TO source $cfgFile *****************&#34;

<span class="comment-line">#</span>
<span class="comment-line"># EY-07-17-2012: Catch source command in case of failure.</span>
if {[catch {source $cfgFile } reason]} {
    puts &#34;*** ERROR occured while trying to source $cfgFile:&#34;;
    puts &#34;$reason&#34;;
    return -5;
}

global configurationFile
set configurationFile $cfgFile

<span class="comment-line">############ Modify by arun ###############</span>
source ../Lib/mapping.tcl

<span class="comment-line">###########################################</span>

<span class="comment-line"># Open the initFile</span>
set MAIN(initFile) [<a name="::::GetInitFileName(1)"><a href="./SystemSetup.tcl.html#::::GetInitFileName_2846">::::GetInitFileName</a></a> $curAutoRoot $cfg]
catch {open $MAIN(initFile) &#34;w&#34;} MAIN(ifPipe)
if {[regexp -nocase &#34;denied&#34; $MAIN(ifPipe)]} {
    puts &#34;@\n@\nNO INIT FILE WILL BE CREATED. ERROR OPENING FILE\n@\n@&#34;
    set MAIN(ifPipe) NULL
}
 
if {[info exists ixiaCh1] &amp;&amp; $ixiaCh1 != &#34;NO_IXIA&#34;} {
    puts &#34;****** the ixia chassis is $ixiaCh1&#34;;
    puts &#34;****** the ixia path is $ixiaPath($ixiaCh1)&#34;;
    set TrafficGen ixia
} elseif {[info exists SPIRENTCH1]} {
    puts &#34;****** The Spirent Chassis is $SPIRENTCH1 ******&#34;
    foreach key [array names env] {
        puts &#34;$key=$env($key)&#34;
    }
puts &#34;\n\n&#34;
    set TrafficGen stc
    set ::LABSERVER $stcLabserver($SPIRENTCH1)
    set env(IXIA_HOME) null
    lappend auto_path &#34;/auto/ixia_5_70/lib/mpexpr-1.1/&#34;
    <a name="::::overWriteProcs(1)"><a href="./stc.tcl.html#::::overWriteProcs_95">::::overWriteProcs</a></a> $LIB_PATH [file join $LIB_PATH spirent]
    source [file join $LIB_PATH ePTLib ePTUtils.tcl]
    <a name="::logcmd(1)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> lappend auto_path $stcPath($SPIRENTCH1)
puts &#34;STC PATH $auto_path&#34;
puts &#34;STC env path: $env(PATH)&#34;
    <a name="::stcInit(1)"><a href="./spirent.tcl.html#::stcInit_11">::stcInit</a></a> $LABSERVER
    package require Mpexpr
    puts &#34;\n\nPackage Require SpirentTestCenter&#34;
    <a name="::logcmd(2)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> package require SpirentTestCenter
    <a name="::GenerateDUTPortMapping(1)"><a href="./ePTPortMapping.tcl.html#::GenerateDUTPortMapping_217">::GenerateDUTPortMapping</a></a>; <span class="comment-line"># Add here temporarily b/c called in SystemSetup</span>
    <a name="::ReservePorts(1)"><a href="./spirent.tcl.html#::ReservePorts_67">::ReservePorts</a></a>
}

if {[info exists ixiaPath($ixiaCh1)] &amp;&amp; $TrafficGen == &#34;ixia&#34;} {
    <a name="::SetIxiaEnv(1)"><a href="./ePTMisc.tcl.html#::SetIxiaEnv_517">::SetIxiaEnv</a></a> &#34;$ixiaPath($ixiaCh1)&#34;
    puts &#34;****** The ixia path is $ixiaPath($ixiaCh1)&#34;;
}

if {$tcl_platform(platform) == &#34;windows&#34;} {
    lappend auto_path &#34;C:/Program Files/Ixia/TclScripts/Lib/ixTcl1.0&#34;
} else {
    lappend auto_path [file join $env(HOME) &#34;ixia/lib/mpexpr-1.0&#34;]
    lappend auto_path [file join $env(HOME) &#34;ixia/lib/ixTcl1.0&#34;]
    lappend auto_path [file join $env(HOME) &#34;ixia/lib/dp4.0&#34;]
}

<span class="comment-line"># mode setup   </span>
set clean [string tolower $clean]
switch $clean  {
       yes      { puts &#34;#\nClean checkConnection (with unconfig).\n#&#34;}
       no       { puts &#34;#\ncheckConnection without unconfig. May fail if switch conflicting cfg.\n#&#34; }
       cli      { puts &#34;#\ncheckConnection without unconfig. Send CLI to insure no conflicting cfg.\n#&#34; }
       default  { puts &#34;No Match - default to clean&#34;}
}
      
<span class="comment-line"># Create supporting directories if they don't exist.</span>
<a name="::_createSupportDirectories(2)"><a href="./filetools.tcl.html#::_createSupportDirectories_50">::_createSupportDirectories</a></a> -dirList &#34;Report Result Tmp Tmp2 Log&#34;

<span class="comment-line">############################################################</span>

set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]

set testDuration 0
set testHour 0
set testMin 0
set testSec 0

set resultDir &#34;NULL&#34;

set fd_res [<a name="::open_result_file(3)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;checkConnection&#34;]

if {$poweron} {
    set hitPower 0
    for {set i 1} {$i &lt;= 10} {incr i} {
        if {[info exists POWERCYCLE_DUT($i)]} {
            set hitPower 1
            <a name="::PowerOffDUT(1)"><a href="./poweroutlet.tcl.html#::PowerOffDUT_983">::PowerOffDUT</a></a> $i &#34;on&#34;
        }
    }
    if {$hitPower} {
        <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleep &#34;
        <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 120
    }
}

<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Build setup script from cfg file</span>
<span class="comment-line"># ----------------------------------------------------------</span>
set numDUT 1
while { [info exists DUT${numDUT}_CONNECT] } {
      set connect [set DUT${numDUT}_CONNECT]
      set script [set DUT${numDUT}_SETUP]
      puts &#34;***** DUT${numDUT}_CONNECT=$connect ***** &#34;
      puts &#34;***** numDUT=$numDUT ***** &#34;
      <a name="::Login(7)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${numDUT}_CONNECT] -masterCheck 0 -CheckOperational 0
      <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable log display&#34;
      lappend scriptList $script
      lappend connectList $connect
      if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
          lappend makeXsfList &#34;CreateDefaultXsf -dut $numDUT&#34;
      }
      incr numDUT 1
}
incr numDUT -1


<a name="::::_initDUTs_infoArray(2)"><a href="./swConf.tcl.html#::::_initDUTs_infoArray_11">::::_initDUTs_infoArray</a></a>;
<span class="comment-line"># --- Set any port partitioning CLI ---</span>
_SetPartitionVars;


<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Execute setup script if clean mode is &#34;yes&#34; - the default</span>
<span class="comment-line"># ----------------------------------------------------------</span>
if {$clean == &#34;yes&#34;} {
    if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE &amp;&amp; $defxsf} {
        <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;------------------  Create default.xsf of all DUTs  ------------------&#34;
        <a name="::_setShowOutput(7)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt off
        <a name="::MultiTask(5)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $makeXsfList
        <a name="::_setShowOutput(8)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    }
    <span class="comment-line"># RunSetupScript $connectList $scriptList</span>
    set runSetupRetVal [<a name="::::RunSetupScript(1)"><a href="./swConf.tcl.html#::::RunSetupScript_225">::::RunSetupScript</a></a> $connectList $scriptList]
    if {$runSetupRetVal==-1} {
	unset connectList
	unset scriptList
	puts stderr &#34;testSkipped&#34;
	<span class="comment-line">#</span>
        <span class="comment-line"># EY-07-17-2012: Return unique error code.</span>
        <a name="::close_result_file(4)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;
        return -6;
    } elseif { $runSetupRetVal==&#34;REGROUTER_FAILED&#34; } {
	unset connectList
	unset scriptList
	puts stderr $returnFlag
	flush stderr
	return $runSetupRetVal
    }
    unset connectList
    unset scriptList
} elseif {$clean == &#34;cli&#34;} {
    puts &#34;\n#########################################################################&#34;
    puts &#34;               S T A R T I N G     PARALLEL CLI CLEANUP&#34;
    puts &#34;#########################################################################&#34;
    sleep 1
    set cleancliList &#34;&#34;
    for {set e 1} {$e&lt;=$numDUT} {incr e} {
        lappend cleancliList &#34;allCleanup $e&#34;
    }
    <a name="::_setShowOutput(9)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt on
    <a name="::MultiTask(6)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $cleancliList
    <a name="::_setShowOutput(10)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
    puts &#34;\n#########################################################################&#34;
    puts &#34;                F I N I S H E D    PARALLEL CLI CLEANUP&#34;
    puts &#34;#########################################################################&#34;
    sleep 1
}
<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Gather critical variables from all switches in the test bed</span>
<span class="comment-line"># ----------------------------------------------------------</span>
if {[set rc [<a name="::::get_DUTs_info(2)"><a href="./swConf.tcl.html#::::get_DUTs_info_881">::::get_DUTs_info</a></a>]] != 0} {
    <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
    <a name="::close_result_file(5)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;
    return -7;
}
<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Verify all of the test bed connections</span>
<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line">#check connections between DUTs and Ixia</span>
if {$TrafficGen == &#34;ixia&#34;} {
    if {![regexp -nocase &#34;no_ixia&#34; $ixiaCh1]} {
        set returnFlag [<a name="::::SystemSetup(1)"><a href="./SystemSetup.tcl.html#::::SystemSetup_16">::::SystemSetup</a></a>]
    } else {
        set returnFlag &#34;connectionOkay&#34;
    }
} elseif {$TrafficGen == &#34;stc&#34;} {
    set returnFlag [<a name="::::SystemSetup(2)"><a href="./SystemSetup.tcl.html#::::SystemSetup_16">::::SystemSetup</a></a>]
} else {
    <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Can't find Ixia OR Spirent Information&#34;
    set returnFlag &#34;connectionBad&#34;
}
<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Verify Mgmt and Inband Networks</span>
<span class="comment-line"># ----------------------------------------------------------</span>
global defaultRouter
global bootpserver
global tftpServerList
global switchPort2DefaultRouter
set tftpServer [lindex $tftpServerList 0]
set netConFlag 1
set numDUT 1
set procList &#34;&#34;
result_h2 &#34;Network port validation&#34;
<a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Network port validation&#34;
while { [info exists DUT${numDUT}_CONNECT] } {
    lappend procList &#34;VerifyMgmtConnections $numDUT&#34;
    incr numDUT 1
}
<a name="::MultiTask(7)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $procList
<a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
incr numDUT -1

<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Close the temporary file that holds variables for dev</span>
<span class="comment-line"># ----------------------------------------------------------</span>
if {([info exists MAIN(ifPipe)]) &amp;&amp; ($MAIN(ifPipe) != &#34;NULL&#34;)} {
    close $MAIN(ifPipe)
}
if {[<a name="::::VerifyInitFile(1)"><a href="./SystemSetup.tcl.html#::::VerifyInitFile_2823">::::VerifyInitFile</a></a> $MAIN(initFile)]} {
   regsub -all &#34;Tmp&#34; $MAIN(initFile) &#34;Tmp2&#34; initFile2
   catch {file copy -force $MAIN(initFile) $initFile2} why
}
if {[file exists $MAIN(initFile)]} {
    file copy $MAIN(initFile) [<a name="::get_result_dir(3)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> { $randomIndex }]/initFile.txt
} 
if {$fd_res != &#34;&#34;} {
    catch {flush $fd_res} result
    if {$result != &#34;&#34;} { <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$result&#34; }
}

set tEndTime [clock seconds]
set testDuration [expr $tEndTime-$tStartTime]
puts &#34;Before : $testDuration&#34;
set testDuration [expr $testDuration+$finaltime]
puts &#34;After :  $testDuration&#34;
set testSec  [expr $testDuration % 60]
set testMin  [expr $testDuration / 60]
set testHour [expr $testMin / 60]
set testMin  [expr $testMin % 60]
<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Close all result files and put them in the Report dir</span>
<span class="comment-line">#   Print time summary</span>
<span class="comment-line"># ----------------------------------------------------------</span>
<a name="::create_report_directory(2)"><a href="./result.tcl.html#::create_report_directory_890">::create_report_directory</a></a> $cfgFile yes &#34;&#34; &#34;&#34; &#34;&#34; &#34;&#34; ; <span class="comment-line"># Creates the report_dir.txt in result</span>
<a name="::save_test_report(1)"><a href="./report.tcl.html#::save_test_report_329">::save_test_report</a></a> &#34;[<a name="::get_result_dir(4)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34;
<a name="::gen_text_report(2)"><a href="./report.tcl.html#::gen_text_report_602">::gen_text_report</a></a> &#34;[<a name="::get_result_dir(5)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34; &#34;stdout&#34; &#34;[file tail [pwd]]&#34; $cfgFile
<a name="::close_result_file(6)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>

<span class="comment-line">#######################################</span>
<a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a>  &#34;\n\n*** Time for check connections ( $testHour hours, $testMin minutes, \
              $testSec seconds )\n\n&#34;

<span class="comment-line"># ----------------------------------------------------------</span>
<span class="comment-line"># Return Execution Status</span>
<span class="comment-line"># ----------------------------------------------------------</span>
if { $returnFlag == &#34;connectionOkay&#34;} {
     <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;[file tail $cfg] Check connection - PASS\n\n&#34;
     set Ccstat &#34;OK&#34;
} else {
    <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;[file tail $cfg] Failed Connection Check\n        DUTs, Ixia or Mgmt Network&#34;
    <a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Verify physical connections match with config setup file&#34;
    set Ccstat &#34;FAILED&#34;
}

set ttime &#34;$testHour:$testMin:$testSec&#34;
regsub -all {cfg/|} $cfg &#34;&#34; cfg
set filetype &#34;2Node&#34;
if {[regexp -nocase &#34;ipr&#34; $cfg]  } {
       set filetype &#34;5Node&#34;
    }

set reportme [open &#34;$filetype.txt&#34; a+]
puts $reportme &#34;[format &#34;| %*s| %*s | %*s| %*s      |&#34; 35 $cfg 15 $Qloadstat 20 $Ccstat 15 $ttime]&#34;
puts $reportme &#34;+-[string repeat - 35]+-[string repeat - 15]-+[string repeat - 20]-+[string repeat - 23]&#34;
close $reportme

puts &#34;Passed here&#34;
<a name="::gen_text_report(3)"><a href="./report.tcl.html#::gen_text_report_602">::gen_text_report</a></a> &#34;[<a name="::get_result_dir(6)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.exr&#34; &#34;[<a name="::get_result_dir(7)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/report.txt&#34; &#34;[file tail [pwd]]&#34; $cfg;
<a name="::move_result_directory(2)"><a href="./result.tcl.html#::move_result_directory_1006">::move_result_directory</a></a>
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
