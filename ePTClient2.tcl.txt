####################### Global Variables initialization Starts Here ##################################
set numFrames 1
set stream_name "s1"
set framesize "60"
set frameSizeType "sizeFixed"
set frameSizeMAX "1514"
set frameSizeMIN "60"
set rateMode "fixed"
set percentPacketRate "100"
set fcs "good"
set fir "true"
set patternType "nonRepeat"
set dataPattern "1234"
set sa "00debb000001"
set da "00debc000002"
set saRepeatCounter "idle"
set daRepeatCounter "idle"
set numSA "0"
set numDA "0"
set frameType "08 00"
set dma "fixed"
set cfi  "0"
set vlan_mode "vIdle"
set repeat "1"
set userPriority "0"
set protocolTagId "8100"
set vlan_id "0"
set name "mac"
set enable802dot1qTag "false"
set ethernetType "noType"
set appName "none"
set captureFilterEnable "true"
set captureTriggerEnable "true"
set userDefinedStat1Enable "false"
set userDefinedStat1DA "00:00:00:00:00:00"
set userDefinedStat1SA "00:00:00:00:00:00"
set captureFilterPattern "0"
set captureTriggerPattern "0"
set captureTriggerDA "00:00:00:00:00:00"
set captureFilterDA "00:00:00:00:00:00"
set userDefinedStat1Pattern "0"
set userDefinedStat2Enable "0"
set pattern1 "0000"
set patternOffset1 "14"
set DA1 "00:00:00:00:00:00"
set SA1 "00:00:00:00:00:00"
set matchType1 "00:00:00:00:00:00"
set ipProtocol "ip"
set destClass "classC"
set destIpAddr "127.0.0.1"
set destIpMask "255.255.255.0"
set destIpAddrMode "ipIdle"
set sourceClass "classC"
set sourceIpAddr "127.0.0.1"
set sourceIpMask "255.255.255.0"
set sourceIpAddrMode "ipIdle"
set sourceIpAddrRepeatCount "1"
set destIpAddrRepeatCount "1"
set destMacAddr "00 A1 F1 00 00 02"
set destDutIpAddr "127.0.0.1"
set ttl "64"
set useValidChecksum "true"
set fragment "0"
set options ""
set delay "0"
set throughput "0"
set reliability "0"
set precedence "000"
set lengthOverride "0"
set totalLength "20"
set identifier "6558"
set sourceNetwork "00.00.00.00"
set sourceNetworkMaskSelect "0"
set sourceNode "000000000000"
set sourceSocket "0400"
set destNetwork "00.00.00.00"
set destNode "000000000000"
set destSocket "0400"
set command "ripRequest"
set version "2"
set familyId "2"
set routeTag "00"
set ipAddress "0.0.0.0"
set subnetMask "0.0.0.0"
set nextHop "0.0.0.0"
set metric "1"
set opCode "01"
set hwType "01"
set transactionID "8a9ab8e8"
set seconds "7680"
set dhcp_flags "0000"
set clientIpAddr "127.0.0.1"
set yourIpAddr "127.0.0.1"
set serverIpAddr "0.0.0.0"
set relayAgentIpAddr "0.0.0.0"
set clientHwAddr "00:A1:F1:00:00:01"
set optionData "ff"
set version "1"
set igmp_type "16"
set groupIpAddress "224.0.0.1"
set maxResponseTime "10"
set igmp_mode "1"
set repeatCount "1"
set sourcePort "0000"
set destPort "0000"
set sequenceNumber "0"
set synchronize "0"
set finished "0"
set resetConnection "0"
set acknowledgeValid "0"
set pushFunctionValid "0"
set urgentPointerValid "0"
set type "08"
set code "00" 
set id "0"
set sequence "0"
set sourceProtocolAddr "127.0.0.1"
set destProtocolAddr "127.0.0.1"
set sourceProtocolAddrMode "arpIdle"
set destProtocolAddrMode "arpIdle"
set sourceHardwareAddr "00:A1:F1:00:00:01"
set destHardwareAddr "FF:FF:FF:FF:FF:FF"
set sourceProtocolAddrRepeatCount "1"
set destProtocolAddrRepeatCount "1"
set operation "1"
set sourceHardwareAddrMode "arpIdle"
set sourceHardwareAddrRepeatCount "1"
set destHardwareAddrMode "arpIdle"
set destHardwareAddrRepeatCount "1"
set trafficClass "3000"
set flowLabel "00"
set hopLimit "01"
set sourceAddr "3555:5555:6666:7777:7777:8888:8888"
set sourceMask "ffff:ffff:ffff:ffff:ffff:ffff:ffff"
set destAddr "FE80:0:0:0:201:3FF:FE00:100"
set destMask "ffff:ffff:ffff:ffff:ffff:ffff:ffff"
set nextHeader "06"
set sourceAddrMode "ipV6Idle"
set sourceAddrRepeatCount "1"
set destAddrMode "ipV6Idle"
set destAddrRepeatCount "1"
set destMacAddr "00E02B000001"
set sourceudpPort "0000"
set destudpPort "0000"
set checksumMode "0000"
set enable "false"
set continuousCount "false"
set initval "00"
set offset "0"
set countertype "c8"
set statAllStats  "0"
set statFramesSent "0" 
set getstatAllStats "0"
set protocol_offset "0"
set getRatestatAllStats "0"  
####################### Global Variables initialization Ends Here ##################################

###############################################################################
# Procedure: ePTServer_read
#
# Description: Reads the buffer from the TclServer socket
#
# Results:
###############################################################################
if { 0 } {
proc ePTServer_read {aa} {
after 500
set err [catch {set data1 [gets $aa data]} errmsg]
if {$err != 0} {
puts "Error <$aa>: $errmsg"
} else {
# Process incoming messages here:
puts "Server sent:$data"
return $data
}
}
}
proc ePTServer_read {socket} \
{
    variable buffer
    after 1500
    set buffer ""
    set length -1
	if {[eof $socket] || [catch {gets $socket buffer}]} {
	# end-of-file or abnormal connection drop
#        catch {close $socket}
        puts "Error <$socket>: $errmsg"
    } else {
        puts "buffer=$buffer"
#        flush $socket 
        return $buffer
    }
}
########################################################################################
# Procedure:   ePTGettingPrefix
########################################################################################
proc ePTGettingPrefix {address} {

set address_list [split $address ":"]
set address_len  [llength $address_list]
set append_len  [expr 9 - $address_len]
puts "$append_len"
set append_pre ""
set prefix "64"

for {set i 0} {$i < $append_len} {incr i} {

   append append_pre ":0"

}
   append append_pre ":"

 regsub -all "::" $address $append_pre exp_address

  puts "Expanded Address $exp_address"
set address_list [split $exp_address ":"]
set address_prefix ""

 set trunk_len [expr $prefix / 16]

 for {set i 0} {$i < $trunk_len} {incr i} {

  append address_prefix [lindex $address_list $i]

if {!($i == [expr $trunk_len -1])} {
  append address_prefix :
}
 }
   puts "ADDRESS Prefix $address_prefix"
   return $exp_address
}

########################################################################################
# Procedure:   ePTConnectToChassis
#
# Description: This procedure connects to a list of chassis. An ID number is assigned to
#              the chassis in sequence starting from 1 in the order that the list is passed.
#              The first chassis in the list is assigned as the master chassis.
#
# Argument(s):
#    chassisList - The list of hostnames or IP addresses of chassis in a chain
#    cableLength - Optional.  The length of the cables between the chassis.  If not passed in,
#                  then uses cable3feet.  Note - may be a list of lengths, one for each chassis
#                  in the chassisList.
#
# Returns:
#    0 : if no error
#    1 : if error connecting to chassis
#    2 : if version mismatch, ePTTcl_versionMismatch
#    3 : if chassis timeout occurred, ePTTcl_chassisTimeout
#    4 : if connection interrupted by user
########################################################################################
proc ePTConnectToChassis {} \
{
	global clientSocket portmap_List
		set mac_address [exec ifconfig eth0 | grep -i "HWaddr"]
		set mac_address [lindex $mac_address 4]
		set ip_address [exec ifconfig eth0 | grep -i "inet addr:"]
		set ip_address [lindex [split [lindex $ip_address 1] ":"] 1]
                set chassisList1 "1:1:1#1:1:2#1:1:3#1:1:4#1:1:5#1:1:6#1:1:7#1:1:8"
		set portmap_List "01#$chassisList1#$clientSocket#$ip_address#$mac_address"
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $portmap_List]
		flush $clientSocket
                after 200
		}
           
#        set ePTConnectToChassis_output [ePTServer_read $clientSocket]
	return 0 
}

#	return $portmap_List
#}

#######################################################################################
#  Procedure : ePTputs
#
#  Description:  This command is similar to "puts" except that it has an update :command
# so that the output queue gets flushed and the message gets printed immediately. In
# Window 95/NT platform, the "puts" command does not print the messages rightaway.
#
#  Arguments :
#       args - Message to display
#
########################################################################################
proc ePTputs {args} \
{
	catch {
		if {[lindex $args 0] == "-nonewline"} {
			set args [lreplace $args 0 0]
				puts -nonewline [join $args " "]
		} else {
			puts [join $args " "]
		}
# Reported that the update blocks the display on Solaris using wish8.0
# so use update idletasks instead
#		update
	}
}
########################################################################################
# Procedure:   ePTDisconnectTclServer
#
# Description: This procedure disconnects from the Server
#
# Argument(s):
#    serverName - UNUSED.  Still exists for backwards script support
#
# Returns:
########################################################################################
proc ePTDisconnectTclServer {{serverName ""}} \
{
#global clientSocket
#	set retCode 0

#	if {[info exists clientSocket]} {
#		set retCode [close $clientSocket]
#	}
#       set ePTDisconnectTclServer_output [ePTServer_read $clientSocket]
	return 0
}

#######################################################################################
# Procedure:    map       
#
# Description:  Used to map the T.G ports              
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc map {add args} \
{
	global tx_port rx_port direction 
		set tx_rx_ports $args
                puts "INSIDE map Proc -------------> TX_RX PORTS : $tx_rx_ports"
		set tx_port [join [lrange $tx_rx_ports 0 2] ":"]
		set rx_port [join [lrange $tx_rx_ports 3 5] ":"]
		if {[lrange $tx_rx_ports 6 8] != ""} {
			set rx_port [join [lrange $tx_rx_ports 6 8] ":"]
				set tx_port [join [lrange $tx_rx_ports 9 11] ":"]
				set direction "2way"
		} else {
			set direction "1way"
		}
}
#######################################################################################
# Procedure:    card      
#
# Description:  Used to create a port in client side.
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc card {option args} \
{
puts "-------------------------- inside card---"
switch $option {

  "get" {
        global cardportget clientSocket
        set getVariable_list $args
        set cardportget [join $getVariable_list "#"]
        set portget_mac "29#$cardportget"
	set retCode [puts $clientSocket $portget_mac]
	flush $clientSocket
        after 200
	}
   "cget" {
        global portcount clientSocket
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == "-portCount"} {
        set dummy_data "Getting Port Count" 
	set dummy_data "30#$dummy_data"
	set retCode [puts $clientSocket $dummy_data]
	flush $clientSocket
        after 200
        set portcount [ePTServer_read $clientSocket]
        return $portcount
      }
}
}
}       
#######################################################################################
# Procedure:    port      
#
# Description:  Used to create a port in client side.
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
#         if {$portget_mac == "1:1:9" || $portget_mac == "1:1:10" || $portget_mac == "1:1:11" || $portget_mac == "1:1:12" || $portget_mac == "1:1:13" || $portget_mac == "1:1:14" || $portget_mac == "1:1:15" || $portget_mac == "1:1:16" || $portget_mac == "1:1:17" || $portget_mac == "1:1:18" || $portget_mac == "1:1:19"} {
#        set portget_mac "1:1:2"
#         }
#        set portget_mac1 "31#$portget_mac"
#	set retCode [puts $clientSocket $portget_mac1]
#	flush $clientSocket
#        after 200
proc port {option args} \
{
global buffer
puts "-------------------------- inside port----"
switch $option {

  "get" {
        global portget_mac clientSocket
        set getVariable_list $args
        set portget_mac [join $getVariable_list ":"]
	}
   "cget" {
        global MacAddress clientSocket portget_mac
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == "-MacAddress"} {
        set dummy_data "Getting MacAddress" 
        puts "CLIENT SOCKET : $clientSocket" 
	set dummy_data "32#$portget_mac"
	set retCode [puts $clientSocket $dummy_data]
	flush $clientSocket
        after 200
        set MacAddress [ePTServer_read $clientSocket]
        set MacAddress [lindex [split $MacAddress "#"] 1]
        return $MacAddress
      }
}
}
}       
#######################################################################################
# Procedure:    stream    
#
# Description:  Used to create a stream in client side.
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc stream {option args} \
{
puts "-------------------------- inside stream ----"
switch $option {

"config" {

	global numFrames stream_name framesize frameSizeType frameSizeMAX frameSizeMIN \
		rateMode percentPacketRate fcs fir patternType dataPattern sa da \
		saRepeatCounter daRepeatCounter numSA numDA frameType dma

	array set param $args

	if { [info exists param(-name)] } {
		set stream_name $param(-name)
	}
	if { [info exists param(-numFrames)] } {
		set numFrames $param(-numFrames)
	}
	if { [info exists param(-frameSizeType)] } {
		set frameSizeType $param(-frameSizeType)
		if {$frameSizeType == "sizeRandom"} {
			if { [info exists param(-frameSizeMAX)] } {
				set frameSizeMAX $param(-frameSizeMAX)
				set frameSizeMAX [expr $param(-frameSizeMAX) -4]
			}
			if { [info exists param(-frameSizeMIN)] } {
				set frameSizeMIN $param(-frameSizeMIN)
				set frameSizeMIN [expr $param(-frameSizeMIN) -4]
			}
	}
        }
        if { [info exists param(-framesize)] } {
				set framesize [expr $param(-framesize) -4]
                                puts "Frame Size : $framesize"
	}
	if { [info exists param(-rateMode)] } {
		set rateMode $param(-rateMode)
	}
	if { [info exists param(-percentPacketRate)] } {
		set percentPacketRate $param(-percentPacketRate)
	}
	if { [info exists param(-fcs)] } {
		set fcs $param(-fcs)
	}
	if { [info exists param(-patternType)] } {
		set patternType $param(-patternType)
	}
	if { [info exists param(-dataPattern)] } {
		set dataPattern [join $param(-dataPattern) ""]
	}
	if { [info exists param(-frameType)] } {
		set frameType $param(-frameType)
                set frameType [join $frameType ""]  
	}
	if { [info exists param(-saRepeatCounter)] } {
		set saRepeatCounter $param(-saRepeatCounter)
	}
	if { [info exists param(-daRepeatCounter)] } {
		set daRepeatCounter $param(-daRepeatCounter)
	}
	if { [info exists param(-numSA)] } {
                 if {$param(-numSA) == 1 } {
		set numSA 0
                   } else {
		set numSA $param(-numSA)
                  }
	}
	if { [info exists param(-numDA)] } {
                 if {$param(-numDA) ==1} {
		set numDA 0
                   } else {
		set numDA $param(-numDA)
                  }
	}
	if { [info exists param(-asyncIntEnable)] } {
		set asyncIntEnable $param(-asyncIntEnable)
	}
	if { [info exists param(-fir)] } {
		set fir $param(-fir)
	}
	if { [info exists param(-sa)] } {
                set sa [join [join [split $param(-sa) ":"] ""] ""]
               if {$sa == ""} {
                   set sa "00A1F1000001"
                }
	}
	if { [info exists param(-da)] } {
		set da [join [join [split $param(-da) ":"] ""] ""]
               if {$da == ""} {
                   set sa "00A1F1000002"
                }
	}
	if { [info exists param(-dma)] } {
		set dma $param(-dma)
	}
}
"get" {

   	global stream_port_id

	set getvariable_list $args
	puts " ----------- args --- $args"
		set stream_get_data $args
		set stream_port_id [lrange $stream_get_data 0 2]
        puts "-------------- STREAM PORT ID : $stream_port_id"
}
"cget" {

   	global streamsent tx_port stream_port_id
	global clientSocket
	set cgetvariable_list $args
puts "-----------inside stream cget function--------"
puts "-----------Variable LIST : $cgetvariable_list"
puts "-----------Variable LIST1 : [lindex $cgetvariable_list 0]"
	if {[lindex $cgetvariable_list 0] == "-packetView"} {
	set portList $stream_port_id
	set portList [join $portList ":"]
	set portList "34#$portList"
	set retCode [puts $clientSocket $portList]
        flush $clientSocket
        after 200
        set streamsent [ePTServer_read $clientSocket]
        set streamsent [lindex [split $streamsent "#"] 1]
        return $streamsent
        }
        }
}
}
#######################################################################################
# Procedure:    protocol  
#
# Description:  Used to create a protocol stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc protocol {config args} {

puts "----------Enter into protocol---------------"
	global protocol_name enable802dot1qTag ethernetType appName

	array set param $args

	if { [info exists param(-name)] } {
		set protocol_name $param(-name)
	}
	if { [info exists param(-enable802dot1qTag)] } {
		set enable802dot1qTag $param(-enable802dot1qTag)
	}
	if { [info exists param(-ethernetType)] } {
		set ethernetType $param(-ethernetType)
	}
	if { [info exists param(-appName)] } {
		set appName $param(-appName)
	}
}
#######################################################################################
# Procedure:    vlan      
#
# Description:  Used to create a vlan stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc vlan {config args} \
{

puts "############################Inside VLAN PROC###########################"
 
	array set param $args

	global cfi vlan_mode vlan_repeat vlan_id userPriority protocolTagId

	if { [info exists param(-cfi)] } {
		set cfi $param(-cfi)
                if {$cfi == "resetCFI"} {
                      set cfi 0
                   }
           }
	if { [info exists param(-mode)] } {
		set vlan_mode $param(-mode)
           }
	if { [info exists param(-repeat)] } {
		set vlan_repeat $param(-repeat)
           }
	if { [info exists param(-vlanID)] } {
		set vlan_id $param(-vlanID)
           }
	if { [info exists param(-userPriority)] } {
		set userPriority $param(-userPriority)
           }
	if { [info exists param(-protocolTagId)] } {
		set protocolTagId $param(-protocolTagId)
           }
}
#######################################################################################
# Procedure:    protocoloffset  
#
# Description:  Used to create a protocol offset in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc protocolOffset {config args} {

puts "--------- Enter into protocolOffset --------------"
	global protocoloffset_enable protocol_offset userDefinedTag

		array set param $args

		if { [info exists param(-enable)] } {
			set protocoloffset_enable $param(-enable)
		}
	if { [info exists param(-offset)] } {
		set protocol_offset $param(-offset)
	}
	if { [info exists param(-userDefinedTag)] } {
		set userDefinedTag $param(-userDefinedTag)
	}
}
#######################################################################################
# Procedure:    filter          
#
# Description:  Used to create a filter in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc filter {config args} {

puts "--------- Enter into filter --------------"

	array set param $args

		if { [info exists param(-captureFilterEnable)] } {
			set captureFilterEnable $param(-captureFilterEnable)
		}
	if { [info exists param(-captureTriggerEnable)] } {
		set captureTriggerEnable $param(-captureTriggerEnable)
	}
	if { [info exists param(-userDefinedStat1Enable)] } {
		set userDefinedStat1Enable $param(-userDefinedStat1Enable)
	}
	if { [info exists param(-userDefinedStat1DA)] } {
		set userDefinedStat1DA $param(-userDefinedStat1DA)
	}
	if { [info exists param(-userDefinedStat1SA)] } {
		set userDefinedStat1SA $param(-userDefinedStat1SA)
	}
	if { [info exists param(-captureFilterPattern)] } {
		set captureFilterPattern $param(-captureFilterPattern)
	}
	if { [info exists param(-captureTriggerPattern)] } {
		set captureTriggerPattern $param(-captureTriggerPattern)
	}
	if { [info exists param(-captureTriggerDA)] } {
		set captureTriggerDA $param(-captureTriggerDA)
	}
	if { [info exists param(-captureFilterDA)] } {
		set captureFilterDA $param(-captureFilterDA)
	}
	if { [info exists param(-userDefinedStat1Pattern)] } {
		set userDefinedStat1Pattern $param(-userDefinedStat1Pattern)
	}
	if { [info exists param(-userDefinedStat2Enable)] } {
		set userDefinedStat2Enable $param(-userDefinedStat2Enable)
	}
}
#######################################################################################
# Procedure:    filterPallette          
#
# Description:  Used to create a filter in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc filterPallette {config args} {

puts "--------- Enter into filterPallette --------------"
	array set param $args

		if { [info exists param(-pattern1)] } {
			set pattern1 $param(-pattern1)
		}
	if { [info exists param(-patternOffset1)] } {
		set patternOffset1 $param(-patternOffset1)
	}
	if { [info exists param(-DA1)] } {
		set DA1 $param(-DA1)
	}
	if { [info exists param(-SA1)] } {
		set SA1 $param(-SA1)
	}
	if { [info exists param(-matchType1)] } {
		set matchType1 $param(-matchType1)
	}
}
#######################################################################################
# Procedure:    ip         
#
# Description:  Used to create a ip stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc ip {config args} {

puts "--------- Enter into ip --------------"
	global ipProtocol destClass destIpAddr destIpMask destIpAddrMode sourceClass\
		sourceIpAddr sourceIpMask sourceIpAddrMode sourceIpAddrRepeatCount\
		destIpAddrRepeatCount destMacAddr destDutIpAddrttl useValidChecksum\
		fragment options delay throughput reliability precedence lengthOverride\
		totalLength identifier 

	array set param $args
	if { [info exists param(-ipProtocol)] } {
		set ipProtocol $param(-ipProtocol)
	}
	if { [info exists param(-destClass)] } {
		set destClass $param(-destClass)
	}
	if { [info exists param(-destIpAddr)] } {
		set destIpAddr $param(-destIpAddr)
	}
	if { [info exists param(-destIpMask)] } {
		set destIpMask $param(-destIpMask)
	}
	if { [info exists param(-destIpAddrMode)] } {
		set destIpAddrMode $param(-destIpAddrMode)
	}
	if { [info exists param(-sourceClass)] } {
		set sourceClass $param(-sourceClass)
	}
	if { [info exists param(-sourceIpAddr)] } {
		set sourceIpAddr $param(-sourceIpAddr)
	}
	if { [info exists param(-sourceIpMask)] } {
		set sourceIpMask $param(-sourceIpMask)
	}
	if { [info exists param(-sourceIpAddrMode)] } {
		set sourceIpAddrMode $param(-sourceIpAddrMode)
	}
	if { [info exists param(-sourceIpAddrRepeatCount)] } {
		set sourceIpAddrRepeatCount $param(-sourceIpAddrRepeatCount)
	}
	if { [info exists param(-destIpAddrRepeatCount)] } {
		set destIpAddrRepeatCount $param(-destIpAddrRepeatCount)
	}
	if { [info exists param(-destMacAddr)] } {
		set destMacAddr $param(-destMacAddr)
		set destMacAddr [join $destMacAddr ":"]
	}
	if { [info exists param(-destDutIpAddr)] } {
		set destDutIpAddr $param(-destDutIpAddr)
	}
	if { [info exists param(-ttl)] } {
		set ttl $param(-ttl)
	}
	if { [info exists param(-useValidChecksum)] } {
		set useValidChecksum $param(-useValidChecksum)
	}
	if { [info exists param(-fragment)] } {
		set fragment $param(-fragment)
	}
	if { [info exists param(-options)] } {
		set options [join $param(-options) ""]
	}
	if { [info exists param(-delay)] } {
		set delay $param(-delay)
	}
	if { [info exists param(-throughput)] } {
		set throughput $param(-throughput)
	}
	if { [info exists param(-reliability)] } {
		set reliability $param(-reliability)
	}
	if { [info exists param(-precedence)] } {
		set precedence $param(-precedence)
                if { $precedence == "routine"} {
                     set precedence "000"
                   } elseif {$precedence == "priority" } {
                     set precedence "001"
                   } elseif { $precedence == "immediate" } {
                     set precedence "010"
                   } elseif { $precedence == "flash" } {
                     set precedence "011"
                   } elseif { $precedence == "flashOverride" } {
                     set precedence "100"
                   } elseif { $precedence == "criticEcp" } {
                     set precedence "101"
                   } elseif { $precedence == "internetControl" } {
                     set precedence "110"
                   } else {
                     set precedence "111"
                   }
	}
	if { [info exists param(-lengthOverride)] } {
		set lengthOverride $param(-lengthOverride)
	}
	if { [info exists param(-totalLength)] } {
		set totalLength $param(-totalLength)
	}
	if { [info exists param(-identifier)] } {
		set identifier $param(-identifier)
	}
}
#######################################################################################
# Procedure:    ipx                     
#
# Description:  Used to create a ipx stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc ipx {config args} {

puts "--------- Enter into ipx--------------"
	global sourceNetwork sourceNetworkMaskSelect sourceNode sourceSocket\
		destNetwork destNode destSocket 

	array set param $args

	if { [info exists param(-sourceNetwork)] } {
		set sourceNetwork $param(-sourceNetwork)
			set sourceNetwork [join $sourceNetwork "."]
	}
	if { [info exists param(-sourceNetworkMaskSelect)] } {
		set sourceNetworkMaskSelect $param(-sourceNetworkMaskSelect)
			set sourceNetworkMaskSelect [join $sourceNetworkMaskSelect ""]
	}
	if { [info exists param(-sourceNode)] } {
		set sourceNode $param(-sourceNode)
			set sourceNode [join $sourceNode ""]
	}
	if { [info exists param(-sourceSocket)] } {
		set sourceSocket $param(-sourceSocket)
			set sourceSocket [join $sourceSocket ""]
	}
	if { [info exists param(-destNetwork)] } {
		set destNetwork $param(-destNetwork)
			set destNetwork [join $destNetwork "."]
	}
	if { [info exists param(-destNode)] } {
		set destNode $param(-destNode)
			set destNode [join $destNode ""]
	}
	if { [info exists param(-destSocket)] } {
		set destSocket $param(-destSocket)
			set destSocket [join $destSocket ""]
	}

}
#######################################################################################
# Procedure:    rip                     
#
# Description:  Used to create a rip stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc rip {config args} {

puts "--------- Enter into rip--------------"
	global command version

	array set param $args
	if { [info exists param(-command)] } {
		set command $param(-command)
	}
	if { [info exists param(-version)] } {
		set version $param(-version)
	}

}
#######################################################################################
# Procedure:    ripRoute                     
#
# Description:  Used to create a rip Route in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc ripRoute {config args} {

puts "--------- Enter into ripRoute--------------"
	global familyId routeTag ipAddress subnetMask nextHop metric

	array set param $args

	if { [info exists param(-familyId)] } {
		set familyId $param(-familyId)
	}
	if { [info exists param(-routeTag)] } {
		set routeTag $param(-routeTag)
	}
	if { [info exists param(-ipAddress)] } {
		set ipAddress $param(-ipAddress)
	}
	if { [info exists param(-subnet)] } {
		set subnet $param(-subnet)
	}
	if { [info exists param(-MasnextHop)] } {
		set MasnextHop $param(-MasnextHop)
	}
	if { [info exists param(-metric)] } {
		set metric $param(-metric)
	}
}
#######################################################################################
# Procedure:    dhcp                     
#
# Description:  Used to create a dhcp stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc dhcp {config args} {

puts "--------- Enter into dhcp--------------"
	global opCode hwType transactionID seconds dhcp_flags clientIpAddr yourIpAddr\
		serverIpAddr relayAgentIpAddr clientHwAddr optionData

	array set param $args

	if { [info exists param(-opCode)] } {
		set opCode $param(-opCode)
                if { $opCode == "dhcpBootRequest"} {
                   set opCode "01"
                   }
	}
	if { [info exists param(-hwType)] } {
		set hwType $param(-hwType)
	}
	if { [info exists param(-transactionID)] } {
		set transactionID $param(-transactionID)
	}
	if { [info exists param(-seconds)] } {
		set seconds $param(-seconds)
	}
	if { [info exists param(-flags)] } {
		set dhcp_flags $param(-flags)
	}
	if { [info exists param(-clientIpAddr)] } {
		set clientIpAddr $param(-clientIpAddr)
	}
	if { [info exists param(-yourIpAddr)] } {
		set yourIpAddr $param(-yourIpAddr)
	}
	if { [info exists param(-serverIpAddr)] } {
		set serverIpAddr $param(-serverIpAddr)
	}
	if { [info exists param(-relayAgentIpAddr)] } {
		set relayAgentIpAddr $param(-relayAgentIpAddr)
	}
	if { [info exists param(-clientHwAddr)] } {
		set clientHwAddr [ join $param(-clientHwAddr) ""]
	}
	if { [info exists param(-optionData)] } {
		set optionData [join $param(-optionData) "@"]
	}
}
#######################################################################################
# Procedure:    igmp                    
#
# Description:  Used to create a igmp stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc igmp {config args} {

puts "--------- Enter into igmp--------------"
	global version igmp_type groupIpAddress maxResponseTime igmp_mode repeatCount

	array set param $args

	if { [info exists param(-version)] } {
		set version $param(-version)
	}
	if { [info exists param(-maxResponseTime)] } {
		set maxResponseTime [format %02x $param(-maxResponseTime)]
	}
	if { [info exists param(-type)] } {
		set igmp_type $param(-type)
                if {$igmp_type == 22} {
                    set igmp_type 16
                  }
	}
	if { [info exists param(-groupIpAddress)] } {
		set groupIpAddress $param(-groupIpAddress)
	}
	if { [info exists param(-mode)] } {
		set igmp_mode $param(-mode)
	}
	if { [info exists param(-repeatCount)] } {
		set repeatCount $param(-repeatCount)
	}
}
#######################################################################################
# Procedure:    tcp                     
#
# Description:  Used to create a tcp stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc tcp {config args} {

puts "--------- Enter into tcp-------------"
	global sourcePort destPort sequenceNumber synchronize finished resetConnection\
		acknowledgeValid pushFunctionValid urgentPointerValid

	array set param $args

        if { [info exists param(-sourcePort)] } {
		set sourcePort $param(-sourcePort)
               puts "TCP SOURCE PORT : $sourcePort"
 	}
	if { [info exists param(-destPort)] } {
		set destPort $param(-destPort)
               puts "TCP DESTINATION PORT : $destPort"
	}
	if { [info exists param(-sequenceNumber)] } {
		set sequenceNumber $param(-sequenceNumber)
	}
	if { [info exists param(-synchronize)] } {
		set synchronize $param(-synchronize)
                if {$synchronize == "false"} {
                   set synchronize 0 
                   } else {
                     set synchronize 1
                   }                   
	}
	if { [info exists param(-finished)] } {
		set finished $param(-finished)
                if {$finished == "false"} {
                   set finished 0 
                   } else {
                     set finished 1
                   }                   
	}
	if { [info exists param(-resetConnection)] } {
		set resetConnection $param(-resetConnection)
                if {$resetConnection == "false"} {
                   set resetConnection 0 
                   } else {
                     set resetConnection 1
                   }                   
	}
	if { [info exists param(-acknowledgeValid)] } {
		set acknowledgeValid $param(-acknowledgeValid)
                if {$acknowledgeValid == "false"} {
                   set acknowledgeValid 0 
                   } else {
                     set acknowledgeValid 1
                   }                   
	}
	if { [info exists param(-pushFunctionValid)] } {
		set pushFunctionValid $param(-pushFunctionValid)
                if {$pushFunctionValid == "false"} {
                   set pushFunctionValid 0 
                   } else {
                     set pushFunctionValid 1
                   }                   
	}
	if { [info exists param(-urgentPointerValid)] } {
		set urgentPointerValid $param(-urgentPointerValid)
                if {$urgentPointerValid == "false"} {
                   set urgentPointerValid 0 
                   } else {
                     set urgentPointerValid 1
                   }                   
	}
}
#######################################################################################
# Procedure:    icmp                    
#
# Description:  Used to create a icmp stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc icmp {config args} {

puts "--------- Enter into icmp-----------"
	global type code id sequence

	array set param $args

	if { [info exists param(-type)] } {
		set type [format %02x $param(-type)]
	}
	if { [info exists param(-code)] } {
		set code [format %02x $param(-code)]
	}
	if { [info exists param(-id)] } {
		set id [format %04x $param(-id)]
	}
	if { [info exists param(-sequence)] } {
		set sequence [format %04x $param(-sequence)]
	}
}
#######################################################################################
# Procedure:    arp                     
#
# Description:  Used to create a arp stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc arp {config args} {

puts "--------- Enter into arp-----------"
	global sourceProtocolAddr destProtocolAddr sourceProtocolAddrMode destProtocolAddrMode\
           sourceHardwareAddr destHardwareAddr sourceProtocolAddrRepeatCount destProtocolAddrRepeatCount\
           operation sourceHardwareAddrMode sourceHardwareAddrRepeatCount destHardwareAddrMode\
		   destHardwareAddrRepeatCount

	array set param $args

	if { [info exists param(-sourceProtocolAddr)] } {
		set sourceProtocolAddr $param(-sourceProtocolAddr)
	}
	if { [info exists param(-destProtocolAddr)] } {
		set destProtocolAddr $param(-destProtocolAddr)
	}
	if { [info exists param(-sourceProtocolAddrMode)] } {
		set sourceProtocolAddrMode $param(-sourceProtocolAddrMode)
	}
	if { [info exists param(-destProtocolAddrMode)] } {
		set destProtocolAddrMode $param(-destProtocolAddrMode)
	}
	if { [info exists param(-sourceHardwareAddr)] } {
#	set sourceHardwareAddr $param(-sourceHardwareAddr)
                set sourceHardwareAddr [join [join [split $param(-sourceHardwareAddr) ":"] ""] ""]
               if {$sourceHardwareAddr == ""} {
                   set sourceHardwareAddr "00a1f1000001"
                }
	}
	if { [info exists param(-destHardwareAddr)] } {
#		set destHardwareAddr $param(-destHardwareAddr)
                set destHardwareAddr [join [join [split $param(-destHardwareAddr) ":"] ""] ""]
               if {$destHardwareAddr == ""} {
                   set destHardwareAddr "00a1f2000001"
                }
	}
	if { [info exists param(-sourceProtocolAddrRepeatCount)] } {
		set sourceProtocolAddrRepeatCount $param(-sourceProtocolAddrRepeatCount)
	}
	if { [info exists param(-destProtocolAddrRepeatCount)] } {
		set destProtocolAddrRepeatCount $param(-destProtocolAddrRepeatCount)
	}
	if { [info exists param(-operation)] } {
		set operation $param(-operation)
	}
	if { [info exists param(-sourceHardwareAddrMode)] } {
		set sourceHardwareAddrMode $param(-sourceHardwareAddrMode)
	}
	if { [info exists param(-sourceHardwareAddrRepeatCount)] } {
		set sourceHardwareAddrRepeatCount $param(-sourceHardwareAddrRepeatCount)
	}
	if { [info exists param(-destHardwareAddrMode)] } {
		set destHardwareAddrMode $param(-destHardwareAddrMode)
	}
	if { [info exists param(-destHardwareAddrRepeatCount)] } {
		set destHardwareAddrRepeatCount $param(-destHardwareAddrRepeatCount)
	}
}
#######################################################################################
# Procedure:    ipV6                    
#
# Description:  Used to create a ipV6 stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc ipV6 {config args} {

puts "--------- Enter into ipV6-----------"
	global trafficClass flowLabel hopLimit sourceAddr sourceMask destAddr destMask\
		nextHeader sourceAddrMode sourceAddrRepeatCount destAddrMode\
		destAddrRepeatCount destMacAddr

	array set param $args

	if { [info exists param(-trafficClass)] } {
		set trafficClass $param(-trafficClass)
	}
	if { [info exists param(-flowLabel)] } {
		set flowLabel $param(-flowLabel)
	}
	if { [info exists param(-hopLimit)] } {
		set hopLimit $param(-hopLimit)
	}
	if { [info exists param(-sourceAddr)] } {
		set sourceAddr [ePTGettingPrefix $param(-sourceAddr)]
               
	}
	if { [info exists param(-sourceMask)] } {
		set sourceMask $param(-sourceMask)
	}
	if { [info exists param(-destAddr)] } {
		set destAddr [ePTGettingPrefix $param(-destAddr)]
	}
	if { [info exists param(-destMask)] } {
		set destMask $param(-destMask)
	}
	if { [info exists param(-nextHeader)] } {
		set nextHeader $param(-nextHeader)
	}
	if { [info exists param(-sourceAddrMode)] } {
		set sourceAddrMode $param(-sourceAddrMode)
	}
	if { [info exists param(-sourceAddrRepeatCount)] } {
		set sourceAddrRepeatCount $param(-sourceAddrRepeatCount)
	}
	if { [info exists param(-destAddrMode)] } {
		set destAddrMode $param(-destAddrMode)
	}
	if { [info exists param(-destAddrRepeatCount)] } {
		set destAddrRepeatCount $param(-destAddrRepeatCount)
	}
	if { [info exists param(-destMacAddr)] } {
		set destMacAddr $param(-destMacAddr)
	}
}
#######################################################################################
# Procedure:    capture                 
#
# Description:  Used to capture the streams         
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc capture {option args} {

        global clientSocket nPackets
puts "--------- Enter into capture-----------"
    switch $option {
        get {
	global capture_port_id
        set capture_port_id $args
	set capture_port_id [join $capture_port_id ":"]
        return $capture_port_id
        }
        cget {
	global nPackets capture_port_id
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == "-nPackets"} {
	set portList "22#$capture_port_id"
        set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set nPackets [ePTServer_read $clientSocket]
        set nPackets [lindex [split $nPackets "#"] 1]
	return $nPackets
         }         
       }
    }
}
#######################################################################################
# Procedure:    captureBuffer                 
#
# Description:  Used to capture the streams         
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
#        return $captureBuffer_frame
proc captureBuffer {option args} {

puts "--------- Enter into captureBuffer-----------"
	global captureBuffer_port_id captureBuffer stream_id num_of_frames clientSocket

switch $option {
    "get" {
            global captureBuffer
                set captureBuffer_data $args
		set retCode 0
		set captureBuffer_port_id [join [lrange $captureBuffer_data 0 2] ":"]
		set stream_id [lindex $captureBuffer_data 3]
		set num_of_frames [lindex $captureBuffer_data 4]
		set portList "07#$captureBuffer_port_id"
		set retCode [puts $clientSocket $portList]
		flush $clientSocket
                after 200
                set captureBuffer [ePTServer_read $clientSocket]
                return $captureBuffer
     } 
   "getframe" {
	global captureBuffer captureBuffer_frame
        set getframe_num $args
        set captureBuffer_frame [lindex $captureBuffer $getframe_num]
         puts "Capture Buffer Frame : $captureBuffer_frame"
        return 0
    }
    "cget" {
	global captureBuffer
        set cgetvariable_list $args
	if {[lindex $cgetvariable_list 0] == "-frame"} {
        return $captureBuffer
     }
 }  
}
}
#######################################################################################
# Procedure:    stat                    
#
# Description:  Used to get the port stattistics    
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc stat {option args} {
puts "--------- Enter into stat-----------"

    switch $option {
        "get" {
	global statAllStats statFramesSent clientSocket statFramesSent_port
        set getvariable_list $args
	if {[lindex $getvariable_list 0] == "statAllStats"} {
		set statAllStats $getvariable_list
                puts "StatAllStats1 : $statAllStats"
                set statAllStats [join [lrange $statAllStats 1 3] ":"]
                puts "StatAllStats2 : $statAllStats"
	}
	if {[lindex $getvariable_list 0] == "statFramesSent"} {
	set statFramesSent_port [join [lrange $getvariable_list 1 3] ":"]
        return 0
	}
        }
        "cget" {
	global clientSocket tx_port framesSent framesReceived bytesSent bytesReceived\
               oversize userDefinedStat1 rx_port getstatAllStats statAllStats statFramesSent_port\
               getRatestatAllStats 
	set cgetvariable_list $args
puts "-----------inside stream cget function--------"
puts "-----------Variable LIST : $cgetvariable_list"
puts "-----------Variable LIST1 : [lindex $cgetvariable_list 0]"
	if {[lindex $cgetvariable_list 0] == "-framesSent"} {
           if {$getRatestatAllStats == 0} {
	set portList $statAllStats
        after 200
	set portList "20#$portList"
	set retCode [puts $clientSocket $portList]
        flush $clientSocket
        set framessent [ePTServer_read $clientSocket]
        set framessent [lindex [split $framessent "#"] 1]
        puts "Frames SENT : $framessent"
        return $framessent
        } else {
        set portList $getRatestatAllStats
        set portList "20#$portList"
        set retCode [puts $clientSocket $portList]
        flush $clientSocket
        after 200
        set framessent [ePTServer_read $clientSocket]
        set framessent [lindex [split $framessent "#"] 1]
        puts "Frames SENT : $framessent"
        return $framessent
        }
        }
        if {[lindex $cgetvariable_list 0] == "-framesReceived"} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "22#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set framesReceived [ePTServer_read $clientSocket]
        set framesReceived [lindex [split $framesReceived "#"] 1]
	return $framesReceived
        } else {
        set portList $getRatestatAllStats
	set portList "22#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set framesReceived [ePTServer_read $clientSocket]
        set framesReceived [lindex [split $framesReceived "#"] 1]
	return $framesReceived
        }
       }
        if {[lindex $cgetvariable_list 0] == "-counterVal"} {
	set portList $statFramesSent_port
	set portList "20#$portList"
	set retCode [puts $clientSocket $portList]
        flush $clientSocket
        after 200
        set counterVal [ePTServer_read $clientSocket]
        set counterVal [lindex [split $counterVal "#"] 1]
        puts "Counter Val : $counterVal"
        return $counterVal
	}
        if {[lindex $cgetvariable_list 0] == "-bitsSent"} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "42#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "42#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-bytesSent"} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "21#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "21#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-bytesReceived"} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "23#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "23#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-bitsReceived"} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "43#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "43#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-oversize"} { 
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "24#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "24#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-userDefinedStat1"} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "22#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "22#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-vlanTaggedFramesRx"} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "40#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "40#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        }
	}
        if {[lindex $cgetvariable_list 0] == "-rxArpRequest"} {
           if {$getRatestatAllStats == 0} {
        set portList $statAllStats
	set portList "39#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200  
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
        } else {
        set portList $getRatestatAllStats
	set portList "39#$portList"
	set retCode [puts $clientSocket $portList]
	flush $clientSocket
        after 200
        set bytesSent [ePTServer_read $clientSocket]
        set bytesSent [lindex [split $framesReceived "#"] 1]
	return $bytesSent
	}
        }
}
        "getRate" {
	global getRatestatAllStats
        set getRatevariable_list $args 
	if {[lindex $getRatevariable_list 0] == "statAllStats"} {
		set getRatestatAllStats $getRatevariable_list
                set getRatestatAllStats [join [lrange $getRatestatAllStats 1 3] ":"]
	}
         return 0
	}
        }
}
#######################################################################################
# Procedure:    udp                     
#
# Description:  Used to create a udp stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc udp {config args} {

puts "--------- Enter into udp-----------"
	global sourceudpPort destudpPort checksumMode

	array set param $args

	if { [info exists param(-sourcePort)] } {
		set sourceudpPort $param(-sourcePort)
               puts "UDP SOURCE PORT : $sourceudpPort"
	}
	if { [info exists param(-destPort)] } {
		set destudpPort $param(-destPort)
               puts "UDP DEST PORT : $destudpPort"
	}
	if { [info exists param(-checksumMode)] } {
		set checksumMode $param(-checksumMode)
	}
}
#######################################################################################
# Procedure:    udf                     
#
# Description:  Used to create a udf in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc udf {config args} {

puts "--------- Enter into udf-----------"
	global udf_enable continuousCount initval offset countertype

	array set param $args

	if { [info exists param(-enable)] } {
		set udf_enable $param(-enable)
	}
	if { [info exists param(-continuousCount)] } {
		set continuousCount $param(-continuousCount)
	}
	if { [info exists param(-initval)] } {
		set initval $param(-initval)
                set initval [join $initval ""]
	}
	if { [info exists param(-offset)] } {
		set offset $param(-offset)
	}
	if { [info exists param(-countertype)] } {
		set countertype $param(-countertype)
	}
}
#######################################################################################
# Procedure : BintoHex
# 
# Description : Used to convert binary to hex data
#
# Input : args : Binary 
#
# Returns : Success : TCL return result
#           Failure : {}
#
#######################################################################################
proc bin2hex {bin} {
	set result ""
		set prepend [string repeat 0 [expr (4-[string length $bin]%4)%4]]
		foreach g [regexp -all -inline {[01]{4}} $prepend$bin] {
			foreach {b3 b2 b1 b0} [split $g ""] {
				append result [format %X [expr {$b3*8+$b2*4+$b1*2+$b0}]]
			}
		}
	return $result
}
########################################################################################
# Procedure:   ePTConnectToTclServer
#
# Description: This procedure connects a Server
#
# Argument(s):
#    serverName - Ip addr/name of Server
#
# Returns:
#    0 - if no error
#    1 - if any error found
########################################################################################
	proc ePTConnectToTclServer {serverName} \
{
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "INSIDE CONNECT FN SERVER NAME : $serverName"
          puts "##################### INSIDE EPT CLIENT 2 FILE ###############################"
          puts "##################### INSIDE EPT CLIENT 2 FILE ###############################"
          puts "##################### INSIDE EPT CLIENT 2 FILE ###############################"
          puts "##################### INSIDE EPT CLIENT 2 FILE ###############################"
          puts "##################### INSIDE EPT CLIENT 2 FILE ###############################"
          puts "##################### INSIDE EPT CLIENT 2 FILE ###############################"
	global clientSocket
		set client_port 8888
		set clientSocket [socket -async $serverName $client_port]
                puts "CLIENT SOCKET : $clientSocket" 
		if {$clientSocket == {}} {
			return 1
		} else {
                               fileevent  $clientSocket readable [list ePTServer_read $clientSocket]
                               fconfigure $clientSocket -translation auto -blocking 0 -buffering line
#                               fconfigure $clientSocket -translation auto -blocking 0
				set mac_address [exec ifconfig eth0 | grep -i "HWaddr"]
				set mac_address [lindex $mac_address 4]
				set ip_address [exec ifconfig eth0 | grep -i "inet addr:"]
				set ip_address [lindex [split [lindex $ip_address 1] ":"] 1]
                set chassisList1 "1:1:1#1:1:2#1:1:3#1:1:4#1:1:5#1:1:6#1:1:7#1:1:8"
				set portmap_List "01#$chassisList1#$clientSocket#$ip_address#$mac_address"
				set portList "02#$chassisList1"
				set retCode [puts $clientSocket $portmap_List]
				after 200
				flush $clientSocket
				set retCode [puts $clientSocket $portList]
				after 200 
				flush $clientSocket
		}
	return 0
}

########################################################################
# Procedure: ePTLogin
#
# This command logs in a user.
#
# Argument(s):
#   userName    - name of the user to login
#
########################################################################
proc ePTLogin {userName} \
{
#	global clientSocket
#		if {[info exists clientSocket]} {
#			set retCode [puts $clientSocket $userName]
#				flush $clientSocket
#		}
	return 0
}

########################################################################
# Procedure: ePTLogout
#
# This command logs out the current user.
#
# Argument(s):
#   None
#
########################################################################
proc ePTLogout {} \
{
	global clientSocket

		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket logout]
				flush $clientSocket
                        after 200 
		}
	return 0
}

########################################################################
# Procedure: ePTTakeOwnership
#
# This command attempts to take ownership of all the ports in the list
#
# Argument(s):
#   txRxList    - list of ports to take ownership
#   takeType    - if "force" take regardless of whether
#                 the port is previously owned by someone else
#
########################################################################
proc ePTTakeOwnership {txRxList {takeType ""}} \
{
		set portList $txRxList
		set portList [join [join $portList "#"] ":"]
		global clientSocket
		set portList "02#$portList"
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#        set ePTTakeOwnership_output [ePTServer_read $clientSocket]
	return 0 
}

########################################################################
# Procedure: ePTPortTakeOwnership
#
# This command attempts to take ownership of this port
#
# Arguments(s):
#    chassis
#    lm
#    port
#   takeType    - if "force" take regardless of whether
#                 the port is previously owned by someone else
#
########################################################################
proc ePTPortTakeOwnership {chassis lm port {takeType ""}} \
{
	global clientSocket
		set portList "$chassis:$lm:$port"
		set portList "02#$portList"
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#        set ePTPortTakeOwnership_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTClearOwnership
#
# This command clears ownership of all the ports in the list
#
# Argument(s):
#   txRxList    - list of ports to take ownership
#   takeType    - if "force" take regardless of whether
#                 the port is previously owned by someone else
#
########################################################################
proc ePTClearOwnership {{txRxList "" } {takeType ""}} \
{
		set portList $txRxList
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set portList "05#$portList"
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTClearOwnership_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTPortClearOwnership
#
# This command clears ownership of this port
#
# Arguments(s):
#    chassis
#    lm
#    port
#   takeType    - if "force" take regardless of whether
#                 the port is previously owned by someone else
#
########################################################################
proc ePTPortClearOwnership {chassis lm port {takeType ""}} \
{
	global clientSocket
		set portList "$chassis:$lm:$port"
		set portList "05#$portList"
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTPortClearOwnership_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTCheckOwnership
#
# This command checks ownership of all the ports in the list
#
# Argument(s):
#   TxRxList    - list of ports to take ownership
#
########################################################################
proc ePTCheckOwnership {txRxList} \
{
		set portList $txRxList
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set retCode 0
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTPortCheckOwnership_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################################
# Procedure:   ePTGetChassisID
#
# Description: This procedure gets the chassis ID of the specified chassis name. It is
#              useful when multiple chassis are chained together.
#
# Argument(s):
#    chassisName - chassis name for which ID is to be obtained
#
# Returns:
#    -1 - if error found
#    chasissID - ID number of the chassis
########################################################################################
proc ePTGetChassisID {chassisName} \
{
	if [chassis get $chassisName] {
		puts "Error getting parameters for chassis $chassisName"
			return -1
	}
	set chassisID [chassis cget -id]
		return $chassisID
}

########################################################################################
# Procedure:   ePTDisconnectFromChassis
#
# Description: Disconnects from input chassis or list of chassis; if no arg given, then
#              will removeAll.
#
# Argument(s):
#    args - list of chassis to del; if empty, removeAll
#
# Returns:
#    0 - if no error
#
########################################################################################
proc ePTDisconnectFromChassis {args} \
{
	global clientSocket
		set retCode 0
		set chassisList "08#$chassisList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $chassisList]
				flush $clientSocket
                        after 200 
		}
	return 0
#                        set ePTDisconnectFromChassis_output [ePTServer_read $clientSocket]
}


########################################################################################
# Procedure:   ePTStartTransmit
#
# Description: Starts transmission on the specific ports
#
# Arguments:
#    PortList - Represented in Chassis Card Port and can be a list also, example {1,1,1 1,1,2}
#
# Returns:
########################################################################################
proc ePTStartTransmit {PortList} \
{
	set portList $PortList
		global clientSocket
		set retCode 0
		set portList [join [join $portList "#"] ":"]
             
		set portList "04#$portList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                after 200 
		}
#                        set ePTStartTransmit_output [ePTServer_read $clientSocket]
#                        puts "Inside ePTStartTransmit OUTPUT : $ePTStartTransmit_output"
	return 0
}


########################################################################
# Procedure:   ePTStartPortTransmit
#
# Description: This command starts Transmit on a single port; it will also stop transmit &
#              zero stats on this port before transmitting.
#
# Arguments(s):
#    chassis
#    lm
#    port
#
# Return:
#    0 if OK, 1 if port not configured
########################################################################
proc ePTStartPortTransmit {chassis lm port} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "04#$port"
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $port]
		flush $clientSocket
                after 200 
		}
#                        set ePTStartPortTransmit_output [ePTServer_read $clientSocket]
#                        puts "Inside ePTStartPortTransmit OUTPUT : $ePTStartPortTransmit_output"
	return 0
}

########################################################################################
# Procedure:   ePTStopTransmit
#
# Description: Stops transmission on the specific ports
#
# Arguments:
#    PortList - Represented in Chassis Card Port and can be a list also, for ex. {1,1,1 1,1,2}
#
# Returns:
########################################################################################
proc ePTStopTransmit {PortList} \
{

		global clientSocket
		set PortList [join [join $PortList "#"] ":"]
		set PortList "15#$PortList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $PortList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTStopTransmit_output [ePTServer_read $clientSocket]
	return 0

}
########################################################################
# Procedure:   ePTStopPortTransmit
#
# Description: This command stops Tx on a single port
#
# Arguments(s):
#    chassis
#    lm
#    port
#
# Return:      0 if OK, 1 if port not configured
########################################################################
proc ePTStopPortTransmit {chassis lm port} \
{
        puts "Inside Stop Port transmit"
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "15#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
	return 0
#                        set ePTStopPortTransmit_output [ePTServer_read $clientSocket]
}

########################################################################
# Procedure:   ePTStartCapture
#
# Description: This command turns on capture for each Rx port
#
# Arguments:
#    PortList - Represented in Chassis Card Port and can be a list also for ex. {1,1,1 1,1,2}
#
# Returns:
########################################################################
proc ePTStartCapture {PortList} \
{
	set portList $PortList
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set portList "25#$portList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTStartCapture_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTStopCapture
#
# This command stops capture for each Rx port
#
# Arguments:
#      PortList  - Represented in Chassis Card Port and can be a list also
#                  for ex. {1,1,1 1,1,2}
#
########################################################################
proc ePTStopCapture {PortList} \
{
	    set portList $PortList
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set PortList "35#$portList"
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $PortList]
		flush $clientSocket
                after 200 
		}
		set PortList1 "15#$portList"
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $PortList1]
		flush $clientSocket
                after 200 
		}
#                        set ePTStopCapture_output [ePTServer_read $clientSocket]
	return 0
}
########################################################################
# Procedure: ePTStartPortCapture
#
# This command starts capture on a single port;
#
# Arguments(s):
#    chassis
#    lm
#    port
#
# Return:
#    0 if OK, 1 if port not configured
#
########################################################################
proc ePTStartPortCapture {chassis lm port} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "25#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
#                        set ePTStartPortCapture_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTStopPortCapture
#
# This command stops capture on a single port
#
# Arguments(s):
#    chassis
#    lm
#    port
#
# Return:
#    1 if OK, 0 if port not configured
#
########################################################################
proc ePTStopPortCapture {chassis lm port {groupId 710} {create create} {destroy destroy}} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set Port "35#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $Port]
				flush $clientSocket
                        after 200 
		}
		set PortList1 "15#$port"
		if {[info exists clientSocket]} {
		set retCode [puts $clientSocket $PortList1]
		flush $clientSocket
                after 200 
		}
#                        set ePTStopCapture_output [ePTServer_read $clientSocket]
#                        set ePTStopPortCapture_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################################
#  Procedure  :  ePTClearStats
#
#  Description:  Clear statistics counters on the specific ports
#
#  Arguments  :
#      ports     - Represented in Chassis Card Port and can be a list also
#                  for ex. {1,1,1 1,1,2}
#
########################################################################################
proc ePTClearStats {PortList} \
{

	puts "------------------------ PortList ********************* ================ $PortList"
	    set portList $PortList
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set portList "18#$portList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTClearStats_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTClearPortStats
#
# This command zeros all stats & stops the specified port if transmitting
#
# Argument(s):
#    chassis     chassis ID
#    lm          Load Module number
#    port        port number
#
########################################################################
proc ePTClearPortStats {chassis lm port} \
{
	global clientSocket
		set retCode 0
		set port "$chassis:$lm:$port"
		set port "18#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
#                        set ePTClearPortStats_output [ePTServer_read $clientSocket]

	return 0
}

########################################################################
# Procedure: ePTDisablePortArpResponse
#
# This command disables the arp response engine for the specified port
#
# Arguments(s):
#   chassis
#   lm
#   port
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTDisablePortArpResponse {chassis lm port {write write}} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "57#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
#                        set ePTDisablePortArpResponse_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTTransmitPortArpRequest
#
# This command transmits an Arp request via the protocol server on a
# single port
#
# Arguments(s):
#       chassis
#       lm
#       port
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTTransmitPortArpRequest {chassis lm port} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "13#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
#                        set ePTTransmitPortArpRequest_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTSetPacketStreamMode
#
# This command sets all the TX ports in the list or array to packet
# stream mode
#
# Arguments(s):
#   TxRxArray       - list or array of TX ports to change
#   write           - write ports to hw as they are modified
#
########################################################################
proc ePTSetPacketStreamMode {TxRxArray {write nowrite}} \
{
	    set portList $TxRxArray
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set portList "59#$portList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
#                        set ePTSetPacketStreamMode_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTSetPortPacketStreamMode
#
# This command sets specified port to packet stream mode
#
# Arguments(s):
#   chassis
#   lm
#   port
#   write           - write port to hw
#
########################################################################
proc ePTSetPortPacketStreamMode {chassis lm port {write nowrite}} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "59#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
#                        set ePTSetPortPacketStreamMode_output [ePTServer_read $clientSocket]
	return 0
}
########################################################################
# Procedure: ePTWritePortsToHardware
#
# This command writes the ports, including speed, etc into hardware. It
# differs from writeConfigToHardware because this command writes all
# the phy as well as the configuration.
#
# Argument(s):
#    PortArray      either list of ports or array of ports
#    args           options include:
#                   -verbose             <turn on messages>
#                   -noVerbose           <turn off messages, default>
#                   -writeProtocolServer <stops protocol server & writes
#                                         all associated objects, default>
#                   -noProtocolServer    <no effect on protocol server,
#                                         doesn't update protocol server objects>
#
########################################################################
proc ePTWritePortsToHardware {PortArray args} \
{
		global clientSocket
		set stream [stream_construct]
        set stream "03#$stream"
		if {[info exists clientSocket]} {
      	set retCode [puts $clientSocket $stream]
	flush $clientSocket
                    after 200 
#                 set output [ePTServer_read $clientSocket]
		}
	return 0
}
########################################################################
# Procedure: ePTWriteConfigToHardware
#
# This command writes the port array into hardware
#
# Argument(s):
#    PortArray      either list of ports or array of ports
#    args           options include:
#                   -verbose             <turn on messages>
#                   -noVerbose           <turn off messages, default>
#                   -writeProtocolServer <stops protocol server & writes
#                                         all associated objects, default>
#                   -noProtocolServer    <no effect on protocol server,
#                                         doesn't update protocol server objects>
#
########################################################################
proc ePTWriteConfigToHardware {PortArray args} \
{
		global clientSocket
		set stream [stream_construct]
        set stream "03#$stream"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $stream]
				flush $clientSocket
                        after 200 
#                 set output [ePTServer_read $clientSocket]
		}
	return 0
}
########################################################################
# Procedure: ePTCheckTransmitDone
#
# This command polls the TX rate counters & returns when done transmitting
#
# Argument(s):
#    PortArray                either list of ports or array of ports
#
########################################################################
proc ePTCheckTransmitDone {PortArray} \
{
     	set portList $PortArray
		global clientSocket
		set portList [join [join $portList "#"] ":"]
		set portList "28#$portList"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portList]
				flush $clientSocket
                        after 200 
		}
	return 0
}


########################################################################
# Procedure: ePTCheckPortTransmitDone
#
# This command polls the TX rate counters & returns the number of frames
# transmitted
#
# Argument(s):
#    chassis        chassis ID
#    lm            Load Module number
#    port        port number
#
########################################################################
proc ePTCheckPortTransmitDone {chassis lm port} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set port "28#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $port]
				flush $clientSocket
                        after 200 
		}
#                        set ePTCheckPortTransmitDone_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTCheckLinkState
#
# This command checks the link state of all ports in parallel and labels
# the ones that are down. Then it polls the links that are down for two
# seconds and returns 1 if any port is still down and a 0 if all ports are
# up.
#
# Arguments(s):
#    PortArray    array or list of ports, ie, ePTgSortMap
#
########################################################################
proc ePTCheckLinkState {PortArray {message messageOn}} \
{
    	set portArray $PortArray
		global clientSocket
		set portArray [join [join $portArray "#"] ":"]
		set portArray "19#$portArray"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portArray]
				flush $clientSocket
                        after 200 
		}
#                        set ePTCheckLinkState_output [ePTServer_read $clientSocket]
	return 0
}
########################################################################################
# Procedure: ePTRequestStats
#
# Description: This command combines the statGroup w/a portList or map array to request
#              stats for a list of ports. statList command must be used to retrieve stats
#              after call completion.
#
# Arguments:
#    TxRxArray - either list of ports or array of ports
#
# Returns:
#       TCL_OK or TCL_ERROR
#
########################################################################################
proc ePTRequestStats {TxRxArray} \
{
     	set txRxArray $TxRxArray
		global clientSocket
		set txRxArray [join [join $txRxArray "#"] ":"]
		set txRxArray "15#$txRxArray"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $txRxArray]
				flush $clientSocket
                        after 200 
		}
#                        set ePTRequestStats_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTEnableArpResponse
#
# This command gets the MAC & IP addresses for that port, sets up the
# address table and enables the arp response engine for all ports in
# the portlist
#
# Arguments(s):
#   mapType - either oneIpToOneMAC or manyIpToOneMAC
#   PortMap - list or array of ports, ie. ePTgSortMap
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTEnableArpResponse { mapType PortMap } \
{
	    set portMap $PortMap
		global clientSocket
		set portMap [join [join $portMap "#"] ":"]
		set portMap "12#$portMap"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
#                        set ePTEnableArpResponse_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTEnablePortArpResponse
#
# This command gets the MAC & IP addresses for that port, sets up the
# address table and enables the arp response engine for the specified port
#
# Arguments(s):
#   mapType - either oneIpToOneMAC or manyIpToOneMAC
#   chassis
#   lm
#   port
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTEnablePortArpResponse { mapType chassis lm port {write write}} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set portMap "12#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
#                        set ePTEnablePortArpResponse_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTDisableArpResponse
#
# This command disables the arp response engine for all ports in
# the portlist
# Arguments(s):
#   PortMap - list or array of ports, ie. ePTgSortMap
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTDisableArpResponse { PortMap } \
{
	    set portMap $PortMap
		global clientSocket
		set portMap [join [join $portMap "#"] ":"]
		set portMap "27#$portMap"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
#                        set ePTDisableArpResponse_output [ePTServer_read $clientSocket]
	return 0
}


########################################################################
# Procedure: ePTTransmitArpRequest
#
# This command transmits an Arp request via the protocol server.
#
# Arguments:
#   TxRxArray       - either array or list containing ports to transmit
#                     arp request on
#
########################################################################
proc ePTTransmitArpRequest {TxRxArray} \
{
	    set txRxArray $TxRxArray
		global clientSocket
		set portMap [join [join $txRxArray "#"] ":"]
		set portMap "13#$txRxArray"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
#                        set ePTTransmitArpRequest_output [ePTServer_read $clientSocket]
	return 0
}

########################################################################
# Procedure: ePTDisablePortArpResponse
#
# This command disables the arp response engine for the specified port
#
# Arguments(s):
#   chassis
#   lm
#   port
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTDisablePortArpResponse {chassis lm port {write write}} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set portMap "36#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
	return 0
#                        set ePTDisablePortArpResponse_output [ePTServer_read $clientSocket]
}


########################################################################
# Procedure: ePTTransmitPortArpRequest
#
# This command transmits an Arp request via the protocol server on a
# single port
#
# Arguments(s):
#       chassis
#       lm
#       port
#
# Return:
#       0 if OK, 1 if port not configured
#
########################################################################
proc ePTTransmitPortArpRequest {chassis lm port} \
{
	global clientSocket
		set port  "$chassis:$lm:$port"
		set portMap "13#$port"
		if {[info exists clientSocket]} {
			set retCode [puts $clientSocket $portMap]
				flush $clientSocket
                        after 200 
		}
#                        set ePTTransmitPortArpRequest_output [ePTServer_read $clientSocket]
	return 0
}

#######################################################################################
# Procedure:    stream_construct                     
#
# Description:  Used to create a stream in client side
#
# Input:        args:        TCL command to evaluate
#
# Returns:      Success:    TCL Return result
#               Failure:    {}
#
# Remarks:  TCL procs can embed i/o.
#
########################################################################################
proc stream_construct {} \
{

    global clientSocket tx_port rx_port numFrames stream_name framesize frameSizeType frameSizeMAX\
        frameSizeMIN rateMode percentPacketRate fcs fir patternType dataPattern sa da\
        saRepeatCounter daRepeatCounter	numSA numDA frameType protocol_name enable802dot1qTag\
        ethernetType appName cfi vlan_mode vlan_repeat vlan_id userPriority protocolTagId protocoloffset_enable\
        protocol_offset userDefinedTag ipProtocol destClass destIpAddr destIpMask destIpAddrMode sourceClass\
        sourceIpAddr sourceIpMask sourceIpAddrMode sourceIpAddrRepeatCount destIpAddrRepeatCount\
        destMacAddr destDutIpAddr ttl useValidChecksum fragment options delay throughput reliability\
        precedence lengthOverride totalLength identifier command version familyId routeTag ipAddress\
        subnet MasnextHop metric opCode hwType transactionID seconds dhcp_flags clientIpAddr yourIpAddr\
        serverIpAddr relayAgentIpAddr clientHwAddr optionData version maxResponseTime igmp_type\
        groupIpAddress maxResponseTime igmp_mode repeatCount sourcePort destPort sequenceNumber\
        synchronize finished resetConnection type code id sequence sourceProtocolAddr\
	acknowledgeValid pushFunctionValid urgentPointerValid \
        destProtocolAddr sourceProtocolAddrMode destProtocolAddrMode sourceHardwareAddr\
        destHardwareAddr sourceProtocolAddrRepeatCount destProtocolAddrRepeatCount operation\
        sourceHardwareAddrMode sourceHardwareAddrRepeatCount destHardwareAddrMode\
        destHardwareAddrRepeatCount sourceudpPort\
        destudpPort checksumMode trafficClass flowLabel hopLimit sourceAddr sourceMask destAddr\
        destMask nextHeader sourceAddrMode sourceAddrRepeatCount destAddrMode destAddrRepeatCount\
        destMacAddr sourceProtocolAddr destProtocolAddr sourceProtocolAddrMode destProtocolAddrMode\
        sourceHardwareAddr destHardwareAddr sourceProtocolAddrRepeatCount destProtocolAddrRepeatCount\
        operation sourceHardwareAddrMode sourceHardwareAddrRepeatCount destHardwareAddrMode\
        destHardwareAddrRepeatCount direction udf_enable continuousCount initval offset countertype dma\
	sourceNetwork sourceNetworkMaskSelect sourceNode sourceSocket destNetwork destNode destSocket 

###################Stream construction STRTS HERE####################################### 
 puts "Inside stream_construct ----->cfi : $cfi------------>"
 puts "Inside stream_construct ----->vlan_mode : $vlan_mode------------->"
 puts "Inside stream_construct ----->vlan_Id : $vlan_id------------->"
 puts "Inside stream_construct ----->vlan_repeat : $vlan_repeat------------->"
 puts "Inside stream_construct ----->userPriority: $userPriority------------>"
 puts "Inside stream_construct ----->protocolTagId: $protocolTagId------------>"
 puts "Inside stream_construct ----->ipProtocol: $ipProtocol------------>"

        if {![info exists protocoloffset_enable]} {
              set protocoloffset_enable "false"
           }
        if {![info exists udf_enable]} {
              set udf_enable "false"
           }
        if {![info exists continuousCount]} {
              set continuousCount "0"
           }
        if {![info exists initval]} {
              set initval "0"
           }
        if {![info exists offset]} {
              set offset "14"
           }
        if {![info exists countertype]} {
              set countertype "c8"
           }
        if { [string tolower $sa] == [string tolower $da] } {
               set da "00DEBB000001"
           }
        switch $protocol_name {
            mac {
                if {$vlan_id !=0 && $vlan_id != "none"} {
                        puts "INSIDE VLAN_ID MAC PROC"
                        set stream_name "VLAN"
                        set vlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$protocolTagId$userPriority$cfi$vlan_id$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $vlan_stream
               } elseif {$frameType != "null" && $frameType != "0800"} { 
                        puts "INSIDE FRAMETYPE  MAC PROC"
                        set stream_name "MAC"
                        set mac_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $mac_stream 
               } elseif {$protocoloffset_enable == "true"} { 
                set stream_name "DoubleVLAN"
                    set qinq_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                    return $qinq_stream
               } else {
                        puts "INSIDE MAC PROC"
                        set stream_name "MAC"
                        set mac_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $mac_stream 
                       }
                }
                ip { 
                    if {$appName == "Arp" && $vlan_id !=0 && $vlan_id != "none"} {
                        set frameType "8100"
                            set protocol_name "0806"
                            set hw_type "0001"
                            set protocol_type "0800"
                            set hw_size "06"
                            set protocol_size "04"
                            set stream_name "ARPVLAN"
                            if {$operation == "arpRequest"} {
                                set operation "0001"
                            } else {
                                set operation "0002"
                            }
                        set arpvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destHardwareAddr$sourceHardwareAddr$frameType$userPriority$cfi$vlan_id$protocol_name$hw_type$protocol_type$hw_size$protocol_size$operation$sourceHardwareAddr@$sourceProtocolAddr@$destHardwareAddr@$destProtocolAddr@#$sourceHardwareAddrMode#$sourceHardwareAddrRepeatCount#$destHardwareAddrMode#$destHardwareAddrRepeatCount#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceProtocolAddrMode#$sourceProtocolAddrRepeatCount#$destProtocolAddrMode#$destProtocolAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $arpvlan_stream
                   } elseif {$appName == "Arp"} {
                            set frameType "0806"
                            set hw_type "0001"
                            set protocol_type "0800"
                            set hw_size "06"
                            set protocol_size "04"
                            set stream_name "ARPSTREAM"
                            if {$operation == "arpRequest"} {
                                set operation "0001"
                            } else {
                                set operation "0002"
                            }
                        set arpip_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destHardwareAddr$sourceHardwareAddr$frameType$hw_type$protocol_type$hw_size$protocol_size$operation$sourceHardwareAddr@$sourceProtocolAddr@$destHardwareAddr@$destProtocolAddr@#$destHardwareAddrMode#$destHardwareAddrRepeatCount#$sourceHardwareAddrMode#$sourceHardwareAddrRepeatCount#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceProtocolAddrMode#$sourceProtocolAddrRepeatCount#$destProtocolAddrMode#$destProtocolAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $arpip_stream
                   } elseif {$vlan_id !=0 && $vlan_id != "none" && $ipProtocol == "igmp"} {
                        set frameType "8100"
                        set ip_frameType "0800"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set protocol_name "02"
                        set igmp_checksum "0000"
                        set router_alert "94040000"
                        set stream_name "IGMPVLAN"
                        set igmpvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$igmp_type$maxResponseTime$igmp_checksum@$groupIpAddress@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $igmpvlan_stream
                } elseif {$ipProtocol == "igmp"} {
                    set frameType "0800"
                        set headerlength "45" 
                        set protocol_name "02"
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set igmp_checksum "0000"
                        set router_alert "94040000"
                        set stream_name "IGMP"
                        set ipigmp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$igmp_type$maxResponseTime$igmp_checksum@$groupIpAddress@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipigmp_stream
                   } elseif {$vlan_id !=0 && $vlan_id != "none" && $ipProtocol == "icmp"} {
                        set frameType "8100"
                        set ip_frameType "0800"
                        set headerlength "45" 
                        set dscp "e0"
                        set protocol_name "01"
                        set flags "4000"
                        set Checksum "0000"
                        set icmp_checksum "0000"
                        set stream_name "ICMPVLAN"
                        set icmpvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $icmpvlan_stream
                } elseif {$ipProtocol == "icmp"} {
                    set protocol_name "01"
                        set frameType "0800"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set icmp_checksum "0000"
                        set stream_name "ICMP"
                        set ipicmp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x $ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipicmp_stream
                  } elseif {$vlan_id !=0 && $vlan_id != "none" && $ipProtocol == "udp" && $appName == "Dhcp"} {
                    set frameType "8100"
                        set ip_frameType "0800"
                        set headerlength "45" 
                        set protocol_name "11"
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "0134" 
                        set hwType "01"
                        set hwlength "06"
                        set hops "00"
                        set flags "0000"
                        set udp_checksum "0000"
                        set opCode "01"
                        set reserved "00000000000000000000" 
                        set magic_cookie "63825363" 
                        set server_name "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                        set bootfile_name "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                        set stream_name "DHCPVLAN"
                        set dhcpvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$opCode$hwType$hwlength$hops$transactionID$seconds$dhcp_flags@$clientIpAddr@$yourIpAddr@$serverIpAddr@$relayAgentIpAddr@$clientHwAddr$reserved$server_name$bootfile_name$magic_cookie*$optionData*#$daRepeatCounter#$numDA#$saRepeatCounter#$vlan_mode#$vlan_repeat#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $dhcpvlan_stream
                } elseif {$ipProtocol == "udp" && $appName == "Dhcp"} {
                    set frameType "0800"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set protocol_name "11"
                        set length "0134" 
                        set hwlength "06"
                        set hops "00"
                        set flags "0000"
                        set opCode "01"
                        set udp_checksum "0000"
                        set stream_name "DHCP"
                        set reserved "00000000000000000000" 
                        set magic_cookie "63825363" 
                        set bootfile_name "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                        set server_name "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                        set ipdhcp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$opCode$hwType$hwlength$hops$transactionID$seconds$dhcp_flags@$clientIpAddr@$yourIpAddr@$serverIpAddr@$relayAgentIpAddr@$clientHwAddr$reserved$server_name$bootfile_name$magic_cookie*$optionData*#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipdhcp_stream
                  } elseif {$vlan_id !=0 && $vlan_id != "none" && $ipProtocol == "udp"} {
                    set frameType "8100"
                        set ip_frameType "0800"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set protocol_name "11"
                        set length "001a" 
                        set udp_checksum "0000"
                        set stream_name "UDPVLAN"
                        set udpvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $udpvlan_stream
                } elseif {$protocoloffset_enable == "true" && $ipProtocol == "udp"} {
                    set frameType "0800"
                        set protocol_name "11"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "001a" 
                        set udp_checksum "0000"
                        set stream_name "DoubleUDP"
                        set qinqudp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $qinqudp_stream
                } elseif {$ipProtocol == "udp"} {
                    set frameType "0800"
                        set protocol_name "11"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "001a" 
                        set udp_checksum "0000"
                        set stream_name "UDP"
                        set ipudp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipudp_stream
                  } elseif {$vlan_id !=0 && $vlan_id != "none" && $ipProtocol == "tcp"} {
                    set frameType "8100"
                        set ip_frameType "0800"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "50" 
                        set window_size "0fa0"
                        set protocol_name "06"
                        set tcp_checksum "0000"
                        set stream_name "TCPVLAN"
                        set tcp_flags "$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize"
                        set tcp_flags [bin2hex $tcp_flags]
                        set ack_num $sequenceNumber
                        set tcpvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ip_frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$tcp_flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                       return $tcpvlan_stream
                } elseif {$protocoloffset_enable == "true" && $ipProtocol == "tcp"} {
                    set frameType "0800"
                        set protocol_name "06"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "50" 
                        set window_size "0fa0"
                        set tcp_checksum "0000"
                        set tcp_flags "$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize"
                        set tcp_flags [bin2hex $tcp_flags]
                        set ack_num $sequenceNumber
                        set stream_name "DoubleTCP"
                        set qinqtcp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$tcp_flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $qinqtcp_stream
                } elseif {$ipProtocol == "tcp"} {
                        set frameType "0800"
                        set protocol_name "06"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "50" 
                        set window_size "0fa0"
                        set tcp_checksum "0000"
                        set tcp_flags "$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize"
                        set tcp_flags [bin2hex $tcp_flags]
                        set ack_num $sequenceNumber
                        set stream_name "TCP"
                        set iptcp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$tcp_flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $iptcp_stream
                } elseif {$vlan_id !=0 && $vlan_id != "none"} {
                            set headerlength "45" 
                            set dscp "e0"
                            set flags "4000"
                            set ipProtocol "04"
                            set frameType1 "8100"
                            set Checksum "0000"
                            set stream_name "IPVLAN"
                            set ipvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType1$userPriority$cfi$vlan_id$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$ipProtocol$Checksum@$sourceIpAddr@$destIpAddr@$options$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $ipvlan_stream
                } elseif {$protocoloffset_enable == "true"} {
                        set headerlength "45" 
                            set dscp "e0"
                            set flags "4000"
                            set Checksum "0000"
                            set protocol "04"
                            set stream_name "DoubleIP"
                            set qinqip_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$userDefinedTag$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol$Checksum@$sourceIpAddr@$destIpAddr@$options$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $qinqip_stream
                 } else {
                        set headerlength "45" 
                            set dscp "e0"
                            set flags "4000"
                            set Checksum "0000"
                            set protocol "04"
                            set stream_name "IP"
                            set ip_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x $identifier]$flags[format %02x $ttl]$protocol$Checksum@$sourceIpAddr@$destIpAddr@$options$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                            return $ip_stream
                    }
            }
            ipV6  {
                if {$vlan_id !=0 && $vlan_id != "none" &&  $nextHeader == "udp"} {
                    set frameType "8100"
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set nextHeader "11"
                        set payloadlength "0072"
                        set stream_name "UDPVLANv6"
                        set length "001a" 
                        set udp_checksum "0000"
                        set vlanipv6udp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destMacAddr$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $vlanipv6udp_stream
                } elseif {$nextHeader == "udp"} {
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set nextHeader "11"
                        set payloadlength "0072"
                        set stream_name "UDPv6"
                        set length "001a" 
                        set udp_checksum "0000"
                        set ipv6udp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$destMacAddr$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$length$udp_checksum#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipv6udp_stream
                } elseif {$vlan_id !=0 && $vlan_id != "none" && $nextHeader == "tcp"} {
                        set frameType "8100"
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set payloadlength "0072"
                        set nextHeader "06"
                        set length "50" 
                        set window_size "0fa0"
                        set tcp_checksum "0000"
                        set flags "$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize"
                        set flags [bin2hex $flags]
                        set ack_num $sequenceNumber
                        set stream_name "TCPVLANv6"
                        set vlanipv6tcp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $vlanipv6tcp_stream
                } elseif {$nextHeader == "tcp"} {
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set payloadlength "0072"
                        set nextHeader "06"
                        set length "50" 
                        set window_size "0fa0"
                        set tcp_checksum "0000"
                        set flags "$urgentPointerValid$pushFunctionValid$acknowledgeValid$resetConnection$finished$synchronize"
                        set flags [bin2hex $flags]
                        set ack_num $sequenceNumber
                        set stream_name "TCPv6"
                        set ipv6tcp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$sourcePort$destPort$sequenceNumber$ack_num$length$flags$window_size$tcp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipv6tcp_stream
                } elseif {$vlan_id !=0 && $vlan_id != "none" && $nextHeader == "icmpV6"} {
                        set frameType "8100"
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set payloadlength "0072"
                        set nextHeader "01"
                        set stream_name "ICMPVLANv6"
                        set icmp_checksum "0000"
                        set vlanipv6icmp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $vlanipv6icmp_stream
                } elseif {$nextHeader == "icmpV6"} {
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set payloadlength "0072"
                        set nextHeader "01"
                        set stream_name "ICMPVLANv6"
                        set icmp_checksum "0000"
                        set stream_name "ICMPv6"
                        set ipv6icmp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$type$code$icmp_checksum$id$sequence$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipv6icmp_stream
                } elseif {$vlan_id !=0 && $vlan_id != "none"} {
                        set frameType "8100"
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set payloadlength "0072"
                        set nextHeader "3b"
                        set stream_name "IPVLANv6"
                        set vlanipv6_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numS#$vlan_mode#$vlan_repeatA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $vlanipv6_stream
                } else {
                        set ipv6_frameType "86dd"
                        set version "60"
                        set Checksum "0000"
                        set payloadlength "0072"
                        set nextHeader "3b"
                        set stream_name "IPv6"
                        set ipv6_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$ipv6_frameType$version$trafficClass$flowLabel$payloadlength$nextHeader$hopLimit@$sourceAddr@$destAddr@$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceAddrMode#$sourceAddrRepeatCount#$destAddrMode#$destAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipv6_stream
            }
           }  
            ipx {
                if {$vlan_id !=0 && $vlan_id != "none"} {
                    set frameType "8100"
                        set ipx_frameType "8137"
                        set stream_name "IPXVLAN"
                        set ipx_checksum "0000"
                        set length "03ee"
                        set transport_control "00"
                        set packet_type "04"
                        set ipxvlan_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$userPriority$cfi$vlan_id$ipx_frameType$ipx_checksum$length$transport_control$packet_type@$destNetwork@$destNode$destSocket@$sourceNetwork@$sourceNode$sourceSocket$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$vlan_mode#$vlan_repeat#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipxvlan_stream
                } else {
                    set frameType "8137"
                        set stream_name "IPX"
                        set ipx_checksum "0000"
                        set length "03ee"
                        set transport_control "00"
                        set packet_type "04"
                        set ipx_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$ipx_checksum$length$transport_control$packet_type@$destNetwork@$destNode$destSocket@$sourceNetwork@$sourceNode$sourceSocket$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipx_stream
                }
            } 
            default {
                    set frameType "0800"
                        set protocol_name "11"
                        set headerlength "45" 
                        set dscp "e0"
                        set flags "4000"
                        set Checksum "0000"
                        set length "001a" 
                        set udp_checksum "0000"
                        set stream_name "UDP"
                        set ipudp_stream "$useValidChecksum#$tx_port#$stream_name#$direction#$dma#$numFrames#$da$sa$frameType$headerlength$dscp[format %04x 0x$totalLength][format %04x 0x$identifier]$flags[format %02x 0x$ttl]$protocol_name$Checksum@$sourceIpAddr@$destIpAddr@$sourceudpPort$destudpPort$length$udp_checksum$dataPattern#$daRepeatCounter#$numDA#$saRepeatCounter#$numSA#$frameSizeType#$framesize#$frameSizeMIN#$frameSizeMAX#$sourceIpAddrMode#$sourceIpAddrRepeatCount#$destIpAddrMode#$destIpAddrRepeatCount#$udf_enable#$offset#$countertype#$initval#$continuousCount#$rx_port"
                        return $ipudp_stream
            } 
        }
}
###################Stream construction ENDS HERE#########################################

