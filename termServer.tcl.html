<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>termServer.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#termServer.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>termServer.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="termServer.tcl-annot.html">annotations</a> | <a href="termServer.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">##################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># If you wish to add additional terminal servers check </span>
<span class="comment-line">#  </span>
<span class="comment-line">#   Add a login expect case</span>
<span class="comment-line">#   Add login support</span>
<span class="comment-line">#</span>
<span class="comment-line">#   Create a proc to handle: </span>
<span class="comment-line">#   - Verifying the tcp port to termserver port pulled from the cfg</span>
<span class="comment-line">#   - verifying port is in use</span>
<span class="comment-line">#   - Exit if not in use</span>
<span class="comment-line">#   - Clear console if in use</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: ClearConsoleDUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:</span>
<span class="comment-line">#   Clear the termserver console ports on a DUT</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#   Returns 1 on success and -1 on error</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     DUT    - DUT number or DUT ip address tcpport</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: 1 on success or -1 on failure</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">#    ClearConsoleDUT $dut</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ClearConsoleDUT_40">proc <a href="termServer.tcl-annot.html#::::ClearConsoleDUT">::::ClearConsoleDUT</a></a></strong><a name="::::ClearConsoleDUT"></a> {DUT {wait &#34;NO&#34;} {showError &#34;true&#34;} } {

    set time1 [clock seconds]
    global numDUT spawn_id whichDutNow

    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ClearConsoleDUT $DUT&#34;
    puts &#34;@@\n@@\n@@\nClearConsole DUT $whichDutNow\n@@\n@@\n@@&#34;
    if {[llength [split $DUT &#34;.&#34;]] &gt; 2} {
        set connList [split $DUT &#34; &#34;]
        set term [lindex $connList 0]
        set port [lindex $connList 1]
    } else {
        set firstSubStr &#34;DUT&#34;
        set lastSubStr &#34;_CONNECT&#34;
        global $firstSubStr$DUT$lastSubStr
        global $firstSubStr$DUT${lastSubStr}B ;<span class="comment-line">#global variable for msm-b</span>
        if [info exists $firstSubStr$DUT$lastSubStr] {
            puts &#34;DUT $DUT [set $firstSubStr$DUT$lastSubStr]&#34;
            set termList [split [set $firstSubStr$DUT$lastSubStr] &#34; &#34;]
            set term [lindex $termList 0]
            set port [lindex $termList 1]
            puts &#34;term = $term port = $port&#34;
        }
    }
    <span class="comment-line"># Find the cfg file no matter where you are</span>
    set myDir [pwd]
    puts &#34;PATH $myDir&#34;
    set myDirList [split $myDir &#34;/&#34;]
    set theDir &#34;&#34;
    set dCount 0
    while {$theDir != &#34;automation&#34; &amp;&amp; $dCount &lt; 7} {
       set theDir [lindex $myDirList $dCount]
       lappend newDirList $theDir
       incr dCount
    }
    set newPath [join $newDirList &#34;/&#34;]
   
    <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Source $newPath/main/cfg/termservers.cfg&#34; 
    if {[file exists $newPath/main/cfg/termservers.cfg]} {
        source $newPath/main/cfg/termservers.cfg
    } else {
        return -1
    }

    set ip $term
    set ports $port
    set pass1 &#34;&#34;
    set pass2 &#34;&#34;
    set username &#34;&#34;
    set usePass1 0

    ;<span class="comment-line"># Seperate out the passwords from the cfg/termservers.cfg file</span>
    <span class="comment-line">#    If they exist</span>
    if {[info exists termArray($term)]} {
        if {[llength $termArray($term)] == 3} {
            set pass1       [lindex $termArray($term) 0]
            set pass2       [lindex $termArray($term) 1]
            set username    [lindex $termArray($term) 2]
        } elseif {[llength $termArray($term)] == 2} {
            set pass1      [lindex $termArray($term) 0]
            set pass2       [lindex $termArray($term) 1]
        } else {
            <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Not enough elements in termArray($term)&#34;
        }
    } else {
        puts &#34;No static termserver info defined, Try defaults&#34;
        set pass1 &#34;DEFAULTS&#34;
    }

    <span class="comment-line"># Log in to the terminal server.  The termserver type is returned</span>
    <span class="comment-line">#   after the login occurs.  Once login is completed, the termserver</span>
    <span class="comment-line">#   should be sitting at an enabled prompt</span>
    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;_login_termserver $ip $pass1 $pass2 $username&#34;
    set returnCode [<a name="::::_login_termserver(1)"><a href="./termServer.tcl.html#::::_login_termserver_177">::::_login_termserver</a></a> $ip &#34;$pass1&#34; &#34;$pass2&#34; &#34;$username&#34;]
    if {$returnCode==&#34;error&#34;} {
        puts &#34;Unable to connect to termserver at $ip...&#34;
        return -1
    }
    <span class="comment-line"># Based on the termserver type returned above, call the appropriate</span>
    <span class="comment-line">#   Termserver clear procedure</span>
    switch -- $returnCode \
      &#34;cisco&#34; {
        <a name="::::_clear_cisco_terms(1)"><a href="./termServer.tcl.html#::::_clear_cisco_terms_472">::::_clear_cisco_terms</a></a> $ports
        if {$wait == &#34;YES&#34;} {
            <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5  ;<span class="comment-line"># For PC platform in worst scenario with fsck</span>
        }
    } &#34;lantronix&#34; {
        <a name="::::_clear_lantronix_terms(1)"><a href="./termServer.tcl.html#::::_clear_lantronix_terms_641">::::_clear_lantronix_terms</a></a> $ports
        if {$wait == &#34;YES&#34;} {
            <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5  ;<span class="comment-line"># For PC platform in worst scenario with fsck</span>
        }
    } &#34;mrv&#34; {
        <a name="::::_clear_MRV_terms(1)"><a href="./termServer.tcl.html#::::_clear_MRV_terms_773">::::_clear_MRV_terms</a></a> $ports
        if {$wait == &#34;YES&#34;} {
            <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5  ;<span class="comment-line"># For PC platform in worst scenario with fsck</span>
        }
    } &#34;xyplex&#34; {
        <a name="::::_clear_xyplex_terms(1)"><a href="./termServer.tcl.html#::::_clear_xyplex_terms_901">::::_clear_xyplex_terms</a></a> $ports
        if {$wait == &#34;YES&#34;} {
            <a name="::exSleep(4)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5  ;<span class="comment-line"># For PC platform in worst scenario with fsck</span>
        }
    } &#34;ser2net&#34; {
        _clear_ser2net_terms $ports
        if {$wait == &#34;YES&#34;} {
            <a name="::exSleep(5)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5  ;<span class="comment-line"># For PC platform in worst scenario with fsck</span>
        }
    } &#34;default&#34; {
        <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No termserver identified&#34;
    }
    <span class="comment-line">## Add code to verify that the console is in fact cleared.</span>

    set time2 [clock seconds]
    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;*** Time for clear terms on $DUT = [expr $time2-$time1] secs\n\n&#34;
    return 1
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _login_termserver</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#   Internal proc that is used to login to termservers</span>
<span class="comment-line">#   returns error or ok</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     ipAddr - Ip address of the power cycle device used to login</span>
<span class="comment-line">#     pass1  - first level password</span>
<span class="comment-line">#     pass2  - second level password (enable password usually)</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: cisco|xyplex|inreach or error on failure</span>
<span class="comment-line">#              </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#</span>
<span class="comment-line">#    set returnCode [_login_termserver $ipAddr lab lab]</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_login_termserver_177">proc <a href="termServer.tcl-annot.html#::::_login_termserver">::::_login_termserver</a></a></strong><a name="::::_login_termserver"></a> {ipAddr pass1  pass2 username {numRetry 5}  {backOffTime 10}} {
    global timeout
    global numDUT
    global spawn_id

    <span class="comment-line"># initialize the variable as successful, set to 0 on bad attempts</span>
    set connectStatus 1

    <span class="comment-line"># Save the expect timeout in case the global is different</span>
    set init_timeout $timeout

    ;<span class="comment-line"># We try several times to spawn telnet because only 1 telnet session is allowed</span>
    ;<span class="comment-line"># per termserver.  In the event there is already one connected, we backOff then</span>
    ;<span class="comment-line"># retry.  </span>
    set numRetry 3 
    for {set i 0}  {$i &lt; $numRetry} {incr i} {
        <span class="comment-line"># open the telnet session to the device</span>
        if [catch &#34;spawn telnet $ipAddr&#34; reason] {
            <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;failed to spawn program: $reason\n&#34;
            error &#34;failed to spawn program: $reason\n&#34;
            return &#34;error&#34;
        }
        set timeout 5
        <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Login telnet $ipAddr,  pid=$spawn_id&#34;
        <span class="comment-line"># After the session is spawned check for bad as well</span>
        <span class="comment-line">#   as successful scenerios</span>
        send &#34;\r&#34;	
        expect {
            &#34;?nable to ?onnect&#34; {
                expect *
                <a name="::result_warning(1)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Unable to connect&#34;		
                return error
            }
            &#34;closed by foreign host&#34; {
                <a name="::result_warning(2)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Connection closed by foreign host&#34;
                return error
            }
            &#34;Connection refused&#34; {
                <a name="::result_warning(3)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;Connection refused&#34;
                return error
            }
            &#34;assword: &#34; {
                <span class="comment-line"># This prompt is a cisco prompt with a first level pass required</span>
                if {$pass1 == &#34;DEFAULTS&#34;} {
                    send &#34;lab\r&#34;
                    expect &#34;&gt;&#34;
                    send &#34;enable\r&#34;
                    expect &#34;assword: &#34;
                    send &#34;extreme\r&#34;
                    expect {
                        &#34;#&#34; {
                            set timeout $init_timeout
                            return cisco
                        }
                        &#34;assword: &#34; {
                            send &#34;lab\r&#34;
                            expect {
                                &#34;#&#34; {
                                    set timeout $init_timeout
                                    return cisco
                                }
                                timeout {
                                    set timeout $init_timeout
                                    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;CISCO Default login did not work: update cfg/termservers.cfg&#34;
                                    return error
                                }
                            }
                        }
                    }
                } else {
                    send &#34;$pass1\r&#34;
                    expect &#34;&gt;&#34;
                    send &#34;enable\r&#34;
                    expect &#34;assword: &#34;
                    send &#34;$pass2\r&#34;
                    expect &#34;#&#34;
                    <span class="comment-line"># reset the expect timeout before exiting</span>
                    set timeout $init_timeout
                    <span class="comment-line"># return from the proc setting the value to cisco</span>
                    return &#34;cisco&#34;
                }
            }
            &#34;assword : &#34; {
                <span class="comment-line"># This prompt is a lantronix prompt with a first level pass required</span>
                <span class="comment-line">#   skip defaults for lantronix</span>
                puts &#34;This matched a Lantronix&#34;
                if {$pass1 == &#34;DEFAULTS&#34;} {
                    send &#34;extreme\r&#34;
                    expect &#34;&gt; &#34;
                    send &#34;enable\r&#34;
                    expect &#34;assword : &#34;
                    send &#34;extreme\r&#34;
                    expect {
                        &#34;#&#34; {
                            set timeout $init_timeout
                            return lantronix
                        }
                        &#34;assword : &#34; {
                            send &#34;\r&#34;
                            expect {
                                &#34;#&#34; {
                                    set timeout $init_timeout
                                    return lantronix
                            }
                            timeout {
                                    set timeout $init_timeout
                                    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;LANTRONIX Default login did not work: \
                                                     update cfg/termservers.cfg&#34;
                                    return error
                                }
                            }
                        }
                    }
                } else {
puts &#34;not defaults&#34;
                    send &#34;$pass1\r&#34;
                    expect &#34;&gt; &#34;
                    send &#34;enable\r&#34;
                    expect &#34;assword : &#34;
                    send &#34;$pass2\r&#34;
                    expect &#34;# &#34;
                    <span class="comment-line"># reset the expect timeout before exiting</span>
                    set timeout $init_timeout
                    <span class="comment-line"># return from the proc setting the value to cisco</span>
                    return &#34;lantronix&#34;
                }
            }
            &#34;&gt;&#34; {
                <span class="comment-line"># This prompt is a cisco prompt with a first level pass required</span>
                if {$pass1 == &#34;DEFAULTS&#34;} {
                    send &#34;enable\r&#34;
                    expect {
                        &#34;assword: &#34; {
                            send &#34;extreme\r&#34;
                            expect {
                                &#34;#&#34; {
                                    set timeout $init_timeout
                                    return cisco
                                }
                                &#34;assword: &#34; {
                                    send &#34;lab\r&#34;
                                    expect {
                                        &#34;#&#34; {
                                            set timeout $init_timeout
                                            return cisco
                                        }
                                        timeout {
                                            <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MRV Default login did not work: update cfg/termservers.cfg&#34;
                                            return error
                                        }
                                    }
                                }
                                -re &#34;.*denied*&#34; {
                                    send &#34;enable\r&#34;
                                    expect {
                                        &#34;assword: &#34; {
                                            send &#34;lab\r&#34;
                                            expect {
                                                &#34;#&#34; {
                                                    set timeout $init_timeout
                                                    return cisco
                                                }
                                                timeout {
                                                    set timeout $init_timeout
                                                    <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MRV Default login did not work: update cfg/termservers.cfg&#34;
                                                    return error
                                                }
                                            }
                                         }
                                         timeout {
                                             <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MRV Default login did not work: update cfg/termservers.cfg&#34;
                                             return error
                                         }
                                    }
                                }
                            }
                        }
                        &#34;In-Reach&gt; &#34; {
                            <span class="comment-line"># new inreach/xyplex</span>
                            send &#34;set priv\r&#34;;
                            expect &#34;assword&gt; &#34;;
                            send &#34;system\r&#34;
                            set timeout $init_timeout
                            return xyplex
                        }
                        &#34;(enable)#&#34; {
                            set timeout $init_timeout
                            return lantronix
                        }
                    }
                } else {
                    send &#34;$pass1\r&#34;
                    expect &#34;&gt;&#34;
                    send &#34;enable\r&#34;
                    expect &#34;assword: &#34;
                    send &#34;$pass2\r&#34;
                    expect &#34;#&#34;
                    <span class="comment-line"># reset the expect timeout before exiting</span>
                    set timeout $init_timeout
                    <span class="comment-line"># return from the proc setting the value to cisco</span>
                    return &#34;cisco&#34;
                }
            }
            &#34;ogin: &#34; {
                if {$pass1 == &#34;DEFAULTS&#34;} {
                    send &#34;InReach\r&#34;
                    expect -re &#34;Password*&#34;
                    send &#34;access\r&#34;
                    expect -re &#34;&gt;&#34;
                    send &#34;enable\n&#34;
                    expect &#34;assword:&#34;
                    send &#34;extreme\n&#34;
                    expect {
                        &#34;&gt;&gt;&#34; {
                            set timeout $init_timeout
                            return &#34;mrv&#34;
                        }
                        -re &#34;assword:&#34; {
                            send &#34;system\r&#34;
                            expect {
                                &#34;&gt;&gt;&#34; {
                                    set timeout $init_timeout
                                    return &#34;mrv&#34;
                                }
                                timeout {
                                    <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MRV Default login did not work: update cfg/termservers.cfg&#34;
                                    return error
                                }
                            }
                        }
                        -re &#34;failed&#34; {
                            send &#34;system\r&#34;
                            expect {
                                &#34;&gt;&gt;&#34; {
                                    set timeout $init_timeout
                                    return &#34;mrv&#34;
                                }
                                timeout {
                                    <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;MRV Default login did not work: update cfg/termservers.cfg&#34;
                                    return error
                                }
                            }
                        }
                    }
                } else {
                    send &#34;$username\r&#34;
                    expect -re &#34;Password*&#34;
                    send &#34;$pass1\r&#34;
                    expect -re &#34;&gt;&#34;
                    send &#34;enable\n&#34;
                    expect &#34;assword:&#34;
                    send &#34;$pass2\n&#34;
                    expect &#34;&gt;&gt;&#34;
                    return &#34;mrv&#34;
                }
            }
            timeout {
                <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit timeout after $timeout sec&#34;
                return error
                <span class="comment-line">#send &#34;\r&#34;</span>
            }
        }
        <span class="comment-line"># In the case that there </span>
        if {$connectStatus == 0} {
            <a name="::result_warning(4)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;($i) Failed to spawn telnet to powerCycler: $reason...\
                retrying after $backOffTime secs\n&#34;
            <span class="comment-line"># Time to wait before another attempt to connect to the termserver</span>
            <a name="::exSleep(6)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $backOffTime
        }
    }

    puts &#34;After $numRetry attempts, we failed to connect to \
        Terminal Server at $ip: $reason\n&#34;
    return &#34;error&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _clear_cisco_terms</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     units   - ports to be cleared on the cisco term server</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line">#              </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#</span>
<span class="comment-line">#    _clear_cisco_terms $destinationPort</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_clear_cisco_terms_472">proc <a href="termServer.tcl-annot.html#::::_clear_cisco_terms">::::_clear_cisco_terms</a></a></strong><a name="::::_clear_cisco_terms"></a> { units } {
    set result 0
    set done 0
    global expect_out spawn_id timeout

    set units [string trim $units]
    <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found TCP Port $units to clear on cisco&#34;
    set init_timeout $timeout
    <span class="comment-line"># Get the local port from the TCP port</span>
    if {[regexp -nocase &#34;2(1\[0-9]\[0-9])&#34; $units m m1]} {
        <span class="comment-line">#set units [string trimleft $units 2]</span>
        set units $m1
        <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 21xx $units&#34;
    } elseif {[regexp -nocase &#34;200(\[0-9])&#34; $units m m1]} {
        <span class="comment-line">#set units [string trimleft $units 200]</span>
        set units $m1
        <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 200x $units&#34;
    } elseif {[regexp -nocase &#34;20(\[0-9]\[0-9])&#34; $units m m1]} {
        <span class="comment-line">#set units [string trimleft $units 20]</span>
        set units $m1
        <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 20xx $units&#34;
    }
    <a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found port $units to clear on cisco&#34;
    <span class="comment-line"># Get the local port from the TCP port</span>

    <span class="comment-line"># Initialize the used variable assuming the the port is hung or in use</span>
    set used 1
    set unitString $units

    <span class="comment-line"># Check to see if the connection is in use</span>
    set fC 1
    set loopCount 1
    set hitMore 0
    while {$loopCount &lt; 3} {
        puts &#34;Checking Cisco&#34;
        send &#34;show line $unitString\r&#34;; <span class="comment-line">#Status: Ready, Connected, Active</span>
        expect {
            &#34; --More-- &#34; {
                <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;HIT MORE&#34;
                set hitMore 1
                if {[regexp -nocase &#34;Connected, Active&#34; $expect_out(buffer)] || \
                    [regexp -nocase &#34;1.*in use&#34; $expect_out(buffer)] } {
                    <a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and found the used case&#34;
                    set used 1
                } else {
                    <a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and DID NOT find the used case&#34;
                    if {!$hitMore} {
                        set used 0
                    }
                }
                exp_send &#34; \r&#34;
                exp_continue;
            }
            -re &#34;More&#34; {
                <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;HIT MORE 2&#34;
                set hitMore 1
                if {[regexp -nocase &#34;Connected, Active&#34; $expect_out(buffer)] || \
                    [regexp -nocase &#34;1.*in use&#34; $expect_out(buffer)] } {
                    <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and found the used case&#34;
                    set used 1
                } else {
                    <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and DID NOT find the used case&#34;
                    if {!$hitMore} {
                        set used 0
                    }
                }
                exp_send &#34; \r&#34;
                exp_continue
            }
            &#34;#&#34; {
                if {[regexp -nocase &#34;Connected, Active&#34; $expect_out(buffer)] || \
                    [regexp -nocase &#34;1.*in use&#34; $expect_out(buffer)] } {
                    <a name="::result_debug(27)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and found the used case&#34;
                    set used 1
                } else {
                    <a name="::result_debug(28)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and DID NOT find the used case&#34;
                    if {!$hitMore} {
                        set used 0
                    }
                }
             }
             timeout {
                 <a name="::result_debug(29)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timed out on  output for show line $unitString&#34;
                 if {$fC &lt;= 3} {
                    <a name="::result_debug(30)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Send Again&#34;
                    send &#34;show line $unitString\r&#34;
                    incr fC
                    exp_continue
                 }
                 exp_close
                 wait
                 <a name="::exSleep(7)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                 set result 1
                 set done 1
                 set timeout $init_timeout
                 return &#34;error&#34;
            }
        }
        if {!$used} {
            <a name="::result_debug(31)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The port is not in used - NO NEED TO CLEAR Console - Close Cisco session!&#34;
            exp_close
            wait
            <a name="::exSleep(8)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
            set result 1
            set done 1
            set timeout $init_timeout
            return;
        }
        exp_send &#34;\r&#34;
        puts &#34;\nClearing Consoles on Cisco #$units  Expect timeout = $timeout\n&#34;
        <a name="::exSleep(9)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
        expect {
            &#34;#&#34; {
                <a name="::result_debug(32)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] Clearing line $unitString on Cisco&#34;
                exp_send &#34;clear line $unitString\r&#34;
            }
            &#34;# &#34;  {
                <a name="::result_debug(33)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] +++&#34;
                <a name="::exSleep(10)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
                exp_send &#34;clear line $unitString\r&#34;
            }
            timeout {
                puts &#34;ERROR: All of your expect conditions are wrong dummy&#34;
            }
        }
        expect {
            -re &#34;.*?&#34; {
                <a name="::result_debug(34)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Matched on question mark&#34;
                <a name="::exSleep(11)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
                send &#34;y\r&#34;
                expect &#34;#&#34;
            }
            &#34;confirm&#34; {
                <a name="::result_debug(35)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Matched on question mark&#34;
                send &#34;y\r&#34;
                expect &#34;#&#34;
            }
            timeout {
                <a name="::result_debug(36)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;!!!!!!! ERROR: Did not get the expected confirmation&#34;
            }
        }
        incr loopCount
    }
    exp_close
    wait
    <a name="::exSleep(12)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
    set result 1
    set done 1
    set timeout $init_timeout
}  
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: _clear_lantronix_terms</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     units   - port numbers on lantronix to be cleared</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">#    _clear_cisco_terms $destinationPort</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_clear_lantronix_terms_641">proc <a href="termServer.tcl-annot.html#::::_clear_lantronix_terms">::::_clear_lantronix_terms</a></a></strong><a name="::::_clear_lantronix_terms"></a> { units } {
    set result 0
    set done 0
    global expect_out spawn_id timeout

    set units [string trim $units]
    <a name="::result_debug(37)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;LANTRONIX Found TCP Port $units to clear&#34;
    set init_timeout $timeout
    <span class="comment-line"># Get the local port from the TCP port</span>
    if {[regexp -nocase &#34;1000(\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(38)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 1000x $units&#34;
    } elseif {[regexp -nocase &#34;100(\[0-9]\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(39)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 100xx $units&#34;
    } elseif {[regexp -nocase &#34;2(1\[0-9]\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(40)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 21xx $units&#34;
    } elseif {[regexp -nocase &#34;200(\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(41)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 200x $units&#34;
    } elseif {[regexp -nocase &#34;20(\[0-9]\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(42)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 20xx $units&#34;
    }
    <a name="::result_debug(43)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found port $units to clear on Lantronix&#34;
    <span class="comment-line"># Get the local port from the TCP port</span>

    <span class="comment-line"># Initialize the used variable assuming the the port is hung or in use</span>
    set used 1
    set unitString $units

    <span class="comment-line"># Check to see if the connection is in use</span>
    set fC 1
    set loopCount 1
        send &#34;tunnel $unitString\r&#34;; <span class="comment-line">#Status: Ready, Connected, Active</span>
        expect &#34;#&#34;
        send &#34;accept\r&#34;
        expect &#34;#&#34;
        after 1000
        send &#34;show status\r&#34;
        expect &#34;#&#34;
        send &#34;show status\r&#34;
        expect {
            &#34;#&#34; {
                if {[regexp -nocase &#34;State.*Active&#34; $expect_out(buffer)]} {
                    <a name="::result_debug(44)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit # and found the used case&#34;
                    set used 1
                } else {
                    <a name="::result_debug(45)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NOT IN USE&#34;
                    set used 0
                }
             }
             timeout {
                 <a name="::result_debug(46)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timed out on  output for show line $unitString&#34;
                 exp_close
                 wait
                 <a name="::exSleep(13)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                 set result 1
                 set done 1
                 set timeout $init_timeout
                 return &#34;error&#34;
            }
        }
        if {!$used} {
            <a name="::result_debug(47)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NO NEED TO CLEAR Console - Close Lantronix session!&#34;
            exp_close
            wait
            <a name="::exSleep(14)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
            set result 1
            set done 1
            set timeout $init_timeout
            return;
        }
        exp_send &#34;\r&#34;
        puts &#34;\nClearing Consoles on Lantronix #$units  Expect timeout = $timeout\n&#34;
        expect {
            &#34;#&#34; {
                <a name="::result_debug(48)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] Clearing line $unitString on Cisco&#34;
                exp_send &#34;kill connection\r&#34;
                expect &#34;#&#34;
                exp_close
                wait
                <a name="::exSleep(15)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                set result 1
                set done 1
                set timeout $init_timeout
                return;
            }
            &#34;# &#34;  {
                <a name="::result_debug(49)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] +++&#34;
                <a name="::exSleep(16)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
                exp_send &#34;kill connection\r&#34;
                expect &#34;#&#34;
                exp_close
                wait
                <a name="::exSleep(17)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                set result 1
                set done 1
                set timeout $init_timeout
                return;
            }
            timeout {
                puts &#34;ERROR: All of your expect conditions are wrong dummy&#34;
            }
        }
    exp_close
    wait
    <a name="::exSleep(18)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
    set result 1
    set done 1
    set timeout $init_timeout
} 
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _clear_MRV_terms</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     units   - port numbers on wti to be power cycled</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line">#              </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#</span>
<span class="comment-line">#    _clear_MRV_terms $destinationPort</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_clear_MRV_terms_773">proc <a href="termServer.tcl-annot.html#::::_clear_MRV_terms">::::_clear_MRV_terms</a></a></strong><a name="::::_clear_MRV_terms"></a> { units } {
    set result 0
    set done 0
    global expect_out spawn_id timeout

    set timeout 10
    set init_timeout $timeout
    <span class="comment-line"># Get the local port from the TCP port</span>
    send &#34;\r&#34;
    expect &#34;&gt;&gt;&#34;
    set my_buffer &#34;&#34;
    send &#34;show port async summary\r&#34;
    expect {
        &#34;&gt;&gt;&#34; {
            append my_buffer $expect_out(buffer)
            if {[regexp -nocase &#34;(\[0-9]+) *Port_\[0-9]+ *Remote *9600 *$units *\[0-9]+&#34; $my_buffer dummy1 dummy2]} {
                <a name="::result_debug(50)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found the real port number: $dummy2&#34;
                set units [string trim $dummy2]
            } elseif {[regexp -nocase &#34;(\[0-9]+) *Port_\[0-9]+ *Remote *115200 *$units *\[0-9]+&#34; $my_buffer dummy1 dummy2]} {
                <a name="::result_debug(51)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found the real port number: $dummy2&#34;
                set units [string trim $dummy2]
            } else {
                <a name="::result_debug(52)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Can't find real port number&#34;
                exp_close
                wait
                <a name="::exSleep(19)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                return error
            }
        }
        &#34;quit&#34; {
            append my_buffer $expect_out(buffer)
            exp_send &#34;\r&#34;
            exp_continue;
        }
        timeout {
             <a name="::result_debug(53)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Can't find real port number&#34;
             return &#34;Error&#34;
        }
    }
    puts &#34;PORT Value&#34;
    <span class="comment-line"># Initialize the used variable assuming the the port is hung or in use</span>
    set used 1
    set unitString $units

    <span class="comment-line"># Check to see if the connection is in use</span>
    set loopCount 1
    while {$loopCount &lt; 4} {
        send &#34;show port async $unitString status\r&#34;; <span class="comment-line">#63: u</span>
        expect {
            &#34;&gt;&gt;&#34; {
                if {[regexp -nocase &#34;Port.*In Use&#34; $expect_out(buffer)]} {
                    <a name="::result_debug(54)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit &gt;&gt; and Port $unitString is currently In Use&#34;
                    set used 1
                } else {
                    <a name="::result_debug(55)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit &gt;&gt; and DID NOT find the used case&#34;
                    set used 0
                }
            }
            timeout {
                <a name="::result_debug(56)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timed out  on show line $unitString&#34;
                return &#34;Error&#34;
            }
        }
        if {!$used} {
            <a name="::result_debug(57)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The port is not in used - NO NEED TO CLEAR!&#34;
            exp_close
            wait
            <a name="::exSleep(20)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
            set result 1
            set done 1
            set timeout $init_timeout
            return;
        }
        exp_send &#34;\r&#34;
        puts &#34;\nClearing Consoles on MRV #$units  Expect timeout = $timeout\n&#34;
        <a name="::exSleep(21)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
        expect {
            &#34;&gt;&gt; &#34; {
                <a name="::result_debug(58)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] Clearing line $unitString on MRV &gt;&gt;space&#34;
                exp_send &#34;logout port $unitString\r&#34;
            }
            &#34;&gt;&gt;&#34;  {
                <a name="::result_debug(59)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] Clearing line $unitString on MRV&#34;
                <a name="::exSleep(22)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
                exp_send &#34;logout port $unitString\r&#34;
            }
            timeout {
                puts &#34;ERROR: All of your expect conditions are wrong dummy&#34;
            }
        }
        expect {
            &#34;&gt;&gt;&#34; {
                <a name="::result_debug(60)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port $unitString Cleared&#34;
                send &#34;\r&#34;
                expect &#34;&gt;&gt;&#34;
            }
            timeout {
                <a name="::result_debug(61)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;!!!!!!! ERROR: Did not get the expected confirmation&#34;
            }
        }
        incr loopCount
    }
    exp_close
    wait
    <a name="::exSleep(23)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
    set result 1
    set done 1
    set timeout $init_timeout
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _clear_xyplex_terms</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#     units   - port numbers on wti to be power cycled</span>
<span class="comment-line">#                </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Return value: none</span>
<span class="comment-line">#              </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage: </span>
<span class="comment-line">#</span>
<span class="comment-line">#    _clear_xyplex_terms $destinationPort</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_clear_xyplex_terms_901">proc <a href="termServer.tcl-annot.html#::::_clear_xyplex_terms">::::_clear_xyplex_terms</a></a></strong><a name="::::_clear_xyplex_terms"></a> { units } {
    set result 0
    set done 0
    global expect_out spawn_id timeout

    set timeout 5
    set init_timeout $timeout
    <span class="comment-line"># Get the local port from the TCP port</span>
    set units [string trim $units]
    <a name="::result_debug(62)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Xyplex Found TCP Port $units to clear&#34;
    set init_timeout $timeout
    <span class="comment-line"># Get the local port from the TCP port</span>
    if {[regexp -nocase &#34;1000(\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(63)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 1000x $units&#34;
    } elseif {[regexp -nocase &#34;100(\[0-9]\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(64)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 100xx $units&#34;
    } elseif {[regexp -nocase &#34;2(1\[0-9]\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(65)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 21xx $units&#34;
    } elseif {[regexp -nocase &#34;200(\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(66)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 200x $units&#34;
    } elseif {[regexp -nocase &#34;20(\[0-9]\[0-9])&#34; $units m m1]} {
        set units $m1
        <a name="::result_debug(67)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;match 20xx $units&#34;
    }

    send &#34;\r&#34;
    expect &#34;Priv&gt; &#34;
    <span class="comment-line"># Check to see if the connection is in use</span>
    set loopCount 1
    while {$loopCount &lt; 2} {
        send &#34;show port $units status\r&#34;; <span class="comment-line">#63: u</span>
        expect {
            &#34;Priv&gt; &#34; {
                if {[regexp -nocase &#34;Connected&#34; $expect_out(buffer)]} {
                    <a name="::result_debug(68)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit Connected and Port $units is currently In Use&#34;
                    set used 1
                } else {
                    <a name="::result_debug(69)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit &gt;&gt; and DID NOT find the used case&#34;
                    set used 0
                }
            }
            timeout {
                <a name="::result_debug(70)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Timed out  on show line $unit&#34;
                return &#34;Error&#34;
            }
        }
        set used 1
        if {!$used} {
            <a name="::result_debug(71)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;The port is not in used - NO NEED TO CLEAR!&#34;
            exp_close
            wait
            <a name="::exSleep(24)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
            set result 1
            set done 1
            set timeout $init_timeout
            return;
        }
        exp_send &#34;\r&#34;
        puts &#34;\nClearing Consoles on Xyplex #$units  Expect timeout = $timeout\n&#34;
        <a name="::exSleep(25)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
        expect {
            &#34;Priv&gt; &#34; {
                <a name="::result_debug(72)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] Clearing line $units on Xyplex &gt;&gt;space&#34;
                exp_send &#34;disconnect port $units session all\r&#34;
            }
            &#34;Priv&gt;&#34;  {
                <a name="::result_debug(73)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;+++ [timestamp -format %T] Clearing line $units on Xyplex2&#34;
                <a name="::exSleep(26)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 1
                exp_send &#34;disconnect port $units session all\r&#34;
            }
            timeout {
                puts &#34;ERROR: All of your expect conditions are wrong dummy&#34;
            }
        }
        expect {
            &#34;Priv&gt; &#34; {
                <a name="::result_debug(74)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port $units Cleared&#34;
                send &#34;\r&#34;
                expect &#34;priv&gt;&#34;
            }
            timeout {
                <a name="::result_debug(75)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;!!!!!!! ERROR: Did not get the expected confirmation&#34;
            }
        }
        incr loopCount
    }
    exp_close
    wait
    <a name="::exSleep(27)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
    set result 1
    set done 1
    set timeout $init_timeout
}

</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
