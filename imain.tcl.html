<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>imain.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#imain.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>imain.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="imain.tcl-annot.html">annotations</a> | <a href="imain.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#!/usr/bin/tclsh</span>

source ../Lib/parse_args.tcl
source ../Lib/mainLib.tcl
<span class="comment-line">#source ../Lib/mysqlLib.tcl</span>
source ../Lib/filetools.tcl
source ../Lib/menu.tcl
source ../Lib/iMainLib.tcl
source ../Lib/stc.tcl
source ../Util/iTest.cfg

package require http 1.0;
package require Tclx

<span class="comment-line"># Global Variables</span>
global ezinfofile env
global initsend mySock
global TrafficGen
global MAIN_LOG; <span class="comment-line"># main_log.txt file descriptor</span>
global currentTestNumber
global NEWBUILD
global OLDBUILD
global efence
global subversion
global enableSaveConfigPerTest
global enableAbortTestCondition
global gHeapTracingProcess
global heapTraceEnabled
global DEBUGFAILLOCK
global modName regPath showErrorData configurationFile
global DUTs_info tStartDateString
global bcmLynx CTLIST
global lynxIncludeModList regressionModules
global HEADERFORMAT;<span class="comment-line"># the formatting for headers and notifications</span>
global MAIN;<span class="comment-line"># single dem array of important main.tcl stateful info</span>
global FEATMAIN;<span class="comment-line"># 2 dem array of important feature stateful info</span>
global FEATPLAT;<span class="comment-line"># Feature support per test bed using a dut list and sysType list. in ct.lst</span>
<span class="comment-line"># ----- Test variables setup</span>
set TestsRemaining &#34;&#34;
set testNo &#34;imain&#34;
set clitestDir &#34;cli-ew&#34;
set skipCount 0
set _VERSION 6.0 ;<span class="comment-line"># define here as global variable.  Will change later</span>
set VERSION 6    ;<span class="comment-line"># define here as global variable.  Will change later</span>
set returnFlag &#34;NULL&#34;
set runMode    0
set MAIN(ifPipe)   &#34;NULL&#34;
set MAIN(initFile) &#34;NULL&#34;
set MAIN(startexecution) 0
set retFlag &#34;&#34;
set licenseList {l2edge edge advancededge core advancedcore mpls}
set debugLevel 0
set currentTestNumber main
set DEBUGFAILLOCK 0
set powerCyclerRetry 0
<span class="comment-line">#       Report variables</span>
set MAIN(timeFile) &#34;NULL&#34;
set MAIN(tSetupDuration) 0;
set MAIN(tCheckConnectionDuration) 0;
set MAIN(testDuration) 0;
set FEATPLAT(SupportedTypes) &#34;&#34;;<span class="comment-line"># Ex VXLAN ct.lst = [list &#34;$bcmx690|$bcmx870|$bcmx770|$bcmx670_G2&#34; &#34;$bcmxG2&#34;]</span>
set FEATPLAT(SupportedDUTs) &#34;&#34;; <span class="comment-line">#                 = [list &#34;1 2 3&#34;  &#34;4 5&#34;]</span>
set FEATPLAT(NoSupportTypes) &#34;&#34;; <span class="comment-line"># 03-2017 not coded yet</span>
set FEATPLAT(NoSupportDuts) &#34;&#34;;<span class="comment-line"># 03-2017 not coded yet</span>
set CTLIST(quick) &#34;&#34;;<span class="comment-line"># check common.cfg for all mixes quick_pass, quick_pass_all etc. Lib/tests_to_exec.tcl</span>
set tSetupDuration 0;
set tCheckConnectionDuration 0;
set testDuration 0;
set tStartTime [clock seconds]
set tStartDate [clock format [clock seconds] -format &#34;%Y-%m-%d %I.%M.%S%p&#34;]
set tStartDateString [clock format [clock seconds] -format &#34;%Y-%m-%d_%I.%M.%S%p&#34;]
set passCount 0
set failCount 0
set skipCount 0
set testDuration 0
set testHour 0
set testMin 0
set testSec 0
<span class="comment-line">#       Report directory structure variables</span>
<span class="comment-line">#  Note - resultDir name = &#34;timestamp $randomIndex&#34;</span>
set resultDir &#34;NULL&#34;;<span class="comment-line"># NULL forces creation of a new resultDir (also global resultDir)</span>
set MAIN(RESULTPATH) &#34;Result&#34;
set MAIN(RESULTDIR) &#34;null&#34;;<span class="comment-line"># all script results file will be posted here while running</span>
set MAIN(REPORTDIR) &#34;null&#34;;<span class="comment-line"># ResultDir is renamed to this at the very end.</span>
set optionalPath &#34;&#34;;<span class="comment-line"># optional location for the Report directory</span>
set optionalFlag &#34;null&#34;;<span class="comment-line"># used for cliFlag by default.</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<span class="comment-line"># The help output on invalid or too few args</span>
<span class="comment-line"># ---------------------------------------------------------------------------------------</span>
<strong><a name="::::print_usage_90">proc <a href="imain.tcl-annot.html#::::print_usage">::::print_usage</a></a></strong> {} {
    puts &#34;\r&#34;
    puts {Usage: main.tcl -mode &lt;mode&gt; -module &lt;module&gt; -cfg &lt;config file&gt; \n \
    [-lst &lt;test list&gt;|-tcList] [-regPath &lt;regression Path&gt;] [-testlinkplan &lt;testlinkplan&gt;] \n \
    [-build &lt;xos build1&gt;] [-subversion &lt;subversion&gt;] [-obuild &lt;xos build2&gt;] [-cliFlag &lt;cliFlag&gt;]\n \
    [-moduleArg &lt;module specific arg&gt;] [-debugLevel &lt;error debug level&gt;] [-clean|-c &lt;dev mode cleanup&gt;]\n \
    [-efence &lt;process list&gt;] [-saveConfigPerTest &lt;yes/no&gt;] [-stopRegOn &lt;condition to abort&gt;] \n \
    [-qId &lt;regserver queue id&gt;] [-heapTracingProcess &lt;process list&gt;] [-ezinfofile &lt;infofile&gt;] \n \
    [-ezkillfile &lt;id&gt;] [-harness &lt;all|tcl|itest&gt;] [-trackingdb &lt;on|off&gt;] \n \
    [-launchserver &lt;on|off&gt;]}
    puts {   &lt;mode&gt;: auto|dev|autodev}
    puts {      (auto: Official automation run from start, performs unconfig, checkConnection)}
    puts {      (dev: Development run using init file, skips unconfig, checkConnection)}
    puts {      (autodev: Official automation run using init file, skips checkConnection)}
    puts {   &lt;module&gt;: L2|L3|IGMPS|QOS-AC (case insensitive, nearest match accepted)}
    puts {   &lt;cfg&gt;: Path of the config file name (e.g. short/ptgm4x6.2.2b4.cfg)}
    puts {   [&lt;lst&gt;]: test list (all|pass|quick|userDefined). By default all, userDefined is a filename value in module)}
    puts {   [&lt;regPath&gt;]: regression Path (func|snmp|per|stres. By default function, case insensitive, nearest match accepted)}
    puts {         If running CLI test, give regPath as ../CLItest/uploadanddownload.}
    puts {   [&lt;testlinkplan&gt;]: TestLink test plan name.  All plan cases with a scriptPath will execute}
    puts {   [&lt;clean | c&gt;]: If running in dev mode the allcleanup cli script can be run to insure no cfg on switch}
    puts {   [&lt;cliFlag&gt;]: cliFlag (NO_REBOOT|NO_REBOOT_NO_DOWNLOAD, optional with regPath clitest)}
    puts {   [&lt;debugLevel&gt;]: debug level 1|2|3. The level at which the debug information is dumped when script encounters an error}
    puts {   [&lt;subversion&gt;]: subversion variable if any, used for private testing}
    puts {   [&lt;efence&gt;]: list of efence activated processes}
    puts {   [&lt;saveConfigPerTest&gt;]: enable saving of switch configuration before start of each test supported from  release 12.1}
    puts {   [&lt;stopRegOn&gt;]: testFailure|coreDump|anyFailure conditions which will cause regression to abort}
    puts {   [&lt;qId&gt;]: SC_######_######|RTP_######_###### the id of the currently running queue}
    puts {   [&lt;heapTracingProcess&gt;]: process for which heaptracing is required}
    puts {   [&lt;TrafficGen&gt;]: default = ixia.  ixia|ixvm|stc}
    puts {   [&lt;harness&gt;]: all|tcl|itest|tpb|testlink which harness cases to execute}
    puts {   [&lt;trackingdb&gt;]: on|off default: on Enables server startup for tracking test bed activity}
    puts {   [&lt;trackport&gt;]: official use only}
    puts {   [&lt;launchserver&gt;]: on|off default: on Starts a server which can interact with regression}
    puts &#34;\r&#34;
}

<span class="comment-line"># ------------------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">#      Start MAIN functionality</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># ------------------------------------------------------------------------------</span>


<a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> main $argv {
    mode &#34;dev&#34;
    module &#34;qad&#34;
    cfg &#34;null&#34;
    lst &#34;dev&#34;
    tcList &#34;all&#34;
    regPath &#34;Functional&#34;
    clean &#34;no&#34;
    c     &#34;null&#34;
    cc &#34;&#34;
    cliFlag &#34;&#34;
    testlinkplan &#34;null&#34;
    build &#34;&#34;
    subversion &#34;&#34;
    obuild &#34;&#34;
    moduleArg &#34;&#34;
    debugLevel &#34;0&#34;
    randomIndex &#34;unknown&#34;
    efence &#34;no&#34;
    saveConfigPerTest &#34;no&#34;
    stopRegOn &#34;null&#34;
    qId &#34;null&#34;
    heapTracingProcess &#34;no&#34;
    ezinfofile &#34;&#34;
    ezkillfile &#34;&#34;
    TrafficGen &#34;ixia&#34;
    harness &#34;tcl&#34;
    trackingdb &#34;on&#34;
    trackport  &#34;null&#34;
    launchserver &#34;off&#34;
}
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line">#  Menus</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
    set MAIN(skipIxInit) 1; set MAIN(IxiaReady) 0;
    set rundev dev
    set rCfgList &#34;&#34;
    set nCfgList &#34;&#34;
    set useEnv &#34;no&#34;
    if {![file isdirectory /tmp/imain]} {
        file mkdir /tmp/imain
    }
    if {![file isdirectory /tmp/imain/$env(USER)]} {
        file mkdir /tmp/imain/$env(USER)
    }
    if {![file exists /tmp/imain/$env(USER)/runs.txt]} {
        <span class="comment-line">#set fd_cfg [open &#34;/tmp/imain/$env(USER)/runs.txt&#34; &#34;a+&#34;]</span>
    } else {
        set fd_cfg [open &#34;/tmp/imain/$env(USER)/runs.txt&#34; &#34;r+&#34;]
        while {[gets $fd_cfg cline] != -1} {
            lappend rCfgList [string trim $cline]
        }
        close $fd_cfg
        set rc [llength $rCfgList]
        set rb [expr $rc - 12]
        if {$rb &lt; 0} {set rb 0;}
        if {$rc &gt; 0} {
            for {set ccc $rb} {$ccc &lt; $rc} {incr ccc} {
                lappend nCfgList [lindex $rCfgList $ccc]
            }
        }
    }
    if {[llength $nCfgList]&gt;0} {
        set startl &#34;No&#34;
        set mmlist [concat $startl $nCfgList]
        set preCfg [<a name="::NumberedMenu(1)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Run on a previously executed test bed&#34; \
                    -question1 &#34;Select a test bed?&#34; \
                    -choices $mmlist \
                    -menuWidth        75 \
                    -keyWidth         3 \
                    -headerPadChar    &#34;=&#34; \
                    -chAppendList     &#34;null&#34; \
                    -chPrependList    &#34;null&#34; \
                    -barChar          &#34;-&#34; \
                    -clearXterm       &#34;yes&#34; \
                    -simple           &#34;yes&#34; \
                    -clearXtermInfo   &#34;&#34; ]
        if {[file exists /tmp/imain/$env(USER)/store.$preCfg]} {
            source /tmp/imain/$env(USER)/store.$preCfg
            puts  &#34;----------------------------------------------------&#34;
            puts  &#34;cfg $cfg&#34;
            puts  &#34;mode $mode&#34;
            puts  &#34;module $module&#34;
            puts  &#34;regPath $regPath&#34;
            puts  &#34;lst $lst&#34;
            puts  &#34;rundev $rundev&#34;
            puts  &#34;----------------------------------------------------&#34;
            set useEnv [<a name="::menuYesNo(1)"><a href="./menu.tcl.html#::menuYesNo_294">::menuYesNo</a></a> &#34;Use Previous In Info&#34; &#34;Y&#34;]
        } else {
            set useEnv &#34;no&#34;
            set cfg &#34;null&#34;
        }
    }
    if {$useEnv == &#34;yes&#34; &amp;&amp; [file exists /tmp/imain/$env(USER)/store.$preCfg]} {
        source /tmp/imain/$env(USER)/store.$preCfg
        if {$mode == &#34;auto&#34; || $mode == &#34;autodev&#34;} {
            set lm [<a name="::menuYesNo(2)"><a href="./menu.tcl.html#::menuYesNo_294">::menuYesNo</a></a> &#34;Your stored run is in $mode mode.  Change to dev mode?&#34; &#34;Yes&#34;]
            if {$lm == &#34;yes&#34;} {
                set mode &#34;dev&#34;
            }
        }
    } else {
        set cfg &#34;null&#34;
        <span class="comment-line"># menu level 1</span>
        set iList {
            &#34;Run Regression&#34;
        }

        set sList [<a name="::NumberedMenu(2)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Interactive Main Library and Test Case Development Environment&#34; \
                    -question1 &#34;What do you want to do?&#34; \
                    -choices $iList \
                    -menuWidth        75 \
                    -keyWidth         3 \
                    -headerPadChar    &#34;=&#34; \
                    -chAppendList     &#34;null&#34; \
                    -chPrependList    &#34;null&#34; \
                    -barChar          &#34;-&#34; \
                    -clearXterm       &#34;yes&#34; \
                    -simple           &#34;yes&#34; \
                    -clearXtermInfo   &#34;&#34; ]

        if {[lsearch $sList &#34;Work on libraries&#34;] &gt;= 0} {
            set wList {
                &#34;Select live test bed&#34;
                &#34;Source an init file (Be Careful)&#34;
            }
            set MAIN(skipIxInit) 1
            set sList [<a name="::NumberedMenu(3)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Load test bed cfg information&#34; \
                        -question1 &#34;Select test bed info source&#34; \
                        -choices $wList \
                        -menuWidth        75 \
                        -keyWidth         3 \
                        -headerPadChar    &#34;=&#34; \
                        -chAppendList     &#34;null&#34; \
                        -chPrependList    &#34;null&#34; \
                        -barChar          &#34;-&#34; \
                        -clearXterm       &#34;yes&#34; \
                        -simple           &#34;yes&#34; \
                        -clearXtermInfo   &#34;&#34; ]


            if {[lsearch $sList &#34;Select live test bed&#34;] &gt;= 0} {
                <span class="comment-line">#set AllDirs [glob -type d *]</span>
                set ic 1
                while {$ic} {
                    set s [<a name="::SingleQuestion(1)"><a href="./menu.tcl.html#::SingleQuestion_262">::SingleQuestion</a></a> -q1 &#34;Cfg File Name Search Phrase&#34;]
                    set stat [catch {glob cfg/*{$s}*.cfg} myCfgs]
                    if {$stat} {
                        puts &#34;Did not match any cfg files&#34;
                        continue;
                    } else {
                        <span class="comment-line">#puts &#34;\ncfgs $myCfgs \nstat $stat&#34;</span>
                        set cList [<a name="::NumberedMenu(4)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Configuration File&#34; \
                            -question1 &#34;Select Cfg File&#34; \
                            -choices $myCfgs \
                            -simple           &#34;yes&#34; \
                            -menuWidth        75 \
                            -keyWidth         3 \
                            -headerPadChar    &#34;=&#34; \
                            -chAppendList     &#34;null&#34; \
                            -chPrependList    &#34;TryAgain&#34; \
                            -barChar          &#34;-&#34; \
                            -clearXterm       &#34;yes&#34; \
                            -clearXtermInfo   &#34;&#34; ]
                        if {[llength $cList] &gt; 1 || [llength $cList] == 0} {
                            continue;
                        }
                        if {[lsearch $cList &#34;TryAgain&#34;] &gt;= 0} {
                            continue;
                        }
                        set cfg [lindex $cList 0]
                        set ic 0
                    }
                }
            } elseif {[lsearch $sList &#34;Source an init file (Be Careful)&#34;] &gt;= 0} {
                set nohit 1
                while {$nohit} {
                    set s [<a name="::SingleQuestion(2)"><a href="./menu.tcl.html#::SingleQuestion_262">::SingleQuestion</a></a> -q1 &#34;Init File Search -- \&#34;DUTSINFO*\&#34; will show all&#34;]
                    set stat [catch {glob ${autoPath}main/Tmp/*{$s}*} myInitF]
                    puts &#34;searched ${autoPath}main/Tmp/*{$s}*&#34;
                    if {$stat} {
                        puts &#34;No matches&#34;
                        continue;
                    } else {
                        set fList [<a name="::NumberedMenu(5)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Init Files&#34; \
                            -question1 &#34;Select Init File&#34; \
                            -choices $myInitF \
                            -menuWidth        75 \
                            -keyWidth         3 \
                            -headerPadChar    &#34;=&#34; \
                            -chAppendList     &#34;null&#34; \
                            -chPrependList    &#34;TryAgain&#34; \
                            -barChar          &#34;-&#34; \
                            -clearXterm       &#34;yes&#34; \
                            -simple           &#34;yes&#34; \
                            -clearXtermInfo   &#34;&#34; ]
                        if {[llength $fList] &gt; 1 || [llength $fList] == 0} {
                            continue;
                        }
                        if {[lsearch $fList &#34;TryAgain&#34;] &gt;= 0} {
                            continue;
                        }
                        set ifile [lindex $fList 0]
                        set nohit 0
                    }
                }
                <span class="comment-line">#----  DUTINFO_10.69.1.100 2001_p13_stack_ipr.txt</span>
                set infoList [split $ifile &#34;_&#34;]
                set ctxt [lindex $infoList [expr [llength $infoList] - 1]]
                set cmain [string trimright &#34;.txt&#34;]
                set infocfg ${cmain}.cfg
                puts &#34;Found info file $ifile&#34;
                puts &#34;cfg file $cfg&#34;
            }
        }
        if {[lsearch $sList &#34;Run Regression&#34;] &gt;= 0} {
            if {$cfg == &#34;null&#34;} {
                <span class="comment-line">#set AllDirs [glob -type d *]</span>
                set ic 1
                while {$ic} {
                    set s [<a name="::SingleQuestion(3)"><a href="./menu.tcl.html#::SingleQuestion_262">::SingleQuestion</a></a> -q1 &#34;Cfg File Name Search Phrase&#34;]
                    set stat [catch {glob cfg/*{$s}*.cfg} myCfgs]
                    if {$stat} {
                        puts &#34;Did not match any cfg files&#34;
                        continue;
                    } else {
                        <span class="comment-line">#puts &#34;\ncfgs $myCfgs \nstat $stat&#34;</span>
                        set cList [<a name="::NumberedMenu(6)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Configuration File&#34; \
                            -question1 &#34;Select Cfg File&#34; \
                            -choices $myCfgs \
                            -simple           &#34;yes&#34; \
                            -menuWidth        75 \
                            -keyWidth         3 \
                            -headerPadChar    &#34;=&#34; \
                            -chAppendList     &#34;null&#34; \
                            -chPrependList    &#34;TryAgain&#34; \
                            -barChar          &#34;-&#34; \
                            -clearXterm       &#34;yes&#34; \
                            -clearXtermInfo   &#34;&#34; ]
                        if {[llength $cList] &gt; 1 || [llength $cList] == 0} {
                            continue;
                        }
                        if {[lsearch $cList &#34;TryAgain&#34;] &gt;= 0} {
                            continue;
                        }
                        set cfg [lindex $cList 0]
                        set ic 0
                    }
                }

            }
            set ir 1
            while {$ir} {
                lappend myPs &#34;../Functionaltest&#34;
                lappend myPs &#34;../FeatureInteraction&#34;
                lappend myPs &#34;../SnmpFunctionaltest&#34;
                lappend myPs &#34;../SystemTest&#34;
                lappend myPs &#34;../Scalabilitytest&#34;
                lappend myPs &#34;../Stresstest&#34;
                set mList [<a name="::NumberedMenu(7)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Regression Paths&#34; \
                    -question1 &#34;Select Path&#34; \
                    -choices $myPs \
                    -menuWidth        75 \
                    -keyWidth         3 \
                    -simple           &#34;yes&#34; \
                    -headerPadChar    &#34;=&#34; \
                    -chAppendList     &#34;null&#34; \
                    -chPrependList    &#34;TryAgain&#34; \
                    -barChar          &#34;-&#34; \
                    -clearXterm       &#34;yes&#34; \
                    -clearXtermInfo   &#34;&#34; ]
                if {[llength $mList] &gt; 1 || [llength $mList] == 0} {
                    continue;
                }
                if {[lsearch $mList &#34;TryAgain&#34;] &gt;= 0} {
                    continue;
                }
                set regPath [lindex $mList 0]
                set ir 0
            }
            set im 1
            while {$im} {
                set s [<a name="::SingleQuestion(4)"><a href="./menu.tcl.html#::SingleQuestion_262">::SingleQuestion</a></a> -q1 &#34;Module Search Phrase&#34;]
                set stat [catch {glob -type d ${regPath}/$s*} myMods]
                puts &#34;searched ${regPath}/$s*&#34;
                if {$stat} {
                    puts &#34;No matches&#34;
                    continue;
                } else {
                    set mList [<a name="::NumberedMenu(8)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Module Directories&#34; \
                        -question1 &#34;Select Module&#34; \
                        -choices $myMods \
                        -menuWidth        75 \
                        -keyWidth         3 \
                        -simple           &#34;yes&#34; \
                        -headerPadChar    &#34;=&#34; \
                        -chAppendList     &#34;null&#34; \
                        -chPrependList    &#34;TryAgain&#34; \
                        -barChar          &#34;-&#34; \
                        -clearXterm       &#34;yes&#34; \
                        -clearXtermInfo   &#34;&#34; ]
                    if {[llength $mList] &gt; 1 || [llength $mList] == 0} {
                        continue;
                    }
                    if {[lsearch $mList &#34;TryAgain&#34;] &gt;= 0} {
                        continue;
                    }
                    set module [lindex $mList 0]
                    set ml [split $module &#34;/&#34;]
                    set mlen [llength $ml]
                    set dir [lindex $ml [expr $mlen - 1]]
                    set module $dir
                    set regPath [string trim $regPath &#34;../&#34;]
                    set im 0
                }
            }
            set dList {
                &#34;dev&#34;
                &#34;autodev&#34;
                &#34;auto&#34;
            }

            set dList [<a name="::NumberedMenu(9)"><a href="./menu.tcl.html#::NumberedMenu_2">::NumberedMenu</a></a> -head &#34;Main Mode&#34; \
                        -question1 &#34;Mode for main&#34; \
                        -choices $dList \
                        -menuWidth        75 \
                        -keyWidth         3 \
                        -simple           &#34;yes&#34; \
                        -headerPadChar    &#34;=&#34; \
                        -chAppendList     &#34;null&#34; \
                        -chPrependList    &#34;null&#34; \
                        -barChar          &#34;-&#34; \
                        -clearXterm       &#34;yes&#34; \
                        -clearXtermInfo   &#34;&#34; ]

            set mode $dList

        }

        puts &#34;\n@@ \nRunning cfg: $cfg\n\nregPath: $regPath\nmodule: $module\n@@&#34;
        sleep 3
        <span class="comment-line"># ------------------------------------------------------------------</span>
        <span class="comment-line"># Set the env variables for the selections so we can skip next time</span>
        <span class="comment-line"># ------------------------------------------------------------------</span>
    <span class="comment-line">#    catch {file delete /tmp/imain/$env(USER)_imain.txt} reason</span>
    <span class="comment-line">#    set tfile [open &#34;/tmp/imain/$env(USER)_imain.txt&#34; &#34;w&#34;]</span>
        set shtCfg [file tail $cfg]
        catch {file delete /tmp/imain/$env(USER)/store.$shtCfg} reason
        set tfile [open &#34;/tmp/imain/$env(USER)/store.$shtCfg&#34; &#34;w&#34;]
        puts $tfile &#34;set cfg $cfg&#34;
        puts $tfile &#34;set mode $mode&#34;
        puts $tfile &#34;set module $module&#34;
        puts $tfile &#34;set regPath $regPath&#34;
        puts $tfile &#34;set lst $lst&#34;
        puts $tfile &#34;set rundev $rundev&#34;
        close $tfile

        <span class="comment-line"># --- Create or update the file that holds the 12 latest cfg files run.</span>
        if {![file exists /tmp/imain/$env(USER)/runs.txt]} {
            set fd_cfg [open &#34;/tmp/imain/$env(USER)/runs.txt&#34; &#34;a+&#34;]
            puts $fd_cfg [string trim $shtCfg]
            close $fd_cfg
        } else {
            if {[llength $nCfgList] &gt; 0} {
                catch {file delete /tmp/imain/$env(USER)/runs.txt} reason
                set ixc [lsearch -exact $nCfgList $shtCfg]
                if {$ixc &gt;= 0} {
                    set nCfgList [lreplace $nCfgList $ixc $ixc]
                }
                set fd_cfg [open &#34;/tmp/imain/$env(USER)/runs.txt&#34; &#34;a+&#34;]
                foreach nc $nCfgList {
                    puts $fd_cfg [string trim $nc]
                }
                puts $fd_cfg [string trim $shtCfg]
                close $fd_cfg
            }
        }

    }
    set logfilt &#34;false&#34;
<span class="comment-line"># ---------------------------------------------------------</span>
<span class="comment-line"># ----             ARGUMENT VERIFCATION                ----</span>
<span class="comment-line"># ---------------------------------------------------------</span>

    <span class="comment-line">############################################################</span>
    <span class="comment-line">#  -mode is meant to determine the run state of this current test</span>
    <span class="comment-line">#     the switch command is mostly self explanitory.</span>
    <span class="comment-line">#    auto      =  results will be copied to a central repository</span>
    <span class="comment-line">#                 as well as to the &#34;Report&#34; directory</span>
    <span class="comment-line">#    autodev   =  same as auto plus init file used instead of</span>
    <span class="comment-line">#                 systemsetup and getdutinfo to save time</span>
    <span class="comment-line">#    dev       =  systemsetup and getdutinfo skipped and init</span>
    <span class="comment-line">#                 file sourced to save time</span>
    <span class="comment-line">#############################################################</span>
    set mode [string tolower $mode]
    switch $mode  {
        &#34;auto&#34;    {
            puts &#34;\n\nThis is an official automation run.&#34;
            puts &#34;The cfg file setup script and check connections will be run&#34;
            set runMode 0;
            set MAIN(runMode) 0;
                }
        &#34;autodev&#34; {
            puts &#34;\n\nThis is an autodev run&#34;;
            puts &#34;The setup script is being run&#34;;
            puts &#34;Using the initFile from a previous run&#34;;
            set runMode 1;
            set MAIN(runMode) 1;
        }
        &#34;dev&#34;     {
            puts &#34;\n\nDEVELOPMENT RUN NO UNCONFIG BOXES&#34;
            puts &#34;Using the initFile from a previous run&#34;
            set runMode 2;
            set MAIN(runMode) 2;
        }
        default  {
            puts &#34;\n\nNo -mode define!! Using -mode auto&#34;;
            puts &#34;The cfg file setup script and check connections will be run&#34;;
            set runMode 0;
            set MAIN(runMode) 0;
        }
    }

    <span class="comment-line">## module setup</span>
    if {$module == &#34;null&#34;} {
        puts &#34;\n\n-module is a required argument&#34;
        exit 1
    } else {
        puts &#34;Setting to run regression for module $module&#34;
    }
    <span class="comment-line">## cfg check</span>
    if {$cfg == &#34;null&#34;} {
        puts &#34;\n\n-cfg is a required argument&#34;
        exit 1
    }
    switch -nocase -regexp $clean {
        y.* {
            set clean yes
        }
        n.* {
            set clean no
        }
        c.* {
            set clean cli
        } default {
            set clean yes
        }
    }
    <span class="comment-line"># check test vendor selection</span>
    set TrafficGen [string tolower $TrafficGen]
    switch -exact -- $TrafficGen {
        stc -
        ixvm -
        stcvm -
        ixia -
        ept -
        none {
            puts &#34;main.tcl: Test vendor selection - $TrafficGen&#34;
        }
        default {
            <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;main.tcl: Invalid test vendor selected ($TrafficGen)\n \
                 - must be one of IXIA,IXVM,STC or NONE. Aborting...&#34;
            exit 1
        }
    }
    switch -exact -- $harness {
        all {puts &#34;\nExecuting tcl and iTest cases - tcl runs first&#34;}
        tcl {puts &#34;\nExecuting tcl cases Only&#34;}
        itest {puts &#34;\nExecuting iTest cases Only&#34;}
        tpb {puts &#34;\nExecuting in TPB mode&#34;}
        testlink {puts &#34;\nExecuting in TestLink mode&#34;}
        default {
            puts &#34;main.tcl: Invalid harness type.  \n\
               Must be \&#34;all\&#34; \&#34;tcl\&#34; \&#34;tpb\&#34; \&#34;testlink\&#34; or \&#34;itest\&#34;. Aborting...&#34;
            exit 1
        }
    }
    if { $tcList == &#34;&#34; } {
        puts &#34;Fatal Error: tcList cannot be empty. \n\
           Specify 'all' or do not give -tcList option.&#34;
        exit 1
    }
    if { $testlinkplan != &#34;null&#34; &amp;&amp; $harness != &#34;tpb&#34;} {
        <span class="comment-line">#If testplan does not appear in json exit</span>
        puts &#34;You are in Test Link Mode&#34;
        puts &#34;Your results will post to TestLink/$testlinkplan/$module/Report&#34;
    }
    <span class="comment-line"># Verify the regPath</span>
    set MAIN(mainPath) [pwd]
    set MAIN(origRegPath) $regPath
    set regPath [<a name="::_verifyRegPathArg(1)"><a href="./filetools.tcl.html#::_verifyRegPathArg_107">::_verifyRegPathArg</a></a> -regPath $regPath];<span class="comment-line"># Full/real path. Not the short one passed in</span>
    set MAIN(regPath) $regPath;<span class="comment-line"># More portable</span>
    set MAIN(feature_type) [file tail $regPath];<span class="comment-line">#</span>

    <span class="comment-line"># Rename a bunch of stuff - for compatibility</span>
    set enableAbortTestCondition $stopRegOn
    set enableSaveConfigPerTest $saveConfigPerTest
    set gHeapTracingProcess $heapTracingProcess
    set heapTraceEnabled &#34;no&#34;
    set NEWBUILD $build
    set OLDBUILD $obuild

    <span class="comment-line"># Verify the module / feature / testplan to run</span>
    set module [_verifyModuleNameArg $regPath $module];<span class="comment-line"># Set the full, verified module name</span>
    set DUTs_info(current_module) $module
    set MAIN(module) $module;<span class="comment-line"># Full path, not just the short one passed into the arg</span>
    set modName [file tail $module]; <span class="comment-line"># modName is feature_directory name</span>
    set MAIN(feature_directory) $modName;
    
    <span class="comment-line"># Make some cli args more portable</span>
    set MAIN(randomIndex) $randomIndex 
    set MAIN(cliFlag)     $cliFlag
    set MAIN(build)       $build
    set MAIN(subversion)  $subversion
    set MAIN(efence)      $efence
    set MAIN(qId)         $qId
    set MAIN(lst)         $lst
    set MAIN(clean)       $clean

<span class="comment-line"># ------------------------------------------------------</span>
<span class="comment-line"># ----   Set harness paths and source important files</span>
<span class="comment-line"># ------------------------------------------------------</span>

    <span class="comment-line"># -- Normalize the current directory --</span>
    set curAutoRoot [<a name="::_setCurrentAutoDir(1)"><a href="./filetools.tcl.html#::_setCurrentAutoDir_149">::_setCurrentAutoDir</a></a>]
    set MAIN(autoRoot) $curAutoRoot;<span class="comment-line"># More portable</span>
    set LIB_PATH ${curAutoRoot}/Lib
    set MAIN(LIB_PATH) $LIB_PATH
    set SYSTEM_LIB_PATH ${curAutoRoot}/SystemTest/Lib
    set MAIN(SYSTEM_LIB_PATH) $SYSTEM_LIB_PATH

    <span class="comment-line"># -- Remove user ixia environment variables from the auto_path</span>
    set auto_path [<a name="::_cleanAutoPath(1)"><a href="./filetools.tcl.html#::_cleanAutoPath_178">::_cleanAutoPath</a></a> -remove ixia]
    lappend auto_path $LIB_PATH

    <span class="comment-line"># -------  Create the main and lib tclIndex files -------</span>
    <a name="::::gen_index(1)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;./../Lib&#34;
    if {[file isdirectory ./../SystemTest/Lib]} {
        lappend auto_path $SYSTEM_LIB_PATH
        <a name="::::gen_index(2)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> &#34;./../SystemTest/Lib&#34;
    }

<span class="comment-line"># -------------------------------------------------------------</span>
<span class="comment-line"># -- Source important harness files. runReg,common and test bed</span>
<span class="comment-line"># -------------------------------------------------------------</span>
    if [catch {source &#34;../main/runReg.cfg&#34;} rea] {
        puts &#34;*** WARNING: Unable to source runReg.cfg:$rea............... ***&#34;
        puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
        exit -1
    }
    set sourceFile &#34;&#34;
    <span class="comment-line"># backtracked path needed for other utilties outside main to work</span>
    if [catch {source &#34;../main/cfg/common.cfg&#34;} rea] {
        puts &#34;*** WARNING: Unable to source common.cfg:$rea............... ***&#34;
        puts &#34;*** WARNING: Application level variables may not be defined. ***&#34;
        exit -1
    }
    if {$cfg != &#34;null&#34;} {
        set sourceFile $cfg
        if {([regexp -nocase &#34;^short&#34; $sourceFile]&amp;&amp;[regexp -nocase {/} $sourceFile]) || \
                  [regexp -nocase &#34;^pt&#34; $sourceFile]} {
            puts &#34;regPath:$regPath  module:$module  sourceFile: $sourceFile&#34;
            <span class="comment-line">#set sourceFile [format %s/%s/%s $regPath $module $sourceFile]</span>
            set sourceFile [format %s/%s $module $sourceFile]
            set sourceFile [string trim $sourceFile];
        } elseif {![regexp -nocase &#34;^cfg&#34; $sourceFile] &amp;&amp; ![regexp -nocase {/} $sourceFile]} {
            if {[file exists $sourceFile]==0} {
                set sourceFile [format %s/%s cfg $sourceFile]
                set sourceFile [string trim $sourceFile];
            }
        }
        puts &#34;Using config file: ($sourceFile)&#34;
    }
    if {[file exists $sourceFile] == 0} {
        puts &#34;Cannot find config file: $sourceFile\n&#34;
        puts stderr &#34;Cannot find config file: $sourceFile&#34;
        return
    }
    set configurationFile $sourceFile
    set MAIN(sourceFile)  $sourceFile
    set MAIN(cfg)         [file tail $cfg]
    puts &#34;**** ABOUT TO source test bed cfg $sourceFile ****&#34;
    if [catch {source $sourceFile} reason] {
        puts &#34;*** ERROR: Unable to source $sourceFile :$rea............... ***&#34;
        puts &#34;*** ERROR: Application level variables may not be defined. ***&#34;
        exit -1
    }
    <span class="comment-line"># Get the revision number</span>
    set MAIN(REPO_VERSION) [<a name="::_getRepoVersion(1)"><a href="./filetools.tcl.html#::_getRepoVersion_201">::_getRepoVersion</a></a>]
<span class="comment-line"># --------------------------------------------------------------------------------</span>
<span class="comment-line"># ----  Configurations for regression types / paths other than Functionaltest ----</span>
<span class="comment-line"># --------------------------------------------------------------------------------</span>
    if { [regexp -nocase &#34;cli&#34; $regPath] &amp;&amp; [info exists ixiaCh1] } {
        unset ixiaCh1 ;<span class="comment-line"># prevent Ixia from initializing for CLI run</span>
        set optionalFlag $cliFlag
    }
    <span class="comment-line"># If regPath is snmp then check whether SNMP configuraiton file exists or not</span>
    if {[regexp -nocase &#34;snmp&#34; $regPath]} {
        source ./../Lib/snmplib.tcl
        if {[file exists &#34;../main/cfg/snmp.cfg&#34;] == 0} {
            puts stderr &#34;Cannot find SNMP config file: cfg/snmp.cfg&#34;
            return
        } else {
            source ../main/cfg/snmp.cfg
            <a name="::snmpInit(1)"><a href="./snmplib.tcl.html#::snmpInit_115">::snmpInit</a></a>
            global env
            puts &#34;ENVIRONMENT VARIABLE = $env(MIBS)&#34;
            puts &#34;                       $env(MIBDIRS)&#34;
            puts &#34;                       $env(SNMPCONFPATH)&#34;
        }
    }
    set optionalPath &#34;&#34;
    set optionalFlag $cliFlag

<span class="comment-line"># ----------------------------------------------------------------</span>
<span class="comment-line"># Error handling, report structure, main communication socket</span>
<span class="comment-line">#</span>
<span class="comment-line"># ----------------------------------------------------------------</span>
    <span class="comment-line"># -- Make sure directory structure exists in main folder</span>
    <a name="::_createSupportDirectories(1)"><a href="./filetools.tcl.html#::_createSupportDirectories_50">::_createSupportDirectories</a></a> -dirList &#34;Report Result Tmp Tmp2 Log&#34;
    
    <span class="comment-line"># ----------   Set up global error display levels ----------</span>
    <span class="comment-line"># Set the showErrorData flag for multiple level debug</span>
    <span class="comment-line"># showErrorData = 0 means don't dump debug info in result_error</span>
    <span class="comment-line"># showErrorData != 0 means dump debug info in result_error a this level</span>
    set showErrorData $debugLevel
    unset debugLevel   

    <span class="comment-line">############################################################</span>
    <span class="comment-line"># AVOID TEST BED CONFLICTS</span>
    <span class="comment-line">#</span>
    <span class="comment-line">#   open a socket</span>
    <span class="comment-line">#   register with a central server database</span>
    <span class="comment-line">#     - tell the server what my socket and ip are</span>
    <span class="comment-line">#     - pass cfgfile, user, uuid</span>
    <span class="comment-line">#   The central server has a daemon running that checks</span>
    <span class="comment-line">#       the socket.  If it is not open, the database</span>
    <span class="comment-line">#       entry is cleared</span>
    <span class="comment-line">#</span>
    <span class="comment-line">#   At this point in main.  The database is checked.</span>
    <span class="comment-line">#     - If the database is not reachable, it continues</span>
    <span class="comment-line">#     - If the database is checked and there is not entry.. run</span>
    <span class="comment-line">#     - If the database is checked and there is an entry</span>
    <span class="comment-line">#         print the info of who is running and exit</span>
    <span class="comment-line">#</span>
    <span class="comment-line">############################################################</span>

    <span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line"># Test Plan Builder Controlled TCL --</span>
    <span class="comment-line">#    TPB starts main.tcl from a wrapper in this directory tpb_main.tcl</span>
    <span class="comment-line">#    TPB uses the socket to pass tests to main.tcl and receive results</span>
    <span class="comment-line"># --------------------------------------------------------------------   </span>
    if {$harness == &#34;tpb&#34;} {
        global useSocket
        set useSocket 0
        if {$trackport != &#34;null&#34;} {
            set useSocket 1
        }

        <span class="comment-line"># --- TPB controller may run main.tcl as root. Set user to regLogin</span>
        if {[id effective user] == &#34;root&#34;} {
            puts &#34;\nTPB Controller SETTING USER TO $regLogin\n&#34;
            id user $regLogin
        }
        puts &#34;TPBMainClearConsole $qId $modName $regPath $useSocket&#34;
        <a name="::::TPBMainClearConsole(1)"><a href="./tpbMainLib.tcl.html#::::TPBMainClearConsole_841">::::TPBMainClearConsole</a></a> $qId $modName $regPath $useSocket
        set initsend &#34;TPB Control Session Started&#34;
    } else {
        set initsend &#34;Main.tcl Session Started&#34;
    }
    set force 0;
    set ineed &#34;&#34;;
    set mySock &#34;&#34;
    <span class="comment-line"># --- Open the server listing on the trackport</span>
    if {$launchserver == &#34;on&#34; || $trackport != &#34;null&#34;} {
        set myPipe [<a name="::OpenTrackingPort(1)"><a href="./resource_track.tcl.html#::OpenTrackingPort_7">::OpenTrackingPort</a></a>  -user &#34;null&#34; -port &#34;$trackport&#34; -cfg &#34;[file tail $cfg]&#34; \
        -script_name &#34;MAIN&#34; -force &#34;$force&#34; -trackingdb &#34;off&#34;]
    }

<span class="comment-line"># --------------------------------------------------------------</span>
<span class="comment-line"># Expect and traffic gen libraries</span>
<span class="comment-line"># --------------------------------------------------------------</span>
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># Load Expect</span>
    <span class="comment-line">############################################################</span>
    load [lindex [glob &#34;/usr/lib/libexpect*so*&#34;] 0]
    <span class="comment-line"># --- increase the default buffer</span>
    match_max -d 200000
    log_user 0

    <span class="comment-line">############################################################</span>
    <span class="comment-line"># Setup the Ixia libraries</span>
    <span class="comment-line">############################################################</span>
    set MAIN(skipIxInit) 1; set MAIN(IxiaReady) 0;
    if {[info exists ixiaCh1] &amp;&amp; [regexp {[0-9]+\.[0-9]+} $ixiaCh1]} {
        if {[info exists ixiaPath($ixiaCh1)]} {
           <a name="::SetIxiaEnv(1)"><a href="./ePTMisc.tcl.html#::SetIxiaEnv_517">::SetIxiaEnv</a></a> &#34;$ixiaPath($ixiaCh1)&#34;
           lappend auto_path [file join $env(IXIA_HOME) &#34;lib&#34;]
        }
    }

<span class="comment-line"># --------------------------------------------------------------</span>
<span class="comment-line"># Decide the how to run main.</span>
<span class="comment-line">#   - In the module, for a single run</span>
<span class="comment-line">#   - A TestLink run, jumping between different directories</span>
<span class="comment-line"># --------------------------------------------------------------</span>
    <span class="comment-line"># Save the base auto_path which holds all TCL necessary up</span>
    <span class="comment-line">#     until this point.  No test case TCL procs are in yet</span>
    set MAIN(auto_path_clean) $auto_path;

    if {$testlinkplan == &#34;null&#34;} {
        <span class="comment-line"># ----------------------------------------------------------</span>
        <span class="comment-line"># If in single module mode LEGACY MAIN.TCL</span>
        <span class="comment-line"># ----------------------------------------------------------</span>
        cd $module
        set REG_PATH [pwd]
        set MAIN(REG_PATH) [pwd]
        set MAIN(REPO_VERSION) [<a name="::_getRepoVersion(2)"><a href="./filetools.tcl.html#::_getRepoVersion_201">::_getRepoVersion</a></a>]

        <span class="comment-line"># Create supporting dirctories for this feature</span>
        <a name="::_createSupportDirectories(2)"><a href="./filetools.tcl.html#::_createSupportDirectories_50">::_createSupportDirectories</a></a> -dirList &#34;Report Result Tmp Log&#34;    
        
        if {[regexp -nocase &#34;^../clitest&#34; $regPath]} {
            set reportPath &#34;./Report&#34;;
            set moduleRegression [file tail $module]
            puts &#34;the moduleRegression $moduleRegression&#34;
            if {![file isdirectory $reportPath]} {
                file mkdir $reportPath;
            }
            set reportPath &#34;./Report&#34;;
            set resultPath &#34;./Result&#34;;
            set tmpPath &#34;./Tmp&#34;;
            set logPath &#34;./Log&#34;;
            set LIB_PATH &#34;../../../Lib&#34;
            lappend auto_path $LIB_PATH
            set auto_path [linsert $auto_path 0 ..]
        } else {
            set auto_path [linsert $auto_path 0 . ]
            <a name="::::gen_index(3)"><a href="./summarize.tcl.html#::::gen_index_76">::::gen_index</a></a> .
            lappend MAIN(indexedList) [pwd];<span class="comment-line"># track fresh indexes</span>
            <span class="comment-line"># --- load module directory libs in other locations ---</span>
            if {[file exists lib_links.tcl]} {
                catch {source lib_links.tcl}
            }
        }

        <span class="comment-line"># ----------------------------------------------------------------</span>
        <span class="comment-line"># Depending on your run type - create the dir to hold results</span>
        <span class="comment-line"># ----------------------------------------------------------------</span>
        <span class="comment-line">#</span>
        <span class="comment-line">#    If normal module run  (testlinkplan=null)</span>
        <span class="comment-line">#       ./Result/&lt;timestamp&gt;_&lt;autogenindex&gt;</span>
        <span class="comment-line">#    Passing in randomIndex to main or resetting randomIndex = qid</span>
        <span class="comment-line">#       ./Result/&lt;timestamp&gt;_&lt;randomIndex&gt;</span>
        <span class="comment-line">#    Setting global MAIN(RESULTPATH) to override &#34;./Result&#34;</span>
        <span class="comment-line">#       For SystemSetup -</span>
        <span class="comment-line">#       set MAIN(RESULTPATH) &#34;$MAIN(autoRoot)/TestLink/$testlinkplan/Result&#34;</span>
        <span class="comment-line">#       For feature_dirs during the run</span>
        <span class="comment-line">#       set MAIN(RESULTPATH) &#34;$MAIN(autoRoot)/TestLink/$testlinkplan/$modName/Result&#34;</span>
        <span class="comment-line"># ----------------------------------------------------------------</span>
        <a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> $randomIndex;<span class="comment-line"># Create resultDir, set global</span>
    } else {
        <span class="comment-line"># -------------------------------------------------------------</span>
        <span class="comment-line"># Test Link Mode</span>
        <span class="comment-line">#   -Always execute from within the main dir.</span>
        <span class="comment-line">#   -Adjust the auto_path for feature_directories</span>
        <span class="comment-line">#   -Change the resultDir to where you want the results to post</span>
        <span class="comment-line">#</span>
        <span class="comment-line">#   Note: executeTestLink below is the first time main.tcl will</span>
        <span class="comment-line">#       know which feature_directories are going to be executed</span>
        <span class="comment-line"># -------------------------------------------------------------</span>
        lappend tlDirs &#34;../TestLink&#34;
        lappend tlDirs &#34;../TestLink/$testlinkplan&#34;
        <a name="::_createSupportDirectories(3)"><a href="./filetools.tcl.html#::_createSupportDirectories_50">::_createSupportDirectories</a></a> -dirList $tlDirs
        set MAIN(RESULTPATH) &#34;$MAIN(autoRoot)/TestLink/$testlinkplan/Result&#34;
        set MAIN(RESULTDIR) [<a name="::get_result_dir(2)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> $randomIndex];<span class="comment-line">#</span>
    }
    <span class="comment-line"># My need to move this.  Probably will be used for variable dir posting</span>
    set MAIN(optionalPath) $optionalPath

<span class="comment-line"># -------------------------------------------------------------------</span>
<span class="comment-line"># -------------------------------------------------------------------</span>

<span class="comment-line"># Start the run</span>

<span class="comment-line"># -------------------------------------------------------------------</span>
<span class="comment-line"># -------------------------------------------------------------------</span>

<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line"># Harness specific / Test bed variable gathering</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">#dummy first file</span>
    set fd_main_skip [<a name="::open_result_file(1)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;skipTestsList&#34;];
    <a name="::close_result_file(1)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>

    <span class="comment-line"># --- Create the main_log file for capturing harness related log messages</span>
    <a name="::open_mainlog_file(1)"><a href="./logging.tcl.html#::open_mainlog_file_17">::open_mainlog_file</a></a>; <span class="comment-line"># open main_log.txt in the result dir. (WriteToMainLog $text)</span>

    <span class="comment-line"># --- Init DUTs_info vars</span>
    <a name="::::_initDUTs_infoArray(1)"><a href="./swConf.tcl.html#::::_initDUTs_infoArray_11">::::_initDUTs_infoArray</a></a>;<span class="comment-line"># Sets MAIN(DUTLIST) and MAIN(NODECOUNT)</span>
    set numDUT $MAIN(NODECOUNT)
    set MAIN(loginQuick) 1;<span class="comment-line"># First login.</span>
    <span class="comment-line"># #########################################################</span>
    <span class="comment-line"># ---- Open the main.txt result file to hold init dut learn</span>
    <span class="comment-line"># #########################################################</span>
    set fd_res [<a name="::open_result_file(2)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;init_switchinfo&#34;]
    result_h1 &#34;[file tail [pwd]] Test&#34;
    if {$MAIN(runMode) == 0} {
        set MAIN(loginQuick) 1
        <span class="comment-line"># --------------------------------------------------------</span>
        <span class="comment-line"># Gather DUTs_info variables that are not Software Related</span>
        <span class="comment-line">#   - loop to get the DUT count and build multitask procs</span>
        <span class="comment-line"># --------------------------------------------------------</span>
        set getInfoList &#34;&#34;
        foreach dut $MAIN(DUTLIST) {
            puts &#34;\n***** DUT${dut}_CONNECT=[set DUT${dut}_CONNECT] ***** &#34;
            puts &#34;***** DUT=$dut ***** &#34;
            _SetPartitionVars -dut $dut;<span class="comment-line"># Get port info from cfg file</span>
            set wayToBootPart($dut) &#34;setupScript&#34;;<span class="comment-line">#</span>
            lappend getInfoList  &#34;_get_HW_DUTs_info -dut $dut -checkOperational 0&#34;
            if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
                lappend makeXsfList &#34;CreateDefaultXsf -dut $dut&#34;
            }
        }
        foreach sBy $MAIN(STDBYLIST) {
            if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
                lappend makeXsfList &#34;CreateDefaultXsf -dut none -standby $sBy&#34;
            }
        }
        <span class="comment-line"># Initialize the DUTs_info variables. See swConf for list of vars</span>
        <a name="::MultiTask(1)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $getInfoList
        <a name="::::_printMultiTaskOutput(1)"><a href="./swConf.tcl.html#::::_printMultiTaskOutput_3651">::::_printMultiTaskOutput</a></a>;<span class="comment-line"># show the output in order + in result file</span>
    } else {
        foreach dut $MAIN(DUTLIST) {
            puts &#34;\n***** DUT${dut}_CONNECT=[set DUT${dut}_CONNECT] ***** &#34;
            puts &#34;***** DUT=$dut ***** &#34;
            _SetPartitionVars -dut $dut;<span class="comment-line"># Get port info from cfg file</span>
            set wayToBootPart($dut) &#34;setupScript&#34;;<span class="comment-line">#</span>
            if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
                lappend makeXsfList &#34;CreateDefaultXsf -dut $dut&#34;
            }
            <a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dut}_CONNECT] -masterCheck 0 -CheckOperational 0
            lappend cleancliList &#34;allCleanup $dut&#34;
        }
        foreach sBy $MAIN(STDBYLIST) {
            if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
                lappend makeXsfList &#34;CreateDefaultXsf -dut none -standby $sBy&#34;
            }
        }
        if {$MAIN(runMode) == &#34;2&#34; &amp;&amp; ($MAIN(clean) == &#34;cli&#34; || $MAIN(clean) == &#34;yes&#34;)} {
            puts &#34;\n\n# ------------------------------------------------------------------&#34;
            puts &#34;               S T A R T I N G     PARALLEL CLI CLEANUP&#34;
            puts &#34;# ------------------------------------------------------------------&#34;
            <a name="::_setShowOutput(1)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt off
            <a name="::MultiTask(2)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $cleancliList
            <a name="::_setShowOutput(2)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
            puts &#34;\n# ------------------------------------------------------------------&#34;
            puts &#34;               E N D               PARALLEL CLI CLEANUP&#34;
            puts &#34;# ------------------------------------------------------------------&#34;
        }
    }
    <a name="::close_result_file(2)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;<span class="comment-line"># end of main.txt</span>
    set MAIN(loginQuick) 0;
<span class="comment-line"># -------------------------------------------------------------------------------------</span>
<span class="comment-line"># Check Feature content available for this test bed</span>
<span class="comment-line"># -------------------------------------------------------------------------------------</span>
    if {$testlinkplan != &#34;null&#34;} {
        <span class="comment-line">#_validTestLinkSupport</span>
    } else {
        set fd_res [<a name="::open_result_file(3)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;main&#34;]
        result_h1 &#34;[file tail [pwd]] Starting Test&#34;
        set MAIN(NOFEATSUPPORT) 0
        <span class="comment-line"># ---------------------------------------------------------------------</span>
        <span class="comment-line">#          FEATURE SUPPORT ON THIS PLATFORM SECTION</span>
        <span class="comment-line">#</span>
        <span class="comment-line">#      Use the global MAIN(NOFEATSUPPORT) 0|1</span>
        <span class="comment-line">#      if a skip is found the next section will end main    </span>
        <span class="comment-line"># ---------------------------------------------------------------------</span>

        <span class="comment-line"># ---------------------------------------------------------</span>
        <span class="comment-line"># bcmLynx feature checks</span>
        <span class="comment-line"># ---------------------------------------------------------</span>
        if {[regexp -nocase $bcmLynx $DUTs_info(DUT1,platform)]} {
            <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT platform is $DUTs_info(DUT1,platform) a bcmLynx&#34;
            if {[lsearch $lynxIncludeModList [file tail $module]] == -1 } {
                <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;This module [file tail $module] skipped for Lynx platform&#34;
                if {$harness == &#34;tpb&#34;} {
                    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Skip all TPB cases for this feature&#34;
                    <a name="::::_TPBLynxExecution(1)"><a href="./tpbMainLib.tcl.html#::::_TPBLynxExecution_898">::::_TPBLynxExecution</a></a>
                } else {
                    <span class="comment-line">#report_start_test &#34;Lynx Skip $MAIN(feature_directory) on $DUTs_info(DUT1,platform)&#34;</span>
                    <span class="comment-line">#result_skip &#34;Lynx Skip $MAIN(feature_directory) on $DUTs_info(DUT1,platform)&#34;</span>
                    <span class="comment-line">#report_end_test;</span>
                }
                set MAIN(NOFEATSUPPORT) 1
            }
        }
        <span class="comment-line"># ---------------------------------------------------------</span>
        <span class="comment-line"># Other feature support checking</span>
        <span class="comment-line">#</span>
        <span class="comment-line"># use plats_to_run(all) OR plats_to_skip(all)</span>
        <span class="comment-line"># ---------------------------------------------------------</span>
        if {[catch {source ./completetests.lst} reason]} {
            puts &#34;Sourcing [pwd] completetest.lst failed: $reason&#34;
        } else {
            if {[info exists FEATPLAT(SupportedTypes)] &amp;&amp; [info exists FEATPLAT(SupportedDUTs)]} {
                if {$FEATPLAT(SupportedTypes) != &#34;all&#34;} {
                    set p 0
                    foreach sysNStr $FEATPLAT(SupportedTypes) {
                        if {[regexp -nocase &#34;all&#34; [lindex $FEATPLAT(SupportedDUTs) $p]]} {
                            for {set d 1} {$d&lt;=$MAIN(NODECOUNT)} {incr d} {
                                if {![regexp -nocase &#34;$sysNStr&#34; $DUTs_info(DUT$d,sysType)]} {
                                    <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                     &#34;$DUTs_info(DUT$d,sysType) System Type Not supported by $MAIN(feature_directory):$sysNStr&#34;
                                    set MAIN(NOFEATSUPPORT) 1
                                }
                            }
                        } else {
                            foreach d [lindex $FEATPLAT(SupportedDUTs) $p] {
                                if {$p &gt; $MAIN(NODECOUNT)} {
                                    <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;There are not $p DUTs in this Test Bed.  Wrong test bed type?&#34;
                                    set MAIN(NOFEATSUPPORT) 1
                                    exit;
                                }
                                if {![regexp -nocase &#34;$sysNStr&#34; $DUTs_info(DUT$d,sysType)]} {
                                    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                     &#34;$DUTs_info(DUT$d,sysType) System Type Not supported by $MAIN(feature_directory):$sysNStr&#34;
                                    set MAIN(NOFEATSUPPORT) 1
                                }
                            }
                        }
                    }
                }
            }
            if {[info exists FEATPLAT(PlatNoSupport)] &amp;&amp; [info exists FEATPLAT(NoSupportDuts)]} {
                set p 0
                foreach platStr $FEATPLAT(PlatNoSupport) {
                    if {[regexp -nocase &#34;all|any&#34; [lindex $FEATPLAT(NoSupportDuts) $p]]} {
                        for {set d 1} {$d&lt;=$MAIN(NODECOUNT)} {incr d} {
                            if {[regexp -nocase &#34;$platStr&#34; $DUTs_info(DUT$d,platform)]} {
                                <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                 &#34;$DUTs_info(DUT$d,platform) Platform Not supported by $MAIN(feature_directory):$platStr&#34;
                                set MAIN(NOFEATSUPPORT) 1
                            }
                        }
                    } else {
                        foreach d [lindex $FEATPLAT(NoSupportDuts) $p] {
                            if {$p &gt; $MAIN(NODECOUNT)} {
                                <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;There are not $p DUTs in this Test Bed.  Wrong test bed type?&#34;
                                set MAIN(NOFEATSUPPORT) 1
                                exit;
                            }
                            if {[regexp -nocase &#34;$platStr&#34; $DUTs_info(DUT$d,platform)]} {
                                <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> \
                                 &#34;$DUTs_info(DUT$d,platform) Platform Not supported by $MAIN(feature_directory):$platStr&#34;
                                set MAIN(NOFEATSUPPORT) 1
                            }
                        }
                    }
                }
            }
        }
    };<span class="comment-line"># End the non test link TCL skip check</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line">#  Cleanup and exit main.tcl for features that are not supported</span>
<span class="comment-line">#  on this test bed</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
    
    if {$MAIN(NOFEATSUPPORT)} {
        if {![info exists DUTs_info(DUT1,version)] || $DUTs_info(DUT1,version) == &#34;INVALID&#34;} {
            <a name="::_init_All_DUTs_info(1)"><a href="./iMainLib.tcl.html#::_init_All_DUTs_info_148">::_init_All_DUTs_info</a></a>;<span class="comment-line"># Real switch info needed to run so we need to connect to duts and gather</span>
        }
        puts &#34;!!\n!!\nThe completetests.lst is configured to skip this feature on this platform\n!!\n!!&#34;
        ;<span class="comment-line"># Setup Durations with a not covered feature</span>
        set tSetupStart [clock seconds]
        set tSetupDuration [expr $tSetupStart - $tStartTime]
        set MAIN(tSetupDuration) $tSetupDuration

        <a name="::::_initCompleteTests(1)"><a href="./tests_to_exec.tcl.html#::::_initCompleteTests_6">::::_initCompleteTests</a></a> -regPath $MAIN(regPath) -module $modName \
             -version $DUTs_info(DUT1,version) -platform $DUTs_info(DUT1,platform) \
             -lst $lst
        <span class="comment-line">#CTLIST(quick_pass_all_dev)</span>
        if ([info exists CTLIST($LSTGROUPING($lst))]) {
            if {[set fd_main_skip [open &#34;[<a name="::get_result_dir(3)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/skipTestsList.txt&#34;\
            &#34;w&#34;]] == -1} {
                return -1
            }
            set MAIN(MAKESKIPRESULTFILE) 1;<span class="comment-line"># create the tc.txt result files and put entries in report.txt</span>
            foreach st $CTLIST($LSTGROUPING($lst)) {
                if {[regexp -nocase &#34;init|end&#34; $st]} {
                    continue;
                }
                if {[catch {eval $st} tc]} {
                } else {
                    puts $fd_main_skip &#34;$tc&#34;
                }
            }
            set MAIN(MAKESKIPRESULTFILE) 0
            close $fd_main_skip
        }
        <a name="::imain_prompt(1)"><a href="./iMainLib.tcl.html#::imain_prompt_98">::imain_prompt</a></a> -id &#34;Skip feature $modName stopping in imain&#34;
    }
<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line"># END of CLEANUP FOR FEATURES NOT SUPPORTED ON THIS TEST BED</span>
<span class="comment-line"># --------------------------------------------------------------------</span>

<span class="comment-line"># --------------------------------------------------------------------</span>
<span class="comment-line"># Continue for supported fetures.</span>
<span class="comment-line"># --------------------------------------------------------------------</span>
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># MODE auto,autodev,dev Init Setup</span>
    <span class="comment-line">############################################################</span>
    set MAIN(initFile) [<a name="::::GetInitFileName(1)"><a href="./SystemSetup.tcl.html#::::GetInitFileName_2846">::::GetInitFileName</a></a> $curAutoRoot $cfg]
    <span class="comment-line"># -- MAIN(runMode) &gt; 0 check for the init and verify source of init</span>
    <span class="comment-line">#    If this fails, change to MAIN(runMode) 0 and create a new initFile</span>
    <span class="comment-line">#    source the init file with VerifyInitFile</span>
    if {($MAIN(runMode) &gt;= 1) &amp;&amp; (![file exists $MAIN(initFile)]) || \
        ($MAIN(runMode) &gt;= 1 &amp;&amp; ![<a name="::::VerifyInitFile(1)"><a href="./SystemSetup.tcl.html#::::VerifyInitFile_2823">::::VerifyInitFile</a></a> $MAIN(initFile)])} {
        puts &#34;\n@\n@\nInit check failed\n@\n@&#34;
        set MAIN(runMode) 0
    }
    if {$MAIN(runMode) == 0} {
        catch {open $MAIN(initFile) &#34;w&#34;} MAIN(ifPipe)
        if {[regexp -nocase &#34;denied&#34; $MAIN(ifPipe)]} {
            puts &#34;@\n@\nNO INIT FILE WILL BE CREATED. ERROR OPENING FILE\n@\n@&#34;
            set MAIN(ifPipe) NULL
        }        
    }
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># --- Take ownership of the traffic generator</span>
    <span class="comment-line">############################################################</span>
    <span class="comment-line"># If SPIRENTCH1 exists in the config file... Assume stc run.</span>
    if {[info exists ixiaCh1] &amp;&amp; [info exists SPIRENTCH1] &amp;&amp; $ixiaCh1 == &#34;NO_IXIA&#34;} {
        set TrafficGen stc
    }
    switch -exact -- $TrafficGen {
        stc {
            set env(IXIA_HOME) &#34;&#34;
            <span class="comment-line">#set ::_DEBUG 0</span>
            set ::LABSERVER $stcLabserver($SPIRENTCH1)
            lappend auto_path &#34;/auto/ixia_5_70/lib/mpexpr-1.1/&#34;
            <a name="::::overWriteProcs(1)"><a href="./stc.tcl.html#::::overWriteProcs_95">::::overWriteProcs</a></a> $LIB_PATH [file join $LIB_PATH spirent]
            source [file join $LIB_PATH ePTLib ePTUtils.tcl]
            <a name="::logcmd(1)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> set auto_path [linsert $auto_path 0 $stcPath($SPIRENTCH1)]
            <a name="::stcInit(1)"><a href="./spirent.tcl.html#::stcInit_11">::stcInit</a></a> $LABSERVER
            package require Mpexpr
            puts &#34;\n\nPackage Require SpirentTestCenter - Ch:$SPIRENTCH1 LS:$LABSERVER&#34;
            <a name="::logcmd(2)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> package require SpirentTestCenter
            <a name="::GenerateDUTPortMapping(1)"><a href="./ePTPortMapping.tcl.html#::GenerateDUTPortMapping_217">::GenerateDUTPortMapping</a></a>; <span class="comment-line"># Add here temporarily b/c called in SystemSetup</span>
            set returnFlag &#34;connectionOkay&#34;
            <a name="::ReservePorts(1)"><a href="./spirent.tcl.html#::ReservePorts_67">::ReservePorts</a></a>
            set MAIN(IxInitialized) 1;set MAIN(skipIxInit) 0; set MAIN(IxiaReady) 1;
        }
        ixia -
        ixvm {
            if {[<a name="::shareDevInit(1)"><a href="./SetupShareLib.tcl.html#::shareDevInit_19">::shareDevInit</a></a>] == -1} {
                set returnFlag &#34;connectionBad&#34;
                <a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34; IXIA Reservation FAILED&#34;
            } else {
                set MAIN(IxInitialized) 1
                <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34; IXIA Reservation OK&#34;
    <span class="comment-line"># move this</span>
                if {[file exists &#34;license.lst&#34;]} {
                    source &#34;./license.lst&#34;
                    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;license.lst file found. sourcing the contents&#34;
                }
            }
        }
        ept {
        }
        default {
        }
    }
<span class="comment-line"># ----------------------------------------------------------------------------</span>
<span class="comment-line">#   Start the run.</span>
<span class="comment-line">#   - run setup script for auto and autodev</span>
<span class="comment-line">#   - get DUTs info if auto mode</span>
<span class="comment-line">#   - checkConnections</span>
<span class="comment-line"># ---------------------------------------------------------------------------</span>
    if {($MAIN(runMode) != &#34;2&#34;)} {
        <span class="comment-line"># ----  NOT dev mode, unc sw will happen, create default.xsf ----</span>
        if {[info exists DEFAULT_XSF_AUTO_CREATE] &amp;&amp; $DEFAULT_XSF_AUTO_CREATE} {
            <a name="::_setShowOutput(3)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt off
            <a name="::MultiTask(3)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $makeXsfList
            <a name="::_setShowOutput(4)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
        }
        <span class="comment-line"># ----  Execute the setup script from bottom of cfg file  ----</span>
        set runSetupRetVal [<a name="::::_multiRunSetupScript(1)"><a href="./swConf.tcl.html#::::_multiRunSetupScript_442">::::_multiRunSetupScript</a></a>]

        if {$runSetupRetVal==-1} {
            puts stderr &#34;testSkipped&#34;
            if {[set fd_main_skip [open &#34;[<a name="::get_result_dir(4)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a>]/skipTestsList.txt&#34;\
            &#34;w&#34;]] == -1} {
                return -1
            }
            puts $fd_main_skip &#34;FeatureSkipped&#34;
            close $fd_main_skip
            return -1
        } elseif { $runSetupRetVal==&#34;REGROUTER_FAILED&#34; } {
            puts stderr $returnFlag
            flush stderr
            return $runSetupRetVal
        }

        <span class="comment-line">#added following definition to aid per module report-mailing</span>
        global DUTs_info

        set DUTs_info(current_module) $module

        <span class="comment-line">#Capture the number of DUT for the MAIN(ifPipe) setup file</span>
        if {$MAIN(ifPipe) != &#34;NULL&#34;} {
            puts $MAIN(ifPipe) &#34;set numDUT $numDUT&#34;
        }

        if {$MAIN(runMode) == 0} {
            global eware_dut
            set dutlst &#34;&#34;

            if {[set rc [<a name="::::get_DUTs_info(1)"><a href="./swConf.tcl.html#::::get_DUTs_info_881">::::get_DUTs_info</a></a>]] != 0} {
                <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error $rc while calling get_DUTs_info.&#34;;
                <a name="::close_result_file(3)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>;
                return -2;
            }

        }
    }

    ;<span class="comment-line"># Setup Durations with a covered feature</span>
    set tSetupStart [clock seconds]
    set tSetupDuration [expr $tSetupStart - $tStartTime]
    set MAIN(tSetupDuration) $tSetupDuration
    set tCheckConnectionDuration 0

    <span class="comment-line">#############################################################################</span>
    <span class="comment-line"># Verify the test bed connections and gather port variables</span>
    <span class="comment-line">#############################################################################</span>
    <span class="comment-line">#  Skip SystemSetup if &#34;autodev&#34; or &#34;dev&#34; are selected</span>
    if {$MAIN(runMode) == 0 &amp;&amp; ![regexp -nocase &#34;^../clitest&#34; $regPath]} {
        <span class="comment-line"># added for checkConnection overRide if necessary</span>
        if {$cc != &#34;&#34;} {
            set checkConnection $cc;
        }

        switch -exact -- $TrafficGen {
            stc {
                set returnFlag [<a name="::::SystemSetup(1)"><a href="./SystemSetup.tcl.html#::::SystemSetup_16">::::SystemSetup</a></a>]
                set tCheckConnectionDuration [expr [clock seconds] - $tSetupStart]
                set MAIN(tCheckConnectionDuration) $tCheckConnectionDuration
            }
            ixia -
            ixvm {
                if {[info exists ixiaCh1]} {
                    if {![regexp -nocase &#34;no_ixia&#34; $ixiaCh1]} {
                        set returnFlag [<a name="::::SystemSetup(2)"><a href="./SystemSetup.tcl.html#::::SystemSetup_16">::::SystemSetup</a></a>]
                        set tCheckConnectionDuration [expr [clock seconds] - $tSetupStart]
                        set MAIN(tCheckConnectionDuration) $tCheckConnectionDuration
                    } else {
                        set returnFlag connectionOkay
                    }
                } else {
                    set returnFlag connectionOkay
                }
            }
            default {
                <span class="comment-line"># no test equipment selected, assume connection OK</span>
                set returnFlag connectionOkay
            }
        }
    } else {
        if {$MAIN(runMode)==0 &amp;&amp; $MAIN(ifPipe) != &#34;NULL&#34;} {
            close $MAIN(ifPipe);
            set MAIN(ifPipe) &#34;NULL&#34;
        }
        source $MAIN(initFile); <span class="comment-line"># Get all test bed variables from the main/Tmp/DUTsINFO tmp file</span>
        set returnFlag connectionOkay
        foreach dut $MAIN(DUTLIST) {
            set connect [set DUT${dut}_CONNECT]
            <a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $connect -CheckOperational 0
            set buf [<a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear log st&#34;]  ;<span class="comment-line"># Check if MSM is backup, abort</span>
            set backupStr &#34;Error: This command can only be executed on Master&#34;
            if {[regexp -nocase $backupStr $buf]} {
                <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Backup encountered, aborting&#34;
                return -1
            }
            
            <span class="comment-line"># set correct time</span>
            set tm [exec date &#34;+%m %d %Y %H %M %S&#34;]
            set timeCmd &#34;configure time &#34;
            append timeCmd $tm
            <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> $timeCmd
            
            <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable clipa&#34;
            <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable idletime&#34;
            <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable edp ports all&#34;
            <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;con edp advertisement-interval 60 holddown-interval 180&#34;
            <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure default delete port all&#34;
            <a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable stp s0&#34;
            if {[<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${dut}] 22.2.0.26]&gt;=0} {
                <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure cli column 248&#34;
            }
            global DUTs_info bcmStackable bcmPlatform
            if {[info exists DUTs_info(DUT${dut},coreFileTarget)]} {
                <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure debug core-dumps $DUTs_info(DUT${dut},coreFileTarget)&#34;
            }
        }
        switch -exact -- $TrafficGen {
            stc {
                <span class="comment-line">#smallStcInit</span>
            }
            ixia -
            ixvm {
                if {$ixiaCh1 != &#34;NO_IXIA&#34;} {
                    if {!$MAIN(skipIxInit)} {
                        <a name="::::smallIxiaInit(1)"><a href="./swConf.tcl.html#::::smallIxiaInit_1778">::::smallIxiaInit</a></a>
                    }
                }
            }
            ept {
            }
            default {
            }
        }
    }
    if {$MAIN(ifPipe) != &#34;NULL&#34;} {
       flush $MAIN(ifPipe)
    }
<span class="comment-line"># ---------------------------------------------------------------------------------</span>
<span class="comment-line"># End of Variable Gathering and CheckConnections</span>
<span class="comment-line"># ---------------------------------------------------------------------------------</span>
    if {$returnFlag == &#34;connectionBad&#34;} {
        set tEndTime [clock seconds]
        set MAIN(MainDuration) [expr $tEndTime-$tStartTime]

        <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n*** Time for [file tail [pwd]] Regression test = $MAIN(MainDuration) seconds&#34;
        <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;***    ( [formatSeconds $MAIN(MainDuration)] )\n\n&#34;

        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <span class="comment-line"># Move the execution to the final request.</span>
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        set returnFlag [lindex $returnFlag 0]
        <a name="::_cleanAndStoreResults(1)"><a href="./maincleanup.tcl.html#::_cleanAndStoreResults_2">::_cleanAndStoreResults</a></a> -returnFlag $returnFlag

        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <span class="comment-line"># Print to stderr so any tracking wrapper can make decisions</span>
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        puts stderr $returnFlag
        flush stderr
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <span class="comment-line"># Module mode of main.tcl runs regressions from with the feature dir</span>
        <span class="comment-line">#    Return to main directory</span>
        <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <a name="::close_result_file(4)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
        puts &#34;Made it to the feature end - location [pwd]&#34;
        cd $MAIN(mainPath)
        puts &#34;Made it to the end of main - location [pwd]&#34;
        exit;
    }

<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Create debug cli procedure and source commands</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>
CalculateDebug $modName $showErrorData;
<span class="comment-line"># -----------------------------------------------------------------------</span>
<span class="comment-line"># Figure out what tests to run</span>
<span class="comment-line"># -----------------------------------------------------------------------</span>

if { $retFlag != &#34;testSkipped&#34; } {
    if {![info exists tests_to_run]} {
        set fName &#34;&#34;

        ;<span class="comment-line"># Go to the CLITest/&lt;module&gt; directory to source completetests.lst</span>
        set curDir [pwd]
        if [regexp -nocase &#34;CLItest&#34; $curDir] {
            puts &#34;Temporily changing directory to  ../../$clitestDir/$modName&#34;
            cd ../../$clitestDir/$modName
        } 
        set testsToRun [calculateTestToRun $lst [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]]
        array set init_tests_to_run $testsToRun
        array set tests_to_run $testsToRun

        ;<span class="comment-line"># Go back to old directory</span>
        cd $curDir

    } else {
        ;<span class="comment-line"># Zero out so we don't try to generate execution times</span>
        set lst &#34;none&#34;
    }

    <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DEBUG PRINTING -- tests to run [parray tests_to_run]&#34;

    <a name="::::AddTestbedInfoToDUTs_info(1)"><a href="./SystemSetup.tcl.html#::::AddTestbedInfoToDUTs_info_905">::::AddTestbedInfoToDUTs_info</a></a>;

    <span class="comment-line">#only start test if connections checked to be okay</span>
    <span class="comment-line">#then eval each tests_to_run array var based on version index</span>

    if { $returnFlag == &#34;connectionOkay&#34; } {
        set testtorunNo 1
        ;<span class="comment-line"># create the reportdir.txt filedirectory</span>
        <a name="::create_report_directory(1)"><a href="./result.tcl.html#::create_report_directory_890">::create_report_directory</a></a> $sourceFile no $optionalPath &#34;&#34; $subversion $qId

        set what [<a name="::::GetCleanTestList(1)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> dev]
        set verList [<a name="::::GetVerSkipList(1)"><a href="./tpbMainLib.tcl.html#::::GetVerSkipList_98">::::GetVerSkipList</a></a> dev]
        puts &#34;*****\n*****ALL:\n$what\n*****\n*****&#34;
        puts &#34;*****\n*****VERSKIP:\n$verList\n*****\n*****&#34;
        set mydev [<a name="::::GetCleanTestList(2)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> devonly]
        puts &#34;*****\n*****DEVONLY:\n$mydev\n*****\n*****&#34;
        set mydebug [<a name="::::GetCleanTestList(3)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> debugonly]
        puts &#34;*****\n*****DEBUGONLY:\n$mydebug\n*****\n*****&#34;

        set elist &#34;&#34;
        if {[file isfile license.lst] &amp;&amp; \
            [regexp $bcmLynx $DUTs_info(DUT1,platform)]} {
            source license.lst
            foreach edgetc $license_to_run(edge) {
                lappend elist $edgetc
            }
            puts &#34;Found EDGE: $elist&#34;
        }
        set ALLPLATTESTS $what
        set ALLPLATDEV $mydev
        set ALLPLATDEBUG $mydebug
        set ALLPLATEDGE $elist
        set SKIPVERTESTS $verList
        set currInit &#34;&#34;
        set currEnd &#34;&#34;
        set hitPair 0
        set numInit &#34;A&#34;
        set numEnd &#34;B&#34;
        foreach w $what {
            if {[regexp -nocase &#34;init&#34; $w]} {
                if {!$hitPair} {
                    set currInit &#34;&#34;
                    set numInit &#34;&#34;
                    set currEnd &#34;&#34;
                    set numEnd &#34;&#34;
                }
                regsub -all &#34;\.init&#34; $w &#34;&#34; myInit
                set currInit $w
                set numInit $myInit
            }
            if {[regexp -nocase &#34;end&#34; $w]} {
                regsub -all &#34;\.end&#34; $w &#34;&#34; myEnd
                set currEnd $w
                set numEnd $myEnd
            }
            if {$numEnd == $numInit} {
                set initEndScript($currInit) $currEnd
                set INITBYENDSCRIPT($currEnd) $currInit
                set currInit &#34;&#34;
                set numInit &#34;&#34;
                set currEnd &#34;&#34;
                set numEnd &#34;&#34;
                set hitPair 1
            }
        }
        set currInit &#34;NULL&#34;
        set currEnd &#34;&#34;
        foreach w $what {
            if {[regexp -nocase &#34;init&#34; $w]} {
                set currInit $w
            } elseif {[regexp -nocase &#34;end&#34; $w]} {
                set currInit NULL
            } else {
                if {[info exists initEndScript($currInit)]} {
                   set blockEnd $initEndScript($currInit)
                } else {
                   set blockEnd &#34;NULL&#34;
                }
                set TESTPRE($w) $currInit
                set TESTPOST($w) $blockEnd
            }
        }
        set useSocket 0
        if {$trackport != &#34;null&#34;} {
            set useSocket 1
        }
        set MAIN(startexecution) 1

    <span class="comment-line"># -----------------------------------------------------------------------------</span>
    <span class="comment-line">#</span>
    <span class="comment-line">#     Start the imain prompt</span>
    <span class="comment-line">#</span>
    <span class="comment-line"># -----------------------------------------------------------------------------</span>
        <span class="comment-line">##########################################################</span>
        <span class="comment-line"># ---- Open the main.txt result file to hold init dut learn</span>
        <span class="comment-line">##########################################################</span>
        set fd_res [<a name="::open_result_file(4)"><a href="./result.tcl.html#::open_result_file_276">::open_result_file</a></a> &#34;imain&#34;]
        result_h1 &#34;[file tail [pwd]] Test&#34;


        if {![file exists /tmp/imain/$env(USER)_imain_history.txt]} {
            puts &#34;Creating $env(USER) history file&#34;
            set hfile [open &#34;/tmp/imain/$env(USER)_imain_history.txt&#34; &#34;w&#34;]
        } else {
            <span class="comment-line">#set hfile [open &#34;/tmp/imain/$env(USER)_imain_history.txt&#34; &#34;r+&#34;]</span>
        }
        fconfigure stdin -blocking 1
        while {1} {
            puts -nonewline &#34;dev&gt; &#34;
            flush stdout;
            set intC [gets stdin]
            <span class="comment-line">#puts $hfile &#34;$intC&#34;</span>
            <a name="::_writeToIHist(1)"><a href="./iMainLib.tcl.html#::_writeToIHist_66">::_writeToIHist</a></a> &#34;$intC&#34;
            set stat [catch {eval $intC} cout]
            if {$stat} {
                puts &#34;There was a tcl error $cout&#34;
                <a name="::_imainErrorHelp(1)"><a href="./iMainLib.tcl.html#::_imainErrorHelp_189">::_imainErrorHelp</a></a> $cout
            } else {
                puts &#34;\n$cout&#34;
            }
        }
    }
} else {
    puts &#34;You got a test skipped... I don't think you wanted this.&#34;
}
set tEndTime [clock seconds]
set MAIN(MainDuration) [expr $tEndTime-$tStartTime]

<a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n\n*** Time for [file tail [pwd]] Regression test = $MAIN(MainDuration) seconds&#34;
<a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;***    ( [formatSeconds $MAIN(MainDuration)] )\n\n&#34;

<span class="comment-line"># -----------------------------------------------------------------------------</span>
<span class="comment-line"># Move the execution to the final request.</span>
<span class="comment-line"># -----------------------------------------------------------------------------</span>
set returnFlag [lindex $returnFlag 0]
<a name="::_cleanAndStoreResults(2)"><a href="./maincleanup.tcl.html#::_cleanAndStoreResults_2">::_cleanAndStoreResults</a></a> -returnFlag $returnFlag

<span class="comment-line"># -----------------------------------------------------------------------------</span>
<span class="comment-line"># Print to stderr so any tracking wrapper can make decisions</span>
<span class="comment-line"># -----------------------------------------------------------------------------</span>
puts stderr $returnFlag
flush stderr
<span class="comment-line"># -----------------------------------------------------------------------------</span>
<span class="comment-line"># Module mode of main.tcl runs regressions from with the feature dir</span>
<span class="comment-line">#    Return to main directory</span>
<span class="comment-line"># -----------------------------------------------------------------------------</span>
<a name="::close_result_file(5)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
puts &#34;Made it to the feature end - location [pwd]&#34;
cd $MAIN(mainPath)
puts &#34;Made it to the end of main - location [pwd]&#34;
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
