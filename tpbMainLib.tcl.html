<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>tpbMainLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#tpbMainLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>tpbMainLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="tpbMainLib.tcl-annot.html">annotations</a> | <a href="tpbMainLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">#</span>
<span class="comment-line"># tpb test login stuff</span>
<span class="comment-line">#</span>
<strong><a name="::::logout_dutnum_4">proc <a href="tpbMainLib.tcl-annot.html#::::logout_dutnum">::::logout_dutnum</a></a></strong><a name="::::logout_dutnum"></a> {dut {mm &#34;&#34;}} {
    global DUT${dut}_CONNECT
    if {$mm != &#34;&#34;} {
        global DUT${dut}_CONNECT$mm
    }

    if {[info exists DUT${dut}_CONNECT${mm}]} {
        set connect [set DUT${dut}_CONNECT${mm}]
        <a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $connect -CheckOperational 0
        <a name="::logout(1)"><a href="./logout.tcl.html#::logout_21">::logout</a></a>
    }
}
<strong><a name="::::logout_alldut_16">proc <a href="tpbMainLib.tcl-annot.html#::::logout_alldut">::::logout_alldut</a></a></strong><a name="::::logout_alldut"></a> {} {
    set nDUT 1
    for {set x 1} {$x&lt;30} {incr x} {
        global DUT${x}_CONNECT
        global DUT${x}_CONNECTB
    }
    while { [info exists DUT${nDUT}_CONNECT] } {
        lappend procList &#34;logout_dutnum ${nDUT}&#34;
        if {[info exists DUT${nDUT}_CONNECTB]} {
            lappend procList &#34;logout_dutnum ${nDUT} B&#34;
        }
        incr nDUT 1
    }
    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\n@@@\n@@@Calling MultiTask To Logout of ALL DUTs\n@@@\n$procList\n@@@&#34;
    <a name="::MultiTask(1)"><a href="./multiTask.tcl.html#::MultiTask_39">::MultiTask</a></a> $procList

}
<span class="comment-line">####################################################################</span>
<span class="comment-line"># proc GetCleanTestList</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">####################################################################</span>
<strong><a name="::::GetCleanTestList_38">proc <a href="tpbMainLib.tcl-annot.html#::::GetCleanTestList">::::GetCleanTestList</a></a></strong><a name="::::GetCleanTestList"></a> {lst} {
    global DUTs_info
    if {![info exists DUTs_info(DUT1,version)]} {
        set DUTs_info(DUT1,version) 50.1.1.1
    }
    set testsToRun [calculateTestToRun $lst [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]]
    array set tests_to_run $testsToRun
    <span class="comment-line">#build a list of all test cases that will run</span>
    if { [array size tests_to_run] == 0 } {
        ;<span class="comment-line"># Convert old list style to array</span>
        if {[string trim $testsToRun] == &#34;&#34;} {
            set tempList &#34;&#34;
        } else {
            set tempList $tests_to_run
            unset tests_to_run
        }
        set tests_to_run(all) $tempList
        puts &#34;set tests_to_run(all) $tempList&#34;
    }

    set testtorunNo 1

    ;<span class="comment-line"># Array of tests_to_run() lists. i.e. tests_to_run(all), tests_to_run(7.0),etc.</span>
    set indexList [array names tests_to_run]
    mainSort indexList

    set what &#34;&#34;
    foreach arrayIndex $indexList {
        set ver [string tolower $arrayIndex]
        if { (&#34;$ver&#34; == &#34;all&#34;) || (&#34;$ver&#34; == &#34;null&#34;) \
              || [<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> $ver [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 ]] &lt;= 0 } {
            set mytests [string trim $tests_to_run($ver)]
            regsub -all &#34;\n&#34; $mytests &#34;zzz&#34; mytests
            set myTestList [split $mytests &#34;zzz&#34;]
            foreach myNewTest $myTestList {
                set myTrimTest [string trim $myNewTest]
                set myTrimTest [string trim $myTrimTest &#34;;&#34;]
                if {$myTrimTest != &#34;&#34;} {
                    set lineList [split $myTrimTest &#34;#&#34;]
                    if {[llength $lineList] &gt;=2} {
                        set l [lindex $lineList 0]
                        regsub -all &#34;;&#34; $l &#34;&#34; myTrimTest
                        set myTrimTest [string trim $myTrimTest]
                    }
                    if {$myTrimTest != &#34;&#34;} {
                        lappend what &#34;$myTrimTest&#34;
                    }
                }
            }
        } else {
            puts &#34;\n======\n======\nNOTHING MATCHED FOR $ver\n======\n======&#34;
        }
    }
    return $what
}
<span class="comment-line">####################################################################</span>
<span class="comment-line"># proc GetVerSkipList </span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">####################################################################</span>
<strong><a name="::::GetVerSkipList_98">proc <a href="tpbMainLib.tcl-annot.html#::::GetVerSkipList">::::GetVerSkipList</a></a></strong><a name="::::GetVerSkipList"></a> {lst} {
    set testsToRun [calculateTestToRun $lst [<a name="::GetPlatform(2)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]]
    array set tests_to_run $testsToRun
    <span class="comment-line">#build a list of all test cases that will run</span>
    if { [array size tests_to_run] == 0 } {
        ;<span class="comment-line"># Convert old list style to array</span>
        set tempList $tests_to_run
        unset tests_to_run
        set tests_to_run(all) $tempList
        puts &#34;set tests_to_run(all) $tempList&#34;
    }

    set testtorunNo 1

    ;<span class="comment-line"># Array of tests_to_run() lists. i.e. tests_to_run(all), tests_to_run(7.0),etc.</span>
    set indexList [array names tests_to_run]
    mainSort indexList

    set what &#34;&#34;
    foreach arrayIndex $indexList {
        set ver [string tolower $arrayIndex]
        if { (&#34;$ver&#34; != &#34;all&#34;) &amp;&amp; (&#34;$ver&#34; != &#34;null&#34;) &amp;&amp; [string trim $ver] != &#34;&#34; \
              &amp;&amp; [<a name="::CompareRelease(2)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> $ver [<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT1 ]] &gt; 0 } {
            set mytests [string trim $tests_to_run($ver)]
            regsub -all &#34;\n&#34; $mytests &#34;zzz&#34; mytests
            set myTestList [split $mytests &#34;zzz&#34;]
            foreach myNewTest $myTestList {
                set myTrimTest [string trim $myNewTest]
                set myTrimTest [string trim $myTrimTest &#34;;&#34;]
                if {$myTrimTest != &#34;&#34;} {
                    set lineList [split $myTrimTest &#34;#&#34;]
                    if {[llength $lineList] &gt;=2} {
                        set l [lindex $lineList 0]
                        regsub -all &#34;;&#34; $l &#34;&#34; myTrimTest
                        set myTrimTest [string trim $myTrimTest]
                    }
                    if {$myTrimTest != &#34;&#34;} {
                        lappend what &#34;$myTrimTest&#34;
                    }
                }
            }
        }
    }
    return $what
}
<span class="comment-line">####################################################################</span>
<span class="comment-line"># proc GetEndArray</span>
<span class="comment-line">#</span>
<span class="comment-line"># return an array of endProcByInitProc(initProc) endProc</span>
<span class="comment-line">####################################################################</span>
<strong><a name="::::GetEndArray_148">proc <a href="tpbMainLib.tcl-annot.html#::::GetEndArray">::::GetEndArray</a></a></strong><a name="::::GetEndArray"></a> {allCTProcs} {
   set endByInit(a) -1
   set initIndexList [lsearch -all -regexp $allCTProcs init]
   set endIndexList [lsearch -all -regexp $allCTProcs end]
   set hit 0
   <span class="comment-line"># -----------------------------------------------------</span>
   <span class="comment-line"># Find init and end pairs</span>
   <span class="comment-line"># -----------------------------------------------------</span>
   foreach i $initIndexList {
       set endByInit($i) -1
       set iVal [lindex $allCTProcs $i]
       regsub -all &#34;\.init&#34; $iVal &#34;&#34; iVal
       foreach e $endIndexList {
           if {$e &lt;= $i} {
               continue;
           }
           set eVal [lindex $allCTProcs $e]
           regsub -all &#34;\.end&#34; $eVal &#34;&#34; eVal
           if {$iVal == $eVal &amp;&amp; !$hit} {
               set hit 1
               set endByInit($i) &#34;$e&#34;
               <span class="comment-line">#puts &#34;pair: $iVal == $eVal  index: $i $e&#34;</span>
           }
           unset eVal
       }
       unset iVal
       if {!$hit} {
           set endByInit($i) -1
       }
       set hit 0
   }
   return [array get endByInit]
}
<span class="comment-line">####################################################################</span>
<span class="comment-line"># proc GetTestCaseCTListArrays</span>
<span class="comment-line">#</span>
<span class="comment-line"># upvar arrays initByProc endByProc procsByInit</span>
<span class="comment-line">#    initByProc(1.1.1) 1.init</span>
<span class="comment-line">#    endByProc(1.1.1) 1.end</span>
<span class="comment-line">#    procsByInit(1.init) &#34;1.1.1 1.1.2 1.1.3 1.1.4 1.1.5 1.1.6 1.1.7 ....&#34;</span>
<span class="comment-line">####################################################################</span>
<strong><a name="::::GetTestCaseCTListArrays_189">proc <a href="tpbMainLib.tcl-annot.html#::::GetTestCaseCTListArrays">::::GetTestCaseCTListArrays</a></a></strong><a name="::::GetTestCaseCTListArrays"></a> {allCTProcs initByProc endByProc procsByInit} {

   upvar initByProc iByProc
   upvar endByProc eByProc
   upvar procsByInit pByInit
   array set endByInit [<a name="::::GetEndArray(1)"><a href="./tpbMainLib.tcl.html#::::GetEndArray_148">::::GetEndArray</a></a> $allCTProcs]
   set initIndexList [lsearch -all -regexp $allCTProcs init]
   set endIndexList [lsearch -all -regexp $allCTProcs end]
   if {[lsearch $allCTProcs &#34;1.init&#34;] &gt;= 0} {set hit1Init 1} else {set hit1Init 0}
   set hitSomething 0
   set noEnd 0
   set top [llength $allCTProcs]
   set pByInit(A) &#34;&#34;
   set lastUsedIndex -1
   for {set a 0} {$a&lt;$top} {incr a} {
       foreach i $initIndexList {
           if {$a &gt; $i &amp;&amp; $a &lt; $endByInit($i)} {
               if {[lsearch $endIndexList $a] &lt; 0 &amp;&amp; [lsearch $initIndexList $a] &lt; 0} {
                   if {![info exists iByProc([lindex $allCTProcs $a])]} {
                       set iByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $i]
                   } else {
                       lappend iByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $i]
                   }
                   if {![info exists eByProc([lindex $allCTProcs $a])]} {
                       set eByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $endByInit($i)]
                   } else {
                       lappend eByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $endByInit($i)]
                   }
                      <span class="comment-line"># puts &#34;iByProc([lindex $allCTProcs $a]) $iByProc([lindex $allCTProcs $a]) \</span>
                      <span class="comment-line">#        eByProc([lindex $allCTProcs $a]) $eByProc([lindex $allCTProcs $a])&#34;</span>
                   if {[info exists pByInit([lindex $allCTProcs $i])]} {
                       lappend pByInit([lindex $allCTProcs $i]) [lindex $allCTProcs $a]
                   } else {
                        set pByInit([lindex $allCTProcs $i]) [lindex $allCTProcs $a]
                   }
                   set hitSomething 1
                   set hitEnd 0
                   set lastUsedIndex $i
               }
           } elseif {$a &gt; $i &amp;&amp; $endByInit($i) &lt; 0 &amp;&amp; [lindex $allCTProcs $i] != &#34;1.init&#34; &amp;&amp; \
                     $i &gt; $lastUsedIndex} {
               if {[lsearch $endIndexList $a] &lt; 0 &amp;&amp; [lsearch $initIndexList $a] &lt; 0} {
                   if {![info exists iByProc([lindex $allCTProcs $a])]} {
                       set iByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $i]
                   } else {
                       lappend iByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $i]
                   }
                   if {[info exists pByInit([lindex $allCTProcs $i])]} {
                       lappend pByInit([lindex $allCTProcs $i]) [lindex $allCTProcs $a]
                   } else {
                       set pByInit([lindex $allCTProcs $i]) [lindex $allCTProcs $a]
                   }
                   set noEnd 1
                   set lastUsedIndex $i
               }
           }
       }
       if {$noEnd} {
           set noEnd 0
           continue
       } elseif {$hitSomething &amp;&amp; [info exists eByProc([lindex $allCTProcs $a])]} {
           set eByProc([lindex $allCTProcs $a]) [lreverse $eByProc([lindex $allCTProcs $a])]
           set hitSomething 0
           continue
       } elseif {$lastUsedIndex &gt;= 0 &amp;&amp; $endByInit($lastUsedIndex) &lt; 0} {
           set iByProc([lindex $allCTProcs $a]) [lindex $allCTProcs $lastUsedIndex]
           if {[info exists pByInit([lindex $allCTProcs $lastUsedIndex])]} {
               lappend pByInit([lindex $allCTProcs $lastUsedIndex]) [lindex $allCTProcs $a]
           } else {
               set lappend pByInit([lindex $allCTProcs $lastUsedIndex]) [lindex $allCTProcs $a]
           }           
       } elseif {$hit1Init &amp;&amp; [lsearch $endIndexList $a] &lt; 0 &amp;&amp; [lsearch $initIndexList $a] &lt; 0} {
           set iByProc([lindex $allCTProcs $a]) &#34;1.init&#34;
           if {[info exists pByInit(1.init)]} {
               lappend pByInit(1.init) [lindex $allCTProcs $a]
           } else {
               set pByInit(1.init) [lindex $allCTProcs $a]
           }
       } else {
           <span class="comment-line">#puts &#34;No pre [lindex $allCTProcs $a]&#34;</span>
       }
       set hitSomething 0
   }
   return 1
}
<span class="comment-line">#################################################################################</span>
<span class="comment-line"># Gather proc info</span>
<span class="comment-line">#################################################################################</span>
<span class="comment-line"># procname</span>
<strong><a name="::::GetCurrentProcName_278">proc <a href="tpbMainLib.tcl-annot.html#::::GetCurrentProcName">::::GetCurrentProcName</a></a></strong><a name="::::GetCurrentProcName"></a> { } {
    return [lindex [split [info level [expr [info level] - 1]]] 0]
}
<span class="comment-line"># returns: the actual procname</span>

<span class="comment-line">#################################################################################</span>
<span class="comment-line"># Gather proc info</span>
<span class="comment-line">#################################################################################</span>
<span class="comment-line"># preprocname</span>
<strong><a name="::::PreProcName_287">proc <a href="tpbMainLib.tcl-annot.html#::::PreProcName">::::PreProcName</a></a></strong><a name="::::PreProcName"></a> { } {
    return [lindex [split [info level [expr [info level] - 2]]] 0]
}
<span class="comment-line"># returns: the name of the previous proc</span>
<span class="comment-line">#################################################################################</span>
<span class="comment-line"># Gather proc info</span>
<span class="comment-line">#################################################################################</span>
<span class="comment-line"># evaltree</span>
<strong><a name="::::ProcEvalTree_295">proc <a href="tpbMainLib.tcl-annot.html#::::ProcEvalTree">::::ProcEvalTree</a></a></strong><a name="::::ProcEvalTree"></a> { } {
    set result [list]
    set level [info level]
    incr level -1
    for { set i 1 } { $i &lt;= $level } { incr i 1 } {
        lappend result [lindex [info level $i] 0]
    }
    return $result
}
<span class="comment-line"># returns: a list with all previous and the actual procname; the calling proc is this first element</span>
<span class="comment-line">#################################################################################</span>
<span class="comment-line"># Main db checking proc and execution for TPB</span>
<span class="comment-line">#################################################################################</span>
<strong><a name="::::executeTestsToRunTPB_308">proc <a href="tpbMainLib.tcl-annot.html#::::executeTestsToRunTPB">::::executeTestsToRunTPB</a></a></strong><a name="::::executeTestsToRunTPB"></a> {tbf {useSocket 0}} {
    global numDUT TESTPRE TESTPOST
    global connect
    global script
    global debugStart
    global lastInit
    global origFailCount
    global failCount passCount skipCount
    global TestsRemaining
    global DUTs_info
    global licenseList
    global license_to_run
    global currentTestIndex
    global initFile
    global EX_REPORT_DATA_1
    global EX_REPORT_DATA
    global EX_REPORT_STATUS
    global TrafficGen
    global MGMT_REG
    global pID
    global qId
    global modName
    global regPath
    global randomIndex
    global passSubTestsArr auto_path
    global failSubTestsArr
    global skipSubTestsArr
    global ALLPLATTESTS
    global ALLPLATDEV
    global ALLPLATDEBUG
    global ALLPLATEDGE
    global SKIPVERTESTS
    global TPBRESULTLIST TPBRESULTVALUES
    global INITBYENDSCRIPT
    global MAIN FEATMAIN
    <span class="comment-line"># socket variables</span>
    global getjson getok initsend mySock ineed

    array set endByInit [<a name="::::GetEndArray(2)"><a href="./tpbMainLib.tcl.html#::::GetEndArray_148">::::GetEndArray</a></a> $ALLPLATTESTS]
    set res [<a name="::::GetTestCaseCTListArrays(1)"><a href="./tpbMainLib.tcl.html#::::GetTestCaseCTListArrays_189">::::GetTestCaseCTListArrays</a></a> $ALLPLATTESTS initByProc endByProc procsByInit]

    if {![info exists EX_REPORT_DATA]} {
        set EX_REPORT_DATA &#34;&#34;
    }
    set DBOK 1
    if {[catch {mysqlconnect -host otps -user user -password extreme -db tpb_queues} mysql_handler]} {
        set DBOK 0
    }
    set TestsRemaining $ALLPLATTESTS
    set TestsExecuted &#34;&#34;
    set resStr(1) &#34;PASS&#34;
    set resStr(0) &#34;FAIL&#34;
    set cTest &#34;&#34;
    set tpbRes 0
    set prevcase &#34;&#34;
    set currInit &#34;&#34;
    set init1Run 0
    set skipTheRest 0
    set skipFailTheRest 0
    set lastFailCount 0
    set tclCrashCount 0
    set TPBRESULTLIST &#34;&#34;
    set TPBRESULTVALUES &#34;&#34;
    set filesToUpload &#34;&#34;
    set filesToDownload &#34;&#34;
    set INITFilesExecuted &#34;&#34;
    set EndFilesExecuted &#34;&#34;
    set useSocket 1
    if {![info exists ineed]} {
        set ineed &#34;&#34;
    }
   
    <span class="comment-line"># Executiion Time File</span>
    set fdin_execTime [open $MAIN(timeFile) &#34;RDWR APPEND CREAT&#34;]
    ;<span class="comment-line"># Dump tests to run, so we can see what we intended to run.</span>
    flush $fdin_execTime
 
    while {$cTest != &#34;kill&#34; &amp;&amp; $cTest != &#34;killfinal&#34;} {
        <span class="comment-line"># Lists for building the elist</span>
        <span class="comment-line">#catch {mysqlconnect -host otps -user user -password extreme -db tpb_queues} mysql_handler</span>
        if {!$useSocket} {
             set cTestList [mysqlsel $mysql_handler &#34;SELECT mod_run_id, mod_current_test, tc_externalid, \
                                  dispatch_id FROM \
                                  tpb_modules WHERE queue_id = '$qId' \
                                  AND mod_dir = '$regPath' AND mod_name = '$modName' \
                                  ORDER By mod_run_id ASC&#34; -flatlist]
            puts &#34;@ Checking Database Cases - mod_dir $regPath mod_name $modName queue_id $qId @&#34;
            puts &#34;WAITING FOR TEST &lt;qid&gt;&#34;
            puts &#34;&#34;
            <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
            set disid &#34;[lindex $cTestList 3]&#34;
            set extid &#34;[lindex $cTestList 2]&#34;
            set cTest &#34;[lindex $cTestList 1]&#34;
            set mId [lindex $cTestList 0]
            <span class="comment-line"># prepare to pull all run directories after killfinal</span>
            set tList [split $cTest &#34; &#34;]
            set cTest [lindex $tList 0]
            set mods [lrange $tList 1 end]
            puts &#34;cTest value = $cTest mods $mods&#34;
            puts $tbf &#34;Used Database&#34;
        } else {
            set timeStart [clock seconds];
            <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Using TPB Socket Control Waiting for a Client to Send in test cases&#34;
            vwait getmyjson
            puts &#34;RX: $ineed&#34;
            set ineed [string trim $ineed]
            if {![regexp -nocase &#34;(sock\[0-9]+)\=(\{\&#34;\[a-zA-Z]+\&#34;: *\{\&#34;\[a-zA-Z_\-]+\&#34;:\&#34;\[a-zA-Z0-9_&amp;\-]+\&#34;.*\}\})$&#34; \
                          $ineed ignore s j]} {
                puts &#34;JSON not correctly formatted&#34;;
                set ts [lindex [split $ineed &#34;=&#34;] 0];
                <a name="::handleOutput(1)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $ts &#34;JSON Format Error:&#34;
                set bjson [lindex [split $ineed &#34;=&#34;] 1];
                <a name="::handleOutput(2)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $ts &#34;$bjson&#34;
                <a name="::handleOutput(3)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $ts &#34;SWITCHING TO DB MODE&#34;
                set useSocket 0;
                if {$DBOK} {
                    puts $tbf &#34;Used Socket Failed Going to DB&#34;
                    return testCompleted
                    continue;
                } else {
                    puts $tbf &#34;Used Socket Failed AND DB Failed&#34;
                    return SOCK_DB_FAIL
                }
            } else {
                puts $tbf &#34;Used Socket Response from TPB Received&#34;
                puts &#34;Response from TPB Recieved&#34;;
                set mySock $s
                <span class="comment-line">#puts &#34;JSON = $j&#34;</span>
                set parsed [json::json2dict $j]
                puts $parsed
                foreach {key val} $parsed {
                    foreach {key val} $val {
                        set case($key) $val
                    }
                }
                set mQId $case(queue_id);
                set Module $case(mod_name);
                set testDir $case(mod_dir);
                set cTest $case(mod_current_test);
                set extid $case(tc_externalid);
                set disid $case(dispatch_id);
                set tpbTime $case(time);
                set mods $Module
                set vList [list &#34;queue_id&#34; &#34;$mQId&#34; &#34;mod_name&#34; &#34;$Module&#34; &#34;mod_dir&#34; &#34;$testDir&#34; \
                     &#34;mod_current_test&#34; &#34;$cTest&#34; \
                     &#34;tc_externalid&#34; &#34;$extid&#34; &#34;dispatch_id&#34; &#34;$disid&#34; &#34;time&#34; &#34;$tpbTime&#34;]
                <a name="::handleOutput(4)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;[<a name="::listToJson(1)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $vList -elem &#34;TPBVerify&#34;]&#34;
                puts &#34;Verify sent to TPB. Waiting for Execute Command&#34;
                puts $tbf &#34;Verify sent to TPB. Waiting for Execute Command&#34;
                vwait getexec
                <a name="::handleOutput(5)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;Starting Test Case Execution&#34;
                if {$cTest == &#34;pause&#34;} {
                    set tcOut [catch {eval ClearTestbedSessions} freason];
                    if {$tcOut != 0} {
                        puts $tbf &#34;     ClearTestbedSessions TCL EXCEPTION: $freason&#34;
                        <a name="::handleOutput(6)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;Clear Consoles Failed:&#34;
                    }
                    set tcOut2 [catch {eval ClearTestbedTelnetPIDs} freason2];
                    if {$tcOut2 != 0} {
                        puts $tbf &#34;     ClearTestbedTelnetPIDs TCL EXCEPTION: $freason2&#34;
                        <a name="::handleOutput(7)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;Clear Console Telnet PIDs Failed:&#34;
                    }
                    puts &#34;\n  --  Received a pause command from TPB at $tpbTime --  \n&#34;
                    puts $tbf &#34;PAUSE test bed at $tpbTime&#34;
                    set init1Run 0
                    set TestsExecuted &#34;&#34;
                    set INITFilesExecuted &#34;&#34;
                    set rList [list &#34;mod_current_test&#34; &#34;$cTest&#34; &#34;mod_name&#34; &#34;$modName&#34; &#34;queue_id&#34; &#34;$qId&#34; \
                         &#34;mod_results&#34; &#34;complete&#34;]
                    <a name="::handleOutput(8)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;[<a name="::listToJson(2)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $rList -elem &#34;TCLResult&#34;]&#34;
                    vwait freepause

                    <span class="comment-line">#After the pause is released, run cleanup to make sure next case is ready to go</span>
                    <span class="comment-line">#CleanTestBedCfgs;</span>
                    continue;
                }
            }
        }
        puts &#34;cTest value = $cTest&#34;
        puts $tbf &#34;================ cTest value = $cTest ===================&#34;
        if {$cTest != &#34;&#34; &amp;&amp; $cTest != &#34;kill&#34; &amp;&amp; $cTest != &#34;killfinal&#34;} {
            set tcTCLError 0
            set tpbStat 1
            if {[lsearch $TestsExecuted $cTest] &gt;= 0 &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               if {[info exists FEATMAIN(TCRESULTS,$cTest)]} {
                   if {[regexp -nocase &#34;pass&#34; $FEATMAIN(TCRESULTS,$cTest)]} {
                       set tpbRes 1
                   } else {
                       set tpbRes 0
                   }
                   puts &#34;Test case $cTest already executed - result $FEATMAIN(TCRESULTS,$cTest)&#34;
                   puts $tbf &#34;     Test case $cTest already executed - result $FEATMAIN(TCRESULTS,$cTest) tpbRes $tpbRes&#34;
               } else {
                   puts &#34;Test case $cTest already executed - global not set&#34;
                   puts $tbf &#34;     Test case $cTest already executed - tbpRes 0&#34;
                   set tpbRes 0
               }
            } elseif {[catch {source ${cTest}.tcl} reason] &amp;&amp; $cTest != &#34;cleanup&#34; \
                     &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               puts &#34;Test case $cTest does not exist&#34;
               puts $tbf &#34;     Test case [pwd] $cTest does not exist - tbpRes 0&#34;
               puts $tbf &#34;        error from not exists: $reason&#34;
               set tpbRes 0
            } elseif {$skipTheRest} {
               puts &#34;\nFEATURE SKIPPED NO SUPPORT - FROM INIT FILE&#34;
               puts $tbf &#34;     FEATURE SKIPPED NO SUPPORT - FROM INIT FILE - tbpRes 0&#34;
               set tpbRes 0
            } elseif {[lsearch $ALLPLATDEV $cTest]&gt;=0 &amp;&amp; $cTest != &#34;cleanup&#34; \
                     &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               puts &#34;Test case $cTest is in the DEV list&#34;
               puts $tbf &#34;     Test case $cTest is in the DEV list - tbpRes 0&#34;
               set tpbRes 0
            } elseif {[lsearch $ALLPLATDEBUG $cTest]&gt;=0 &amp;&amp; $cTest != &#34;cleanup&#34; \
                     &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               puts &#34;Test case $cTest is in the DEBUG list&#34;
               puts $tbf &#34;     Test case $cTest is in the DEBUG list - tbpRes 0&#34;
               set tpbRes 0
            } elseif {[lsearch $ALLPLATEDGE $cTest]&gt;=0 &amp;&amp; $cTest != &#34;cleanup&#34; \
                     &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               puts &#34;Test case $cTest is in the EDGE SKIP list&#34;
               puts $tbf &#34;     Test case $cTest is in the EDGE SKIP list - tbpRes 0&#34;
               set tpbRes 0
            } elseif {[lsearch $SKIPVERTESTS $cTest]&gt;=0 &amp;&amp; $cTest != &#34;cleanup&#34; \
                     &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               puts &#34;Test case $cTest is not supported in this software version&#34;
               puts $tbf &#34;     Test case $cTest is not supported in this software version - tbpRes 0&#34;
               set tpbRes 0
            }  elseif {[lsearch $ALLPLATTESTS $cTest]&lt;0 &amp;&amp; $cTest != &#34;cleanup&#34; \
                     &amp;&amp; $cTest != &#34;ClearTestbedSessions&#34;} {
               puts &#34;Test case $cTest not supported on this platform or software version&#34;
               puts $tbf &#34;     Test case $cTest not supported on this platform or software version - tbpRes 0&#34;
               set tpbRes 0
            } elseif {$skipFailTheRest} {
               puts &#34;\nFEATURE SKIP/FAIL due to prerequisite setup failure &#34;
               puts $tbf &#34;     FEATURE SKIP/FAIL due to prerequisite setup failure - tbpRes 0&#34;
               set tpbRes 0
            } else {
                <span class="comment-line"># If completetests does not have init/end files we need to set to null.</span>
                if {![info exists initByProc($cTest)]} {set initByProc($cTest) &#34;NULL&#34;}
                if {![info exists endByProc($cTest)]} {set endByProc($cTest) &#34;NULL&#34;}
                puts $tbf &#34;     Lib init/end list : Pre $initByProc($cTest) $cTest Post $endByProc($cTest)&#34;
                puts &#34;     Lib init/end list : Pre $initByProc($cTest) $cTest Post $endByProc($cTest)&#34;
                <span class="comment-line"># END STUFF</span>
                if {[info exists TESTPOST($prevcase)]} {
                    puts &#34;      Previous end $TESTPOST($prevcase)&#34;
                    if {[info exists TESTPOST($cTest)]} {
                        puts &#34;      This end $TESTPOST($cTest)&#34;
                        if {$TESTPOST($cTest) != $TESTPOST($prevcase) &amp;&amp; $TESTPOST($prevcase) != &#34;NULL&#34;} {
                            set mEnd $TESTPOST($prevcase)
                            puts &#34;\n@@\n@@\nI am going to execute this end -- $TESTPOST($prevcase)&#34;
                            set tcOut [catch {eval $TESTPOST($prevcase)} freason];
                            puts $tbf &#34;     END TEST CASE: $TESTPOST($prevcase) :: tcOut $tcOut&#34;
                            if {$tcOut != 0} {
                                puts &#34;THERE WAS A TCL EXCEPTION RUNNING $mEnd END CASE: $freason&#34;
                            }
                            lappend EndFilesExecuted $mEnd;<span class="comment-line"># end files executed.  When run, remove the matching init.</span>
                            if {![info exists INITBYENDSCRIPT($mEnd)]} {
                                set INITBYENDSCRIPT($mEnd) NULL
                            }
                            if {[lsearch $INITFilesExecuted $INITBYENDSCRIPT($mEnd)] &gt;= 0} {
                                puts &#34;    Remove $INITBYENDSCRIPT($mEnd) from executed init files because matching $mEnd executed&#34;
                                set INITFilesExecuted [<a name="::ldelete(1)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $INITFilesExecuted $INITBYENDSCRIPT($mEnd)]
                            }
                        } else {
                            puts &#34;DO NOT END -- $TESTPOST($cTest)&#34;
                        }
                    }
                }
                <span class="comment-line"># INIT STUFF</span>
                if {[info exists initByProc($cTest)]} {
                    if {$initByProc($cTest) != &#34;NULL&#34;} {
                        foreach p $initByProc($cTest) {
                            if {[lsearch $INITFilesExecuted $p] &lt; 0} {
                                puts &#34;Executing init file -- $p&#34;
                                set tcOut [catch {eval $p} freason];
                                puts $tbf &#34;     INIT TEST CASE: $p :: tcOut $tcOut&#34;
                                if {$freason == &#34;testSkipped&#34; || [regexp -nocase &#34;testSkipped&#34; $tcOut]} {
                                    set skipTheRest 1
                                    set sTcOut $tcOut
                                    puts $tbf &#34;     FEATURE SKIPPED NO SUPPORT - FROM INIT FILE&#34;
                                    puts &#34;\nFEATURE SKIPPED NO SUPPORT - FROM INIT FILE&#34;
                                    break;
                                }
                                if {$freason == &#34;testSkippedFail&#34; || [regexp -nocase &#34;testSkippedFail&#34; $tcOut]} {
                                    set skipFailTheRest 1
                                    set sTcOut $tcOut
                                    puts $tbf &#34;     FEATURE SKIP/FAIL due to prerequisite setup failure&#34;
                                    puts &#34;\nFEATURE SKIP/FAIL due to prerequisite setup failure&#34;
                                    break;
                                }
                                if {$tcOut != 0} {
                                    puts &#34;THERE WAS A TCL EXCEPTION RUNNING $p Init CASE: $freason&#34;
                                }
                                lappend INITFilesExecuted $p;<span class="comment-line"># init files that have been executed.</span>
                            } else {
                                puts &#34;ALREADY Executed -- $p&#34;
                            }
                        }
                    }
                }
                <span class="comment-line">#</span>
                if {[info exists skipTheRest] &amp;&amp; $skipTheRest} {
                    puts &#34;Skipping $cTest due to the init file skip&#34;
                    puts $tbf &#34;Skipping $cTest due to the init file skip&#34;
                } elseif {[info exists skipFailTheRest] &amp;&amp; $skipFailTheRest} {
                    puts &#34;$cTest SKIP/FAIL due to prerequisite setup failure&#34;
                    puts $tbf &#34;$cTest SKIP/FAIL due to prerequisite setup failure&#34;
                } else {
                    lappend TestsExecuted $cTest;<span class="comment-line"># Big list of all scripts that have been executed.</span>
                    puts &#34;Execute Current TEST $cTest&#34;

                    set tcOut [catch {eval $cTest} freason];
                    if {$tcOut != 0} {
                        puts $tbf &#34;     Exception in Test Case $cTest&#34;
                        puts $tbf &#34;     THERE WAS A TCL EXCEPTION: $freason&#34;
                        puts &#34;THERE WAS A TCL EXCEPTION: $freason&#34;
                        set tcTCLError 1
                        <span class="comment-line"># -- Clean up the test bed of cli left behind at the time of the crash --</span>
                        if {![regexp -nocase &#34;No response from the switch&#34; $freason]} {
                            <a name="::CleanTestBedCfgs(1)"><a href="./cleanup.tcl.html#::CleanTestBedCfgs_1102">::CleanTestBedCfgs</a></a>
                            if {$initByProc($cTest) != &#34;NULL&#34;} {
                                foreach p $initByProc($cTest) {
                                    set INITFilesExecuted [<a name="::ldelete(2)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $INITFilesExecuted $p]
                                }
                            }
                        } elseif {0 &amp;&amp; [regexp -nocase {No response from the switch DUT([0-9]+)} $freason a md]} {
                            <a name="::PowerCycleDUT(1)"><a href="./poweroutlet.tcl.html#::PowerCycleDUT_377">::PowerCycleDUT</a></a> $md
                            if {$initByProc($cTest) != &#34;NULL&#34;} {
                                foreach p $initByProc($cTest) {
                                    set INITFilesExecuted [<a name="::ldelete(3)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> $INITFilesExecuted $p]
                                }
                            }
                        }
                        incr tclCrashCount
                        if {$tclCrashCount &gt; 2} {
                            puts $tbf &#34;     SEND PAUSE ALERT TO TPB CTRL - $cTest&#34;
                            puts &#34;\n\n@@@ TCL Exception loop.  Pause to recover. @@@\n&#34;
                            set tclCrashCount 0
                        }
                    } else {
                        set tclCrashCount 0
                    }
                    if {$freason == &#34;testSkipped&#34; || [regexp -nocase &#34;testSkipped&#34; $tcOut]} {
                        set skipTheRest 1
                        puts $tbf &#34;     FEATURE SKIPPED NO SUPPORT - FROM INIT FILE&#34;
                        puts &#34;\nFEATURE SKIPPED NO SUPPORT - FROM INIT FILE&#34;
                    }
                    if {$freason == &#34;testSkippedFail&#34; || [regexp -nocase &#34;testSkippedFail&#34; $tcOut]} {
                        set skipFailTheRest 1
                        puts $tbf &#34;     FEATURE SKIP/FAIL due to prerequisite setup failure&#34;
                        puts &#34;\nFEATURE SKIP/FAIL due to prerequisite setup failure&#34;
                    }
                    puts $tbf &#34;     tcOut = $tcOut&#34;
                    puts &#34;tcOut = $tcOut&#34;
                }
                if {[info exists passCount]} {
                    puts &#34;pass at end $passCount&#34;
                    puts $tbf &#34;     pass at end $passCount&#34;
                }
                if {[info exists failCount]} {
                    puts &#34;fail at end $failCount&#34;
                    puts $tbf &#34;     fail at end $failCount&#34;
                    if {$failCount &gt; 0 &amp;&amp; $failCount &gt; $lastFailCount} {
                        puts $tbf &#34;      Reset the tpbStat 0  -  set lastFailCount $failCount&#34;
                        set tpbStat 0
                        set lastFailCount $failCount
                    }
                }
                if {[info exists skipCount]} {
                    puts $tbf &#34;     Skip Count is set at end count: $skipCount&#34;
                    puts &#34;skip at end $skipCount&#34;
                }
                set length [string length $EX_REPORT_DATA]
                set tmp1 [expr $length - 4]
                set tmp2 [expr $length - 2]
                set tmp3 [expr $length - 3]
                set tmp4 [expr $length - 1]
                set tail [string range $EX_REPORT_DATA $tmp1 $tmp2]
                set tail2 [string range $EX_REPORT_DATA $tmp1 $tmp4]
                puts &#34;DEBUG End of result = $tail2&#34;
                <span class="comment-line">#puts &#34;\n##### TAIL = $tail&#34;</span>
                set tpbRes  [string trimleft $tail &#34;\} &#34;]
                set tpbRes2 [string trimleft $tail2]
                <span class="comment-line">#puts &#34;tpbRes $tpbRes&#34;</span>
                puts $tbf &#34;     TPBRES from EX_REPORT_DATA : tpbRes $tpbRes : tpbRes2 $tpbRes2&#34;
                set tpbRes [string trim $tpbRes]
                if {[info exists skipTheRest] &amp;&amp; $skipTheRest} {
                    puts &#34;Init file skip: tpbRes 0&#34;
                    puts $tbf &#34;     Init file skip :: set tpbRes to 0&#34;
                    set tpbRes 0
                } elseif {[info exists skipFailTheRest] &amp;&amp; $skipFailTheRest} {
                    puts &#34;Init SKIP/FAIL due to prerequisite setup failure  : tpbRes 0&#34;
                    puts $tbf &#34;     SKIP/FAIL due to prerequisite setup failure :: set tpbRes to 0&#34;
                    set tpbRes 0
                } elseif {!$tpbStat} {
                    puts &#34;Good result parse: $tpbStat&#34;
                    puts $tbf &#34;     Good result parse: $tpbStat :: set tpbRes to 0&#34;
                    set tpbRes 0
                } elseif {$tpbRes == 1 || $tpbRes == 0} {
                    puts &#34;Good result parse: $tpbRes&#34;
                    puts $tbf &#34;     Good result parse: $tpbRes&#34;
                } elseif {[regexp -nocase &#34;kip&#34; $tpbRes]} {
                    puts &#34;Hit Test Case Skipped Case&#34;
                    puts $tbf &#34;     Hit Test Case Skipped Case :: set tpbRes to skipped&#34;
                    set tpbRes &#34;skipped&#34;
                } elseif {[regexp -nocase &#34;\} \{&#34; $tpbRes2]} {
                    puts &#34;Hit Test Case returned without Skip, OK or Error&#34;
                    puts $tbf &#34;     Hit Test Case returned without Skip, OK or Error :: set tpbRes to Fix TCL&#34;
                    set tpbRes &#34;Fix TCL&#34;
                } else {
                    puts &#34;Bad result parse:: tail $tail - tbpRes = $tpbRes&#34;
                    puts $tbf &#34;     Bad result parse:: tail $tail - tbpRes = 0&#34;
                    set tpbRes 0
                }
                if {$tcTCLError} {
                    puts &#34;Hit TCL Error in Catch statement&#34;
                    puts $tbf &#34;     Hit TCL Error in Catch statement :: set tpbRes 0&#34;
                    set tpbRes 0
                }
                set prevcase $cTest;<span class="comment-line"># This the previous EXECUTED test.</span>
            }
            <span class="comment-line">#set TestsRemaining [ldelete &#34;$TestsRemaining&#34; &#34;$cTest&#34;]; </span>
            puts &#34;\n\n\ntpbRes $tpbRes\n\n&#34;
            puts &#34;\n------------------------------------------------------------------&#34;
            puts $tbf &#34;     FINAL tpbRes $tpbRes&#34;
            <span class="comment-line">#puts &#34;CASELIST - $TPBRESULTLIST&#34;</span>
            <span class="comment-line">#puts &#34;CASEVALUES - $TPBRESULTVALUES&#34;</span>
            set TPBRESULTLIST &#34;&#34;
            set TPBRESULTVALUES &#34;&#34;
            if {!$useSocket} {
                if {[catch {mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE queue_id = '$qId' \
                                     AND mod_dir = '$regPath' AND mod_name = '$modName' AND mod_current_test = '$cTest'&#34;} mres]} {
                    puts &#34;@@@\n@@@\nMYSQL DELETE ERROR - mysql_handler = $mysql_handler :\n\
                          DELETE FROM tpb_modules WHERE queue_id = $qId \
                          AND mod_dir = $regPath AND mod_name = $modName AND mod_current_test = $cTest\
                          \n $mres\n@@@\n@@@&#34;
                    if {[catch {mysqlconnect -host otps -user user -password extreme -db tpb_queues} mysql_handler]} {
                        puts &#34;@@@\n@@@\nMYSQL COULD NOT RECONNECT ERROR\n$mysql_handler\n@@@\n@@@&#34;
                    } else {
                        catch {mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE queue_id = '$qId' \
                               AND mod_dir = '$regPath' AND mod_name = '$modName' AND mod_current_test = '$cTest'&#34;} newres
                    }
                }
            }
            save_incrementally_run_data $cTest
            if {$tpbRes == 1 || $tpbRes == 0} {
                puts $tbf &#34;     $cTest Result for TPB is $resStr($tpbRes)&#34;
            } else {
                puts $tbf &#34;     $cTest Result for TPB is Neither 1 or 0 WTH&#34;
            }
            if {!$useSocket} {
                set insert_clause &#34;&#34;
                set insert_clause [append insert_clause &#34;insert into tpb_results (mod_run_id, &#34;]
                set insert_clause [append insert_clause &#34;mod_current_test, &#34;]
                set insert_clause [append insert_clause &#34;mod_name, &#34;]
                set insert_clause [append insert_clause &#34;queue_id, &#34;]
                set insert_clause [append insert_clause &#34;mod_results)&#34;]
    
                set insert_clause [append insert_clause &#34;values (\&#34;$mId\&#34;, &#34;]
                set insert_clause [append insert_clause &#34;\&#34;$cTest\&#34;, &#34;]
                set insert_clause [append insert_clause &#34;\&#34;$modName\&#34;, &#34;]
                set insert_clause [append insert_clause &#34;\&#34;$qId\&#34;, &#34;]
                set insert_clause [append insert_clause &#34;\&#34;$tpbRes\&#34;)&#34;]
    
                if {[catch {mysqlexec $mysql_handler $insert_clause} ires]} {
                    puts &#34;@@@\n@@@\nMYSQL insert ERROR\n$ires\n@@@\n@@@&#34;
                    puts $tbf &#34;MYSQL insert FAIL $ires&#34;
                }
            } else {
                set rList [list &#34;mod_current_test&#34; &#34;$cTest&#34; &#34;mod_name&#34; &#34;$modName&#34; &#34;queue_id&#34; &#34;$qId&#34; \
                     &#34;mod_results&#34; &#34;$tpbRes&#34;]
                <a name="::handleOutput(9)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;[<a name="::listToJson(3)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $rList -elem &#34;TCLResult&#34;]&#34;
                puts $tbf &#34;     Return json: [<a name="::listToJson(4)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $rList -elem &#34;TCLResult&#34;]&#34;
                <span class="comment-line"># Set the end time and write duration to the execTime file</span>
                set timeEnd [clock seconds];
                global duration
                set duration [expr $timeEnd - $timeStart]
                ;<span class="comment-line"># write to testcase and duration to execTime.txt</span>
                ;<span class="comment-line"># Write out duration to Execution Time File</span>
                ;<span class="comment-line"># Add testcase: and duration: for easier parsing</span>
                <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;testcase:$cTest    duration:$duration&#34;

                puts $fdin_execTime &#34;testcase:$cTest\tduration:$duration&#34;
                flush $fdin_execTime
            }
            <span class="comment-line">#set prevcase $cTest;# 05082018 - moved into the exec path b/c end scripts only run in exec path</span>
            puts $tbf &#34;     Set the previous test case to: $cTest&#34;
        } elseif {$cTest == &#34;kill&#34; || $cTest == &#34;killfinal&#34;} {
            if [info exists endByProc($prevcase)] {
                if {$endByProc($prevcase) != &#34;NULL&#34;} {
                    <span class="comment-line">#if there was an end proc for a case that ran just before a kill</span>
                    foreach ep $endByProc($prevcase) {
                        set tcOut [catch {eval $ep} freason];
                        puts $tbf &#34;     RUN the LAST END: $ep :: tcOut $tcOut&#34;
                        if {$tcOut != 0} {
                            puts &#34;THERE WAS A TCL EXCEPTION RUNNING KILL END CASE: $freason&#34;
                        }
                    }
                }
            }
            if {!$useSocket} {
                mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE mod_run_id = '$mId'&#34;
            } else {
                <a name="::handleOutput(10)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;Received Kill 1&#34;;
            }
        }
    }
    set tcOut [catch {eval cleanup} freason];
    if {$tcOut != 0} {
        puts &#34;THERE WAS A TCL EXCEPTION IN CLEANUP: $freason&#34;
        puts $tbf &#34;THERE WAS A TCL EXCEPTION IN CLEANUP: $freason&#34;
        set tcTCLError 1
    }
    if {!$useSocket} {
        if {[catch {mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE queue_id = '$qId'&#34;} mres]} {
            puts &#34;@@@\n@@@\nMYSQL DELETE ERROR - mysql_handler = $mysql_handler :\n\
                    DELETE FROM tpb_modules WHERE queue_id = $qId $mres\n@@@\n@@@&#34;
            if {[catch {mysqlconnect -host otps -user user -password extreme -db tpb_queues} mysql_handler]} {
                puts &#34;@@@\n@@@\nMYSQL COULD NOT RECONNECT ERROR\n$mysql_handler\n@@@\n@@@&#34;
            } else {
                catch {mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE queue_id = '$qId'&#34;} newres
            }
        }

        if {[info exists mysql_handler]} {
            catch {mysqlclose $mysql_handler} result
        }
    }
    close $fdin_execTime
    puts &#34;returning testCompleted $mods&#34;
    puts $tbf &#34;RETURNING testCompleted $mods&#34;
    return &#34;testCompleted $mods&#34;
}
<strong><a name="::::TPBMainClearConsole_841">proc <a href="tpbMainLib.tcl-annot.html#::::TPBMainClearConsole">::::TPBMainClearConsole</a></a></strong><a name="::::TPBMainClearConsole"></a> {qId module regPath useSocket} {
    <span class="comment-line"># socket variables</span>
    global getjson getok initsend mySock

    set inClear 0
    if {!$useSocket} {
        catch {mysqlconnect -host otps -user user -password extreme -db tpb_queues} mysql_handler
        set cTestList [mysqlsel $mysql_handler &#34;SELECT mod_run_id, mod_current_test FROM \
                            tpb_modules WHERE queue_id = '$qId' \
                            AND mod_dir = '$regPath' AND mod_name = '$module' \
                            ORDER By mod_run_id ASC&#34; -flatlist]
        set mod_curr_test &#34;[lindex $cTestList 1]&#34;
        set mod_run_id &#34;[lindex $cTestList 0]&#34;
        if {$mod_curr_test == &#34;ClearTestbedSessions&#34;} {
            set inClear 1
            set clearOut [catch {eval ClearTestbedSessions} creason];
            if {[catch {mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE queue_id = '$qId' \
                                  AND mod_run_id = '$mod_run_id'&#34;} mres]} {
                puts &#34;@@@\n@@@\nMYSQL DELETE ERROR - mysql_handler = $mysql_handler :\n\
                      DELETE FROM tpb_modules WHERE queue_id = $qId \
                      AND mod_run_id = $mod_run_id \
                      \n $mres\n@@@\n@@@&#34;
                if {[catch {mysqlconnect -host otps -user user -password extreme -db tpb_queues} mysql_handler]} {
                    puts &#34;@@@\n@@@\nMYSQL COULD NOT RECONNECT ERROR\n$mysql_handler\n@@@\n@@@&#34;
                } else {
                    catch {mysqlexec $mysql_handler &#34;DELETE FROM tpb_modules WHERE queue_id = '$qId' \
                           AND mod_run_id = '$mod_run_id' &#34;} newres
                }
            }
            while {$inClear} {
                set mod_current_test &#34;&#34;
                puts &#34;Test Bed is locked for troubleshooting.  Sleep for 30 secs then check for unlock\n&#34;;
                sleep 30
                set cTestList [mysqlsel $mysql_handler &#34;SELECT mod_run_id, mod_current_test FROM \
                                  tpb_modules WHERE queue_id = '$qId' \
                                  AND mod_dir = '$regPath' AND mod_name = '$module' \
                                  ORDER By mod_run_id ASC&#34; -flatlist]
                set mod_curr_test &#34;[lindex $cTestList 1]&#34;
                set mod_run_id &#34;[lindex $cTestList 0]&#34;
                if {$mod_curr_test != &#34;&#34;} {
                    set inClear 0
                }
            }
        }
        if {[info exists mysql_handler]} {
           catch {mysqlclose $mysql_handler} result
        }
    }
}
<span class="comment-line"># -----------------------------------------------------------------------------------------</span>
<span class="comment-line"># proc _TPBLynxExecution</span>
<span class="comment-line">#</span>
<span class="comment-line">#    - Case were the harness hits a feature that is skipped for lynx</span>
<span class="comment-line">#    TPB still needs to send in cases to receive the result of skipped</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># -----------------------------------------------------------------------------------------</span>
<strong><a name="::::_TPBLynxExecution_898">proc <a href="tpbMainLib.tcl-annot.html#::::_TPBLynxExecution">::::_TPBLynxExecution</a></a></strong><a name="::::_TPBLynxExecution"></a> {args} {
    global randomIndex ineed MAIN

    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _TPBLynxExecution $args {
        wait &#34;future&#34;
        name &#34;dynamic&#34;
    }

    if {[set tbf [open &#34;[<a name="::get_result_dir(1)"><a href="./result.tcl.html#::get_result_dir_189">::get_result_dir</a></a> { $randomIndex }]/tpblogfile.txt&#34; \
       &#34;w&#34;]] == -1} {
          puts &#34;Opening the tpblogfile failed&#34;
    }
    puts $tbf &#34;Lynx - Skip all TPB cases for this feature&#34;
    <span class="comment-line"># socket variables</span>
    global getjson getok initsend mySock ineed
    set useSocket 1
    if {![info exists ineed]} {
        set ineed &#34;&#34;
    }
    set cTest &#34;&#34;;
    while {$cTest != &#34;kill&#34; &amp;&amp; $cTest != &#34;killfinal&#34;} {
        <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Using TPB Socket Control Waiting for a Client to Send in test cases&#34;
        vwait getmyjson
        puts &#34;RX: $ineed&#34;
        set ineed [string trim $ineed]
        if {[regexp -nocase &#34;(sock\[0-9]+)\=(\{\&#34;\[a-zA-Z]+\&#34;: *\{\&#34;\[a-zA-Z_\-]+\&#34;:\&#34;\[a-zA-Z0-9_&amp;\-]+\&#34;.*\}\})$&#34; \
                              $ineed ignore s j]} {
            puts $tbf &#34;Used Socket&#34;
            set mySock $s
            set parsed [json::json2dict $j]
            foreach {key val} $parsed {
                foreach {key val} $val {
                    set case($key) $val
                }
            }
            set qId $case(queue_id);
            set modName $case(mod_name);
            set testDir $case(mod_dir);
            set cTest $case(mod_current_test);
            set extid $case(tc_externalid);
            set disid $case(dispatch_id);
            set tpbTime $case(time);
            set mods $modName
            set vList [list &#34;queue_id&#34; &#34;$qId&#34; &#34;mod_name&#34; &#34;$modName&#34; &#34;mod_dir&#34; &#34;$testDir&#34; \
                &#34;mod_current_test&#34; &#34;$cTest&#34; \
                &#34;tc_externalid&#34; &#34;$extid&#34; &#34;dispatch_id&#34; &#34;$disid&#34; &#34;time&#34; &#34;$tpbTime&#34;]
            <a name="::handleOutput(11)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;[<a name="::listToJson(5)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $vList -elem &#34;TPBVerify&#34;]&#34;
            vwait getexec
            <a name="::handleOutput(12)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;Starting Test Case Execution&#34;
            if {$cTest == &#34;pause&#34;} {
                set tcOut [catch {eval ClearTestbedSessions} freason];
                if {$tcOut != 0} {
                    puts $tbf &#34;     ClearTestbedSessions TCL EXCEPTION: $freason&#34;
                    <a name="::handleOutput(13)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;Clear Consoles Failed:&#34;
                }
                puts $tbf &#34;PAUSE test bed at $tpbTime&#34;
                set rList [list &#34;mod_current_test&#34; &#34;$cTest&#34; &#34;mod_name&#34; &#34;$modName&#34; &#34;queue_id&#34; &#34;$qId&#34; \
                &#34;mod_results&#34; &#34;complete&#34;]
                <a name="::handleOutput(14)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;[<a name="::listToJson(6)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $rList -elem &#34;TCLResult&#34;]&#34;
                vwait freepause
                continue;
            }
            set MAIN(MAKESKIPRESULTFILE) 1;<span class="comment-line"># create the tc.txt result files and put entries in report.txt</span>
            if {[regexp -nocase &#34;init|end&#34; $cTest]} {
                <span class="comment-line">#continue;</span>
            } else {
                if {[catch {eval $cTest} tc]} {
                }
            }
            set MAIN(MAKESKIPRESULTFILE) 0
            set rList [list &#34;mod_current_test&#34; &#34;$cTest&#34; &#34;mod_name&#34; &#34;$modName&#34; &#34;queue_id&#34; &#34;$qId&#34; \
                 &#34;mod_results&#34; &#34;testSkipped&#34;]
            <a name="::handleOutput(15)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $s &#34;[<a name="::listToJson(7)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $rList -elem &#34;TCLResult&#34;]&#34;
            puts $tbf &#34;     Return json: Skiptest [<a name="::listToJson(8)"><a href="./semaphore.tcl.html#::listToJson_5">::listToJson</a></a> -mlist $rList -elem &#34;TCLResult&#34;]&#34;
        } else {
            puts &#34;JSON not correctly formatted&#34;;
            set ts [lindex [split $ineed &#34;=&#34;] 0];
            <a name="::handleOutput(16)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $ts &#34;JSON Format Error:&#34;
            set bjson [lindex [split $ineed &#34;=&#34;] 1];
            <a name="::handleOutput(17)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $ts &#34;$bjson&#34;
            <a name="::handleOutput(18)"><a href="./semaphore.tcl.html#::handleOutput_211">::handleOutput</a></a> $ts &#34;@@@@ Skipped for Lynx platform @@@@&#34;
        }
    }
    close $tbf
}
<span class="comment-line"># ----------------------------------------------------------------------------------------</span>
<span class="comment-line"># proc _buildModuleTestLsts</span>
<span class="comment-line">#</span>
<span class="comment-line">#    Build all of the possible lists from the completetests.lst</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># ----------------------------------------------------------------------------------------</span>
<strong><a name="::::_buildModuleTestLsts_990">proc <a href="tpbMainLib.tcl-annot.html#::::_buildModuleTestLsts">::::_buildModuleTestLsts</a></a></strong><a name="::::_buildModuleTestLsts"></a> {args} {
    global MAIN FEATMAIN

    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _buildModuleTestLsts $args {
        module   &#34;null&#34;
        regPath  &#34;null&#34;
    }

    set regPath [string trim $regPath &#34;.&#34;]
    set regPath [string trim $regPath &#34;/&#34;]

puts &#34;Start find [pwd]&#34;

    set myDir [pwd]
    cd $MAIN(autoRoot)/main
puts &#34;after change to main [pwd]&#34;
    set regPath [<a name="::_verifyRegPathArg(1)"><a href="./filetools.tcl.html#::_verifyRegPathArg_107">::_verifyRegPathArg</a></a> -regPath $regPath];<span class="comment-line">#</span>
    set modulePath [_verifyModuleNameArg $regPath $module]
puts &#34;After find path [pwd]&#34;

    cd $modulePath
puts &#34;In the feature dir $module [pwd]&#34;

    set what [<a name="::::GetCleanTestList(1)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> dev]
    set verList [<a name="::::GetVerSkipList(1)"><a href="./tpbMainLib.tcl.html#::::GetVerSkipList_98">::::GetVerSkipList</a></a> dev]
    puts &#34;*****\n*****ALL:\n$what\n*****\n*****&#34;
    puts &#34;*****\n*****VERSKIP:\n$verList\n*****\n*****&#34;
    set mydev [<a name="::::GetCleanTestList(2)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> devonly]
    puts &#34;*****\n*****DEVONLY:\n$mydev\n*****\n*****&#34;
    set mydebug [<a name="::::GetCleanTestList(3)"><a href="./tpbMainLib.tcl.html#::::GetCleanTestList_38">::::GetCleanTestList</a></a> debugonly]
    puts &#34;*****\n*****DEBUGONLY:\n$mydebug\n*****\n*****&#34;

    set elist &#34;&#34;
    if {[file isfile license.lst] &amp;&amp; \
        [regexp $bcmLynx $DUTs_info(DUT1,platform)]} {
        source license.lst
        foreach edgetc $license_to_run(edge) {
            lappend elist $edgetc
        }
        puts &#34;Found EDGE: $elist&#34;
    }
    set ALLPLATTESTS $what
    set ALLPLATDEV $mydev
    set ALLPLATDEBUG $mydebug
    set ALLPLATEDGE $elist
    set SKIPVERTESTS $verList
    set currInit &#34;&#34;
    set currEnd &#34;&#34;
    set hitPair 0
    set numInit &#34;A&#34;
    set numEnd &#34;B&#34;
    foreach w $what {
        if {[regexp -nocase &#34;init&#34; $w]} {
            if {!$hitPair} {
                set currInit &#34;&#34;
                set numInit &#34;&#34;
                set currEnd &#34;&#34;
                set numEnd &#34;&#34;
            }
            regsub -all &#34;\.init&#34; $w &#34;&#34; myInit
            set currInit $w
            set numInit $myInit
        }
        if {[regexp -nocase &#34;end&#34; $w]} {
            regsub -all &#34;\.end&#34; $w &#34;&#34; myEnd
            set currEnd $w
            set numEnd $myEnd
        }
        if {$numEnd == $numInit} {
            puts &#34;found pair $currInit - $currEnd&#34;
            set initEndScript($currInit) $currEnd
            set INITBYENDSCRIPT($currEnd) $currInit
            set currInit &#34;&#34;
            set numInit &#34;&#34;
            set currEnd &#34;&#34;
            set numEnd &#34;&#34;
            set hitPair 1
        }
    }
    set currInit &#34;NULL&#34;
    set currEnd &#34;&#34;
    foreach w $what {
        if {[regexp -nocase &#34;init&#34; $w]} {
            set currInit $w
        } elseif {[regexp -nocase &#34;end&#34; $w]} {
            set currInit NULL
        } else {
            if {[info exists initEndScript($currInit)]} {
               set blockEnd $initEndScript($currInit)
            } else {
               set blockEnd &#34;NULL&#34;
            }
            set TESTPRE($w) $currInit
            set TESTPOST($w) $blockEnd
            puts &#34;Prereq $currInit  TestCase $w  TestCleanup $blockEnd&#34;
        }
    }

    <span class="comment-line">#cd &#34;$MAIN(autoRoot)/main&#34;</span>
    cd $myDir

}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
