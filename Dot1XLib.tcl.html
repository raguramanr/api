<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>Dot1XLib.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#Dot1XLib.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>Dot1XLib.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="Dot1XLib.tcl-annot.html">annotations</a> | <a href="Dot1XLib.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

set DEBUG_DOT1X_CRASH 0

<span class="comment-line">############################ IXIA SPECIFIC FUNCTIONS #######################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures that issue commands only to IXIA</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc dot1x_ixInit</span>
<span class="comment-line"># proc dot1x_ixGetLogs</span>
<span class="comment-line"># proc dot1x_ixGetIfMacs</span>
<span class="comment-line"># proc dot1x_ixGetPortIdMacs</span>
<span class="comment-line"># proc dot1x_ixCreatePortIfs</span>
<span class="comment-line"># proc dot1x_ixConfigDot1xPorts </span>
<span class="comment-line"># proc dot1x_ixConfigDot1xPortOnly</span>
<span class="comment-line"># proc dot1x_ixAddSupplicantToPort</span>
<span class="comment-line"># proc dot1x_ixStartSupAuth</span>
<span class="comment-line"># proc dot1x_ixStopSupAuth</span>
<span class="comment-line"># proc dot1x_ixDestroyDot1xPorts</span>
<span class="comment-line"># proc dot1x_ixCheckPortGroupStats </span>
<span class="comment-line"># proc dot1x_ixStartAuth</span>
<span class="comment-line"># proc dot1x_ixStopAuth</span>
<span class="comment-line"># proc dot1x_ixDumpInterfaceInfo</span>
<span class="comment-line"># proc dot1x_ixVerifySupplicantAccess</span>
<span class="comment-line"># proc dot1x_ixVerifyMultiSupplicantAccess</span>
<span class="comment-line"># proc dot1x_ixSendIpTraffic</span>
<span class="comment-line"># proc dot1x_ixStartEapolFlood </span>
<span class="comment-line"># proc dot1x_ixStopTx</span>
<span class="comment-line"># proc dot1x_ixStopEapolFlood</span>
<span class="comment-line"># proc dot1x_ixDumpSupplicantStats</span>
<span class="comment-line"># proc dot1x_ixCheckPing</span>
<span class="comment-line"># proc dot1x_ixSendPing</span>
<span class="comment-line"># proc dot1x_ixCheckDHCPBroadcastBlocked</span>
<span class="comment-line"># proc dot1x_ixDelSupMac</span>

<span class="comment-line"># ########################## EXTREME SPECIFIC SWITCH FUNCTIONS #######################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures that issue commands only to DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc dot1x_exEnableNetloginPort</span>
<span class="comment-line"># proc dot1x_exGetNetloginVal</span>
<span class="comment-line"># proc dot1x_exVerifyPortAuth</span>
<span class="comment-line"># proc dot1x_exVerifyMacAuth</span>
<span class="comment-line"># proc dot1x_exVerifyShowNetlogin</span>
<span class="comment-line"># proc dot1x_exVerifyShowNetloginPorts</span>
<span class="comment-line"># proc dot1x_exVerifyShowSession</span>
<span class="comment-line"># proc dot1x_exStandardVlanConfig </span>
<span class="comment-line">#</span>
<span class="comment-line"># ########################## EXTREME + IXIA ############################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures that issue commands to DUT and IXIA</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc dot1x_CheckARPBroadcastBlocked</span>
<span class="comment-line"># proc dot1x_VerifyProtocol</span>
<span class="comment-line"># proc dot1x_VerifyDHCPBootPRelay</span>


<span class="comment-line"># ########################## GENERAL FUNCTIONS ############################</span>
<span class="comment-line">#</span>
<span class="comment-line"># General purpose procedures that do not issue commands to either DUT or Ixia</span>
<span class="comment-line">#</span>
<span class="comment-line"># proc dot1x_stripMac</span>
<span class="comment-line"># proc dot1x_VerifySupplicantPackets</span>
<span class="comment-line"># proc dot1x_VerifySupplicantEAPPackets</span>
<span class="comment-line"># proc dot1x_VerifyTaggedPackets</span>
<span class="comment-line"># proc dot1x_SkipTestBasedOnPlatform</span>
<span class="comment-line"># proc dot1x_CheckDot1xTaskCrash</span>

<span class="comment-line"># ############################## INTERNAL LIBRARY FUNCTIONS ###########################</span>
<span class="comment-line">#</span>
<span class="comment-line"># Procedures internal to Dot1xLib that should not be called by the user </span>
<span class="comment-line">#</span>
<span class="comment-line"># proc _ixStreamConfig</span>
<span class="comment-line"># proc _ixSeedFdbTable</span>
<span class="comment-line"># proc _ixCreateMultiSupplicantStreams</span>
<span class="comment-line"># proc _ixVerifyMultiSupplicantAccess</span>
<span class="comment-line"># proc _ixVerifySupplicantAccess</span>
<span class="comment-line"># proc _ixWaitForAuth</span>
<span class="comment-line"># proc _ixWaitForDeauth</span>
<span class="comment-line"># proc _ixWaitForSupAuth</span>
<span class="comment-line"># proc _reportVerifyProtocolResult</span>
<span class="comment-line"># proc _verifyEDP</span>
<span class="comment-line"># proc _verifySTP</span>
<span class="comment-line"># proc _verifyRIP</span>
<span class="comment-line"># proc _verifyOSPF</span>
<span class="comment-line"># proc _verifyIGMP</span>
<span class="comment-line"># proc _exCheckMatch</span>
<span class="comment-line"># proc _exMacMatchDot1x</span>
<span class="comment-line"># proc _exVerifyShowNetlogin</span>
<span class="comment-line"># proc dot1x_exVerifyShowNetloginPorts</span>


<span class="comment-line">#                           TYPICAL TOPOLOGY</span>
<span class="comment-line">#                           ----------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># We verify traffic by sending IP frames from supplicants to</span>
<span class="comment-line"># target and back.</span>
<span class="comment-line">#</span>
<span class="comment-line">#        IXIA</span>
<span class="comment-line">#   supMac1/supIp1                                    DUT1</span>
<span class="comment-line">#   supMac2/supIp2                       +--------------------------+  </span>
<span class="comment-line">#   supMac3/supIp3 -----------supPortId--| gwIp           (vlan_1)  |</span>
<span class="comment-line">#   supMacX/supIpX                       |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line"># targetMac/targetIp ------targetPortId--| targetPortGwIp (vlan_2)  |</span>
<span class="comment-line">#                                        |   t1  t2                 |  </span>
<span class="comment-line">#                                        +----+--+-----+------------+</span>
<span class="comment-line">#                                             |  |     |       </span>
<span class="comment-line">#                                             |  |     |</span>
<span class="comment-line">#                                             |  |     +--commvlan------&gt; RADIUS</span>
<span class="comment-line">#                                             |  |           |</span>
<span class="comment-line">#                                             |  |     DUT2  |</span>
<span class="comment-line">#                                        +----+--+-----------+------+</span>
<span class="comment-line">#                                        |   t1  t2                 |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        |                          |</span>
<span class="comment-line">#                                        +--------------------------+</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTES: Writing Port Configuration to Ixia causes port to go down, and</span>
<span class="comment-line">#        thus Deauthenticate port. Writing Stream Config does not </span>
<span class="comment-line">#        bring port down.</span>

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixInit</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Connects to IXIA chassis and defaults the ports.</span>
<span class="comment-line">#              Chassis must be running IxOS 3.65 or higher</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: chassis: IP Address of Ixia chassis to connect to</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixInit_134">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixInit">::::dot1x_ixInit</a></a></strong> { chassis } {
	global TrafficGen
	
	if {$TrafficGen == &#34;stc&#34;} {
		return
	}
	
    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nIxTclHAL version   :[<a name="::version(1)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> cget -ixTclHALVersion]&#34;
    <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Product version    :[<a name="::version(2)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> cget -productVersion]&#34;
    <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Installed version  :[<a name="::version(3)"><a href="./ePTClient.tcl.html#::version_470">::version</a></a> cget -installVersion]&#34;

    if {[ isUNIX ]} {
        set errMsg &#34;&#34;
        dot1xUtil::connectToTclServer  $chassis errMsg
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixGetLogs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retreives DOT1x Logs for a set of ports.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: ID of ports to retrieve logs from</span>
<span class="comment-line">#             filename:   Filename to store logs in</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTES: 02/03/04: This does NOT work when running script outside</span>
<span class="comment-line">#                  of Ixia chassis.  Ixia to fix.</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixGetLogs_165">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixGetLogs">::::dot1x_ixGetLogs</a></a></strong> { portIdList filename } {
    
    set portList [list]

    foreach portId $portIdList {
	<a name="::MapIxiaPortId(1)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
	lappend portList &#34;$chassis $card $port&#34;
    }

    <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Retrieving logs for $portList and putting in [pwd]/$filename&#34;

    dot1xGetLogs portList $filename
    
    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Exiting dot1x_ixGetLogs&#34;
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixGetIfMacs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retreives all the Macs on a ch/ca/po</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: ch(assis) ca(rd) po(rt)</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: List of MAC interfaces created on this port.</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixGetIfMacs_193">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixGetIfMacs">::::dot1x_ixGetIfMacs</a></a></strong> { ch ca po } {

    set macList [list]

    interfaceTable select $ch $ca $po

    ;<span class="comment-line"># Walk through interfaceTable!</span>
    for {set curIf [interfaceTable getFirstInterface]} \
	    {$curIf == 0 } {set curIf [interfaceTable getNextInterface]} {
	set mac [interfaceEntry cget -macAddress]
	lappend macList $mac
    }
    return $macList
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixGetPortIdMacs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retreives all the Macs on a given portID</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portId: Which port Id to retreive</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: List of MAC interfaces created on this port.</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixGetPortIdMacs_218">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixGetPortIdMacs">::::dot1x_ixGetPortIdMacs</a></a></strong> { portId } {

    <a name="::MapIxiaPortId(2)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    return [<a name="::dot1x_ixGetIfMacs(1)"><a href="./Dot1XLib.tcl.html#::dot1x_ixGetIfMacs_193">::dot1x_ixGetIfMacs</a></a> $ch $ca $po]
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixCreatePortIfs</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configure port interfaces.  Each interface (or supplicant)</span>
<span class="comment-line">#              has a MAC and IP address. Before you can configure supplicants</span>
<span class="comment-line">#              and supTable, you need to create the &#34;virtual&#34; interfaces</span>
<span class="comment-line">#              representing these supplicants.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: -portInfoList: List of ports to create interfaces on</span>
<span class="comment-line">#                 &lt;portId&gt; &lt;startIp&gt; &lt;gw&gt; &lt;vlanId*&gt;</span>
<span class="comment-line">#                    *vlanId is optional </span>
<span class="comment-line">#             -startMacAddr: First 3 octets of MAC.  Last three are </span>
<span class="comment-line">#                            generated as card:port:count  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#    lappend portInfoList &#34;1 10.1.1.1 10.1.1.254 8&#34;</span>
<span class="comment-line">#    lappend portInfoList &#34;2 10.1.1.1 10.1.1.254 1&#34;</span>
<span class="comment-line">#    dot1x_ixCreatePortIfs -portInfoList $portInfoList -startMacAddr &#34;00 00 01&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixCreatePortIfs_249">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixCreatePortIfs">::::dot1x_ixCreatePortIfs</a></a></strong> {args} {
   global TrafficGen
    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_setupPortInterfaces $args {
	portInfoList &#34;1  10.1.1.1  10.1.1.254  1&#34;
	startMacAddr &#34;00 00 01&#34;    ;<span class="comment-line"># Last 3 octets are CARD:PORT:COUNT </span>
	protocolServer &#34;disable&#34;
    }

   switch -exact -- $TrafficGen
   stc {
      if { [catch {
         
         foreach port $portInfoList {
            
            set portId [lindex $port 0]
            set hPort [<a name="::hMapPortIdToSpirentPort(1)"><a href="./spirent.tcl.html#::hMapPortIdToSpirentPort_216">::hMapPortIdToSpirentPort</a></a> $portId]
            set portStartIpAddr [lindex $port 1]
            set portGwIpAddr [lindex $port 2]
            set numSupplicants [lindex $port 3]
            set vlanId [lindex $port 4]
            set incrOctet 4
            set ipAddressForThisInterface $portStartIpAddr
            set gCount 1
            for {set count 1} {$count &lt;= $numSupplicants} {incr count} {
               if {$vlanId == &#34;&#34;} {
                  array set cmdResults [<a name="::logcmd(1)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform DeviceCreateCommand \
                      -ParentList [<a name="::logcmd(2)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get system1 -children-project] -port $hPort -IfStack &#34;Ipv4If EthIIIf&#34; -IfCount &#34;1 1&#34;]
                  set deviceHndl $cmdResults(-ReturnList)
               } else {
                  array set cmdResults [<a name="::logcmd(3)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform DeviceCreateCommand \
                      -ParentList [<a name="::logcmd(4)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get system1 -children-project] -port $hPort -IfStack &#34;Ipv4If VlanIf EthIIIf&#34; -IfCount &#34;1 1 1&#34;]
                  set deviceHndl $cmdResults(-ReturnList)
                  <a name="::logcmd(5)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::config [<a name="::logcmd(6)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $deviceHndl -children-VlanIf] -VlanId $vlanId 
               }
               <a name="::logcmd(7)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::config [<a name="::logcmd(8)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $deviceHndl -children-Ipv4If] -Address $ipAddressForThisInterface -Gateway $portGwIpAddr
               set suffixMacAddr [format &#34;%02x %02x %02x&#34; 10 94 $gCount]
               set curMac [join &#34;$startMacAddr $suffixMacAddr&#34; :]
               set ifInfoEntry [list $portId $ipAddressForThisInterface $curMac]
               lappend ifInfoList $ifInfoEntry
               incr gCount
               set ipAddressForThisInterface [<a name="::incrIpField(1)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipAddressForThisInterface $incrOctet]
            }					
         }
      } msg ] } {
         <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixStartAuth : Failed to start 802.1X authentication  $msg&#34;
         return 0
      }			
      
   }
   ixia -
   ixvm {
      
    set portList [list]

    ;<span class="comment-line"># List of port intf {{&lt;port&gt; &lt;IP&gt; &lt;MAC&gt;} ... }</span>
    set ifInfoList [list]

    ;<span class="comment-line"># Configure interfaces for each port</span>
    foreach port $portInfoList {

	set portId [lindex $port 0]
	<a name="::MapIxiaPortId(3)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> [lindex $portId 0] ch ca po

	set portStartIpAddr [lindex $port 1]
	set portGwIpAddr [lindex $port 2]
	set numSupplicants [lindex $port 3]
	set vlanId [lindex $port 4]

	;<span class="comment-line"># Create a portList</span>
	lappend portList &#34;$ch $ca $po&#34;

	<a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;portStartIpAddr:$portStartIpAddr  \
		portGwIpAddr:$portGwIpAddr numSupplicants:$numSupplicants&#34; 

	;<span class="comment-line"># Default each port before configuring</span>
        if [<a name="::port(1)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> setFactoryDefaults $ch $ca $po] {
            <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;WARNING: port setFactoryDefaults $ch $ca $po failed&#34;
	    continue
        }

	set incrOctet 4
	interfaceTable  select  $ch $ca $po
	
	interfaceTable clearAllInterfaces
	interfaceEntry clearAllItems addressTypeIpV6
	interfaceEntry clearAllItems addressTypeIpV4
	
	set ipAddressForThisInterface $portStartIpAddr

	set gCount 1
	for {set count 1} {$count &lt;= $numSupplicants} {incr count} {

	    set curMac &#34;$startMacAddr [format &#34;%02x %02x %02x&#34; $ca $po $gCount]&#34;

	    set ifInfoEntry [list $portId $ipAddressForThisInterface $curMac]
	    lappend ifInfoList $ifInfoEntry

	    <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ipAddressForThisInterface: $ipAddressForThisInterface MAC: $curMac&#34;
	    
	    interfaceIpV4   setDefault
	    interfaceIpV4   config      -gatewayIpAddress  $portGwIpAddr
	    interfaceIpV4   config      -maskWidth         24
	    interfaceIpV4   config      -ipAddress         $ipAddressForThisInterface

	    interfaceEntry  addItem     addressTypeIpV4	    
	    interfaceEntry  setDefault
	    interfaceEntry  config      -enable            $::true
	    interfaceEntry  config      -description       [format &#34;%02d:%02d - $count&#34; $ca $po]
	    interfaceEntry  config      -macAddress        $curMac

	    if {$vlanId != &#34;&#34; } {
		interfaceEntry  config      -enableVlan         $::true
		interfaceEntry  config      -vlanId             $vlanId
	    } else {
		interfaceEntry  config      -enableVlan         $::false
		interfaceEntry  config      -vlanId             0
	    }
	    interfaceTable  addInterface

	    if {$protocolServer == &#34;enable&#34;} {
		protocolServer  config      -enableArpResponse  $::true
		protocolServer  config      -enablePingResponse $::true
		if [protocolServer  set $ch $ca $po] {
		    <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR : protocolServer  set $ch $ca $po&#34;
		}
	    }
	    
	    set ipAddressForThisInterface [<a name="::incrIpField(2)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipAddressForThisInterface $incrOctet]
	    incr gCount
	}
    }
    <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Writing portList $portList to hardware.&#34;

    <a name="::ixWritePortsToHardware(1)"><a href="./mapping.tcl.html#::ixWritePortsToHardware_145">::ixWritePortsToHardware</a></a> portList

    ;<span class="comment-line"># Dump some info for debugging.</span>
    ;<span class="comment-line"># dot1x_ixDumpInterfaceInfo</span>
   }

    return $ifInfoList
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixConfigDot1xPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configures Ports for Dot1X.  Uses interfaces created on each </span>
<span class="comment-line">#              port to configure supplicants.  All supplicants for a particular </span>
<span class="comment-line">#              port group will have the same parameters. </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#	portGroupId        ;# Dot1x port group</span>
<span class="comment-line">#	portIdList         ;# Port mapping ID</span>
<span class="comment-line">#	authPeriod         ;# Secs to wait for DUT response 1-3600</span>
<span class="comment-line">#	heldPeriod         ;# Secs after timeout before sending next auth 1-3600</span>
<span class="comment-line">#	startPeriod        ;# Secs between successive EAPOL-Start msgs 1-3600</span>
<span class="comment-line">#	maxStart           ;# Number of EAPOL-Starts before deeming failure 1-10000</span>
<span class="comment-line"># 	fragmentSize       ;# Max frag for EAP TLS packet 500-1400</span>
<span class="comment-line">#	maxSessions        ;# Number sessions for this port</span>
<span class="comment-line">#	setupDelay         ;# Millsec between start of 1 auth to next. 0-4,294,967,295</span>
<span class="comment-line">#	establishDelay     ;# Millsec between completed/failed auth to next multiauth</span>
<span class="comment-line">#	logoffDelay        ;# Millsec delay between successive logoff msgs at teardown</span>
<span class="comment-line">#	dutTestMode        ;# 0 =&gt; Single-Host, 1 =&gt; Multi-Host, 2=&gt; Multi Auth</span>
<span class="comment-line">#	enableSessionOnly  ;# 0 =&gt; Only session, no stream.  We can manually gen stream</span>
<span class="comment-line">#	holdTime           ;# Secs between auth and logoff 0-1,000,000</span>
<span class="comment-line">#	enableRandomHold   ;# 1-Set holdTime to random values</span>
<span class="comment-line">#	enableOnlyMulticastDestMac  ;# 1-Use multicast MAC instead of auth MAC </span>
<span class="comment-line">#	enableAuthOnNoResponse      ;# 1-Supplicant consider itself auth if no response</span>
<span class="comment-line">#	enableStateMachineDebug     ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableConfigurationDebug    ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableEapolFramesDebug      ;# 1- Generate DEBUG LOG  </span>
<span class="comment-line">#	testDuration            ;# Duration of entire test</span>
<span class="comment-line">#	authPass                ;# Password sent for auth	</span>
<span class="comment-line">#	authUser                ;# Username sent for auth</span>
<span class="comment-line">#	dot1xAuth      ;# dot1xAuthMD5,1  dot1xAuthTLS,0</span>
<span class="comment-line">#	dot1xUser      ;# dot1xUserNormal,0 dot1xUserFailing,1 Expect failure.</span>
<span class="comment-line">#	supHoldTime               ;# -1 use port holdTime</span>
<span class="comment-line">#	supNumNoIdResponse        ;# Number of times to suppress EAP-ID msgs 0-100</span>
<span class="comment-line">#	supNumNoAuthResponse      ;# Number of times to suppress EAP-Auth msgs 0-100</span>
<span class="comment-line">#	supEnableWaitIdRequest    ;# &#34;true&#34;-Wait for DUT initiate EAP, rather than sending EAP-start</span>
<span class="comment-line">#       certificateDir            ;# Directory where certificates are located</span>
<span class="comment-line">#	maxSupplicants &#34;          ;# max number of suplicants to add, otherwise 1 per port MAC</span>
<span class="comment-line">#	destroy  &#34;no&#34;             ;# Destroy old port group first</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#    dot1x_ixConfigDot1xPorts -portIdList &#34;1&#34; -portGroupId &#34;1&#34; \</span>
<span class="comment-line">#	   -authUser $uname -authPass $upass</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixConfigDot1xPorts_441">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixConfigDot1xPorts">::::dot1x_ixConfigDot1xPorts</a></a></strong> {args} {
	global TrafficGen
    <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_ixConfigDot1x $args {
        portGroupId &#34;1&#34;        
        portIdList &#34;1&#34;         
        authPeriod &#34;15&#34;        
        heldPeriod &#34;10&#34;        
        startPeriod &#34;10&#34;       
        maxStart &#34;3&#34;           
        fragmentSize &#34;640&#34;     
        maxSessions  &#34;64&#34;      
        setupDelay   &#34;0&#34;       
        establishDelay &#34;1000&#34;  
        logoffDelay &#34;120&#34;       
        dutTestMode  &#34;2&#34;       
        enableSessionOnly &#34;0&#34;
        holdTime &#34;0&#34;
        enableRandomHold &#34;0&#34;
        enableOnlyMulticastDestMac &#34;1&#34;
        enableAuthOnNoResponse &#34;0&#34;
        enableStateMachineDebug &#34;1&#34;
        enableConfigurationDebug &#34;1&#34;
        enableEapolFramesDebug &#34;1&#34;
        testDuration &#34;240&#34;
        authUser  &#34;md5_isp_1&#34;
        authPass  &#34;md5_isp_1&#34;
        dot1xAuth &#34;dot1xAuthMD5&#34;     
        dot1xUser &#34;dot1xUserNormal&#34;  
        supHoldTime &#34;-1&#34;             
        supNumNoIdResponse &#34;0&#34;       
        supNumNoAuthResponse &#34;0&#34;     
        supEnableWaitIdRequest &#34;0&#34;   
        certificateDir &#34;./certfiles&#34; 
        maxSupplicants &#34;0&#34;           
        destroy  &#34;no&#34;                
    }
    
	switch -exact -- $TrafficGen {
		
		stc {
			if { [catch {
				foreach portId $portIdList {
					set hPort [<a name="::hMapPortIdToSpirentPort(2)"><a href="./spirent.tcl.html#::hMapPortIdToSpirentPort_216">::hMapPortIdToSpirentPort</a></a> $portId]
					foreach emulatedDevice [<a name="::logcmd(9)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $hPort -affiliationport-Sources] {
						<a name="::logcmd(10)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::config [lindex [<a name="::logcmd(11)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -children-Ipv4If] 0] -ResolveGatewayMac true
					    <a name="::logcmd(12)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform ArpNdStartCommand -HandleList $emulatedDevice
						set dutMac [<a name="::logcmd(13)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get [lindex [<a name="::logcmd(14)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -children-Ipv4If] 0] -GatewayMac]
						if {$dot1xAuth == &#34;dot1xAuthMD5&#34;} {
							set hDot1xConfig [<a name="::logcmd(15)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::create Dot1xSupplicantBlockConfig -under $emulatedDevice -AuthenticatorMac $dutMac -EapAuthMethod &#34;MD5&#34;]
							<a name="::logcmd(16)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::config [lindex [<a name="::logcmd(17)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $hDot1xConfig -children-Dot1xEapMd5Config] 0] -UserId $authUser -Password $authPass
							
						} elseif {$dot1xAuth == &#34;dot1xAuthTLS&#34;} {							
							set hDot1xConfig [<a name="::logcmd(18)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::create Dot1xSupplicantBlockConfig -under $emulatedDevice -AuthenticatorMac $dutMac -EapAuthMethod &#34;TLS&#34;]
							<a name="::logcmd(19)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::create Dot1xEapTlsConfig -under $hDot1xConfig -UserId $authUser -Password $authPass
							<a name="::logcmd(20)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform Dot1xDownloadCertificateCommand -CertificateDir $certificateDir -ObjectList $hPort
						} else {
							<a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixConfigDot1xPorts : Authentication type $dot1xAuth  not supported&#34;
						}
						
					}					
				}
			} msg ] } {
				<a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixConfigDot1xPorts : Failed to configure 802.1X authentication  $msg&#34;
				return 0
			}			
			
		}
		
		ixia -
        ixvm {
            ;<span class="comment-line"># Generate Ixia portList from IDs</span>
            foreach portId $portIdList {
                <a name="::MapIxiaPortId(4)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
                lappend portList &#34;$chassis $card $port&#34;
            }
            <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Establishing communication with port CPUs $portList &#34;

            set status [dot1xSetup $portList]
            if {$status} {
                <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR: Could not set up ports for dot1x status $status&#34;
                return 0
            }

            if {$destroy  == &#34;yes&#34;} {
                ;<span class="comment-line"># Destroy old port group</span>
                dot1xPortGroup destroy $portGroupId
            }


            <span class="comment-line"># Create a port Group</span>


            dot1xPortGroup setDefault
            dot1xPortGroup create $portGroupId
            
            <span class="comment-line"># Setup generic port properties</span>


            dot1xPort setDefault
            dot1xPort config -authPeriod        $authPeriod
            dot1xPort config -heldPeriod        $heldPeriod
            dot1xPort config -startPeriod       $startPeriod
            dot1xPort config -maxStart          $maxStart
            dot1xPort config -fragmentSize      $fragmentSize
            dot1xPort config -maxSessions       $maxSessions
            dot1xPort config -setupDelay        $setupDelay
            dot1xPort config -establishDelay    $establishDelay
            dot1xPort config -logoffDelay       $logoffDelay
            dot1xPort config -dutTestMode       $dutTestMode
            dot1xPort config -enableSessionOnly $enableSessionOnly
            dot1xPort config -holdTime          $holdTime
            dot1xPort config -enableRandomHold           $enableRandomHold
            dot1xPort config -enableOnlyMulticastDestMac $enableOnlyMulticastDestMac
            dot1xPort config -enableAuthOnNoResponse     $enableAuthOnNoResponse
            dot1xPort config -enableStateMachineDebug    $enableStateMachineDebug
            dot1xPort config -enableConfigurationDebug   $enableConfigurationDebug
            dot1xPort config -enableEapolFramesDebug     $enableEapolFramesDebug
            dot1xPort config -testDuration               $testDuration
            
            <span class="comment-line"># Create configuration for each port we are interested in</span>


            foreach testPort $portList {
                
                <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Creating dot1x configuration for the port $testPort&#34;
                
                <span class="comment-line"># Setup individual port</span>


                scan $testPort &#34;%d %d %d&#34; ch ca po
                dot1xPort set  $ch $ca $po
                dot1xPortGroup add $portGroupId $ch $ca $po
                
                <span class="comment-line"># Cleanup the supplicant table for this port</span>


                dot1xSupplicantTable select $ch $ca $po
                dot1xSupplicantTable delAll
                
                <span class="comment-line"># Add supplicants to this port</span>


                set supplicantMacList [<a name="::dot1x_ixGetIfMacs(2)"><a href="./Dot1XLib.tcl.html#::dot1x_ixGetIfMacs_193">::dot1x_ixGetIfMacs</a></a> $ch $ca $po]
                if {$maxSupplicants &gt; 0} {
                    ;<span class="comment-line"># Only add max count</span>
                    set supplicantMacList [lrange $supplicantMacList 0 [expr $maxSupplicants - 1]]
                }
                
                foreach suppMac $supplicantMacList {
                    dot1xSupplicant setDefault
                    dot1xSupplicant config -macAddr $suppMac
                    dot1xSupplicant config -userType $dot1xUser
                    dot1xSupplicant config -authType $dot1xAuth
                    dot1xSupplicant config -userName $authUser
                    dot1xSupplicant config -passWord $authPass
                    dot1xSupplicant config -holdTime $supHoldTime
                    dot1xSupplicant config -numNoIdResponse $supNumNoIdResponse
                    dot1xSupplicant config -numNoAuthResponse $supNumNoAuthResponse
                    dot1xSupplicant config -enableWaitIdRequest $supEnableWaitIdRequest
                    dot1xSupplicantTable add
                    <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po) Adding MAC:$suppMac u:$authUser p:$authPass authType:$dot1xAuth userType:$dot1xUser&#34;
                    <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     numNoIdResponse:$supNumNoIdResponse numNoAuthResponse:$supNumNoAuthResponse&#34;
                    <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     enableWaitIdRequest:$supEnableWaitIdRequest&#34;
                }
                    
                <span class="comment-line"># Setup maxsessions</span>


                set aSupplicantCnt [llength $supplicantMacList]
                dot1xPort config -maxSessions $aSupplicantCnt
                dot1xPort set  $ch $ca $po
            }
            

            <span class="comment-line"># All ports have been added to a port group. Now write the entire group</span>


            dot1xPortGroup setCommand $portGroupId writeConfig
            
            <span class="comment-line"># Initialize the stat information for this group</span>


            dot1xPortGroup setCommand $portGroupId resetStats

            <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;AuthType is $dot1xAuth&#34;

            if {$dot1xAuth == &#34;dot1xAuthTLS&#34;} {    

            <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Downloading certificates from $certificateDir to ports $portList&#34;

            <span class="comment-line"># Download Certificate files on the port for TLS authentication</span>
            
            <span class="comment-line"># Use this command for downloading all the cert in dir to all ports	</span>
            dot1xDownloadCertificates $portList $certificateDir
            
            <span class="comment-line"># set usernamelist {}</span>
            <span class="comment-line"># lappend usernamelist $authUser</span>
            <span class="comment-line"># Use the command below for individual certificates</span>
            <span class="comment-line"># dot1xDownloadUserSpecificCertificates $ch $ca $po \</span>
                <span class="comment-line">#    &#34;C:\\Program Files\\Ixia\\authfiles&#34; \</span>
                <span class="comment-line">#    &#34;C:\\Program Files\\Ixia\\authfiles&#34; \</span>
                <span class="comment-line">#    $usernamelist</span>
            }
		}
	}	
    return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixConfigDot1xPortOnly</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configures Ports for Dot1X.  DOES NOT configure</span>
<span class="comment-line">#              supplicants.  Allows us to configure the ports,</span>
<span class="comment-line">#              THEN configure &#34;custom&#34; supplicants.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#	portGroupId         ;# Dot1x port group</span>
<span class="comment-line">#	portIdList          ;# Port mapping ID</span>
<span class="comment-line">#	authPeriod          ;# Secs to wait for DUT response 1-3600</span>
<span class="comment-line">#	heldPeriod          ;# Secs after timeout before sending next auth 1-3600</span>
<span class="comment-line">#	startPeriod         ;# Secs between successive EAPOL-Start msgs 1-3600</span>
<span class="comment-line">#	maxStart            ;# Number of EAPOL-Starts before deeming failure 1-10000</span>
<span class="comment-line"># 	fragmentSize        ;# Max frag for EAP TLS packet 500-1400</span>
<span class="comment-line">#	maxSessions         ;# Number sessions for this port</span>
<span class="comment-line">#	setupDelay          ;# Millsec between start of 1 auth to next. 0-4,294,967,295</span>
<span class="comment-line">#	establishDelay      ;# Millsec between completed/failed auth to next multiauth</span>
<span class="comment-line">#	logoffDelay         ;# Millsec delay between successive logoff msgs at teardown</span>
<span class="comment-line">#	dutTestMode         ;# 0 =&gt; Single-Host, 1 =&gt; Multi-Host, 2=&gt; Multi Auth</span>
<span class="comment-line">#	enableSessionOnly   ;# 0 =&gt; Only session, no stream.  We can manually gen stream</span>
<span class="comment-line">#	holdTime            ;# Secs between auth and logoff 0-1,000,000</span>
<span class="comment-line">#	enableRandomHold    ;# 1-Set holdTime to random values</span>
<span class="comment-line">#	enableOnlyMulticastDestMac   ;# 1-Use multicast MAC instead of auth MAC </span>
<span class="comment-line">#	enableAuthOnNoResponse    ;# 1-Supplicant consider itself auth if no response</span>
<span class="comment-line">#	enableStateMachineDebug   ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableConfigurationDebug  ;# 1- Generate DEBUG LOG</span>
<span class="comment-line">#	enableEapolFramesDebug    ;# 1- Generate DEBUG LOG  </span>
<span class="comment-line">#	testDuration              ;# Duration of entire test</span>
<span class="comment-line">#       certificateDir            ;# Directory where certificates are located</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">#  Typical Usage:</span>
<span class="comment-line">#    dot1x_ixConfigDot1xPortOnly -portIdList &#34;1&#34; -portGroupId &#34;1&#34; \</span>
<span class="comment-line">#	   -authUser $uname -authPass $upass</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixConfigDot1xPortOnly_689">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixConfigDot1xPortOnly">::::dot1x_ixConfigDot1xPortOnly</a></a></strong> {args} {
    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_ixConfigDot1x $args {
	portGroupId &#34;1&#34;
	portIdList &#34;1&#34;
	authPeriod &#34;15&#34;
	heldPeriod &#34;10&#34;
	startPeriod &#34;10&#34;
	maxStart &#34;3&#34;
 	fragmentSize &#34;640&#34;
	maxSessions  &#34;64&#34;
	setupDelay   &#34;0&#34;
	establishDelay &#34;1000&#34;
	logoffDelay &#34;20&#34;
	dutTestMode  &#34;2&#34;
	enableSessionOnly &#34;0&#34;
	holdTime &#34;0&#34;
	enableRandomHold &#34;0&#34;
	enableOnlyMulticastDestMac &#34;1&#34;
	enableAuthOnNoResponse &#34;0&#34;
	enableStateMachineDebug &#34;1&#34;
	enableConfigurationDebug &#34;1&#34;
	enableEapolFramesDebug &#34;1&#34;
	testDuration &#34;3600&#34;
        certificateDir &#34;./certfiles&#34;
    }
    
    ;<span class="comment-line"># Generate Ixia portList from IDs</span>
    foreach portId $portIdList {
        <a name="::MapIxiaPortId(5)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
        lappend portList &#34;$chassis $card $port&#34;
    }
    <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Establishing communication with port CPUs $portList &#34;

    set status [dot1xSetup $portList]
    if {$status} {
        <a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ERROR: Could not set up ports for dot1x status $status&#34;
        return 0
    }

    <span class="comment-line"># Create a port Group</span>


    dot1xPortGroup setDefault
    dot1xPortGroup create $portGroupId
    
    <span class="comment-line"># Setup generic port properties</span>


    dot1xPort setDefault
    dot1xPort config -authPeriod        $authPeriod
    dot1xPort config -heldPeriod        $heldPeriod
    dot1xPort config -startPeriod       $startPeriod
    dot1xPort config -maxStart          $maxStart
    dot1xPort config -fragmentSize      $fragmentSize
    dot1xPort config -maxSessions       $maxSessions
    dot1xPort config -setupDelay        $setupDelay
    dot1xPort config -establishDelay    $establishDelay
    dot1xPort config -logoffDelay       $logoffDelay
    dot1xPort config -dutTestMode       $dutTestMode
    dot1xPort config -enableSessionOnly $enableSessionOnly
    dot1xPort config -holdTime          $holdTime
    dot1xPort config -enableRandomHold           $enableRandomHold
    dot1xPort config -enableOnlyMulticastDestMac $enableOnlyMulticastDestMac
    dot1xPort config -enableAuthOnNoResponse     $enableAuthOnNoResponse
    dot1xPort config -enableStateMachineDebug    $enableStateMachineDebug
    dot1xPort config -enableConfigurationDebug   $enableConfigurationDebug
    dot1xPort config -enableEapolFramesDebug     $enableEapolFramesDebug
    dot1xPort config -testDuration               $testDuration
    
    <span class="comment-line"># Create configuration for each port we are interested in</span>


    foreach testPort $portList {
        
        <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Creating dot1x configuration for the port $testPort&#34;
        
        <span class="comment-line"># Setup individual port</span>


        scan $testPort &#34;%d %d %d&#34; ch ca po
        dot1xPort set  $ch $ca $po
        dot1xPortGroup add $portGroupId $ch $ca $po	
    }
	
    <span class="comment-line"># Cleanup the supplicant table for this port</span>


    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable delAll

    <span class="comment-line"># All ports have been added to a port group. Now write the entire group</span>


    dot1xPortGroup setCommand $portGroupId writeConfig
    
    <span class="comment-line"># Initialize the stat information for this group</span>


    dot1xPortGroup setCommand $portGroupId resetStats

}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixAddSupplicantToPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Once dot1xPort is configured, this procedure can be</span>
<span class="comment-line">#              used to add 1 or more supplicants to that port.</span>
<span class="comment-line">#              Each supplicant can be configured with different</span>
<span class="comment-line">#              parameters</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:</span>
<span class="comment-line">#	portId                  ;# Port mapping ID</span>
<span class="comment-line">#	suppMac                 ;# Supplicant MAC</span>
<span class="comment-line">#	authUser                ;# Username</span>
<span class="comment-line">#	authPass                ;# Password</span>
<span class="comment-line">#	dot1xAuth               ;# dot1xAuthMD5,1  dot1xAuthTLS,0</span>
<span class="comment-line">#	dot1xUser               ;# dot1xUserNormal,0 dot1xUserFailing,1 Expect failure.</span>
<span class="comment-line">#	supHoldTime             ;# -1 use port holdTime</span>
<span class="comment-line">#	supNumNoIdResponse      ;# Number of times to suppress EAP-ID msgs (0-100)</span>
<span class="comment-line">#	supNumNoAuthResponse    ;# Number of times to suppress EAP-Auth msgs (0-100)</span>
<span class="comment-line">#	supEnableWaitIdRequest  ;# 1-Wait for DUT initiate EAP, rather than sending EAP-start</span>
<span class="comment-line">#	doWriteHw               ;# Option to write to to Ixia hw now.  Gives user</span>
<span class="comment-line">#                               ;# to do several adds then a single write.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args:  None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixAddSupplicantToPort_819">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixAddSupplicantToPort">::::dot1x_ixAddSupplicantToPort</a></a></strong> {args} {
    <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_ixAddSupplicantToPort $args {
	portId    1
	suppMac   &#34;00 00 00 00 00 01&#34;
	authUser  &#34;md5_isp_1&#34;
	authPass  &#34;md5_isp_1&#34;
	dot1xAuth &#34;dot1xAuthMD5&#34;
	dot1xUser &#34;dot1xUserNormal&#34;
	supHoldTime &#34;-1&#34;
	supNumNoIdResponse &#34;0&#34;
	supNumNoAuthResponse &#34;0&#34;
	supEnableWaitIdRequest &#34;0&#34;
	doWriteHw  &#34;1&#34;
    }

    <a name="::MapIxiaPortId(6)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po
    <a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Adding Supplicant to $ch $ca $po&#34;

    dot1xSupplicantTable select $ch $ca $po
	
    <span class="comment-line"># Add supplicant to this port</span>


    dot1xSupplicant setDefault
    dot1xSupplicant config -macAddr $suppMac
    dot1xSupplicant config -userType $dot1xUser
    dot1xSupplicant config -authType $dot1xAuth
    dot1xSupplicant config -userName $authUser
    dot1xSupplicant config -passWord $authPass
    dot1xSupplicant config -holdTime $supHoldTime
    dot1xSupplicant config -numNoIdResponse $supNumNoIdResponse
    dot1xSupplicant config -numNoAuthResponse $supNumNoAuthResponse
    dot1xSupplicant config -enableWaitIdRequest $supEnableWaitIdRequest
    dot1xSupplicantTable add
    <a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po) Adding MAC:$suppMac u:$authUser p:$authPass authType:$dot1xAuth userType:$dot1xUser&#34;
    <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     numNoIdResponse:$supNumNoIdResponse numNoAuthResponse:$supNumNoAuthResponse&#34;
    <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($ch:$ca:$po)     enableWaitIdRequest:$supEnableWaitIdRequest&#34;
    
    if { $doWriteHw == &#34;1&#34; } {
        dot1xSupplicantTable write
    }

}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForSupAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that loops waiting  for a particular </span>
<span class="comment-line">#              supplicant to authenticate.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 0 - Failed to authenticate</span>
<span class="comment-line">#              1 - Authenticate successful</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForSupAuth_878">proc <a href="Dot1XLib.tcl-annot.html#::::_ixWaitForSupAuth">::::_ixWaitForSupAuth</a></a></strong> { portId mac maxAuthWait } {

    <a name="::MapIxiaPortId(7)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    set curDuration 0
    
    while {$curDuration &lt; $maxAuthWait} {
        puts &#34;Waiting for mac $mac to Auth (max:$maxAuthWait)... $curDuration&#34;
        after 1000

        dot1xSupplicantStats get $ch $ca $po $mac
        if { [dot1xSupplicantStats cget -totalSuccess] &gt;= 1 } {
            break
        }
        incr curDuration 1
    }

    if {$curDuration == $maxAuthWait} {
        <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication could not be completed for $mac =====&#34;
        return 0
    }

    <a name="::dot1x_ixDumpSupplicantStats(1)"><a href="./Dot1XLib.tcl.html#::dot1x_ixDumpSupplicantStats_2241">::dot1x_ixDumpSupplicantStats</a></a> $portId $mac 
    return 1

}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStartSupAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Wait for a particular supplicant to authenticate.</span>
<span class="comment-line">#              This assumes we reset counters prior to starting since </span>
<span class="comment-line">#              we check that totalSuccess is greater than 1.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 0 - Failed to authenticate</span>
<span class="comment-line">#              1 - Authenticate successful</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStartSupAuth_922">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStartSupAuth">::::dot1x_ixStartSupAuth</a></a></strong> { portId mac {maxAuthWait 10} } {

    <a name="::MapIxiaPortId(8)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    ;<span class="comment-line"># Reset stats before starting.</span>
    dot1xSupplicantStats reset $ch $ca $po $mac

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable start $mac
    <a name="::result_debug(27)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Starting sup $mac&#34;

    if { $maxAuthWait != 0 } {
        if { [<a name="::_ixWaitForSupAuth(1)"><a href="./Dot1XLib.tcl.html#::_ixWaitForSupAuth_878">::_ixWaitForSupAuth</a></a> $portId $mac $maxAuthWait] == 0 } { 
            <a name="::result_debug(28)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Authentication failed for mac $mac...test exiting.&#34;
            return 0
        }
    } else {
        <a name="::result_debug(29)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not waiting for authentication of mac $mac...&#34;
    }

    return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStopSupAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Stop a particular supplicant's authenticated session.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStopSupAuth_956">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStopSupAuth">::::dot1x_ixStopSupAuth</a></a></strong> { portId mac {maxAuthWait 4} } {

    <a name="::MapIxiaPortId(9)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    ;<span class="comment-line"># Reset stats before starting.</span>
    dot1xSupplicantStats reset $ch $ca $po $mac

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable stop $mac
    <a name="::result_debug(30)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stopping sup $mac&#34;

    <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $maxAuthWait

    return 1
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixDelSupMac</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Delete a particular supplicant from supplicant table.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID of supplicants</span>
<span class="comment-line">#             mac: Specific MAC of supplicant to wait for</span>
<span class="comment-line">#             maxAuthWait: Max time to wait</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixDelSupMac_982">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixDelSupMac">::::dot1x_ixDelSupMac</a></a></strong> { portId mac {maxAuthWait 4} {doWriteHw 1}} {

    <a name="::MapIxiaPortId(10)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    dot1xSupplicantTable select $ch $ca $po
    dot1xSupplicantTable del $mac
    <a name="::result_debug(31)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Deleting sup $mac&#34;

    if { $doWriteHw == &#34;1&#34; } {
        dot1xSupplicantTable write
    }

    <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $maxAuthWait

    return 1
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixDestroyDot1xPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Wait for a particular supplicant to authenticate.</span>
<span class="comment-line">#              This assumes we reset counters prior to starting since </span>
<span class="comment-line">#              we check that totalSuccess is greater than 1.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: -portGroupId: Dot1x port group</span>
<span class="comment-line">#             -portIdList: Port IDs in group to destroy </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixDestroyDot1xPorts_1012">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixDestroyDot1xPorts">::::dot1x_ixDestroyDot1xPorts</a></a></strong> {args} {
	global TrafficGen
	global DEBUG_DOT1X_CRASH
	
    <a name="::parse_args(5)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_ixDestroyDot1x $args {
        portGroupId &#34;1&#34;
        portIdList &#34;1&#34;
    }
    
	switch -exact -- $TrafficGen {
		stc {
			if { [catch {
				foreach portId $portIdList {
					set hPort [<a name="::hMapPortIdToSpirentPort(3)"><a href="./spirent.tcl.html#::hMapPortIdToSpirentPort_216">::hMapPortIdToSpirentPort</a></a> $portId]
					if {$hPort == &#34;&#34;} {
						<a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error: Port object handle for port $portId not found for STC&#34;
						return
					}
					foreach emulatedDevice [<a name="::logcmd(21)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $hPort -affiliationport-Sources] {
						
						if {[<a name="::logcmd(22)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -children-Dot1xSupplicantBlockConfig] != &#34;&#34;} {
							<a name="::logcmd(23)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::delete $emulatedDevice
						}
					}
				}
				 
			} msg ] } {
				<a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixDestroyDot1xPorts : $msg&#34;
				return 0
			} 
			
			<a name="::logcmd(24)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::apply
		}
		ixia -
        ixvm {
            if {$DEBUG_DOT1X_CRASH == 1} { 
                <a name="::dot1x_CheckDot1xTaskCrash(1)"><a href="./Dot1XLib.tcl.html#::dot1x_CheckDot1xTaskCrash_4301">::dot1x_CheckDot1xTaskCrash</a></a> 
            }

            ;<span class="comment-line"># Generate Ixia portList from IDs</span>
            foreach portId $portIdList {
                <a name="::MapIxiaPortId(11)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId chassis card port
                lappend portList &#34;$chassis $card $port&#34;
            }

            <a name="::result_debug(32)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Cleaning up DOT1x $portList &#34;

            dot1xPortGroup destroy $portGroupId
            dot1xCleanup $portList
        }
	}
}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixCheckPortGroupStats</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Check the dot1x port group stats against a particular </span>
<span class="comment-line">#              value.  Posts actual pass/fail.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             stat: Which stat to compare. See below for values</span>
<span class="comment-line">#             operator: ==, &gt;, &lt;, etc.</span>
<span class="comment-line">#             value: Value to compare against</span>
<span class="comment-line">#</span>
<span class="comment-line"># VALID IXIA stat PARAMETER:</span>
<span class="comment-line">#   allSessionsEstablished, lastStats, </span>
<span class="comment-line">#   eapolStartSent, eapIdResponseSent, eapolLogoffSent, eapNonIdResponseSent, </span>
<span class="comment-line">#   eapIdRequestReceived, eapNonIdRequestReceived, eapSuccessReceived, </span>
<span class="comment-line">#   eapFailureReceived, eapAlertReceived, eapUnExpFailure, </span>
<span class="comment-line">#   md5Sessions, md5Success, md5FailTimeout, md5FailEap, md5MaxLatency</span>
<span class="comment-line">#   md5MinLatency, md5AvgLatency</span>
<span class="comment-line">#   tlsSessions, tlsSuccess, tlsFailTimeout, tlsFailEap, tlsMaxLatency</span>
<span class="comment-line">#   tlsMinLatency, tlsAvgLatency</span>
<span class="comment-line">#   invSessions, invSuccess, invFailTimeout, invFailEap</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixCheckPortGroupStats_1093">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixCheckPortGroupStats">::::dot1x_ixCheckPortGroupStats</a></a></strong> {dot1xPortGroupId stat operator value} {

    dot1xPortGroup setCommand $dot1xPortGroupId getStats
    set curStats [dot1xPortStats cget -$stat]

    <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Check Port GroupStats $stat:$curStats $operator $value&#34;

    if {! [expr $curStats $operator $value]} {
        <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Stats check failed $stat..$curStats $operator $value&#34;
    }
    <a name="::result_debug(33)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stat:$stat:$curStats     $operator $value&#34;
    <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to wait for all supplicants in a group</span>
<span class="comment-line">#              to authenticate.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForAuth_1123">proc <a href="Dot1XLib.tcl-annot.html#::::_ixWaitForAuth">::::_ixWaitForAuth</a></a></strong> {dot1xPortGroupId maxAuthWait} {

    set curDuration 0
    set success 0

    while {$curDuration &lt; $maxAuthWait} {
        puts -nonewline &#34;Waiting(max:$maxAuthWait)... $curDuration                           \r &#34;
        flush stdout
        after 1000
        dot1xPortGroup setCommand $dot1xPortGroupId getStats
        if {[dot1xPortStats cget -allSessionEstablished]} {
            <a name="::result_debug(34)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication completed successfully =====&#34;
            set success 1
            break
        }
        incr curDuration 1
    }

    if {$curDuration == $maxAuthWait} {
        <a name="::result_debug(35)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Authentication could not be completed =====&#34;
        set success 0
    }
    
    ;<span class="comment-line"># Dump out some stats</span>
    dot1xPortGroup setCommand $dot1xPortGroupId getStats
    set eapolStartSent [dot1xPortStats cget -eapolStartSent]
    set eapolLogoffSent [dot1xPortStats cget -eapolLogoffSent]
    set eapolSuccessReceived [dot1xPortStats cget -eapSuccessReceived]
    set eapolFailureReceived [dot1xPortStats cget -eapFailureReceived]
    set eapolAlertReceived [dot1xPortStats cget -eapAlertReceived]
    
    <a name="::result_debug(36)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolStartSent:       $eapolStartSent&#34;
    <a name="::result_debug(37)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolLogoffSent:      $eapolLogoffSent&#34;
    <a name="::result_debug(38)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolSuccessReceived: $eapolSuccessReceived&#34;
    <a name="::result_debug(39)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolFailureReceived: $eapolFailureReceived&#34;
    <a name="::result_debug(40)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;eapolAlertReceived:   $eapolAlertReceived&#34;
    
    return $success
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixWaitForDeauth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to wait for all supplicants in a group</span>
<span class="comment-line">#              to become unauthenticated.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixWaitForDeauth_1176">proc <a href="Dot1XLib.tcl-annot.html#::::_ixWaitForDeauth">::::_ixWaitForDeauth</a></a></strong> {dot1xPortGroupId maxDeauthWait} {

    set curDuration 0
    set success 0

    while {$curDuration &lt; $maxDeauthWait} {
        puts &#34;Waiting(max:$maxDeauthWait)... $curDuration&#34;
        after 1000
        dot1xPortGroup setCommand $dot1xPortGroupId getStats
        if {[dot1xPortStats cget -lastStats]} {
            ;<span class="comment-line"># Wait extra 3 seconds for Ixia state machine to shutdown</span>
            sleep 3
            <a name="::result_debug(41)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Deauthentication completed normally =====&#34;
            set success 1
            break
        }
        incr curDuration 1
    }

    if {$curDuration == $maxDeauthWait} {
        <a name="::result_debug(42)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;===== Deauthentication timed out =====&#34;
        set success 0
    }
    return $success
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStartAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Start authentication for a dot1x port group</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStartAuth_1215">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStartAuth">::::dot1x_ixStartAuth</a></a></strong> { dot1xPortGroupId {maxAuthWait &#34;30&#34;} } {

    <a name="::result_debug(43)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Started Authentications..Max Wait: $maxAuthWait secs.&#34;

		global TrafficGen	
		switch -exact -- $TrafficGen {
            stc {
                if { [catch {
                    set hPort [<a name="::hMapPortIdToSpirentPort(4)"><a href="./spirent.tcl.html#::hMapPortIdToSpirentPort_216">::hMapPortIdToSpirentPort</a></a> $dot1xPortGroupId]
                    <a name="::logcmd(25)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform Dot1xStartAuthCommand -ObjectList $hPort
                    if { $maxAuthWait != 0 } {
                        array set returnList [<a name="::logcmd(26)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform Dot1xWaitForAuthStateCommand \
                                -ObjectList $hPort -WaitSupplicantState &#34;AUTH_SUCCESS&#34; -WaitTime $maxAuthWait]
                        if {$returnList(-PassFailState) == &#34;FAILED&#34;} {
                            <a name="::result_debug(44)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Authentication failed...test exiting.&#34;
                            return 0
                        }
                    } else {
                        <a name="::result_debug(45)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not waiting for authentication...&#34;
                    }
                } msg ] } {
                    <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixStartAuth : Failed to start 802.1X authentication  $msg&#34;
                    return 0
                }	
                
                
            }
            ixia -
            ixvm {
                dot1xPortGroup setCommand $dot1xPortGroupId resetStats
                dot1xPortGroup setCommand $dot1xPortGroupId startTest

                if { $maxAuthWait != 0 } {
                    if { [<a name="::_ixWaitForAuth(1)"><a href="./Dot1XLib.tcl.html#::_ixWaitForAuth_1123">::_ixWaitForAuth</a></a> $dot1xPortGroupId $maxAuthWait] == 0 } { 
                        <a name="::result_debug(46)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Authentication failed...test exiting.&#34;
                        <a name="::nl_exDumpDebugInfo(1)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>		
                        return 0
                    }
                } else {
                    <a name="::result_debug(47)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Not waiting for authentication...&#34;
                }
            }
	    }
    ;<span class="comment-line"># Allow 2 seconds to make sure info show up in &#34;sh netlogin&#34;</span>
    sleep 2

    return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStopAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Deauthenticate a dot1x port group</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dot1xPortGroupId: dot1x group ID</span>
<span class="comment-line">#             maxAuthWait: Max time in sec to wait</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStopAuth_1276">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStopAuth">::::dot1x_ixStopAuth</a></a></strong> { dot1xPortGroupId {maxAuthWait &#34;30&#34;} } {
	global TrafficGen	
    switch -exact -- $TrafficGen {
        stc {
            if { [catch {
                set hPort [<a name="::hMapPortIdToSpirentPort(5)"><a href="./spirent.tcl.html#::hMapPortIdToSpirentPort_216">::hMapPortIdToSpirentPort</a></a> $dot1xPortGroupId]
                <a name="::logcmd(27)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::perform Dot1xLogoutCommand -ObjectList $hPort
                <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $maxAuthWait
                <span class="comment-line">#array set returnList [logcmd stc::perform Dot1xWaitForAuthStateCommand \</span>
                <span class="comment-line">#            -ObjectList $hPort -WaitSupplicantState &#34;UNAUTHORIZED&#34; -WaitTime $maxAuthWait]</span>
                <span class="comment-line">#if {$returnList(-PassFailState) == &#34;FAILED&#34;} {</span>
                <span class="comment-line">#	result_debug &#34;dot1x_ixStopAuth: 802.1X supplicant logout failed...test exiting.&#34;</span>
                <span class="comment-line">#	return 0</span>
                <span class="comment-line">#} </span>
            } msg ] } {
                <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixStopAuth : Failed to stop 802.1X authentication  $msg&#34;
                return 0
            }
        }
        ixia -
        ixvm {
            <a name="::result_debug(48)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stopping Authentications...&#34;

            dot1xPortGroup setCommand $dot1xPortGroupId stopTest

            if {[<a name="::_ixWaitForDeauth(1)"><a href="./Dot1XLib.tcl.html#::_ixWaitForDeauth_1176">::_ixWaitForDeauth</a></a> $dot1xPortGroupId $maxAuthWait] == 0} {
                <a name="::result_debug(49)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Deauthentication timeout...test exiting.&#34;
                return 0
            }
        }
    }
    return 1
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixDumpInterfaceInfo</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Debug routine to dump interface info for a port ID</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: portId: Port ID.  No port ID dumps ALL ports info</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixDumpInterfaceInfo_1319">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixDumpInterfaceInfo">::::dot1x_ixDumpInterfaceInfo</a></a></strong> {{portId 0}} {

    global portMappingList
	global TrafficGen	
	
    switch -exact -- $TrafficGen {
		stc {
			if { [catch {
				if {$portId == &#34;0&#34;} {
					set hPortList [<a name="::logcmd(28)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get [<a name="::logcmd(29)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get system1 -children-project] -children-port]
				} else {
					set hPortList [<a name="::hMapPortIdToSpirentPort(6)"><a href="./spirent.tcl.html#::hMapPortIdToSpirentPort_216">::hMapPortIdToSpirentPort</a></a> $portId]
				}
				foreach hPort $hPortList {	
					foreach emulatedDevice [<a name="::logcmd(30)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $hPort -affiliationport-Sources] {
						puts &#34;[<a name="::logcmd(31)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $hPort -Location], [<a name="::logcmd(32)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -Name] InterfaceMac: [<a name="::logcmd(33)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get [<a name="::logcmd(34)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -children-EthIIIf] -SourceMac]&#34;
						puts &#34;     IP:[<a name="::logcmd(35)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get [<a name="::logcmd(36)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -children-Ipv4If] -Address] GW:[<a name="::logcmd(37)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get [<a name="::logcmd(38)"><a href="./spirent.tcl.html#::logcmd_26">::logcmd</a></a> stc::get $emulatedDevice -children-Ipv4If] -Gateway]&#34;
					}
				}
			} msg ] } {
				<a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;dot1x_ixDumpInterfaceInfo : $msg&#34;
				return 0
			} 
		}
		ixia -
        ixvm {
            if {$portId == 0} {
                ;<span class="comment-line"># Get ALL</span>
                set numIxiaPorts [llength $portMappingList]
                set ixiaPortId [lindex [lindex $portMappingList 0] 0]
            } else {
                set numIxiaPorts 1
                set ixiaPortId $portId
            }

            ;<span class="comment-line"># Walk through each port to get interface info</span>
            set i 1
            while {$numIxiaPorts} {
                <a name="::MapIxiaPortId(12)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $ixiaPortId ch ca po
                interfaceTable select $ch $ca $po
                ;<span class="comment-line"># Walk through interfaceTable to see what we got!</span>
                for {set curIf [interfaceTable getFirstInterface]} \
                   {$curIf == 0 } {set curIf [interfaceTable getNextInterface]} {

                    puts &#34;($ch:$ca:$po) InterfaceMac: [interfaceEntry cget -macAddress]&#34;
                    ;<span class="comment-line"># Walk through IPv4 entries</span>
                    for {set curIPv4 [interfaceEntry getFirstItem addressTypeIpV4]} \
                      {$curIPv4 == 0} {set curIPv4 [interfaceEntry getNextItem addresTypeIpV4] } {
                        puts &#34;     IP:[interfaceIpV4 cget -ipAddress] GW:[interfaceIpV4 cget -gatewayIpAddress]&#34;
                    }
                }
                set ixiaPortId [lindex [lindex $portMappingList $i] 0]
                incr i
                incr numIxiaPorts -1
            }
        }
	}
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixVerifySupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to verify supplicant has access to </span>
<span class="comment-line">#              network by sending L2 (ARP) traffic and IP traffic </span>
<span class="comment-line">#              in both directions.</span>
<span class="comment-line">#              This procedure assumes a default topology similiar</span>
<span class="comment-line">#              to the show at start of file.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       txPortId - Transmistting port </span>
<span class="comment-line">#       supMac   - MAC address of supplicant</span>
<span class="comment-line">#       supIp    - IP Address of supplicant</span>
<span class="comment-line">#       gwIp     - Gateway address of supplicant</span>
<span class="comment-line">#       rxPortId - Receiving port.  This is port we capture packets on.</span>
<span class="comment-line">#       rxPortIp - IP Address on receiving port to send to.  We assume </span>
<span class="comment-line">#                  this is been setup already on the Ixia.</span>
<span class="comment-line">#       rxPortGwIp - Gateway address of interface on receive side.  Needed </span>
<span class="comment-line">#                    to test traffic going in opposite direction.</span>
<span class="comment-line">#       portFlag - &#34;forwarded&#34; | &#34;notForwarded | egress | ingress&#34;</span>
<span class="comment-line">#       DUT      - DUT we're talking about.  Need to get MAC of DUT, so </span>
<span class="comment-line">#                  we specify which DUT to use here.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixVerifySupplicantAccess_1403">proc <a href="Dot1XLib.tcl-annot.html#::::_ixVerifySupplicantAccess">::::_ixVerifySupplicantAccess</a></a></strong> { txPortId supMac supIp gwIp rxPortId rxPortIp \
	rxPortGwIp {portFlag &#34;forwarded&#34;} {DUT &#34;1&#34;} {tag &#34;none&#34;}} {

    global DUTs_info
    global DUT1_CONNECT
    global DUT2_CONNECT

    set numIpPacketsToSend 15
    set blockTolerance 3

    if {$DUT == &#34;1&#34;} {
        <a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT1_CONNECT
        set dutMac $DUTs_info(DUT1,sysMAC)
    } else {
        <a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT2_CONNECT
        set dutMac $DUTs_info(DUT2,sysMAC)
    }

    ;<span class="comment-line"># We allow a tolerance when blocking.  It's okay if up to 3 packets go through</span>
    if {$portFlag == &#34;notForwarded&#34;} {
        set portFlag &#34;forwarded $blockTolerance down&#34;
    }

    ;<span class="comment-line"># This is MAC of the DUT</span>
    set cookedDutMac [<a name="::cookMacForIxia(1)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $dutMac]

    ;<span class="comment-line"># Only check ARP if we have access</span>
    if {$portFlag == &#34;forwarded&#34;} {
        <a name="::result_debug(50)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Check for ARP...&#34;
        if {[<a name="::CheckArpReply(1)"><a href="./CheckArp.tcl.html#::CheckArpReply_22">::CheckArpReply</a></a> -txPortId $txPortId -sIpAddr $supIp -dIpAddr $gwIp \
            -replySendHwAddr &#34;$cookedDutMac&#34; -sMacAddr $supMac -percentage 0.0672 \
            -numArpFrames 2 -comment &#34;MAC:$supMac IP:$supIp &#34; -tag $tag] == 0 } {
            <a name="::nl_exDumpDebugInfo(2)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>		
        }
    }

    ;<span class="comment-line"># Seed ARP table on other port to minimize dropped packets</span>
    ;<span class="comment-line"># due to sending initial ARPs in CheckForwarding</span>
    <a name="::SendArpFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendArpFrame_959">::SendArpFrame</a></a> -txPortId $rxPortId -sourceIp $rxPortIp -destIp $rxPortGwIp

    ;<span class="comment-line"># Save original value</span>
    set originalPortFlag $portFlag
    if {$portFlag == &#34;ingress&#34;} {
        set portFlag &#34;forwarded&#34;
    } elseif {$portFlag == &#34;egress&#34;} {
        set portFlag &#34;notForwarded&#34;
    }
    <a name="::result_debug(51)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Send $numIpPacketsToSend IP Packets MAC:$supMac \
	    IP:$supIp Tag:$tag ==&gt; IP:$rxPortIp $portFlag&#34;
    lappend checkPortList &#34;$rxPortId $portFlag&#34;
    if {[<a name="::CheckForwarding(1)"><a href="./ePTForwarding.tcl.html#::CheckForwarding_269">::CheckForwarding</a></a> -txPortId $txPortId -checkPortList $checkPortList \
	    -numIpFrame $numIpPacketsToSend -protocol &#34;ip&#34; -inSaMac $supMac \
	    -inDaMac $cookedDutMac -dIpAddr $rxPortIp -generateArpReq 0 \
	    -gIpAddr $gwIp -sIpAddr $supIp \
	    -comment &#34;MAC:$supMac IP:$supIp:$tag ==&gt; IP:$rxPortIp $portFlag&#34; \
            -tag $tag] == 0} {

        <a name="::nl_exDumpDebugInfo(3)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>		

    }
    unset checkPortList

    ;<span class="comment-line"># Restore original value</span>
    set portFlag $originalPortFlag

    if {$portFlag == &#34;ingress&#34;} {
        set portFlag &#34;notForwarded&#34;
    } elseif {$portFlag == &#34;egress&#34;} {
        set portFlag &#34;forwarded&#34;
    }
    <a name="::result_debug(52)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Send $numIpPacketsToSend IP Packets IP:$rxPortIp ==&gt; \
	    MAC:$supMac IP:$supIp $portFlag&#34;
    lappend checkPortList &#34;$txPortId $portFlag&#34;
    if {[<a name="::CheckForwarding(2)"><a href="./ePTForwarding.tcl.html#::CheckForwarding_269">::CheckForwarding</a></a> -txPortId $rxPortId -checkPortList $checkPortList \
	    -numIpFrame $numIpPacketsToSend -protocol &#34;ip&#34; -dIpAddr $supIp \
	    -inDaMac $cookedDutMac -generateArpReq 0 \
	    -gIpAddr $rxPortGwIp -sIpAddr $rxPortIp \
	    -comment &#34;IP:$rxPortIp ==&gt; MAC:$supMac IP:$supIp $portFlag&#34;] == 0} {

    	<a name="::nl_exDumpDebugInfo(4)"><a href="./NetloginLib.tcl.html#::nl_exDumpDebugInfo_2455">::nl_exDumpDebugInfo</a></a>
    }
    unset checkPortList
} 
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixVerifySupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to verify supplicants have access to </span>
<span class="comment-line">#              network by sending L2 (ARP) traffic and IP traffic </span>
<span class="comment-line">#              in both directions.  startSupMac and startSupIp</span>
<span class="comment-line">#              is incremented and each mac/ip pair is validated</span>
<span class="comment-line">#              independently.</span>
<span class="comment-line">#              This procedure assumes a default topology similiar</span>
<span class="comment-line">#              to the show at start of file.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       txPortId    - Transmistting port </span>
<span class="comment-line">#       startSupMac - MAC address of supplicant in &#34;:&#34; delimited format</span>
<span class="comment-line">#       startSupIp  - IP Address of supplicant</span>
<span class="comment-line">#       gwIp     - Gateway address of supplicant</span>
<span class="comment-line">#       rxPortId - Receiving port.  This is port we capture packets on.</span>
<span class="comment-line">#       rxPortIp - IP Address on receiving port to send to.  We assume </span>
<span class="comment-line">#                  this is been setup already on the Ixia.</span>
<span class="comment-line">#       rxPortGwIp - Gateway address of interface on receive side.  Needed </span>
<span class="comment-line">#                    to test traffic going in opposite direction.</span>
<span class="comment-line">#       numSupplicants - Number of supplicants</span>
<span class="comment-line">#       portFlag - &#34;forwarded&#34; | &#34;notForwarded&#34; | &#34;egress&#34; | &#34;ingress&#34;</span>
<span class="comment-line">#       DUT      - DUT we're talking about.  Need to get MAC of DUT, so </span>
<span class="comment-line">#                  we specify which DUT to use here.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: None</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixVerifySupplicantAccess_1515">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixVerifySupplicantAccess">::::dot1x_ixVerifySupplicantAccess</a></a></strong> {txPortId startSupMac startSupIp \
	gwIp rxPortId rxPortIp rxPortGwIp {numSupplicants &#34;1&#34;} \
	{portFlag &#34;forwarded&#34;} {DUT &#34;1&#34;} {tag &#34;none&#34;}} {

    set curIp $startSupIp
    set curMac [<a name="::dot1x_stripMac(1)"><a href="./Dot1XLib.tcl.html#::dot1x_stripMac_4170">::dot1x_stripMac</a></a> $startSupMac]
    set i 0 
    while { $numSupplicants } {
    incr i
 
	<a name="::result_debug(53)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Verify traffic from \
		supMac:$curMac supIp:$curIp Tag:$tag &lt;---&gt; target:$rxPortIp \
                $portFlag&#34;

	<a name="::_ixVerifySupplicantAccess(1)"><a href="./Dot1XLib.tcl.html#::_ixVerifySupplicantAccess_1403">::_ixVerifySupplicantAccess</a></a> $txPortId $curMac $curIp $gwIp \
                          $rxPortId $rxPortIp $rxPortGwIp $portFlag $DUT $tag
	
	;<span class="comment-line"># Increment IP and MAC</span>
	set curIp [<a name="::IncrIpAddr(1)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	set curMac [<a name="::IncMacByOne(1)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]

	incr numSupplicants -1
    }

}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixStreamConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to configure an Ixia stream</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: See IXIA doc for explanation of each!</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixStreamConfig_1552">proc <a href="Dot1XLib.tcl-annot.html#::::_ixStreamConfig">::::_ixStreamConfig</a></a></strong> { args } {
    <a name="::parse_args(6)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _ixStreamConfig $args {
	chassis       1
	<a name="::card(1)"><a href="./ePTClient.tcl.html#::card_424">::card</a></a>          1
	<a name="::port(2)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>          1
	streamId      1
	numBursts     1
	numFrames     10
	preambleSize  8
	srcMac        {00 00 00 00 00 01}
	dstMac        {00 00 00 00 00 00}
	saStep        1
	saMaskValue   {00 00 00 00 00 00}
	saMaskSelect  {00 00 00 00 00 00}
	saRepeatCnt   &#34;idle&#34;
	numSA         16
	daStep        1
	daMaskValue   {00 00 00 00 00 00}
	daMaskSelect  {00 00 00 00 00 00}
	daRepeatCnt   &#34;daArp&#34;
 	numDA         16
	percentRate   100.0
	frameSize     64
	frameSizeType &#34;sizeFixed&#34;
	frameSizeMin  64
	frameSizeMax  1518
	frameSizeStep 1
	frameType     {08 00}
	patternType   &#34;fixed&#34;
	dataPattern   x00010203
	pattern       {00 01 02 03}
	dma           &#34;advance&#34;   ;<span class="comment-line"># stopStream</span>
	returnToId    1
	<a name="::protocol(1)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>          &#34;none&#34;
	protEthernetType  &#34;ethernetII&#34;
	prot802dot1qTag   &#34;false&#34;
	protAppName       0
	arpSrcProtAddr  {10.1.1.2}
	arpDstProtAddr  {10.1.1.1}
	arpOp           &#34;arpRequest&#34;
	arpSrcHwAddr    {00 00 01 02 01 01}
	arpDstHwAddr    {FF FF FF FF FF FF}
	arpSrcProtAddrMode       &#34;arpIdle&#34; ;<span class="comment-line"># arpIncrement</span>
	arpSrcProtAddrRepeatCnt  1 ;<span class="comment-line"># 63 </span>
	arpDestProtAddrMode      &#34;arpIdle&#34;
	arpDestProtAddrRepeatCnt 1
	arpSrcHwAddrMode         &#34;arpIdle&#34;
	arpSrcHwAddrRepeatCnt    1
	arpHwAddrMode            &#34;arpIdle&#34;
	arpHwAddreRepeatCnt      1
	vlanTagNo         &#34;000&#34;
	vlanTagCfi        &#34;resetCFI&#34;
	vlanTagMode       &#34;vIdle&#34;
	vlanTagRepeat     &#34;1&#34;
	vlanTagPriority   &#34;0&#34;	  
	ipProtocol    &#34;tcp&#34;
	ipSrcAddr     {10.1.1.2}
	ipSrcMask     {255.255.255.0}
	ipDstAddr     {172.16.16.2}
	ipDstMask     {255.255.255.0}
	tcpOffset     5
	tcpSrcPort    0
	tcpDstPort    0
	writeToHw       &#34;false&#34;
    }

    set portList [list $chassis,$card,$port]

    <a name="::stream(1)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   setDefault        
    <a name="::stream(2)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -name                    &#34;S_$streamId&#34;
    <a name="::stream(3)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -enable                  true
    <a name="::stream(4)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numBursts               $numBursts
    <a name="::stream(5)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numFrames               $numFrames
    <a name="::stream(6)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -rateMode                usePercentRate
    <a name="::stream(7)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -percentPacketRate       $percentRate
    <a name="::stream(8)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -preambleSize            $preambleSize
    <a name="::stream(9)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -sa                      $srcMac
    <a name="::stream(10)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saRepeatCounter         $saRepeatCnt
    <a name="::stream(11)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saStep                  $saStep
    <a name="::stream(12)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saMaskValue             $saMaskValue
    <a name="::stream(13)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -saMaskSelect            $saMaskSelect
    <a name="::stream(14)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -da                      $dstMac
    <a name="::stream(15)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daRepeatCounter         $daRepeatCnt
    <a name="::stream(16)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daStep                  $daStep
    <a name="::stream(17)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daMaskValue             $daMaskValue
    <a name="::stream(18)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -daMaskSelect            $daMaskSelect
    <a name="::stream(19)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numDA                   $numDA
    <a name="::stream(20)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -numSA                   $numSA
    <a name="::stream(21)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -framesize               $frameSize
    <a name="::stream(22)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeType           $frameSizeType
    <a name="::stream(23)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeMIN            $frameSizeMin
    <a name="::stream(24)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeMAX            $frameSizeMax
    <a name="::stream(25)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameSizeStep           $frameSizeStep
    <a name="::stream(26)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -fir                     false
    <a name="::stream(27)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -fcs                     good
    <a name="::stream(28)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -patternType             $patternType
    <a name="::stream(29)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -dataPattern             $dataPattern
    <a name="::stream(30)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -pattern                 &#34;$pattern&#34;
    <a name="::stream(31)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -frameType               &#34;$frameType&#34;
    <a name="::stream(32)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -dma                     $dma
    <a name="::stream(33)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>   config            -returnToId               $returnToId
<span class="comment-line">#    stream   config            -rxTriggerEnable         false</span>
<span class="comment-line">#    stream   config            -asyncIntEnable          true</span>
<span class="comment-line">#    stream   config            -loopCount               1</span>
<span class="comment-line">#    stream   config            -enforceMinGap           12</span>

    <a name="::protocol(2)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  setDefault        
    <a name="::protocol(3)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -name               $protocol
    <a name="::protocol(4)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -appName            $protAppName
    <a name="::protocol(5)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -ethernetType       $protEthernetType
    <a name="::protocol(6)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -enable802dot1qTag  $prot802dot1qTag
    <a name="::protocol(7)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -enableISLtag       false
    <a name="::protocol(8)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -dutStripTag        true
    <a name="::protocol(9)"><a href="./ePTClient.tcl.html#::protocol_728">::protocol</a></a>  config     -enableMPLS         false

    if { $prot802dot1qTag != &#34;false&#34;} {
        <a name="::vlan(1)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -cfi            $vlanTagCfi
        <a name="::vlan(2)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -mode           $vlanTagMode
        <a name="::vlan(3)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -repeat         $vlanTagRepeat
        <a name="::vlan(4)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -vlanID         $vlanTagNo
        <a name="::vlan(5)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> config -userPriority   $vlanTagPriority
        <a name="::vlan(6)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> set                    $chassis $card $port
    }

    if {[regexp -nocase &#34;arp&#34; $protAppName]} {
	
        <a name="::arp(1)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  setDefault        
        <a name="::arp(2)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceProtocolAddr             $arpSrcProtAddr ;<span class="comment-line"># {10.1.1.2}</span>
        <a name="::arp(3)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destProtocolAddr               $arpDstProtAddr ;<span class="comment-line"># {10.1.1.1}</span>
        <a name="::arp(4)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -operation                      $arpOp ;<span class="comment-line"># arpRequest</span>
        <a name="::arp(5)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceHardwareAddr             $arpSrcHwAddr ;<span class="comment-line"># {00 00 01 02 01 01}</span>
        <a name="::arp(6)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destHardwareAddr               $arpDstHwAddr ;<span class="comment-line"># {FF FF FF FF FF FF}</span>
        <a name="::arp(7)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceProtocolAddrMode         $arpSrcProtAddrMode       ;<span class="comment-line"># arpIncrement</span>
        <a name="::arp(8)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceProtocolAddrRepeatCount  $arpSrcProtAddrRepeatCnt  ;<span class="comment-line"># 63 </span>
        <a name="::arp(9)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destProtocolAddrMode           $arpDestProtAddrMode      ;<span class="comment-line"># arpIdle</span>
        <a name="::arp(10)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destProtocolAddrRepeatCount    $arpDestProtAddrRepeatCnt ;<span class="comment-line"># 1</span>
        <a name="::arp(11)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceHardwareAddrMode         $arpSrcHwAddrMode         ;<span class="comment-line"># arpIncrement</span>
        <a name="::arp(12)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -sourceHardwareAddrRepeatCount  $arpSrcHwAddrRepeatCnt    ;<span class="comment-line"># 63</span>
        <a name="::arp(13)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destHardwareAddrMode           $arpHwAddrMode            ;<span class="comment-line"># arpIdle</span>
        <a name="::arp(14)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  config  -destHardwareAddrRepeatCount    $arpHwAddreRepeatCnt      ;<span class="comment-line"># 1</span>
        <a name="::arp(15)"><a href="./ePTClient.tcl.html#::arp_1522">::arp</a></a>  set     $chassis $card $port
    }
    
    if { ([regexp -nocase &#34;ip&#34; $protocol]) &amp;&amp; \
	    (! [regexp -nocase &#34;Arp&#34; $protAppName]) } {
        <a name="::ip(1)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> setDefault        
        <a name="::ip(2)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -precedence              routine
        <a name="::ip(3)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -delay                   normalDelay
        <a name="::ip(4)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -throughput              normalThruput
        <a name="::ip(5)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -reliability             normalReliability
        <a name="::ip(6)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -identifier              0
        <a name="::ip(7)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -cost                    0
        <a name="::ip(8)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -reserved                0
        <a name="::ip(9)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -totalLength             46
        <a name="::ip(10)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -lengthOverride          false
        <a name="::ip(11)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -fragment                may
        <a name="::ip(12)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -lastFragment            last
        <a name="::ip(13)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -fragmentOffset          0
        <a name="::ip(14)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -ttl                     64
        <a name="::ip(15)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -ipProtocol              $ipProtocol
        <a name="::ip(16)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -sourceIpAddr            $ipSrcAddr
        <a name="::ip(17)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -sourceIpMask            $ipSrcMask
        <a name="::ip(18)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -destIpAddr              $ipDstAddr
        <a name="::ip(19)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> config  -destIpMask              $ipDstMask
        <span class="comment-line">#    ip config  -useValidChecksum        true</span>
        <span class="comment-line">#    ip config  -sourceIpAddrMode        ipIdle</span>
        <span class="comment-line">#    ip config  -sourceIpAddrRepeatCount 10</span>
        <span class="comment-line">#    ip config  -sourceClass             classA</span>
        <span class="comment-line">#    ip config  -destIpAddrMode          ipIdle</span>
        <span class="comment-line">#    ip config  -destIpAddrRepeatCount   10</span>
        <span class="comment-line">#    ip config  -destClass               classA</span>
        <span class="comment-line">#    ip config  -destMacAddr             {00 DE BB 00 00 02}</span>
        <span class="comment-line">#    ip config  -destDutIpAddr           {0.0.0.0}</span>
        <span class="comment-line">#    ip config  -options                 {}</span>
        <a name="::ip(20)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> set $chassis $card $port
    }

    if {[regexp -nocase &#34;tcp&#34; $ipProtocol]} {
        <a name="::tcp(1)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   setDefault        
        <a name="::tcp(2)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   config            -offset                             $tcpOffset
        <a name="::tcp(3)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   config            -sourcePort                         $tcpSrcPort
        <a name="::tcp(4)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   config            -destPort                           $tcpDstPort
    <span class="comment-line">#	tcp   config            -sequenceNumber                     0</span>
    <span class="comment-line">#	tcp   config            -acknowledgementNumber              0</span>
    <span class="comment-line">#	tcp   config            -window                             0</span>
    <span class="comment-line">#	tcp   config            -urgentPointer                      0</span>
    <span class="comment-line">#	tcp   config            -options                            {}</span>
    <span class="comment-line">#	tcp   config            -urgentPointerValid                 false</span>
    <span class="comment-line">#	tcp   config            -acknowledgeValid                   false</span>
    <span class="comment-line">#	tcp   config            -pushFunctionValid                  false</span>
    <span class="comment-line">#	tcp   config            -resetConnection                    false</span>
    <span class="comment-line">#	tcp   config            -synchronize                        false</span>
    <span class="comment-line">#	tcp   config            -finished                           false</span>
    <span class="comment-line">#	tcp   config            -useValidChecksum                   true</span>
        <a name="::tcp(5)"><a href="./ePTClient.tcl.html#::tcp_1369">::tcp</a></a>   set               $chassis $card $port
    }

    <a name="::stream(34)"><a href="./ePTClient.tcl.html#::stream_565">::stream</a></a>  set               $chassis $card $port $streamId
    
    protocolServer  config      -enableArpResponse  $::true
    protocolServer  config      -enablePingResponse $::true
    protocolServer  set $chassis $card $port

    if {$writeToHw != &#34;false&#34;} {
        <a name="::result_debug(54)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Writing config to $portList&#34;
        <a name="::writeConfigToHardware(1)"><a href="./mapping.tcl.html#::writeConfigToHardware_148">::writeConfigToHardware</a></a> portList
    }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixSeedFdbTable</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Seeds the FDB table with set of MAC addresses </span>
<span class="comment-line">#              and a single target.  See typical topology below.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: supPortId: PortId that supplicant(s) are connected to</span>
<span class="comment-line">#             startSupMac, startSupIp: Starting MAC/IP Address of supplicants</span>
<span class="comment-line">#                    We assume supplicant MAC/IP are created in increasing order</span>
<span class="comment-line">#	      gwIp: Default GW of supplicants.  Usually IP Address of DUT port to</span>
<span class="comment-line">#                   which supplicants are connected </span>
<span class="comment-line">#             dutMac: Cooked MAC address of DUT. i.e.&#34;00 00 01 DE 98 34&#34;</span>
<span class="comment-line">#	      numSup: Number of supplicants to seed </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixSeedFdbTable_1776">proc <a href="Dot1XLib.tcl-annot.html#::::_ixSeedFdbTable">::::_ixSeedFdbTable</a></a></strong> { supPortId startSupMac startSupIp gwIp \
	dutMac {numMac &#34;1&#34;} } {

    <a name="::result_debug(55)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Seeding FDB table with $numMac supplicant MACs&#34;

    <a name="::MapIxiaPortId(13)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $supPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]

    ;<span class="comment-line"># ##### Seed the FDB table #####    </span>
    set streamId       1
    set curIp          $startSupIp
    set curMac         $startSupMac
    ;<span class="comment-line"># create 1 stream to send out ARP_Requests for ALL supplicants</span>
    <a name="::_ixStreamConfig(1)"><a href="./Dot1XLib.tcl.html#::_ixStreamConfig_1552">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
	    -numBursts 1 -numFrames $numMac \
	    -srcMac $startSupMac -saRepeatCnt &#34;increment&#34; -numSA $numMac \
	    -daRepeatCnt &#34;idle&#34; -dstMac {FF FF FF FF FF FF} \
	    -percentRate 50.0 -frameSize 64 -dma &#34;stopStream&#34; -protocol &#34;ipV4&#34; -protAppName &#34;Arp&#34; \
	    -protEthernetType &#34;ethernetII&#34; \
	    -arpSrcProtAddr  $startSupIp  -arpDstProtAddr $gwIp \
	    -arpOp &#34;arpRequest&#34; -arpSrcHwAddr $startSupMac \
	    -arpDstHwAddr  {FF FF FF FF FF FF} \
	    -arpSrcProtAddrMode &#34;arpIncrement&#34; -arpSrcProtAddrRepeatCnt $numMac \
	    -arpSrcHwAddrMode  &#34;arpIncrement&#34;  -arpSrcHwAddrRepeatCnt   $numMac \
	    -writeToHw &#34;true&#34;	
    
    <a name="::result_debug(56)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Transmitting on $portList&#34;
    <a name="::ixStartTransmit(1)"><a href="./mapping.tcl.html#::ixStartTransmit_91">::ixStartTransmit</a></a> portList
    sleep 2
    <a name="::result_debug(57)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Checking if Tx done...&#34;
    if {[<a name="::ixCheckTransmitDone(1)"><a href="./mapping.tcl.html#::ixCheckTransmitDone_154">::ixCheckTransmitDone</a></a> portList]} {
	<a name="::result_debug(58)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in transmitting&#34;
    }   
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixCreateMultiSupplicantStreams</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to create IP data streams for</span>
<span class="comment-line">#              multiple supplicants.  Multiple streams are</span>
<span class="comment-line">#              created, and all written once to Ixia at the</span>
<span class="comment-line">#              end.  This speeds up tests that require 64</span>
<span class="comment-line">#              supplicants.</span>
<span class="comment-line">#</span>
<span class="comment-line">#              Traffic flow is usually based on topology indicated</span>
<span class="comment-line">#              at start of file.  Supplicants send to single </span>
<span class="comment-line">#              unprotected target.  Target sends traffic back to</span>
<span class="comment-line">#              supplicant.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      supPortId:     Supplicant port Id </span>
<span class="comment-line">#      startSupMac:   Starting MAC address</span>
<span class="comment-line">#      startSupIp:    Starting IP Address</span>
<span class="comment-line">#      gwIp:          GW IP of the supplicants</span>
<span class="comment-line">#      unprotPortId:  Target port Id </span>
<span class="comment-line">#      unprotPortIp   Target IP</span>
<span class="comment-line">#      unprotPortGwIp Target GW</span>
<span class="comment-line">#      dutMac:        MAC of DUT</span>
<span class="comment-line">#      numSup:        Number of supplicants</span>
<span class="comment-line">#      numFrames:     Number of frames to send</span>
<span class="comment-line">#      txDirection:   Direction to send traffic</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixCreateMultiSupplicantStreams_1842">proc <a href="Dot1XLib.tcl-annot.html#::::_ixCreateMultiSupplicantStreams">::::_ixCreateMultiSupplicantStreams</a></a></strong> { supPortId startSupMac startSupIp \
	gwIp unprotPortId unprotPortIp unprotPortGwIp dutMac {numSup &#34;1&#34;} \
	{numFrames 1} {txDirection &#34;out&#34;} }  {

    if { $txDirection == &#34;out&#34; } {
	<a name="::MapIxiaPortId(14)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $supPortId chassis card port
    } else {
	<a name="::MapIxiaPortId(15)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $unprotPortId chassis card port
	set unprotMacList [<a name="::dot1x_ixGetPortIdMacs(1)"><a href="./Dot1XLib.tcl.html#::dot1x_ixGetPortIdMacs_218">::dot1x_ixGetPortIdMacs</a></a> $unprotPortId]
	set unprotMac [<a name="::cookMacForIxia(2)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> [lindex $unprotMacList 0]]
	<a name="::result_debug(59)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;unprotMac: $unprotMac&#34;
    }

    ;<span class="comment-line"># ##### Create the Streams #####</span>
    set streamId       1
    set dma            &#34;advance&#34;
    set writeToHw      &#34;false&#34;
    set curIp          $startSupIp
    set curMac         $startSupMac
    set numSupplicants $numSup
    while { $numSupplicants } {

	;<span class="comment-line"># Configure last stream to stop and also make sure to write to</span>
	if {$numSupplicants == 1} {
	    set dma  &#34;stopStream&#34;
	    set writeToHw  &#34;true&#34;
	}
	if { $txDirection == &#34;out&#34; } {

	    <a name="::result_debug(60)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Setting up stream for \
		    supMac:$curMac supIp:$curIp ---&gt; target:$unprotPortIp&#34;

	    <a name="::_ixStreamConfig(2)"><a href="./Dot1XLib.tcl.html#::_ixStreamConfig_1552">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
		    -numBursts 1 -numFrames $numFrames -srcMac $curMac -dstMac $dutMac \
		    -daRepeatCnt &#34;idle&#34; -percentRate 50.0 \
		    -frameSize 64 -dma $dma -protocol &#34;ipV4&#34; \
		    -protEthernetType &#34;ethernetII&#34; -ipProtocol &#34;tcp&#34; \
		    -ipSrcAddr $curIp -ipSrcMask {255.255.255.0} \
		    -ipDstAddr $unprotPortIp -ipDstMask {255.255.255.0} \
		    -writeToHw $writeToHw
	} else {

	    <a name="::result_debug(61)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Setting up stream for \
		    target:$unprotPortIp --&gt; supMac:$curMac supIp:$curIp&#34;

	    <a name="::_ixStreamConfig(3)"><a href="./Dot1XLib.tcl.html#::_ixStreamConfig_1552">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
		    -numBursts 1 -numFrames $numFrames -srcMac $unprotMac -dstMac $dutMac \
		    -daRepeatCnt &#34;idle&#34; -percentRate 50.0 \
		    -frameSize 64 -dma $dma -protocol &#34;ipV4&#34; \
		    -protEthernetType &#34;ethernetII&#34; -ipProtocol &#34;tcp&#34; \
		    -ipSrcAddr $unprotPortIp  -ipSrcMask {255.255.255.0} \
		    -ipDstAddr $curIp -ipDstMask {255.255.255.0} \
		    -writeToHw $writeToHw
	}

	;<span class="comment-line"># Increment IP and MAC</span>
	set curIp [<a name="::IncrIpAddr(2)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	set curMac [<a name="::IncMacByOne(2)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]

	incr numSupplicants -1
	incr streamId
    }
    <a name="::result_debug(62)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ALL STREAMS CONFIGURED...&#34;
    
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _ixVerifyMultiSupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure to verify traffic for multi</span>
<span class="comment-line">#              supplicants.  Proc assumes streams and DUT are</span>
<span class="comment-line">#              already configured.  This procedure starts and captures</span>
<span class="comment-line">#              traffic and confirms uni-directional traffic is</span>
<span class="comment-line">#              sent correctly.</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      supPortId:     Supplicant port Id </span>
<span class="comment-line">#      startSupIp:    Starting IP Address</span>
<span class="comment-line">#      unprotPortId:  Target port Id </span>
<span class="comment-line">#      numSup:        Number of supplicants</span>
<span class="comment-line">#      numFramesThreshold:    Number of frames requ'd to receive for success</span>
<span class="comment-line">#      txDirection:   Direction to send traffic</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_ixVerifyMultiSupplicantAccess_1926">proc  <a href="Dot1XLib.tcl-annot.html#::::_ixVerifyMultiSupplicantAccess">::::_ixVerifyMultiSupplicantAccess</a></a></strong> { supPortId unprotPortId numSup startSupIp \
	numFramesThreshold {txDirection &#34;out&#34;} } {
    
    <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify $numSup Supplicant Access $txDirection&#34;

    ;<span class="comment-line"># ##### Send and Capture the traffic #####</span>
    <a name="::StopPortsCapture(1)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> [list $supPortId $unprotPortId]
    sleep 2
    
    if {$txDirection == &#34;out&#34;} {
        set txPortId $supPortId
        set rxPortId $unprotPortId
    } else {
        set txPortId $unprotPortId
        set rxPortId $supPortId
    }

    ;<span class="comment-line"># Start capture</span>
    <a name="::StartPortsCapture(1)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> [list $rxPortId]
    sleep 1

    ;<span class="comment-line"># Start streams</span>
    <a name="::MapIxiaPortId(16)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]
    <a name="::ixStartTransmit(2)"><a href="./mapping.tcl.html#::ixStartTransmit_91">::ixStartTransmit</a></a> portList

    if {[<a name="::ixCheckTransmitDone(2)"><a href="./mapping.tcl.html#::ixCheckTransmitDone_154">::ixCheckTransmitDone</a></a> portList]} {
        <a name="::result_debug(63)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Error in transmitting&#34;
        <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
        return
    }
    <a name="::result_debug(64)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DONE TRANSMITTING ********************************&#34;

    <a name="::StopPortsCapture(2)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> [list $rxPortId]
    sleep 2

    ;<span class="comment-line"># ##### Parse the received data  #####</span>
    ;<span class="comment-line"># Parse Rx Port Capture Buffer to verify we received packets. </span>
    set numSupplicants $numSup
    set curIp $startSupIp

    ;<span class="comment-line"># ASSUME CAPTURE BUFFER IS IN ORDER OF supIp ADDRESSES!</span>
    set rawPortDataList [<a name="::GetCapturedFrames(1)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $rxPortId]

    while { $numSupplicants } {
        set numFramesMatched 0
        foreach frame $rawPortDataList {

            if {$txDirection == &#34;out&#34;} {
                set curIpRx [<a name="::GetSourceIPAddress(1)"><a href="./MessageDecoding.tcl.html#::GetSourceIPAddress_411">::GetSourceIPAddress</a></a> $frame]
            } else {
                set curIpRx [<a name="::GetDestIPAddress(1)"><a href="./MessageDecoding.tcl.html#::GetDestIPAddress_447">::GetDestIPAddress</a></a> $frame]
            }

            if {$curIpRx == $curIp} {
                incr numFramesMatched
            }
            if {$numFramesMatched == $numFramesThreshold} {
                <a name="::result_debug(65)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found $numFramesMatched packets from $curIp&#34;
                break
            }
        }

        if {$numFramesMatched != $numFramesThreshold} {
            <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Found only $numFramesMatched packets from $curIp...test failed&#34;
            <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
            return
        }

        ;<span class="comment-line"># Increment IP and MAC</span>
        set curIp [<a name="::IncrIpAddr(3)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]

        incr numSupplicants -1
    }
    
    <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Access Okay for $numSup Supplicants&#34;
    <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixVerifyMultiSupplicantAccess</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to verify traffic for multi-supplicants.  </span>
<span class="comment-line">#              Seeds FDB table for both ends, creates streams</span>
<span class="comment-line">#              sends and verifies traffic flow.  Repeats for</span>
<span class="comment-line">#              opposite direction.</span>
<span class="comment-line">#              Assumes topology similiar to the one shown above.</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      supPortId:       Supplicant Port Mapping ID</span>
<span class="comment-line">#      startSupMac:     Supplicant starting MAC</span>
<span class="comment-line">#      startSupIp:      Supplicant starting IP</span>
<span class="comment-line">#      gwIp:            GW IP of supplicants</span>
<span class="comment-line">#      unprotPortId:    Unprotected target port ID</span>
<span class="comment-line">#      unprotMac:       Unprotected target MAC</span>
<span class="comment-line">#      unprotPortIp:    Unprotected target IP</span>
<span class="comment-line">#      unprotPortGwIp:  Unprotected target port GW </span>
<span class="comment-line">#      dutMac:          DUT MAC</span>
<span class="comment-line">#      numSup:          Number of supplicants to verify</span>
<span class="comment-line">#      portFlag:        &#34;forwarded&#34; | &#34;notForwarded&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixVerifyMultiSupplicantAccess_2029">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixVerifyMultiSupplicantAccess">::::dot1x_ixVerifyMultiSupplicantAccess</a></a></strong> { supPortId startSupMac startSupIp \
	gwIp unprotPortId unprotMac unprotPortIp unprotPortGwIp dutMac \
	{numSup &#34;1&#34;} {portFlag &#34;forwarded&#34;} } {

    set numFrames           10   ;<span class="comment-line"># Send 10</span>
    set numFramesThreshold  5    ;<span class="comment-line"># As long as other end receives 5, we're okay for this test.</span>
    
    ;<span class="comment-line"># Cook MAC</span>
    set startSupMac [<a name="::cookMacForIxia(3)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $startSupMac]
    set unprotMac   [<a name="::cookMacForIxia(4)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $unprotMac]
    set dutMac      [<a name="::cookMacForIxia(5)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $dutMac]


    ;<span class="comment-line"># Seed supplicant end</span>
    <a name="::_ixSeedFdbTable(1)"><a href="./Dot1XLib.tcl.html#::_ixSeedFdbTable_1776">::_ixSeedFdbTable</a></a> $supPortId $startSupMac $startSupIp $gwIp \
	    $dutMac $numSup

    <a name="::exSleep(4)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5

    ;<span class="comment-line"># Seed target end</span>
    <a name="::_ixSeedFdbTable(2)"><a href="./Dot1XLib.tcl.html#::_ixSeedFdbTable_1776">::_ixSeedFdbTable</a></a> $unprotPortId $unprotMac $unprotPortIp $unprotPortGwIp \
	    $dutMac 1

    ;<span class="comment-line"># Debug to check FDB is poplulated</span>
    ;<span class="comment-line">#    SendACmd &#34;show fdb po [MapDUTPortId 1]&#34;</span>

    <a name="::_ixCreateMultiSupplicantStreams(1)"><a href="./Dot1XLib.tcl.html#::_ixCreateMultiSupplicantStreams_1842">::_ixCreateMultiSupplicantStreams</a></a> $supPortId $startSupMac $startSupIp $gwIp \
	    $unprotPortId $unprotPortIp $unprotPortGwIp \
	    $dutMac $numSup $numFrames &#34;out&#34;

    <a name="::_ixVerifyMultiSupplicantAccess(1)"><a href="./Dot1XLib.tcl.html#::_ixVerifyMultiSupplicantAccess_1926">::_ixVerifyMultiSupplicantAccess</a></a> $supPortId $unprotPortId $numSup $startSupIp \
	    $numFramesThreshold &#34;out&#34;

    <a name="::_ixCreateMultiSupplicantStreams(2)"><a href="./Dot1XLib.tcl.html#::_ixCreateMultiSupplicantStreams_1842">::_ixCreateMultiSupplicantStreams</a></a> $supPortId $startSupMac $startSupIp $gwIp \
	    $unprotPortId $unprotPortIp $unprotPortGwIp \
	    $dutMac $numSup $numFrames &#34;in&#34;

    <a name="::_ixVerifyMultiSupplicantAccess(2)"><a href="./Dot1XLib.tcl.html#::_ixVerifyMultiSupplicantAccess_1926">::_ixVerifyMultiSupplicantAccess</a></a> $supPortId $unprotPortId $numSup $startSupIp \
	    $numFramesThreshold &#34;in&#34;

}




<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixSendIpTraffic</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to send IP Traffic to another port.</span>
<span class="comment-line">#              Each MAC (when more than 1) initiates traffic </span>
<span class="comment-line">#              destined to target rxPortIp.  No checking is done.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      txPortId:    Supplicant Port Mapping ID</span>
<span class="comment-line">#      startSupMac: Supplicant starting MAC</span>
<span class="comment-line">#      startSupIp:  Supplicant starting IP</span>
<span class="comment-line">#      gwIp:        GW IP of supplicants</span>
<span class="comment-line">#      rxPortId:    Unprotected target port ID</span>
<span class="comment-line">#      rxPortIp:    Unprotected target IP</span>
<span class="comment-line">#      rxPortGwIp:  Unprotected target port GW </span>
<span class="comment-line">#      numSupplicants:     Number of supplicants</span>
<span class="comment-line">#      numPacketsToSend:   Number of packets to transmit</span>
<span class="comment-line">#      DUT:         1 | 2</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixSendIpTraffic_2095">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixSendIpTraffic">::::dot1x_ixSendIpTraffic</a></a></strong> { txPortId startSupMac startSupIp gwIp rxPortId \
	rxPortIp rxPortGwIp {numSupplicants 1} {numPacketsToSend 10} \
	{DUT &#34;1&#34;}} {

    global DUTs_info
    global DUT1_CONNECT
    global DUT2_CONNECT

    if {$DUT == &#34;1&#34;} {
        <a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT1_CONNECT
        set dutMac $DUTs_info(DUT1,sysMAC)
    } else {
        <a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUT2_CONNECT
        set dutMac $DUTs_info(DUT2,sysMAC)
    }

    ;<span class="comment-line"># This is MAC of the DUT</span>
    set cookedDutMac [<a name="::cookMacForIxia(6)"><a href="./misc.tcl.html#::cookMacForIxia_61">::cookMacForIxia</a></a> $dutMac]

    set curIp $startSupIp
    set curMac [<a name="::dot1x_stripMac(2)"><a href="./Dot1XLib.tcl.html#::dot1x_stripMac_4170">::dot1x_stripMac</a></a> $startSupMac]

    while { $numSupplicants } {
        ;<span class="comment-line"># This should generate entry in table.</span>
        <a name="::SendArpFrame(2)"><a href="./ePTSendPacket.tcl.html#::SendArpFrame_959">::SendArpFrame</a></a> -txPortId $txPortId -sourceMac $curMac -sourceIp $curIp \
            -destIp $gwIp -numFrames 2 
        
        ;<span class="comment-line"># Send some IP traffic</span>
        <a name="::SendIpFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendIpFrame_587">::SendIpFrame</a></a> -txPortId $txPortId -sourceIp $curIp \
            -destMac $cookedDutMac -gatewayIp $gwIp \
            -destIp $rxPortIp -numFrames $numPacketsToSend

        ;<span class="comment-line"># Increment IP and MAC</span>
        if {$curIp != &#34;&#34;} {
            set curIp [<a name="::IncrIpAddr(4)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
        }
        if {$curMac != &#34;&#34;} {
            set curMac [<a name="::IncMacByOne(3)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]
        }
        incr numSupplicants -1
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStartEapolFlood</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to create an L2 stream of a particular EAPOL </span>
<span class="comment-line">#              packet type.  Then start transmitting at that rate.</span>
<span class="comment-line">#              Used for EAPOL flooding tests</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        txPortId: Supplicant Port Mapping ID </span>
<span class="comment-line">#        type:     &#34;start&#34; | &#34;response-identity&#34; | &#34;logoff&#34;  </span>
<span class="comment-line">#        dstMac:   dstMac to send to...usually DUT </span>
<span class="comment-line">#        rate:     % rate to send traffic.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStartEapolFlood_2155">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStartEapolFlood">::::dot1x_ixStartEapolFlood</a></a></strong> {txPortId type dstMac {rate 100.0}} {

    set eapolType {88 8E}
    set srcMac {00 00 01 AB CD EF}


    if {$type == &#34;start&#34;} {
	    set pattern {01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    } elseif { $type == &#34;response-identity&#34; } {
	    set pattern {01 00 00 0C 02 03 00 0C 01 64 6F 74 31 78 31 32 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    } elseif { $type == &#34;logoff&#34; } {
	    set pattern {01 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
    } else {
        <a name="::result_debug(66)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unsupported EAPOL type $type&#34; 
        return 0
    }

    <a name="::MapIxiaPortId(17)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]

    set streamId       1
    set dma            &#34;contPacket&#34;
    set srcMac         {00 00 01 BE EF BA}

    puts &#34;EAPOL stream type $type $chassis:$card:$port&#34;

    <a name="::_ixStreamConfig(4)"><a href="./Dot1XLib.tcl.html#::_ixStreamConfig_1552">::_ixStreamConfig</a></a> -chassis $chassis -card $card -port $port -streamId $streamId \
	    -srcMac $srcMac -dstMac $dstMac \
	    -daRepeatCnt &#34;idle&#34; -percentRate &#34;$rate&#34; \
	    -pattern $pattern -patternType &#34;nonRepeat&#34; -dataPattern &#34;userpattern&#34; \
	    -frameSize 64 -frameType $eapolType -dma $dma -protocol &#34;mac&#34; \
	    -protEthernetType &#34;ethernetII&#34;  -writeToHw &#34;true&#34;

    <a name="::ixStartTransmit(3)"><a href="./mapping.tcl.html#::ixStartTransmit_91">::ixStartTransmit</a></a> portList

    return 1
}
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStopTx</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to stop transmitting on a Ixia port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        txPortId: Port Mapping ID </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStopTx_2203">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStopTx">::::dot1x_ixStopTx</a></a></strong> {txPortId} {

    <a name="::MapIxiaPortId(18)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $txPortId chassis card port
    set portList [list &#34;$chassis,$card,$port&#34;]

    <a name="::ixStopTransmit(1)"><a href="./mapping.tcl.html#::ixStopTransmit_100">::ixStopTransmit</a></a> portList

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixStopEapolFlood</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Procedure to stop transmitting on an Ixia port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        txPortId: Port Mapping ID </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixStopEapolFlood_2223">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixStopEapolFlood">::::dot1x_ixStopEapolFlood</a></a></strong> {txPortId} {
    <a name="::dot1x_ixStopTx(1)"><a href="./Dot1XLib.tcl.html#::dot1x_ixStopTx_2203">::dot1x_ixStopTx</a></a> $txPortId
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixDumpSupplicantStats</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Dump supplicant statistics to STDOUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#        portId: Port Mapping ID </span>
<span class="comment-line">#        mac:    Supplicant mac to dump</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixDumpSupplicantStats_2241">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixDumpSupplicantStats">::::dot1x_ixDumpSupplicantStats</a></a></strong> { portId mac } {

    <a name="::MapIxiaPortId(19)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId ch ca po

    dot1xSupplicantStats get $ch $ca $po $mac

    set totalSuccess [dot1xSupplicantStats cget -totalSuccess]
    set totalSessions [dot1xSupplicantStats cget -totalSessions]
    set avgLatency [dot1xSupplicantStats cget -avgLatency]
    set minLatency [dot1xSupplicantStats cget -minLatency]
    set totalFailEap [dot1xSupplicantStats cget -totalFailEap]
    set totalFailTimeout [dot1xSupplicantStats cget -totalFailTimeout]
    
    <a name="::result_debug(67)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Stats for Supplicant $mac&#34;
    <a name="::result_debug(68)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalSuccess:     $totalSuccess&#34;
    <a name="::result_debug(69)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalSessions:    $totalSessions&#34;
    <a name="::result_debug(70)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  avgLatency:       $avgLatency&#34;
    <a name="::result_debug(71)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  minLatency:       $minLatency&#34;
    <a name="::result_debug(72)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalFailEap:     $totalFailEap&#34;
    <a name="::result_debug(73)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;  totalFailTimeout: $totalFailTimeout&#34;
    
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixCheckPing</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Check that we can ping from supplicant to target. Reports</span>
<span class="comment-line">#              pass of fail.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: dstIp </span>
<span class="comment-line">#             srcIp </span>
<span class="comment-line">#             gwIp </span>
<span class="comment-line">#             txPortId </span>
<span class="comment-line">#             status </span>
<span class="comment-line">#             srcMac </span>
<span class="comment-line">#             dstMac</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: cooked MAC with no : seperators</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixCheckPing_2282">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixCheckPing">::::dot1x_ixCheckPing</a></a></strong> {dstIp srcIp gwIp txPortId status srcMac dstMac} {

    <a name="::_ixSeedFdbTable(3)"><a href="./Dot1XLib.tcl.html#::_ixSeedFdbTable_1776">::_ixSeedFdbTable</a></a> $txPortId $srcMac $srcIp $gwIp $dstMac 1
    <a name="::check_ping(1)"><a href="./ping.tcl.html#::check_ping_13">::check_ping</a></a> $dstIp $srcIp $txPortId $status &#34;NULL&#34; $srcMac $dstMac
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixSendPing</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Proc that sends a PING frame from Ixia.  Does NOT report</span>
<span class="comment-line">#              success or failure.  </span>
<span class="comment-line">#              Sent to start EAP exchange from DUT.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  dstIp </span>
<span class="comment-line">#              srcIp </span>
<span class="comment-line">#              gwIp </span>
<span class="comment-line">#              txPortId </span>
<span class="comment-line">#              srcMac </span>
<span class="comment-line">#              dstMac</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixSendPing_2306">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixSendPing">::::dot1x_ixSendPing</a></a></strong> {dstIp srcIp gwIp txPortId srcMac dstMac {seedFdb 1}} {

    if {$seedFdb == 1} {
        <a name="::result_debug(74)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Seeding fdb table&#34;
        <a name="::_ixSeedFdbTable(4)"><a href="./Dot1XLib.tcl.html#::_ixSeedFdbTable_1776">::_ixSeedFdbTable</a></a> $txPortId $srcMac $srcIp $gwIp $dstMac 1
    }

    set pPattern  &#34;feedbeef&#34;
    set frameSize 64

    <a name="::result_debug(75)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sending ICMP frame&#34;
    set frameSent [<a name="::SendIpFrame(2)"><a href="./ePTSendPacket.tcl.html#::SendIpFrame_587">::SendIpFrame</a></a> -txPortId $txPortId -protocol &#34;icmp&#34; \
                  -dataPattern $pPattern -frameSize $frameSize \
                  -sourceMac $srcMac -destMac $dstMac -sourceIp $srcIp -destIp $dstIp \
                  -type 8 -code 0 -id 1234 -sequence 5678 ]

    <a name="::result_debug(76)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;(802.1x) Frame (icmp) sent on portId $txPortId:&#34;
    <a name="::result_debug(77)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$frameSent&#34;
}

<span class="comment-line">#</span>
<span class="comment-line"># ############################## EXTREME SWITCH FUNCTIONS ###########################</span>
<span class="comment-line"># </span>

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exConfigStandardVlan</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Standard 2 port vlan configuration for dot1x tests</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exConfigStandardVlan_2337">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exConfigStandardVlan">::::dot1x_exConfigStandardVlan</a></a></strong> {protectedPort unprotectedPort \
	protectedIP unprotectedIP \
	{protectedVlanName &#34;vlan_1&#34;} {unprotectedVlanName &#34;vlan_2&#34;}} {

    <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan $protectedVlanName&#34;
    <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $protectedVlanName add port $protectedPort&#34;
    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $protectedVlanName ipaddress $protectedIP/24&#34;
    
    ;<span class="comment-line"># vlan_2 contains the normal port which we send to and from.</span>
    <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan $unprotectedVlanName&#34;
    <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $unprotectedVlanName add port $unprotectedPort&#34;
    <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;conf $unprotectedVlanName ipaddress $unprotectedIP/24&#34;
    
    <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable ipforwarding&#34;
    
}

<strong><a name="::::dot1x_exUnconfigStandardVlan_2354">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exUnconfigStandardVlan">::::dot1x_exUnconfigStandardVlan</a></a></strong> {{protectedVlanName &#34;vlan_1&#34;} \
	{unprotectedVlanName &#34;vlan_2&#34;}} {

    <a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete $protectedVlanName&#34;
    <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete $unprotectedVlanName&#34;
    <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable ipforwarding&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exEnableDebugLogFilter</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Turn on debug logs.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exEnableDebugLogFilter_2369">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exEnableDebugLogFilter">::::dot1x_exEnableDebugLogFilter</a></a></strong> {} {

    <a name="::SendACmd(11)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure log filter \&#34;DefaultFilter\&#34; add events nl.dot1x severity debug-verbose&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exDisableDebugLogFilter</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Turn off debug logs.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exDisableDebugLogFilter_2381">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exDisableDebugLogFilter">::::dot1x_exDisableDebugLogFilter</a></a></strong> {} {

    <a name="::SendACmd(12)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure log filter \&#34;DefaultFilter\&#34; add events nl.dot1x severity notice&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exConfigNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configure and enable netlogin</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  dot1x_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exConfigNetlogin_2396">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exConfigNetlogin">::::dot1x_exConfigNetlogin</a></a></strong> {{<a name="::vlan(7)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;defNetloginVlan&#34;} }  {

    <a name="::SendACmd(13)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan $vlan&#34;
    <a name="::SendACmd(14)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config netlogin vlan $vlan&#34;
    <a name="::SendACmd(15)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable netlogin dot1x&#34;    
}

<strong><a name="::::dot1x_exUnconfigNetlogin_2403">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exUnconfigNetlogin">::::dot1x_exUnconfigNetlogin</a></a></strong> { {<a name="::vlan(8)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a> &#34;defNetloginVlan&#34;} }  {

    <a name="::SendACmd(16)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable netlogin dot1x&#34;
    <a name="::SendACmd(17)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig netlogin vlan&#34;
    <a name="::SendACmd(18)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;delete $vlan&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exConfigRadius</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Configure and enable radius server</span>
<span class="comment-line"># </span>
<span class="comment-line"># Sample Usage:</span>
<span class="comment-line">#  dot1x_exConfigRadius $priRadiusServer $priRadiusPort $clientIP $sharedSecret</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exConfigRadius_2421">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exConfigRadius">::::dot1x_exConfigRadius</a></a></strong> {serverIP serverPort clientIP {sharedSecret &#34;extreme&#34;} \
	{which &#34;primary&#34;}} {

    <a name="::SendACmd(19)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable radius&#34;

    set vr [<a name="::GetVrString(1)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> 1]
    
    <a name="::SendACmd(20)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config radius $which server $serverIP $serverPort \
	    client-ip $clientIP vr $vr&#34;
    <a name="::SendACmd(21)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config radius $which shared-secret $sharedSecret&#34;
    <a name="::SendACmd(22)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable radius&#34;


}

<strong><a name="::::dot1x_exUnconfigRadius_2436">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exUnconfigRadius">::::dot1x_exUnconfigRadius</a></a></strong> {} {

    <a name="::SendACmd(23)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig radius&#34;
    <a name="::SendACmd(24)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable radius&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exEnableNetloginPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Enable netlogin on a port.  We wrap it because of we've seen</span>
<span class="comment-line">#              lots of command truncation after executing this command.  To </span>
<span class="comment-line">#              deal with this we added a delay after executing.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port:  Port to activate</span>
<span class="comment-line">#              type: dot1x/mac/web-based</span>
<span class="comment-line">#              delay: Seconds to wait before returning</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  dot1x_exEnableNetloginPort [MaptDUTPortId 1] &#34;dot1x&#34; 5</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exEnableNetloginPort_2459">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exEnableNetloginPort">::::dot1x_exEnableNetloginPort</a></a></strong> {<a name="::port(3)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> {type &#34;dot1x&#34;} {delay 3}} {
    
    <a name="::SendACmd(25)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable netlogin port $port $type&#34;
    <a name="::exSleep(5)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $delay

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exDisableNetloginPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Disable netlogin on a port.  We wrap it because of we've seen</span>
<span class="comment-line">#              lots of command truncation after executing this command.  To </span>
<span class="comment-line">#              deal with this we added a delay after executing.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port:  Port to deactivate</span>
<span class="comment-line">#              type: /mac/web/dot1x</span>
<span class="comment-line">#              delay: Seconds to wait before returning</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  dot1x_exDisableNetloginPort [MaptDUTPortId 1] &#34;ispVlan&#34; 5</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exDisableNetloginPort_2482">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exDisableNetloginPort">::::dot1x_exDisableNetloginPort</a></a></strong> {<a name="::port(4)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> {type &#34;dot1x&#34;} {delay 3}} {
    
    <a name="::SendACmd(26)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable netlogin port $port $type&#34;
    <a name="::exSleep(6)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $delay
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exVerifyNetloginOnPort</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify netlogin on a port. </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  port:  Port to verify</span>
<span class="comment-line">#              status: enabled/disabled</span>
<span class="comment-line">#              type: dot1x/mac/web</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  dot1x_exVerifyNetloginOnPort [MaptDUTPortId 1] &#34;ispVlan&#34; 5</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyNetloginOnPort_2503">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyNetloginOnPort">::::dot1x_exVerifyNetloginOnPort</a></a></strong> { <a name="::port(5)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> status type {typeStatus &#34;enabled&#34;}} {
    
    <a name="::nl_exVerifyNetloginOnPort(1)"><a href="./NetloginLib.tcl.html#::nl_exVerifyNetloginOnPort_2765">::nl_exVerifyNetloginOnPort</a></a> $port $status $type $typeStatus
    
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exGetNetloginVal</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Retrieve the value for a particular MAC Address.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  mac:   Mac address to look for</span>
<span class="comment-line">#              param: Parameter to retrieve</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: paramter or NULL</span>
<span class="comment-line">#</span>
<span class="comment-line"># VALID param VALUES: IP address, Auth, Type, ReAuth-Timer User</span>
<span class="comment-line">#  i.e.</span>
<span class="comment-line">#  Port: 21,   Vlan: vlan_1,  State: Unauthenticated</span>
<span class="comment-line">#  MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line">#  00:00:01:02:01:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#  set reauth [dot1x_exGetNetloginVal &#34;00:00:01:02:01:01&#34; ReAuth-Timer]</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exGetNetloginVal_2528">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exGetNetloginVal">::::dot1x_exGetNetloginVal</a></a></strong> { <a name="::port(6)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan supMac param } {

   global tmpPath
   set tmp &#34;Tmp&#34;
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile &#34;$tmp/tmp_Dot1X$pid&#34;

    set _mac NULL
    set _ip NULL 
    set _auth NULL
    set _type NULL
    set _reauth NULL
    set _user NULL

    ;<span class="comment-line"># Execute show netlogin and put output into a file</span>
    set fd_in [open $tempFile &#34;w&#34;]
    <a name="::SendACmd(27)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34; NULL $fd_in

    close $fd_in

    ;<span class="comment-line"># Open for reading</span>
    set fd_in [open $tempFile &#34;r&#34;]
    
    set portVlanMatchLine  &#34;&#34;
    set macMatchLine       &#34;&#34;
    ;<span class="comment-line"># Find correct port/vlan and MAC lines </span>
    while {[gets $fd_in line] != -1} {

	;<span class="comment-line"># Look for Port/Vlan Match.</span>
	if {[regexp -nocase -indices -- Port:.*$port.*Vlan:.*$vlan $line matchedRange] == 1} {
	    set portVlanMatchLine $line
	    <a name="::result_debug(78)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND Port:$port Vlan:$vlan on line:$line&#34;

	    ;<span class="comment-line"># Now look for MAC Match</span>
	    while {[gets $fd_in line] != -1} {
		
		if {[regexp -nocase &#34;/-/-/-/-/-/-&#34; $line] == 1} {
		    ;<span class="comment-line"># Found end of port section delimiter...MAC not found in the section.</span>
		    <a name="::result_debug(79)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit delimiter without finding MAC&#34;
		    break;
		}
		
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    <a name="::result_debug(80)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND MAC:$supMac on line:$line&#34;
		    set macMatchLine $line
		    break
		}
	    }
	    break;
	}
    }
    close $fd_in
    file delete $tempFile
    
    
    if {$portVlanMatchLine == &#34;&#34;} {
	<a name="::result_debug(81)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port:$port Vlan:$vlan NOT FOUND&#34;
	return NULL
    }

    if { [string length $macMatchLine] &gt; 0 } {

	scan $macMatchLine {%s %s %s %s %s %s} _mac _ip _auth _type _reauth _user
	if { [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34; majmin] &gt;= 11.7 } {
	    if { [regexp &#34;,&#34; $macMatchLine] } {
		scan $macMatchLine {%s %s %s %s %s %s %s} _mac _ip _auth1 _auth2 _type _reauth _user
		set _auth [string trim $_auth1 &#34;,&#34;]
	    }
	}
	
	<a name="::result_debug(82)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;mac: $_mac&#34;
	<a name="::result_debug(83)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ip: $_ip&#34;
	<a name="::result_debug(84)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;auth: $_auth&#34;
	<a name="::result_debug(85)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;type: $_type&#34;
	<a name="::result_debug(86)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;reauth: $_reauth&#34;
	<a name="::result_debug(87)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;user: $_user&#34;
    }
    
    ;<span class="comment-line"># Default _reauth to 0 if not found or not an int</span>
    if {! [string is integer -strict $_reauth] } {
	set _reauth 0
    }
    switch -exact -- $param \
	    &#34;mac&#34;    {return $_mac} \
	    &#34;ip&#34;     {return $_ip} \
	    &#34;auth&#34;   {return $_auth} \
	    &#34;type&#34;   {return $_type} \
	    &#34;reauth&#34; {return $_reauth} \
	    &#34;user&#34;   {return $_user} \
	    default  {return NULL} \
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exVerifyPortAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a port is authenticated/unauthenticated</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port: DUT port</span>
<span class="comment-line">#              vlan: DUT vlan</span>
<span class="comment-line">#              authStatus: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyPortAuth_2638">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyPortAuth">::::dot1x_exVerifyPortAuth</a></a></strong> {<a name="::port(7)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan authStatus} {    

    set parameterList [list]
 
    lappend parameterList &#34;{Port:.* $port.*Vlan:.*$vlan.* State: $authStatus} exist&#34;
    set returnCode [<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList  \
	    -comment &#34;Checking if Port:$port Vlan:$vlan is $authStatus&#34;]

    return $returnCode

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exVerifyMacAuth</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a particular MAC is authenticated/unauthenticated</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  port: DUT port</span>
<span class="comment-line">#              vlan: DUT vlan</span>
<span class="comment-line">#              mac:  MAC address of supplicant</span>
<span class="comment-line">#              authStatus: &#34;Auth&#34; | &#34;Unauth&#34; | &#34;none&#34;</span>
<span class="comment-line">#                 *authStatus of &#34;none&#34; means MAC is NOT listed at all</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyMacAuth_2664">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyMacAuth">::::dot1x_exVerifyMacAuth</a></a></strong> { <a name="::port(8)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a> vlan mac authStatus } { 

    set parameterList [list]
    
    if {$authStatus == &#34;none&#34;} {
	lappend parameterList &#34;$mac.* notExist&#34;
	set returnCode [<a name="::CheckKeyValue(2)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList \
		-comment &#34;Checking $mac is NOT present&#34;]
    } else {
	lappend parameterList &#34;$mac.*$authStatus exist&#34;
	set returnCode [<a name="::CheckKeyValue(3)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show netlogin&#34; $parameterList \
		-comment &#34;Checking $mac IS present&#34;]
    }

    return $returnCode
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exCheckMatch</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a port is authenticated/unauthenticated</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  actual:</span>
<span class="comment-line">#              expected:</span>
<span class="comment-line">#                 *If expected is &#34;&#34;, we're NOT interested in it, so just return 1.</span>
<span class="comment-line">#              matchType: &#34;greater&#34; | &#34;less&#34; | &#34;equal&#34; | &#34;ge&#34; | &#34;le&#34; | &#34;string</span>
<span class="comment-line">#              nocase: &#34;true&#34; | &#34;false&#34; Case sensitive</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1-match 0-no match</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exCheckMatch_2695">proc <a href="Dot1XLib.tcl-annot.html#::::_exCheckMatch">::::_exCheckMatch</a></a></strong> { actual expected {matchType &#34;string&#34;} {nocase &#34;true&#34;} } {
    
    set nc &#34;&#34;

    if {$nocase == &#34;true&#34;} {
	set nc &#34;-nocase&#34;
    }
	
    if [string length $expected] {
	if {$matchType == &#34;string&#34;} {
	    if [regexp $nc $expected $actual] {
		<a name="::result_debug(88)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;string match of $actual vs. $expected OK&#34;
		return 1
	    } else {
		<a name="::result_debug(89)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;string match of $actual vs. $expected FAIL&#34;
		return 0
	    }
	    
	} elseif {$matchType == &#34;greater&#34;} {
	    if {$actual &gt; $expected} {
		<a name="::result_debug(90)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater match of $actual &gt; $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(91)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater match of $actual &gt; $expected FAIL&#34;
	} elseif {$matchType == &#34;less&#34;} {
	    if {$actual &lt; $expected} {
		return 1
	    }
	    <a name="::result_debug(92)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;less match of $actual &lt; $expected FAIL&#34;
	} elseif {$matchType == &#34;equal&#34;} {
	    if {$actual == $expected} {
		<a name="::result_debug(93)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;equal match of $actual ==  $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(94)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;equal match of $actual ==  $expected FAIL&#34;
	} elseif {$matchType == &#34;ge&#34;} {
	    if {$actual &gt;= $expected} {
		<a name="::result_debug(95)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater or equal match of $actual &gt;= $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(96)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;greater or equal match of $actual &gt;= $expected FAIL&#34;
	} elseif {$matchType == &#34;le&#34;} {
	    if {$actual &lt;= $expected} {
		<a name="::result_debug(97)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;less or equal match of $actual &lt;= $expected OK&#34;
		return 1
	    }
	    <a name="::result_debug(98)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;less or equal match of $actual &lt;= $expected FAIL&#34;
	}

    } else {
	<a name="::result_debug(99)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;NOT Interested in $expected vs $actual&#34;
	;<span class="comment-line"># We're not interested in this parameter, so just return 1.</span>
	return 1
    }
    
    return 0
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exMacMatchDot1x</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Find a matching MAC in the line looking for supMac,supIp,</span>
<span class="comment-line">#              authVal, authType, user, and reauthTimer values</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args:  macMatchLine: Line to do comparison against</span>
<span class="comment-line">#              supMac: MAC of sup.</span>
<span class="comment-line">#              supIp: IP Addr of sup.  Only checked for WEB BASED!</span>
<span class="comment-line">#              authVal: &#34;No&#34; | &#34;Yes&#34;</span>
<span class="comment-line">#              authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#              reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#                 -1 : ignore</span>
<span class="comment-line">#                  0 : Looking for timer == 0</span>
<span class="comment-line">#               &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#              user: Username used to login with.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1-match 0-no match</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin. </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:94 # show netlogin </span>
<span class="comment-line"># Port: 21,   Vlan: vlan_1,  State: Authenticated</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5</span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exMacMatchDot1x_2784">proc <a href="Dot1XLib.tcl-annot.html#::::_exMacMatchDot1x">::::_exMacMatchDot1x</a></a></strong> {macMatchLine supMac supIp authVal authType reauthTimer user} {

    <a name="::result_debug(100)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Examining macMatchLine $macMatchLine&#34;

    set _supMac &#34;&#34;
    set _supIp &#34;&#34; 
    set _authVal &#34;&#34; 
    set _authType &#34;&#34; 
    set _reauthTimer &#34;&#34; 
    set _user &#34;&#34;
    
    ;<span class="comment-line"># MAC - IP - Auth - Type - ReAuth - User</span>
    scan $macMatchLine {%s %s %s %s %s %s} _supMac _supIp _authVal _authType _reauthTimer _user
    if { [<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34; majmin] &gt;= 11.7 } {
	if { [regexp &#34;,&#34; $macMatchLine] } {
	    scan $macMatchLine {%s %s %s %s %s %s %s} _supMac _supIp _authVal1 _authVal2 _authType _reauthTimer _user
	    set _authVal [string trim $_authVal1 &#34;,&#34;]
	}
    }

    ;<span class="comment-line"># Hack for empty IP Address.  Check if _supIp field picks up Yes/No from _authVal field</span>
    if {($_supIp == &#34;Yes&#34;) || ($_supIp == &#34;No&#34;)} {
	scan $macMatchLine {%s %s %s %s %s} _supMac _authVal _authType _reauthTimer _user
	set _supIp &#34;&#34;
    }
    <a name="::result_debug(101)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;EXPECTED: $supMac $supIp $authVal $authType $reauthTimer $user&#34;	
    <a name="::result_debug(102)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ACTUAL    $_supMac $_supIp $_authVal $_authType $_reauthTimer $_user&#34;
    
    ;<span class="comment-line"># IP Address is only valid for WEB Based.  Make sure we don't check it if</span>
    ;<span class="comment-line"># we expect auth type of 802.1x</span>
    if [regexp -nocase &#34;802.1x&#34; $authType] {
	set supIp &#34;&#34;
    }
    
    set macMatch 1
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(1)"><a href="./Dot1XLib.tcl.html#::_exCheckMatch_2695">::_exCheckMatch</a></a> $_supIp $supIp]]
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(2)"><a href="./Dot1XLib.tcl.html#::_exCheckMatch_2695">::_exCheckMatch</a></a> $_authVal $authVal]]
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(3)"><a href="./Dot1XLib.tcl.html#::_exCheckMatch_2695">::_exCheckMatch</a></a> $_authType $authType]]
    set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(4)"><a href="./Dot1XLib.tcl.html#::_exCheckMatch_2695">::_exCheckMatch</a></a> $_user $user &#34;string&#34; &#34;false&#34;]]
    if {$reauthTimer == &#34;0&#34;} {
	set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(5)"><a href="./Dot1XLib.tcl.html#::_exCheckMatch_2695">::_exCheckMatch</a></a> $_reauthTimer $reauthTimer &#34;equal&#34;]]
    } elseif {$reauthTimer == &#34;-1&#34;} {
	set macMatch 1
    } else {
	set macMatch [expr $macMatch &amp; [<a name="::_exCheckMatch(6)"><a href="./Dot1XLib.tcl.html#::_exCheckMatch_2695">::_exCheckMatch</a></a> $_reauthTimer $reauthTimer &#34;greater&#34;]]
    }
    return $macMatch
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exVerifyShowNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that verifies show netlogin params.  Must pass</span>
<span class="comment-line">#              tempfile which contains output of sh netlogin.  This proc</span>
<span class="comment-line">#              just does the checking</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	portState: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#	supMac: supplicant MAC</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#	tempFile: File containing &#34;show netlogin&#34; output</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1-match 0-no match</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin. </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:94 # show netlogin </span>
<span class="comment-line"># Port: 21,   Vlan: vlan_1,  State: Authenticated</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5</span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: Did NOT use CheckKeyValue because it couldn't handle multi layer output of </span>
<span class="comment-line">#       Port, then MAC list</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_exVerifyShowNetlogin_2869">proc <a href="Dot1XLib.tcl-annot.html#::::_exVerifyShowNetlogin">::::_exVerifyShowNetlogin</a></a></strong> {args} {
    <a name="::parse_args(7)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _exVerifyShowNetlogin $args {
	<a name="::port(9)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(9)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	portState   &#34;&#34;
	supMac      &#34;&#34;
	supIp       &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	tempFile    &#34;&#34;
    }

    ;<span class="comment-line"># Open for reading</span>
    set fd_in [open $tempFile &#34;r&#34;]
    
    set portVlanMatchLine  &#34;&#34;
    set macMatchLine       &#34;&#34;
    ;<span class="comment-line"># Find correct port/vlan and MAC lines </span>
    while {[gets $fd_in line] != -1} {
	;<span class="comment-line"># Look for Port/Vlan Match.</span>
	if {[regexp -nocase -indices -- Port:.*$port.*Vlan:.*$vlan $line matchedRange] == 1} {
	    set portVlanMatchLine $line
	    <a name="::result_debug(103)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND Port:$port Vlan:$vlan on line:$line&#34;
	    
	    if {[string length $supMac] == 0} {
		;<span class="comment-line"># Only looking for port/vlan state</span>
		<a name="::result_debug(104)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No MAC given.  Only needed port/vlan state.&#34;
		break
	    }
	    
	    ;<span class="comment-line"># Now look for MAC Match</span>
	    while {[gets $fd_in line] != -1} {
		
		<a name="::result_debug(105)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Looking for a MAC Match...$line&#34;
		if {[regexp -nocase &#34;/-/-/-/-/-/-&#34; $line] == 1} {
		    ;<span class="comment-line"># Found end of port section delimiter...MAC not found in the section.</span>
		    <a name="::result_debug(106)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Hit delimiter without finding MAC&#34;
		    break;
		}
		    
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    <a name="::result_debug(107)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND MAC:$supMac on line:$line&#34;
		    set macMatchLine $line
		    break
		}
	    }
	    break;
	}
    }
    close $fd_in
    
    
    if {$portVlanMatchLine == &#34;&#34;} {
	<a name="::result_debug(108)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port:$port Vlan:$vlan NOT FOUND&#34;
	return 0
    }

    set portVlanMatch 0

    ;<span class="comment-line"># Apply required key info matches</span>
    if { [string length $portVlanMatchLine] &gt; 0 } {
	if {$portState != &#34;&#34;} {
	    set portVlanMatch [regexp -nocase &#34;\ $portState&#34; $portVlanMatchLine]
	    if {$portVlanMatch} {
		<a name="::result_debug(109)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;portState $portState OK&#34;
	    } else {
		<a name="::result_debug(110)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;string match of $portState vs &#34;
		<a name="::result_debug(111)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;                $portVlanMatchLine FAILED&#34;
	    }

	} else {
	    set portVlanMatch 1
	    <a name="::result_debug(112)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Ignoring portState $portState portVlanMatch: $portVlanMatch&#34;
	}
    }
    
    ;<span class="comment-line"># We don't care about supplicant MAC entry</span>
    if {[string length $supMac] == 0} {
	<a name="::result_debug(113)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SupMac $supMac was not given.  Returning portVlanMatch: $portVlanMatch&#34;
	return $portVlanMatch
    }
    

    set macMatch 0

    if { [string length $macMatchLine] &gt; 0 } {
	<a name="::result_debug(114)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Matching supMac $supMac with $macMatchLine&#34;
	set macMatch [<a name="::_exMacMatchDot1x(1)"><a href="./Dot1XLib.tcl.html#::_exMacMatchDot1x_2784">::_exMacMatchDot1x</a></a> $macMatchLine $supMac $supIp $authVal $authType \
		$reauthTimer $user]
    } else {
	<a name="::result_debug(115)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$supMac not found&#34;
    }

    <a name="::result_debug(116)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;RETURNING port: $portVlanMatch  mac: $macMatch&#34;

    return [expr $portVlanMatch &amp; $macMatch]
    
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exVerifyShowNetlogin</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verifies &#34;show netlogin&#34; parameters for 1 or more </span>
<span class="comment-line">#              supplicants.  Writes output to a temp file for which</span>
<span class="comment-line">#              is parsed by an internal proc.  Temp file is deleted</span>
<span class="comment-line">#              before exiting.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	portState: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#	supMac: supplicant MAC</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#	numSupplicants: 1 or more</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin. </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:94 # show netlogin </span>
<span class="comment-line"># Port: 21,   Vlan: vlan_1,  State: Authenticated</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:DE:BB:00:00:01  0.0.0.0         No     802.1x    0            Unknown </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         Yes    802.1x    3383         ixia1md5</span>
<span class="comment-line"># ------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: Did NOT use CheckKeyValue because it couldn't handle multi layer output of </span>
<span class="comment-line">#       Port, then MAC list</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyShowNetlogin_3009">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyShowNetlogin">::::dot1x_exVerifyShowNetlogin</a></a></strong> {args} {
    <a name="::parse_args(8)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_exVerifyShowNetlogin $args {
	<a name="::port(10)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(10)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	portState   &#34;&#34;
	supMac &#34;&#34;
	supIp  &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	numSupplicants &#34;1&#34;
    }

    set curIp $supIp
    set curMac $supMac
    set numSup $numSupplicants

    <a name="::report_start_test(3)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify show netlogin for $numSup supplicant(s) $portState&#34;

   global tmpPath
   set tmp &#34;Tmp&#34;
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile &#34;$tmp/tmp_Dot1X$pid&#34;

    ;<span class="comment-line"># Execute show netlogin and put output into a file</span>
    set fd_in [open $tempFile &#34;w&#34;]
    <a name="::SendACmd(28)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34; NULL $fd_in

    close $fd_in
    set numFail 0
    while { $numSup } {
	<a name="::result_debug(117)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSup) Verify show netlogin supMac:$curMac supIp:$curIp&#34;
    
	if {! [<a name="::_exVerifyShowNetlogin(1)"><a href="./Dot1XLib.tcl.html#::_exVerifyShowNetlogin_2869">::_exVerifyShowNetlogin</a></a> -port $port \
		-vlan $vlan -portState $portState -supMac $curMac \
		-supIp $curIp -authVal $authVal -authType $authType \
		-reauthTimer $reauthTimer -user $user -tempFile $tempFile]} {
	    <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Verification of show netlogin parameters failed.&#34;
	    incr numFail
	}
	;<span class="comment-line"># Increment IP and MAC</span>
	if {$curIp != &#34;&#34;} {
	    set curIp [<a name="::IncrIpAddr(5)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	}
	if {$curMac != &#34;&#34;} {
	    set curMac [<a name="::IncMacByOne(4)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]
	}
	incr numSup -1
    }
    if {$numFail &gt; 0} {
	<a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;$numFail of $numSupplicants supplicants failed to Authenticate&#34;
    }
    <a name="::report_end_test(5)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

    if {$numFail == 0} {
	file delete $tempFile
    } else {
	<a name="::result_debug(118)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FAILURES! Preserving $tempFile for review&#34;
	<a name="::result_debug(119)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;********** EXPECTED FILE CONTENTS ***********&#34;
	<a name="::SendACmd(29)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin&#34;
    }
    return $numFail
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _exVerifyShowNetloginPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that checks &#34;show netlogin ports &lt;x&gt; &lt;vlan&gt;&#34; </span>
<span class="comment-line">#              parameters for an individual port/vlan combination</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	authState: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#	portState: &#34;Enabled&#34; | &#34;Disabled&#34;</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin ports </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:95 # show netlogin ports 21</span>
<span class="comment-line"># Port          : 21        </span>
<span class="comment-line"># Vlan          : vlan_1</span>
<span class="comment-line"># Authentication: Unauthenticated</span>
<span class="comment-line"># Port State    : Enabled</span>
<span class="comment-line">#</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         No     802.1x    2            Unknown         </span>
<span class="comment-line"># ------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyShowNetloginPorts_3116">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyShowNetloginPorts">::::dot1x_exVerifyShowNetloginPorts</a></a></strong> {args} {
    <a name="::parse_args(9)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_exVerifyShowNetloginPorts $args {
	<a name="::port(11)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(11)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	portState   &#34;&#34;
	authState   &#34;&#34;
	supMac      &#34;&#34;
	supIp       &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	showMode    &#34;port_vlan&#34;
    }

    ;<span class="comment-line"># Not enough parameters</span>
    if {$port == &#34;&#34; &amp;&amp; $vlan == &#34;&#34;} {
	<a name="::result_debug(120)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;_exVerifyShowNetloginPorts{} Not enough parameters&#34;
	return 0
    }

   global tmpPath
   set tmp &#34;Tmp&#34;
   if [info exists tmpPath] {
       set tmp $tmpPath
   } 

    set pid _[pid]
    
    set tempFile &#34;$tmp/tmp_Dot1X$pid&#34;

    ;<span class="comment-line"># Execute show netlogin po and put output into a file</span>
    set fd_in [open $tempFile &#34;w&#34;]
   if {$showMode == &#34;port&#34;} {
       <a name="::SendACmd(30)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin port $port&#34; NULL $fd_in
   } elseif {$showMode == &#34;vlan&#34;} {
       <a name="::SendACmd(31)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin vlan $vlan&#34; NULL $fd_in
   } else {
       <a name="::SendACmd(32)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show netlogin port $port vlan $vlan&#34; NULL $fd_in
   }
    close $fd_in

    ;<span class="comment-line"># Open for reading</span>
    set fd_in [open $tempFile &#34;r&#34;]
    
    set portMatchLine  &#34;&#34;
    set vlanMatchLine  &#34;&#34;
    set portStateMatchLine &#34;&#34;
    set authStateMatchLine  &#34;&#34;
    set macMatchLine       &#34;&#34;
    ;<span class="comment-line"># Find correct port/vlan and MAC lines </span>
    while {[gets $fd_in line] != -1} {

	;<span class="comment-line"># Look for Port/Vlan Match.</span>
      if {$portMatchLine == &#34;&#34;} {
	if {[regexp -nocase -indices -- Port\ *:\ *$port $line matchedRange] == 1} {

	    set portMatchLine $line
            break
         }
       }
      }

          if {$vlanMatchLine == &#34;&#34;} {
	    ;<span class="comment-line"># Get next line for Vlan</span>
	    while {[gets $fd_in line] != -1} {
		set vlanMatchLine $line
		if {[regexp -nocase -indices -- Vlan\ *:\ *$vlan $line matchedRange] != 1} {
		    ;<span class="comment-line"># No port/vlan match...get next line</span>
		    set vlanMatchLine &#34;&#34;
		    continue
		} else {
                  break
                }
	    }
          }

	    <a name="::result_debug(121)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND Port:$port Vlan:$vlan\n$portMatchLine\n$vlanMatchLine&#34;
	    
	    ;<span class="comment-line"># Get Auth State</span>
	    if {[gets $fd_in line] != -1} {
		set authStateMatchLine $line
	    }

	    ;<span class="comment-line"># Get Port State</span>
	    if {[gets $fd_in line] != -1} {
		set portStateMatchLine $line
	    }    
	    
	    if {[string length $supMac] != 0} {

	    ;<span class="comment-line"># Now look for MAC Match</span>
	    while {[gets $fd_in line] != -1} {
               <a name="::result_debug(122)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Line here is $line&#34;
		
		if {[regexp -nocase -indices -- $supMac $line matchedRange] == 1} {
		    <a name="::result_debug(123)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FOUND MAC:$supMac on line:$line&#34;
		    set macMatchLine $line
		    break
		}
	    }
           }
	    <span class="comment-line">#if {$macMatchLine == &#34;&#34;} { result_debug &#34;MAC:$supMac NOT FOUND&#34;}</span>
	    <span class="comment-line">#break;</span>

    close $fd_in
    file delete $tempFile
    
    if {$portMatchLine == &#34;&#34;} {
	<a name="::result_debug(124)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Port:$port NOT FOUND&#34;
	return 0
    }

    set portVlanMatch 0

    ;<span class="comment-line"># Apply required key info matches</span>
    if {$portState != &#34;&#34;} {
	set portMatch [regexp -nocase &#34;Port State:.*$portState&#34; $portStateMatchLine]
	<a name="::result_debug(125)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Looking at portState $portState portVlanMatch: $portVlanMatch&#34;
    } else {
	set portVlanMatch 1
	<a name="::result_debug(126)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Ignoring portState $portState port:$port vlan:$vlan&#34;
    }
    
    if {$authState != &#34;&#34;} {
	set authMatch [regexp -nocase &#34;Auth.*:\ *$auth&#34; $portDHCPMatchLine]
	<a name="::result_debug(127)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Looking at Authentication State $authState portMatch: $portMatch&#34;
    } else {
	set portVlanMatch 1
	<a name="::result_debug(128)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Ignoring Authentication State $authState port:$port vlan:$vlan&#34;
    }
           
    ;<span class="comment-line"># We don't care about supplicant MAC entry</span>
    if {[string length $supMac] == 0} {
	<a name="::result_debug(129)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;SupMac $supMac was not given.  Returning portVlanMatch: $portVlanMatch&#34;
	return $portVlanMatch
    }
    

    set macMatch 0
    if { [string length $macMatchLine] &gt; 0 } {

	set macMatch [<a name="::_exMacMatchDot1x(2)"><a href="./Dot1XLib.tcl.html#::_exMacMatchDot1x_2784">::_exMacMatchDot1x</a></a> $macMatchLine $supMac $supIp $authVal $authType \
		$reauthTimer $user]
    }

    <a name="::result_debug(130)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;RETURNING port: $portVlanMatch  mac: $macMatch&#34;
    return [expr $portVlanMatch &amp; $macMatch]
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exVerifyShowNetloginPorts</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Proc that checks &#34;show netlogin ports &lt;x&gt; &lt;vlan&gt;&#34; </span>
<span class="comment-line">#              parameters for 1 or more supplicants.  We, of course,</span>
<span class="comment-line">#              assume all supplicants have the same values when </span>
<span class="comment-line">#              checking multiple supplicants.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#       port:   DUT port</span>
<span class="comment-line">#	vlan:   DUT vlan</span>
<span class="comment-line">#	portState: &#34;Auth&#34; | &#34;Unauth&#34;</span>
<span class="comment-line">#       DHCP:   &#34;Not&#34; | &#34;Enabled&#34;</span>
<span class="comment-line">#	supMac: supplicant MAC</span>
<span class="comment-line">#	supIp:  supplicant IP</span>
<span class="comment-line">#	authVal: &#34;Yes&#34; | &#34;No&#34;</span>
<span class="comment-line">#	authType: &#34;802.1x&#34; | &#34;Http&#34;</span>
<span class="comment-line">#       reauthTimer: &#34;0&#34; | &#34;-1&#34; | &lt;value&gt;</span>
<span class="comment-line">#          -1 : ignore</span>
<span class="comment-line">#           0 : Looking for timer == 0</span>
<span class="comment-line">#        &lt;val&gt;: Looking for GREATER &lt;val&gt; </span>
<span class="comment-line">#	user: username logged in as</span>
<span class="comment-line">#       numSupplicants: Number of supplicants to check.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show netlogin ports </span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:95 # show netlogin ports 21 vlan_1</span>
<span class="comment-line"># Port: 21        Vlan: vlan_1</span>
<span class="comment-line"># Port State:     Unauthenticated</span>
<span class="comment-line"># DHCP:           Not Enabled</span>
<span class="comment-line">#</span>
<span class="comment-line"># MAC                IP address      Auth   Type      ReAuth-Timer User    </span>
<span class="comment-line"># ------------------------------------------------------------------</span>
<span class="comment-line"># 00:00:01:02:01:01  0.0.0.0         No     802.1x    2            Unknown         </span>
<span class="comment-line"># Quiet Period Timer    :  0      Num. Authentication Attempt Failed    :  1</span>
<span class="comment-line"># ------------------------------------------------------------------</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyShowNetloginPorts_3308">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyShowNetloginPorts">::::dot1x_exVerifyShowNetloginPorts</a></a></strong> {args} {
    <a name="::parse_args(10)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_exVerifyShowNetloginPorts $args {
	<a name="::port(12)"><a href="./ePTClient.tcl.html#::port_510">::port</a></a>        &#34;&#34;
	<a name="::vlan(12)"><a href="./ePTClient.tcl.html#::vlan_772">::vlan</a></a>        &#34;&#34;
	portState   &#34;&#34;
	DHCP        &#34;&#34;
	supMac      &#34;&#34;
	supIp       &#34;&#34;
	authVal     &#34;&#34;
	authType    &#34;&#34;
	reauthTimer &#34;&#34;
	user        &#34;&#34;
	numSupplicants &#34;1&#34;
	showMode    &#34;port_vlan&#34;
    }

    set rc 1
    set curIp $supIp
    set curMac $supMac

    <a name="::report_start_test(4)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify show netlogin ports for $numSupplicants supplicant(s) $portState&#34;

    while { $numSupplicants } {
	<a name="::result_debug(131)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($numSupplicants) Verify show netlogin ports supMac:$curMac supIp:$curIp&#34;
	
	if {! [<a name="::_exVerifyShowNetloginPorts(1)"><a href="./NetloginLib.tcl.html#::_exVerifyShowNetloginPorts_3434">::_exVerifyShowNetloginPorts</a></a> -port $port \
		-vlan $vlan -portState $portState -supMac $curMac \
		-supIp $curIp -authVal $authVal -authType $authType \
		-reauthTimer $reauthTimer -user $user -showMode $showMode]} {
	    <a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Verification of show netlogin ports parameters failed.&#34;
	    set rc 0
	}
	;<span class="comment-line"># Increment IP and MAC</span>
	if {$curIp != &#34;&#34;} {
	    set curIp [<a name="::IncrIpAddr(6)"><a href="./misc.tcl.html#::IncrIpAddr_1523">::IncrIpAddr</a></a> $curIp]
	}
	if {$curMac != &#34;&#34;} {
	    set curMac [<a name="::IncMacByOne(5)"><a href="./misc.tcl.html#::IncMacByOne_2383">::IncMacByOne</a></a> $curMac &#34;:&#34;]
	}

	incr numSupplicants -1
    }

    <a name="::report_end_test(6)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

    return $rc
}

    


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_exVerifyShowSession</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Proc that checks &#34;show session&#34;</span>
<span class="comment-line">#              This actually just wraps CheckKeyValue so parameters</span>
<span class="comment-line">#              are checked based on min regexp.  For example, loginTime</span>
<span class="comment-line">#              can be entered as &#34;Dec&#34; or &#34;Thu Dec 16&#34; to yield a</span>
<span class="comment-line">#              good match.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#	id:        Login id. 0-n</span>
<span class="comment-line">#	loginTime: Date/Time of login</span>
<span class="comment-line">#	user:      Username of login</span>
<span class="comment-line">#	type:      &#34;console&#34; | &#34;netlogin&#34; | &#34;radius&#34;</span>
<span class="comment-line">#	auth:      &#34;local&#34; | &#34;radius&#34;</span>
<span class="comment-line">#	cliAuth:   &#34;enabled&#34; | &#34;disabled&#34;</span>
<span class="comment-line">#	location:  &#34;serial&#34; | &lt;ip&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Expected output of show session</span>
<span class="comment-line">#</span>
<span class="comment-line"># * Summit48i:12 # show session</span>
<span class="comment-line">#    # Login Time                 User     Type     Auth     CLI Auth Location</span>
<span class="comment-line"># ==============================================================================</span>
<span class="comment-line">#      0 Wed Dec 15 12:23:20 1999 admin    console  local    disabled serial</span>
<span class="comment-line">#      4 Thu Dec 16 16:20:27 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      5 Thu Dec 16 16:20:28 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      6 Thu Dec 16 16:20:29 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      7 Thu Dec 16 16:20:30 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line">#      8 Thu Dec 16 16:20:32 1999 ixia1md5 netlogin radius   disabled 0.0.0.0</span>
<span class="comment-line"># * 1028 Thu Dec 16 16:20:56 1999 admin    telnet   radius   disabled 10.212.9.4</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_exVerifyShowSession_3393">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_exVerifyShowSession">::::dot1x_exVerifyShowSession</a></a></strong> {args} {
    <a name="::parse_args(11)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_exVerifyShowSession $args {
	id        &#34;&#34;
	loginTime &#34;&#34;
	user      &#34;&#34;
	type      &#34;&#34;
	auth      &#34;&#34;
	cliAuth   &#34;&#34;
	location  &#34;&#34;
    }
    <a name="::report_start_test(5)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify show session&#34;

    lappend parameterList &#34;$id.*$loginTime.*$user.*$type.*$auth.*cliAuth.*$location&#34;
    set rc [<a name="::CheckKeyValue(4)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show session&#34; $parameterList \
	    -comment &#34;Verify Show Session Params&#34;]

    <a name="::report_end_test(7)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    if {$rc == &#34;ok&#34;} {
	return 1
    } else {
	return 0
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _reportVerifyProtocolResult</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal procedure that merely prints error or ok on</span>
<span class="comment-line">#              whether desired traffic was received.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#      traffic:    &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#      matchCnt:   Number of frames found that match</span>
<span class="comment-line">#      portId:     Logging purposes only</span>
<span class="comment-line">#      typeWanted: Logging purposes only</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_reportVerifyProtocolResult_3434">proc <a href="Dot1XLib.tcl-annot.html#::::_reportVerifyProtocolResult">::::_reportVerifyProtocolResult</a></a></strong> { traffic matchCnt portId typeWanted } {
    
    if {$traffic == &#34;exist&#34;} {
	if {$matchCnt &lt;= 0} {
	    <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;PortId:$portId: Wanted $typeWanted but received $matchCnt&#34;
	    return ERROR
	}
    } elseif {$traffic == &#34;notExist&#34;} {
	if {$matchCnt &gt; 0} {
	    <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;PortId:$portId: DID NOT want $typeWanted but received $matchCnt&#34;
	    return ERROR
	}
    } else {
	<a name="::result_debug(132)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;PortId:$portId: Unknown state traffic $traffic specified&#34;
	return ERROR
    }

    <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;SUCCESS: PortId:$portId: Wanted $traffic. $matchCnt \
	    $typeWanted received as expected&#34;
    return OK

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyEDP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of EDP Traffic.  We enable EDP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             edpTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Decode EDP Packet</span>
<span class="comment-line"># EDP Packet is SNAP Encapsulated Frame.  EDP Header should start after</span>
<span class="comment-line"># SNAP header at location 0x0016 bytes from start of frame.</span>
<span class="comment-line"># EDP Header is followed by 1+ TLV blocks</span>
<span class="comment-line">#</span>
<span class="comment-line"># EDP Header (14 octets)</span>
<span class="comment-line"># ----------</span>
<span class="comment-line">#  1 Version</span>
<span class="comment-line">#  1 reserved</span>
<span class="comment-line">#  2 checksum</span>
<span class="comment-line">#  2 sequence#</span>
<span class="comment-line">#  8 device id (00 00 [mac address])</span>
<span class="comment-line">#</span>
<span class="comment-line"># TLV (Type - Length - Value) </span>
<span class="comment-line"># ---</span>
<span class="comment-line">#  1 Marker (0x99)</span>
<span class="comment-line">#  1 Type </span>
<span class="comment-line">#      0 NULL - End Signal</span>
<span class="comment-line">#      1 Display - (MIBII Display String)</span>
<span class="comment-line">#      2 Info - (Basic system info)</span>
<span class="comment-line">#      5 VLAN Info </span>
<span class="comment-line">#      8 ESRP</span>
<span class="comment-line">#  2 Length</span>
<span class="comment-line">#  n DATA</span>
<span class="comment-line">#</span>
<span class="comment-line"># INFO TLV</span>
<span class="comment-line"># --------</span>
<span class="comment-line">#   2  originating slot</span>
<span class="comment-line">#   2  originating port</span>
<span class="comment-line">#   2  Virtual Chassis ID (If connected to virtual chassis)</span>
<span class="comment-line">#   6  RESERVED</span>
<span class="comment-line">#   4  SW Version</span>
<span class="comment-line">#   16 Virtual Chassis ID Connections</span>
<span class="comment-line">#</span>
<span class="comment-line"># VLAN TLV</span>
<span class="comment-line"># --------</span>
<span class="comment-line">#   1  Flags (bit 8 - 1 means this vlan has IP interface) </span>
<span class="comment-line">#   3  RESERVED</span>
<span class="comment-line">#   2  VLAN ID (0 if untagged)</span>
<span class="comment-line">#   2  RESERVED</span>
<span class="comment-line">#   4  VLAN IP Addr</span>
<span class="comment-line">#   n  VLAN Name</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyEDP_3515">proc <a href="Dot1XLib.tcl-annot.html#::::_verifyEDP">::::_verifyEDP</a></a></strong> {portIdList {edpTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(2)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    sleep 2
    
    ;<span class="comment-line"># Enable protocol</span>
    foreach portId $portIdList {
	<a name="::SendACmd(33)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command edp ports [<a name="::MapDUTPortId(1)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $portId]&#34;
    }


    ;<span class="comment-line"># Wait 65 seconds for an EDP Packet (Should arrive every minute)</span>
    <a name="::result_debug(133)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sleeping 65 seconds&#34;
    <a name="::exSleep(7)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 65

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(3)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList

    foreach portId $portIdList {
	<a name="::report_start_test(6)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId EDP $command EDP Traffic $edpTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(2)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    ;<span class="comment-line"># Look for Device ID MAC followed by TLV Marker.	</span>
	    if {[<a name="::GetMessageType(1)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame] == &#34;EDP&#34;} {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(1)"><a href="./Dot1XLib.tcl.html#::_reportVerifyProtocolResult_3434">::_reportVerifyProtocolResult</a></a> $edpTraffic $matchCnt $portId &#34;EDP Packets&#34;
	<a name="::report_end_test(8)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifySTP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of STP Traffic.  We enable STP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             vlanList: List of vlans to enable STP on.</span>
<span class="comment-line">#             stpTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from dot1x_VerifyProtocol</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifySTP_3572">proc <a href="Dot1XLib.tcl-annot.html#::::_verifySTP">::::_verifySTP</a></a></strong> {portIdList vlanList {stpTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {
    
    ;<span class="comment-line"># Make sure we configure one vlan at a time</span>
    <a name="::SendACmd(34)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig stpd s0&#34;

    foreach myVlan $vlanList {
	
	;<span class="comment-line"># Add vlan to default vlan domain s0</span>
	<a name="::SendACmd(35)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config stpd s0 add vlan $myVlan port all&#34;
    }
    
    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(3)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable STP</span>
    <a name="::SendACmd(36)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command stpd s0&#34;

    ;<span class="comment-line"># Wait for some BPDUs to get sent</span>
    <a name="::result_debug(134)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 5 seconds for some BPDUs to get sent&#34;
    <a name="::exSleep(8)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(4)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(7)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId STP $command BPDUs $stpTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(3)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;BPDU&#34; [<a name="::GetMessageType(2)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(2)"><a href="./Dot1XLib.tcl.html#::_reportVerifyProtocolResult_3434">::_reportVerifyProtocolResult</a></a> $stpTraffic $matchCnt $portId &#34;STP BPDUs&#34;
	<a name="::report_end_test(9)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
    
    ;<span class="comment-line"># Clean up</span>
    <a name="::SendACmd(37)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig stpd&#34;
}



<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyRIP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of RIP Traffic.  We enable RIP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             ripTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from dot1x_VerifyProtocol</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyRIP_3635">proc <a href="Dot1XLib.tcl-annot.html#::::_verifyRIP">::::_verifyRIP</a></a></strong> {portIdList {ripTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {


    <a name="::SendACmd(38)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable ipforwarding&#34;      
    <a name="::SendACmd(39)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config rip add vlan all&#34;
    <a name="::SendACmd(40)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config rip updatetime 10&#34;

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(4)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable RIP</span>
    <a name="::SendACmd(41)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command rip&#34;      

    ;<span class="comment-line"># Wait for some RIP packets to get sent</span>
    <a name="::result_debug(135)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 13 seconds for some RIP packets to get sent&#34;
    <a name="::exSleep(9)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 13

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(5)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(8)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId RIP $command RIP Packets $ripTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(4)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;RIP&#34; [<a name="::GetMessageType(3)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(3)"><a href="./Dot1XLib.tcl.html#::_reportVerifyProtocolResult_3434">::_reportVerifyProtocolResult</a></a> $ripTraffic $matchCnt $portId &#34;RIP Packets&#34;
	<a name="::report_end_test(10)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
    
    ;<span class="comment-line"># Clean up</span>
    <a name="::SendACmd(42)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config rip delete vlan all&#34;
    <a name="::SendACmd(43)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable rip&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyOSPF</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of OSPF Traffic.  We enable OSPF</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             ospfTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from dot1x_VerifyProtocol</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyOSPF_3694">proc <a href="Dot1XLib.tcl-annot.html#::::_verifyOSPF">::::_verifyOSPF</a></a></strong> {portIdList {ospfTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {

    <a name="::SendACmd(44)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;create ospf area 0.0.0.5&#34;
    <a name="::SendACmd(45)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable ipforwarding&#34;      
    <a name="::SendACmd(46)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config ospf add vlan all area 0.0.0.5&#34;

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(5)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable OSPF</span>
    <a name="::SendACmd(47)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command ospf&#34;      

    ;<span class="comment-line"># Wait for some OSPF packets to get sent</span>
    <a name="::result_debug(136)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 5 seconds for some OSPF packets to get sent&#34;
    <a name="::exSleep(10)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(6)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(9)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId OSPF $command OSPF Packets $ospfTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(5)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;OSPF&#34; [<a name="::GetMessageType(4)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(4)"><a href="./Dot1XLib.tcl.html#::_reportVerifyProtocolResult_3434">::_reportVerifyProtocolResult</a></a> $ospfTraffic $matchCnt $portId &#34;OSPF Packets&#34;
	<a name="::report_end_test(11)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }
    
    ;<span class="comment-line"># Clean up</span>
    <a name="::SendACmd(48)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig ospf&#34;
    <a name="::SendACmd(49)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable ospf&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _verifyIGMP</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description:  Verify the presence of IGMP Traffic.  We enable IGMP</span>
<span class="comment-line">#               on a DUT then wait to see traffic on a ports(s) by</span>
<span class="comment-line">#               capturing traffic on Ixia.</span>
<span class="comment-line">#</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: portIdList: Port IDs of ports to examine traffic on</span>
<span class="comment-line">#             igmpTraffic:  &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#             command:  &#34;enable&#34; | &#34;disable&#34; protocol on DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Called from dot1x_VerifyProtocol</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_verifyIGMP_3750">proc <a href="Dot1XLib.tcl-annot.html#::::_verifyIGMP">::::_verifyIGMP</a></a></strong> {portIdList {igmpTraffic &#34;exist&#34;} {command &#34;enable&#34;} } {

    ;<span class="comment-line"># Start port capture</span>
    <a name="::StartPortsCapture(6)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    ;<span class="comment-line"># Enable/Disable IGMP</span>
    <a name="::SendACmd(50)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable igmp&#34;
    <a name="::SendACmd(51)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config igmp 1 1 1&#34;  ;<span class="comment-line"># Shorten interval so we don't wait long for</span>
    <a name="::SendACmd(52)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;$command igmp&#34;      ;<span class="comment-line"># a packet to arrive</span>

    ;<span class="comment-line"># Wait for some IGMP Packets to get sent</span>
    <a name="::result_debug(137)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Waiting 30 seconds for some IGMP packets to get sent&#34;
    <a name="::exSleep(11)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 30

    ;<span class="comment-line"># Stop Capture</span>
    <a name="::StopPortsCapture(7)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    ;<span class="comment-line"># Parse Buffer</span>
    foreach portId $portIdList {
	<a name="::report_start_test(10)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify PortId:$portId IGMP $command IGMP Packets $igmpTraffic&#34;
	;<span class="comment-line"># Parse output for packets</span>
	set frameList [<a name="::GetCapturedFrames(6)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $portId]
	set matchCnt 0
	foreach frame $frameList {
	    if { [regexp -nocase &#34;IGMP&#34; [<a name="::GetMessageType(5)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]] } {
		incr matchCnt
	    }
	}
	
	<a name="::_reportVerifyProtocolResult(5)"><a href="./Dot1XLib.tcl.html#::_reportVerifyProtocolResult_3434">::_reportVerifyProtocolResult</a></a> $igmpTraffic $matchCnt $portId &#34;IGMP Packets&#34;
	<a name="::report_end_test(12)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
    }


    ;<span class="comment-line"># Clean up IGMP is enabled by default</span>
    <a name="::SendACmd(53)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfig igmp&#34;
    <a name="::SendACmd(54)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;enable igmp&#34;
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_VerifyProtocol</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that a particular protocol is blocked or unblocked</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#    portIdList:   Port IDs to check traffic on</span>
<span class="comment-line">#    command:      &#34;enable&#34; | &#34;disable&#34;</span>
<span class="comment-line">#    protocol:     &#34;edp&#34; | &#34;rip&#34; | &#34;ospf&#34; | &#34;stp&#34; | &#34;igmp&#34;</span>
<span class="comment-line">#    traffic:      &#34;exist&#34; | &#34;notExist&#34;</span>
<span class="comment-line">#    optionalList: Currently used by &#34;stp&#34; for list of vlans</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    Login $DUT1_CONNECT</span>
<span class="comment-line">#    dot1x_VerifyProtocol [list 1 2] &#34;enable&#34; &#34;edp&#34; &#34;exist&#34;</span>
<span class="comment-line">#    dot1x_VerifyProtocol [list 1 2] &#34;disable&#34; &#34;edp&#34; &#34;notExist&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_VerifyProtocol_3810">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_VerifyProtocol">::::dot1x_VerifyProtocol</a></a></strong> { portIdList command protocol traffic {optionalList [list]} } {
    
    switch -- $protocol \
      &#34;edp&#34; {
        <a name="::_verifyEDP(1)"><a href="./Dot1XLib.tcl.html#::_verifyEDP_3515">::_verifyEDP</a></a> $portIdList $traffic $command
    } &#34;rip&#34; { 
	<a name="::_verifyRIP(1)"><a href="./Dot1XLib.tcl.html#::_verifyRIP_3635">::_verifyRIP</a></a> $portIdList $traffic $command
    } &#34;ospf&#34; {
        <a name="::_verifyOSPF(1)"><a href="./Dot1XLib.tcl.html#::_verifyOSPF_3694">::_verifyOSPF</a></a> $portIdList $traffic $command
    } &#34;stp&#34; {
	<a name="::_verifySTP(1)"><a href="./Dot1XLib.tcl.html#::_verifySTP_3572">::_verifySTP</a></a> $portIdList $optionalList $traffic $command
    } &#34;igmp&#34; {
	<a name="::_verifyIGMP(1)"><a href="./Dot1XLib.tcl.html#::_verifyIGMP_3750">::_verifyIGMP</a></a> $portIdList $traffic $command
    } default {
	<a name="::result_error(16)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Unsupported protocol $protocol&#34;
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ixCheckDHCPBroadcastBlocked</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify that DHCP broadcasts don't go out protected port</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#    protectedPortId: Port which should NOT receive broadcasts</span>
<span class="comment-line">#    dhcpPortId:      Informational only. Used for message. </span>
<span class="comment-line">#    srcMac:          Source MAC of DHCP request.  Usually supplicant.     </span>
<span class="comment-line">#    dhcpServer:      DHCP Server to send request to. Usually DUT </span>
<span class="comment-line">#    reqIP:           IP Address being requested.  This really doesn't matter.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#   dot1x_CheckDHCPBroadcastBlocked $protectedPortId $dhcpPortId \</span>
<span class="comment-line">#	  $supMacCampus &#34;10.1.1.1&#34; &#34;10.1.1.3&#34; </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ixCheckDHCPBroadcastBlocked_3848">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ixCheckDHCPBroadcastBlocked">::::dot1x_ixCheckDHCPBroadcastBlocked</a></a></strong> { protectedPortId dhcpPortId \
	srcMac dhcpServer reqIP} {

    set broadcastMac &#34;FF FF FF FF FF FF&#34;

    <a name="::StartPortsCapture(7)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> [list $protectedPortId]
    set rawframe [<a name="::SendDHCPRequest(1)"><a href="./dhcp.tcl.html#::SendDHCPRequest_219">::SendDHCPRequest</a></a> $srcMac 2 $dhcpServer $reqIP 0]

    <a name="::StopPortsCapture(8)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> [list $protectedPortId]
    
    <a name="::report_start_test(11)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Check DHCP Broadcast from port:[<a name="::MapDUTPortId(2)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $dhcpPortId] does \
	    not reach protected port:[<a name="::MapDUTPortId(3)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId]&#34;

    set rawPortDataList [<a name="::GetCapturedFrames(7)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> 1]
    set fCnt 0
    foreach frame $rawPortDataList {
	;<span class="comment-line"># Check if we received any broadcast traffic.</span>
	set targetMac [<a name="::GetTargetMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetTargetMacAddress_159">::GetTargetMacAddress</a></a> $frame]
	if {$targetMac == $broadcastMac} {
	    incr fCnt
	    <a name="::result_debug(138)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Protected port [<a name="::MapDUTPortId(4)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId] received illegal broadcast $frame&#34;
	}
    }

    if {$fCnt == 0} {
	<a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;DHCP Broadcasts blocked on protected port [<a name="::MapDUTPortId(5)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId]&#34;
    } else {
	<a name="::result_error(17)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Protected port [<a name="::MapDUTPortId(6)"><a href="./ePTPortMapping.tcl.html#::MapDUTPortId_120">::MapDUTPortId</a></a> $protectedPortId] received $fCnt broadcast packets&#34;
    }
    <a name="::report_end_test(13)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_CheckARPBroadcastBlocked</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Ping from DUT out unprotected port.  Verify that ARP </span>
<span class="comment-line">#              Broadcast is sent out unprotected port and protected </span>
<span class="comment-line">#              port.   </span>
<span class="comment-line">#              We assume protected and unprotected ports ARE </span>
<span class="comment-line">#              ON THE SAME VLAN!  </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     protectedPortId    Port ID of netlogin port.</span>
<span class="comment-line">#     unprotectedPortId: Port ID of non-netlogin port.</span>
<span class="comment-line">#     destIp:            IP Address in ARP.  We use this to clear</span>
<span class="comment-line">#                        the entry to make sure we get a new ARP.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#     Login $DUT1_CONNECT</span>
<span class="comment-line">#     dot1x_CheckARPBroadcast $protectedPortId $pingPortId &#34;10.1.1.100&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_CheckARPBroadcastBlocked_3901">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_CheckARPBroadcastBlocked">::::dot1x_CheckARPBroadcastBlocked</a></a></strong> { protectedPortId unprotectedPortId destIp } {
    
    set portIdList [list $protectedPortId $unprotectedPortId]
    
    ;<span class="comment-line"># Delete destIp entry from ARP table to make sure we generate ARP.</span>
    <a name="::SendACmd(55)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear iparp $destIp&#34;

    <a name="::report_start_test(12)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Sending ping from DUT to $destIp to generate ARP&#34;

    <a name="::StartPortsCapture(8)"><a href="./ePTRx.tcl.html#::StartPortsCapture_820">::StartPortsCapture</a></a> $portIdList

    <a name="::SendACmd(56)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ping $destIp&#34;

    <a name="::StopPortsCapture(9)"><a href="./ePTRx.tcl.html#::StopPortsCapture_862">::StopPortsCapture</a></a> $portIdList
    
    set rawPortDataProtected [<a name="::GetCapturedFrames(8)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $protectedPortId]
    set rawPortDataUnprotected [<a name="::GetCapturedFrames(9)"><a href="./ePTRx.tcl.html#::GetCapturedFrames_982">::GetCapturedFrames</a></a> $unprotectedPortId]
    
    <a name="::result_debug(139)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;******************** PROTECTED PORT DATA ************************&#34;
    set protectedStatus   0
    set unprotectedStatus 0
    foreach frame $rawPortDataProtected {
	
	set msgType [<a name="::GetMessageType(6)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	<a name="::result_debug(140)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($msgType) Raw: $frame&#34;
	if [regexp &#34;ARP_REQUEST&#34; $msgType ] {
	    set protectedStatus 1
	}

    }

    <a name="::result_debug(141)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;******************** UNPROTECTED PORT DATA ************************&#34;
    foreach frame $rawPortDataUnprotected {
	
	set msgType [<a name="::GetMessageType(7)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	<a name="::result_debug(142)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;($msgType) Raw: $frame&#34;
	if [regexp &#34;ARP_REQUEST&#34; $msgType] {
	    set unprotectedStatus 1  
	}

    }
    if {$protectedStatus &amp;&amp; $unprotectedStatus} {
	<a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Broadcast ARP_REQUEST seen on Protected AND Unprotected Port&#34;
    } else {
	<a name="::result_error(18)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No ARP_REQUEST seen on Protected($protectedStatus) and/or Unprotected Port($unprotectedStatus)&#34;
    }
    <a name="::report_end_test(14)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_VerifyDHCPBootPRelay</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify we can reach external DHCP server.  We send DHCP </span>
<span class="comment-line">#              request from supplicant on txPortId with MAC srcMac</span>
<span class="comment-line">#              to external DHCP server after authenticating.</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE: We only check that packet is forwarded by looking at </span>
<span class="comment-line">#       BootPRelay Stats.  We don't actually check for response.</span>
<span class="comment-line">#       That's left for a future exercise.  This actually only</span>
<span class="comment-line">#       an interim check.  Ideally, Ixia IxAuth should support</span>
<span class="comment-line">#       DHCP, to really validate.  Until then, this is good enough</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     txPortId: Port to transmit out of</span>
<span class="comment-line">#     srcMac:   Source address of supplicant MAC.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    Login $DUT1_CONNECT</span>
<span class="comment-line">#    .....802.1x Authenticated $cookedSupMac.....     </span>
<span class="comment-line">#    dot1x_VerifyDHCPBootPRelay 1 $cookedSupMac</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_VerifyDHCPBootPRelay_3976">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_VerifyDHCPBootPRelay">::::dot1x_VerifyDHCPBootPRelay</a></a></strong> { txPortId srcMac } {
  
    global switchPort2DefaultRouter

    <a name="::SendACmd(57)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;clear counters&#34;

    set frame [<a name="::SendDhcpFrame(1)"><a href="./ePTSendPacket.tcl.html#::SendDhcpFrame_1045">::SendDhcpFrame</a></a> -txPortId $txPortId -destMac &#34;FF FF FF FF FF FF&#34; \
	    -sourceMac $srcMac -sourceIp &#34;0.0.0.0&#34; \
	    -destIp &#34;255.255.255.255&#34; -opCode &#34;dhcpBootRequest&#34; \
	    -optionCodeList [list dhcpMessageType dhcpDiscover] \
	    -clientHwAddr $srcMac];     	
    
    <a name="::result_debug(143)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;(802.1x) DHCP Discover frame: $frame&#34;
    
    ;<span class="comment-line"># Verify bootprelay stats increasing with show ipstats</span>
;<span class="comment-line"># DHCP/BOOTP relay statistics for virtual router &#34;VR-Default&#34;               </span>
;<span class="comment-line">#     Received to server =          1  Received to client =          0</span>
;<span class="comment-line">#     Requests relayed   =          1  Responses relayed  =          0</span>
;<span class="comment-line">#     DHCP Discover      =          1  DHCP Offer         =          0</span>
;<span class="comment-line">#     DHCP Request       =          0  DHCP Decline       =          0</span>
;<span class="comment-line">#     DHCP Ack           =          0  DHCP NAck          =          0</span>
;<span class="comment-line">#     DHCP Release       =          0  DHCP Inform        =          0</span>


    set parameterList [list]
    if {[<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(3)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> &#34;DUT1&#34;] &#34;12.2.0.4&#34;]&gt;=0} {
       lappend parameterList &#34;{Received from client\ *=\ *1} exist&#34;;
    } else {
       lappend parameterList &#34;{Received to server\ *=\ *1} exist&#34;;
    }
    if {$switchPort2DefaultRouter != &#34;mgmt&#34;} {
       lappend parameterList &#34;{Requests relayed\ *=\ *1} exist&#34;;  
    }
    <a name="::CheckKeyValue(5)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show bootprelay&#34; $parameterList -comment &#34;DHCP relay stats&#34;;
    unset parameterList;
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_VerifySupplicantPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#     rawPortData: Raw frames data</span>
<span class="comment-line">#     srcMac:      Source MAC that we're looking for</span>
<span class="comment-line">#     dstMac       Dest MAC that we're looking for</span>
<span class="comment-line">#     packetExpr:  Type of packet to look for. This should match msgTypes returned</span>
<span class="comment-line">#                  from MessageDecoding.tcl.  If MessageDecoding.tcl does not support</span>
<span class="comment-line">#                  a particular packet type, this procedure will not work.</span>
<span class="comment-line">#                  Use alternation &#34;|&#34; symbol (i.e. &#34;stringA|stringB&#34;) to match multiple strings</span>
<span class="comment-line">#     rx:          &#34;yes&#34; | &#34;no&#34;   yes-we should receive, no-we should NOT receive any</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    dot1x_VerifySupplicantPackets $rawPortData $cookedDutMac $cookedSupMac &#34;EAP.*REQ&#34;</span>
<span class="comment-line">#    dot1x_VerifySupplicantPackets $rawPortData $cookedDutMac $cookedSupMac &#34;EAP.*FAIL&#34;</span>
<span class="comment-line">#    dot1x_VerifySupplicantPackets $rawPortData $srcMac $dstMac &#34;EAP.*REQUEST_IDENTITY|EAP.*SUCC&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_VerifySupplicantPackets_4037">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_VerifySupplicantPackets">::::dot1x_VerifySupplicantPackets</a></a></strong> { rawPortData srcMac dstMac packetExpr {rx &#34;yes&#34;} } {

    <a name="::report_start_test(13)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify we receive correct packets&#34;

    set statusCnt 0

    foreach frame $rawPortData {
	set msgType [<a name="::GetMessageType(8)"><a href="./MessageDecoding.tcl.html#::GetMessageType_992">::GetMessageType</a></a> $frame]
	set frameDstMac [<a name="::GetDestMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetDestMacAddress_19">::GetDestMacAddress</a></a> $frame]
	set frameSrcMac [<a name="::GetSourceMacAddress(1)"><a href="./MessageDecoding.tcl.html#::GetSourceMacAddress_40">::GetSourceMacAddress</a></a> $frame]

	<a name="::result_debug(144)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;FRAME TYPE: $msgType src:$frameSrcMac dst:$frameDstMac&#34;
	<a name="::result_debug(145)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;LOOKING FOR src:$srcMac dst:$dstMac&#34;
	
	;<span class="comment-line"># Verify supplicant received Success/Fail Frame.</span>
	if {[regexp -nocase &#34;$packetExpr&#34; $msgType]} {
	    <a name="::result_debug(146)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;---&gt; Got $packetExpr Packet &lt;---&#34;
	    if { ($srcMac == $frameSrcMac) &amp;&amp; ($dstMac == $frameDstMac) } {
		incr statusCnt 
	    }
	}
    }
    
    if { ($statusCnt == 0) &amp;&amp; ($rx == &#34;no&#34;) } {
	<a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Supplicant received $statusCnt messages as expected ($packetExpr)&#34;
    } elseif { ($statusCnt == 0) &amp;&amp; ($rx == &#34;yes&#34;) } {
	<a name="::result_error(19)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Supplicant received NO messages, but expected to. ($packetExpr)&#34;
    } elseif { ($statusCnt &gt; 0) &amp;&amp; ($rx == &#34;no&#34;) } {
	<a name="::result_error(20)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Supplicant received $statusCnt messages, but expected NONE. ($packetExpr)&#34;
    } elseif { ($statusCnt &gt; 0) &amp;&amp; ($rx == &#34;yes&#34;) } {
	<a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Supplicant received $statusCnt message as expected ($packetExpr)&#34;
    }

    <a name="::report_end_test(15)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_VerifySupplicantEAPPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Looks at raw frame data from capture and verifies that </span>
<span class="comment-line">#              supplicant received the EAP REQUEST_IDENTITY and SUCCESS </span>
<span class="comment-line">#              packets.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     rawPortData: Raw port data from a packet capture </span>
<span class="comment-line">#     srcMac:      Src MAC to search for</span>
<span class="comment-line">#     dstMac:      Dst MAC to search for</span>
<span class="comment-line">#     status:      &#34;SUCCESS&#34; | &#34;FAIL&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#       dot1x_VerifySupplicantEAPPackets $rawPortData $cookedDutMac $cookedSupMac</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_VerifySupplicantEAPPackets_4093">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_VerifySupplicantEAPPackets">::::dot1x_VerifySupplicantEAPPackets</a></a></strong> { rawPortData srcMac dstMac {status &#34;SUCCESS&#34;}} {


    <a name="::dot1x_VerifySupplicantPackets(1)"><a href="./Dot1XLib.tcl.html#::dot1x_VerifySupplicantPackets_4037">::dot1x_VerifySupplicantPackets</a></a> $rawPortData $srcMac $dstMac \
	    &#34;EAP.*$status&#34;

<span class="comment-line">#	    &#34;EAP.*REQUEST_IDENTITY|EAP.*$status&#34;</span>

    return
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_VerifyTaggedPackets</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Verify whether we find any tagged frames in a raw</span>
<span class="comment-line">#              frame capture.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line">#     rawFrameData:   Ixia packet capture frames</span>
<span class="comment-line">#     tag:            Tag number. No tag means we should NOT receive any</span>
<span class="comment-line">#     comment:        Normal comment to output to test</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical Usage:</span>
<span class="comment-line">#    dot1x_VerifyTaggedPackets $rawData_1 &#34;&#34; &#34;Dot1x port [MapDUTPortId 1]&#34;    ;# No tag</span>
<span class="comment-line">#    dot1x_VerifyTaggedPackets $rawData_2 &#34;$tag&#34;  &#34;Tagged port [MapDUTPortId 2]&#34;  </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_VerifyTaggedPackets_4123">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_VerifyTaggedPackets">::::dot1x_VerifyTaggedPackets</a></a></strong> { rawFrameData {tag &#34;&#34;} {comment &#34;&#34;}} {

    if {$tag == &#34;&#34;} {
	<a name="::report_start_test(14)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify packets are NOT tagged ($comment)&#34;

	;<span class="comment-line"># Stop as soon as we find a tagged packet</span>
	set curTag -1
	foreach frame $rawFrameData {
	    set curTag [<a name="::GetTagId(1)"><a href="./MessageDecoding.tcl.html#::GetTagId_482">::GetTagId</a></a> $frame]
	    if { $curTag &gt; -1 } {
		<a name="::result_error(21)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Expected no tagged packets. Got packet $frame with VLAN ID $curTag&#34;
		break;
	    }
	}
	if { $curTag == -1 } {
	    <a name="::result_ok(7)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;No tagged packets found&#34;
	}
	
    } else {
	<a name="::report_start_test(15)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Verify packets are tagged. VLAN ID $tag ($comment)&#34;

	;<span class="comment-line"># Check that NO PACKETS are tagged</span>
	foreach frame $rawFrameData {
	    set curTag [<a name="::GetTagId(2)"><a href="./MessageDecoding.tcl.html#::GetTagId_482">::GetTagId</a></a> $frame]
	    if {$curTag == $tag} {
		<a name="::result_ok(8)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Got a matching tagged packet with id $tag&#34;
		break;
	    }
	}
	if { $curTag != $tag } {
	    <a name="::result_error(22)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No tagged packets found.  Expected packets with VLAN ID $tag&#34;
	}
    }

    <a name="::report_end_test(16)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_stripMac</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Proc that strips MAC of &#34;:&#34; seperators</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  mac: MAC address with &#34;:&#34; to strip</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: cooked MAC with no : seperators</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_stripMac_4170">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_stripMac">::::dot1x_stripMac</a></a></strong> { mac } {

    set cookedMac &#34;&#34;
    regsub -all &#34;:&#34; $mac &#34; &#34; cookedMac

    return $cookedMac
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_delimitMac</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Proc that replaces MAC &#34; &#34; with &#34;:&#34; seperators</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  mac: MAC address</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: uncooked MAC with : seperators</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_delimitMac_4188">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_delimitMac">::::dot1x_delimitMac</a></a></strong> { mac } {

    set uncookedMac &#34;&#34;
    regsub -all &#34; &#34; $mac &#34;:&#34; uncookedMac

    return $uncookedMac
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_getMacForIP </span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Retrieves MAC for a given IP from a list returned</span>
<span class="comment-line">#              by dot1x_ixCreatePortIfs.  Format is {port ip mac}</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  ip, macList, cooked</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: MAC with : seperators, unless cooked != 0</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_getMacForIP_4207">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_getMacForIP">::::dot1x_getMacForIP</a></a></strong> { <a name="::ip(21)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> macList {cooked 0}} {

    set mac &#34;&#34;

    <a name="::result_debug(147)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;dot1x_getMacForIP{} macList: $macList&#34;


    foreach entry $macList {
	;<span class="comment-line"># entry: &lt;port&gt; &lt;IP&gt; &lt;{MAC}&gt;</span>
	<a name="::result_debug(148)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;entry: $entry&#34;
	
	set ipAddr [lindex $entry 1]

	if {$ipAddr == $ip} {
	    set mac [lindex $entry 2]
	    break
	}
    }

    if {$cooked} {
	return $mac   ;<span class="comment-line"># Space delimited MAC</span>
    } else {
	return [<a name="::dot1x_delimitMac(1)"><a href="./Dot1XLib.tcl.html#::dot1x_delimitMac_4188">::dot1x_delimitMac</a></a> $mac]    ;<span class="comment-line"># : delimited MAC</span>
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_SkipTestBasedOnPlatform </span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Skip a test because not supported for a platform</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  platformList as defined in..</span>
<span class="comment-line">#                 DUTs_info(DUT1,platform) &#34;Summit200-24&#34;</span>
<span class="comment-line">#              DUT</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: 1 skip - 0 don't skip</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_SkipTestBasedOnPlatform_4246">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_SkipTestBasedOnPlatform">::::dot1x_SkipTestBasedOnPlatform</a></a></strong> { platformList {DUTName &#34;DUT1&#34;}} {

    set platform [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> $DUTName]

    <a name="::result_debug(149)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;dot1x_SkipTestBasedOnPlatform $platform  list:$platformList&#34;
    foreach platformToSkip $platformList {
	<a name="::result_debug(150)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$platformToSkip&#34;
	if [regexp -nocase $platformToSkip $platform] {
	    <a name="::result_debug(151)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;dot1x_SkipTestBasedOnPlatform $platform  $platformToSkip returning 1&#34;
	    
	    return 1
	}
    }
    return 0
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_CheckTaskCrash</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Check logs for a task crash.  You must know the name</span>
<span class="comment-line">#              of the task.</span>
<span class="comment-line">#</span>
<span class="comment-line"># We look for a log entry similiar to ...</span>
<span class="comment-line"># 04/02/2004 21:45.58 &lt;CRIT:SYST&gt; Task tDot1xTask (a783d331) failed</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  taskName  vxWorks Task Name</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: ok    - no crash</span>
<span class="comment-line">#              error - found task failure</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_CheckTaskCrash_4278">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_CheckTaskCrash">::::dot1x_CheckTaskCrash</a></a></strong> { taskName {DUTName &#34;DUT1&#34;} {exitOnFailure 1}} {
    
    global DUT1_CONNECT
    global DUT2_CONNECT
    global DUT3_CONNECT
    global DUT4_CONNECT
    global DUT5_CONNECT

    <a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set [set DUTName]_CONNECT]

    set paramList [list]

    lappend paramList &#34;{Task $taskName .* failed} notExist&#34;
    set returnVal [<a name="::CheckKeyValue(6)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show log&#34; $paramList]
    
    if {([regexp -nocase &#34;error&#34; $returnVal]) &amp;&amp; ($exitOnFailure)} {
	error &#34;ERROR: Task $taskName crashed...script terminating&#34;	
    } else {
	return $returnVal
    }
}


<strong><a name="::::dot1x_CheckDot1xTaskCrash_4301">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_CheckDot1xTaskCrash">::::dot1x_CheckDot1xTaskCrash</a></a></strong> {} {
    
    <a name="::dot1x_CheckTaskCrash(1)"><a href="./Dot1XLib.tcl.html#::dot1x_CheckTaskCrash_4278">::dot1x_CheckTaskCrash</a></a> &#34;tDot1xTask&#34;
}

<strong><a name="::::ixiaPortLpReboot_4306">proc <a href="Dot1XLib.tcl-annot.html#::::ixiaPortLpReboot">::::ixiaPortLpReboot</a></a></strong> {} {

global portMappingList
set ixiaPortList &#34;&#34;

foreach portList $portMappingList {
  set portId [lindex $portList 0]
  <a name="::result_debug(152)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;port is $portId&#34;
  <a name="::MapIxiaPortId(20)"><a href="./ePTPortMapping.tcl.html#::MapIxiaPortId_14">::MapIxiaPortId</a></a> $portId cha card port
  portCpu reset $cha $card $port
  lappend ixiaPortList &#34;$cha $card $port&#34;
  }
  <a name="::result_debug(153)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;ixia list is $ixiaPortList&#34;
  <a name="::ixWritePortsToHardware(2)"><a href="./mapping.tcl.html#::ixWritePortsToHardware_145">::ixWritePortsToHardware</a></a> ixiaPortList
  <a name="::exSleep(12)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 15

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ConnectRadiusMysql</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Procedure to connect to mysql radius database</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  hostIp userName password db </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: ok    - Connection ok</span>
<span class="comment-line">#              error - Connection failed</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::dot1x_ConnectRadiusMysql_4337">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ConnectRadiusMysql">::::dot1x_ConnectRadiusMysql</a></a></strong> {hostIp userName password db} {

global radius_handler
global mysqlstatus

set radius_handler [mysqlconnect -host $hostIp -user $userName -password $password]

mysqluse $radius_handler $db

if {$mysqlstatus(code) != 0} {
  puts &#34;$mysqlstatus(message)&#34;
  return &#34;error&#34;
}

return &#34;ok&#34;
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_CloseRadiusMysql</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Procedure to close to mysql handler radius database</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args:  </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::dot1x_CloseRadiusMysql_4367">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_CloseRadiusMysql">::::dot1x_CloseRadiusMysql</a></a></strong> {} {

global radius_handler

mysqlclose $radius_handler

}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_GetUserAttribute</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Procedure to get value for a given attribute from radius </span>
<span class="comment-line">#              database from radcheck table</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username and attribue (sample dot1x_GetUserAttribute abcd Password)</span>
<span class="comment-line">#             returns password of the username abcd </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: value for the given attribute</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::dot1x_GetUserAttribute_4389">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_GetUserAttribute">::::dot1x_GetUserAttribute</a></a></strong> {username attribute} {

global radius_handler
 set ret_attribute [mysqlsel $radius_handler &#34;SELECT value FROM radcheck where username = '$username' &amp;&amp; attribute = '$attribute'&#34; -flatlist]

  return $ret_attribute

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_ChgUserAttribute</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Procedure to change value for a given attribute from radius </span>
<span class="comment-line">#              database radcheck</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username, attribue and value </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_ChgUserAttribute_4409">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ChgUserAttribute">::::dot1x_ChgUserAttribute</a></a></strong> {username attribute value} {

global radius_handler
mysqlexec $radius_handler &#34;UPDATE radcheck SET value = '$value' where username = '$username' &amp;&amp; attribute = '$attribute'&#34;

if {[<a name="::dot1x_GetUserAttribute(1)"><a href="./Dot1XLib.tcl.html#::dot1x_GetUserAttribute_4389">::dot1x_GetUserAttribute</a></a> $username $attribute] != $value} {
  return &#34;error&#34;
}

return &#34;ok&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_GetReplyAttribute</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Procedure to get value for a given attribute from radius </span>
<span class="comment-line">#              database from radreply table</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username, attribue and value </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_GetReplyAttribute_4432">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_GetReplyAttribute">::::dot1x_GetReplyAttribute</a></a></strong> {username attribute} {

global radius_handler
 set ret_attribute [mysqlsel $radius_handler &#34;SELECT value FROM radreply where username = '$username' &amp;&amp; attribute = '$attribute'&#34; -flatlist]

  return $ret_attribute

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_GetReplyAttribute</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: Procedure to get value for a given attribute from radius </span>
<span class="comment-line">#              database from radreply table</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username, attribue and value </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_SetReplyAttribute_4452">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_SetReplyAttribute">::::dot1x_SetReplyAttribute</a></a></strong> {username attribute value} {

 global radius_handler
<span class="comment-line"># set present [mysqlexec $radius_handler &#34;select * from radreply where username = '$username' &amp;&amp; attribute = '$attribute'&#34; -flatlist]</span>
  set present [mysqlsel $radius_handler &#34;SELECT value FROM radreply where username = '$username' &amp;&amp; attribute = '$attribute'&#34; -flatlist]

puts &#34;present value $present&#34;
if {$present == &#34;&#34;} {
 if {$attribute == &#34;Termination-Action&#34;} {
   set op &#34;+=&#34;
 } else {
   set op &#34;:=&#34;
 }
 mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$username','$attribute', '$value','$op')&#34;

} else {
 mysqlexec $radius_handler &#34;UPDATE radreply SET value = '$value' where username = '$username' &amp;&amp; attribute = '$attribute'&#34;
}
 if {[<a name="::dot1x_GetReplyAttribute(1)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $username $attribute] != $value} {
   return &#34;error&#34;
 }

 return &#34;ok&#34;

}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_radiusChgVlanAttribute</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: dot1x_radiusChgVlanAttribute - changes value for the attribute</span>
<span class="comment-line">#              Extreme-Netlogin-Extended-Vlan in radreply table</span>
<span class="comment-line">#              if no entry is found for the username, this procedure creates</span>
<span class="comment-line">#              a new entry</span>
<span class="comment-line">#              database from radreply table</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username,  value </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::dot1x_radiusChgVlanAttribute_4494">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_radiusChgVlanAttribute">::::dot1x_radiusChgVlanAttribute</a></a></strong> {userName value} {

global radius_handler
global platformRadUsrName

<span class="comment-line">#set username $platformRadUsrName</span>

set present [mysqlsel $radius_handler &#34;select *  from radreply where username = '$userName'&#34;]

if {$present != 0} {
  mysqlexec $radius_handler &#34;DELETE from radreply where username = '$userName'&#34;
}

<span class="comment-line">#set attributeType [mysqlsel $radius_handler &#34;SELECT attribute from radreply where username = '$username'\</span>
<span class="comment-line">#                 &amp;&amp; attribute = 'Extreme-Netlogin-Extended-Vlan'&#34; -flatlist]</span>
  <span class="comment-line">#no rows insert one</span>
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName','Extreme-Netlogin-Extended-Vlan', '$value',':=')&#34;
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName','Termination-Action', '1','+=')&#34;
  if {[<a name="::dot1x_GetReplyAttribute(2)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $userName Extreme-Netlogin-Extended-Vlan] != $value &amp;&amp; \
      [<a name="::dot1x_GetReplyAttribute(3)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $userName Termination-Action] != 1} {
    return &#34;error&#34;
  } else {
    return &#34;ok&#34;
  }
<span class="comment-line">#set attribute &#34;Extreme-Netlogin-Extended-Vlan&#34;</span>
<span class="comment-line">#set returnValue [dot1x_SetReplyAttribute $useNname $attribute $value]</span>
return $returnValue
}

<span class="comment-line">#For Attribute Extreme-Netlogin-Vlan-Tag</span>
<strong><a name="::::dot1x_radiusChgTagAttribute_4526">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_radiusChgTagAttribute">::::dot1x_radiusChgTagAttribute</a></a></strong> {userName value} {

global radius_handler
global platformRadUsrName

<span class="comment-line">#set username $platformRadUsrName</span>

set present [mysqlsel $radius_handler &#34;select *  from radreply where username = '$userName'&#34;]

if {$present != 0} {
  mysqlexec $radius_handler &#34;DELETE from radreply where username = '$userName'&#34;
}

<span class="comment-line">#set attributeType [mysqlsel $radius_handler &#34;SELECT attribute from radreply where username = '$userName'\</span>
<span class="comment-line">#                 &amp;&amp; attribute = 'Extreme-Netlogin-Extended-Vlan'&#34; -flatlist]</span>
  <span class="comment-line">#no rows insert one</span>
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName','Extreme-Netlogin-Vlan-Tag', '$value',':=')&#34;
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName','Termination-Action', '1','+=')&#34;
  if {[<a name="::dot1x_GetReplyAttribute(4)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $userName Extreme-Netlogin-Vlan-Tag] != $value &amp;&amp; \
      [<a name="::dot1x_GetReplyAttribute(5)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $userName Termination-Action] != 1} {
    return &#34;error&#34;
  } else {
    return &#34;ok&#34;
  }
<span class="comment-line">#set attribute &#34;Extreme-Netlogin-Extended-Vlan&#34;</span>
<span class="comment-line">#set returnValue [dot1x_SetReplyAttribute $username $attribute $value]</span>
return $returnValue

}

<span class="comment-line">#For Attribute Extreme-Netlogin-Vlan</span>
<strong><a name="::::dot1x_radiusChgNtAttribute_4559">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_radiusChgNtAttribute">::::dot1x_radiusChgNtAttribute</a></a></strong> {userName value} {

global radius_handler
global platformRadUsrName

<span class="comment-line">#set username $platformRadUsrName</span>

set present [mysqlsel $radius_handler &#34;select *  from radreply where username = '$userName'&#34;]

if {$present != 0} {
  mysqlexec $radius_handler &#34;DELETE from radreply where username = '$userName'&#34;
}

<span class="comment-line">#set attributeType [mysqlsel $radius_handler &#34;SELECT attribute from radreply where username = '$userName'\</span>
<span class="comment-line">#                 &amp;&amp; attribute = 'Extreme-Netlogin-Extended-Vlan'&#34; -flatlist]</span>
  <span class="comment-line">#no rows insert one</span>
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName','Extreme-Netlogin-Vlan', '$value',':=')&#34;
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName','Termination-Action', '1','+=')&#34;
  if {[<a name="::dot1x_GetReplyAttribute(6)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $userName Extreme-Netlogin-Vlan] != $value &amp;&amp; \
      [<a name="::dot1x_GetReplyAttribute(7)"><a href="./Dot1XLib.tcl.html#::dot1x_GetReplyAttribute_4432">::dot1x_GetReplyAttribute</a></a> $userName Termination-Action] != 1} {
    return &#34;error&#34;
  } else {
    return &#34;ok&#34;
  }
<span class="comment-line">#set attribute &#34;Extreme-Netlogin-Extended-Vlan&#34;</span>
<span class="comment-line">#set returnValue [dot1x_SetReplyAttribute $username $attribute $value]</span>
return $returnValue

}

<strong><a name="::::dot1x_ConnectRadiusDatabase_4591">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_ConnectRadiusDatabase">::::dot1x_ConnectRadiusDatabase</a></a></strong> {} {
global Netloginv2RadiusServer

set hostIp &#34;$Netloginv2RadiusServer&#34;
set userName &#34;autotest&#34;
set password &#34;autotest&#34;
set db &#34;radius&#34;

set returnValue [<a name="::dot1x_ConnectRadiusMysql(1)"><a href="./Dot1XLib.tcl.html#::dot1x_ConnectRadiusMysql_4337">::dot1x_ConnectRadiusMysql</a></a> $hostIp $userName $password $db] 

return $returnValue
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_CreateRadiusUser</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: dot1x_CreateRadiusUser - Creates user name in </span>
<span class="comment-line">#              the necessary tables if user is not. If no username is </span>
<span class="comment-line">#              given then dafault user name md5_isp_$DUT1_IP and for</span>
<span class="comment-line">#              every user password inserted would be same as the username</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_CreateRadiusUser_4617">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_CreateRadiusUser">::::dot1x_CreateRadiusUser</a></a></strong> {args} {
global DUT1_IP
global radius_handler
global radVersion

<a name="::parse_args(12)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_CreateRadiusUser $args {
      username  &#34;&#34;
      authType &#34;EAP&#34;
   }

if {$username == &#34;&#34;} {
 set username &#34;md5_isp_$DUT1_IP&#34;
}

if { $radVersion == 0 } {
    <span class="comment-line">#for radius version &lt; 3.0</span>
    set PasswdStr &#34;Password&#34;
} else {
    set PasswdStr &#34;Cleartext-Password&#34;
}

set present [mysqlsel $radius_handler &#34;select *  from radusergroup where username = '$username'&#34;]
if {$present != 0} {
    <a name="::dot1x_DeleteRadiusUser(1)"><a href="./Dot1XLib.tcl.html#::dot1x_DeleteRadiusUser_4675">::dot1x_DeleteRadiusUser</a></a> -username $username
    set present 0
}

if {$present == 0} {
puts &#34;Adding radius user $username&#34;
mysqlexec $radius_handler &#34;INSERT into radusergroup (username, groupname) VALUES ('$username', 'sup')&#34;

mysqlexec $radius_handler &#34;INSERT into radcheck (username,attribute,value,op) VALUES ('$username',\
                           '$PasswdStr', '$username',':=')&#34;

if {$radVersion == 0} {
mysqlexec $radius_handler &#34;INSERT into radcheck (username,attribute,value,op) VALUES ('$username',\
                           'Auth-Type', '$authType',':=')&#34;
}
set value [<a name="::dot1x_GetUserAttribute(2)"><a href="./Dot1XLib.tcl.html#::dot1x_GetUserAttribute_4389">::dot1x_GetUserAttribute</a></a> $username &#34;$PasswdStr&#34;]

if {$value != $username} {
  return &#34;error&#34;
}
set value [<a name="::dot1x_GetUserAttribute(3)"><a href="./Dot1XLib.tcl.html#::dot1x_GetUserAttribute_4389">::dot1x_GetUserAttribute</a></a> $username &#34;Auth-Type&#34;]
if {$value != $authType} {
  return &#34;error&#34;
}
}
return &#34;ok&#34;

}

<span class="comment-line">##################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::dot1x_DeleteRadiusUser_4675">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_DeleteRadiusUser">::::dot1x_DeleteRadiusUser</a></a></strong> {args} {
    global DUT1_IP
    global radius_handler
    global radVersion

    <a name="::parse_args(13)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_DeleteRadiusUser $args {
          username  &#34;&#34;
    }
    puts &#34;Delete radius user $username&#34;
    if {$username == &#34;&#34;} {
        set username &#34;md5_isp_$DUT1_IP&#34;
    }

    set present [mysqlsel $radius_handler &#34;select *  from radusergroup where username = '$username'&#34;]


    if {$present != 0} {
        puts &#34;Radius found and deleting $username&#34;
        mysqlexec $radius_handler &#34;DELETE FROM radusergroup WHERE username = '$username'&#34;
        mysqlexec $radius_handler &#34;DELETE FROM radcheck WHERE username = '$username'&#34;
        mysqlexec $radius_handler &#34;DELETE FROM radreply WHERE username = '$username'&#34;;
    }
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: dot1x_deleteAllReplyAttribute</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: dot1x_deleteAllReplyAttribute </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: username </span>
<span class="comment-line">#</span>
<span class="comment-line"># Output args: error = unsuccess set; ok - successful set</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::dot1x_deleteAllReplyAttribute_4711">proc <a href="Dot1XLib.tcl-annot.html#::::dot1x_deleteAllReplyAttribute">::::dot1x_deleteAllReplyAttribute</a></a></strong> {args} {
global DUT1_IP
global radius_handler

<a name="::parse_args(14)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> dot1x_deleteAllReplyAttribute $args {
      username  &#34;&#34;
   }

if {$username == &#34;&#34;} {
  return &#34;error&#34;
}


set present [mysqlsel $radius_handler &#34;select *  from radreply where username = '$username'&#34;]


if {$present == 0} {
  return &#34;notPresent&#34;
}

mysqlexec $radius_handler &#34;delete  from  radreply where username = '$username'&#34;;

return &#34;ok&#34;

}

<strong><a name="::::Mac_radiusChguserAttribute_4737">proc <a href="Dot1XLib.tcl-annot.html#::::Mac_radiusChguserAttribute">::::Mac_radiusChguserAttribute</a></a></strong> {userName attr value} {

global radius_handler
global platformRadUsrName


<span class="comment-line">#set username $platformRadUsrName</span>

set present [mysqlsel $radius_handler &#34;select *  from radreply where username = '$userName'&#34;]

if {$present != 0} {
  mysqlexec $radius_handler &#34;DELETE from radreply where username = '$userName'&#34;
}

  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName', '$attr' , '$value',':=')&#34;

  if {[<a name="::Mac_GetReplyAttribute(1)"><a href="./Dot1XLib.tcl.html#::Mac_GetReplyAttribute_4762">::Mac_GetReplyAttribute</a></a> $userName $attr] != $value } {
    return &#34;error&#34;
  } else {
    return &#34;ok&#34;
  }
return $returnValue

}
<strong><a name="::::Mac_GetReplyAttribute_4762">proc <a href="Dot1XLib.tcl-annot.html#::::Mac_GetReplyAttribute">::::Mac_GetReplyAttribute</a></a></strong> {username attribute} {

global radius_handler
 set ret_attribute [mysqlsel $radius_handler &#34;SELECT value FROM radreply where username = '$username' &amp;&amp; attribute = '$attribute'&#34; -flatlist]

  return $ret_attribute

}

<strong><a name="::::Mac_radiusSetuserAttribute_4771">proc <a href="Dot1XLib.tcl-annot.html#::::Mac_radiusSetuserAttribute">::::Mac_radiusSetuserAttribute</a></a></strong> {userName attr value} {

global radius_handler
global platformRadUsrName


<span class="comment-line">#set username $platformRadUsrName</span>
  mysqlexec $radius_handler &#34;INSERT into radreply (username, attribute, value, op) VALUES \
        ('$userName', '$attr' , '$value',':=')&#34;

  if {[<a name="::Mac_GetReplyAttribute(2)"><a href="./Dot1XLib.tcl.html#::Mac_GetReplyAttribute_4762">::Mac_GetReplyAttribute</a></a> $userName $attr] != $value } {
    return &#34;error&#34;
  } else {
    return &#34;ok&#34;
  }
return $returnValue

}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
