<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>email.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#email.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>email.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="email.tcl-annot.html">annotations</a> | <a href="email.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">

<span class="comment-line"># email.tcl</span>
<span class="comment-line"># EMail 1.7 package       Evan Rempel  erempel@uvic.ca</span>

package provide EMail 1.7

<strong>namespace eval  ::EMail::</strong>  {

  variable Version 1.7

  <span class="comment-line"># --- if this is 1, trace messages will be displayed to the std out.</span>
  variable debug 1

  namespace export Init Send Wait Query GetError Addresses InvalidAddresses Discard

  <span class="comment-line"># --- status of each e-mail connection</span>
  variable EMailTokenState
  array set EMailTokenState {}

  <span class="comment-line"># --- Wait flags.</span>
  variable EMailWaitFlags
  array set EMailWaitFlags {Any 0}
  variable EMailCompleteList {}

  <span class="comment-line"># --- sequential counter to create unique tokens</span>
  variable EMailID 0

  <span class="comment-line"># --- e-mail address to use in the from field of outgoing e-mail</span>
  variable EMailFromAddress &#34;&#34;
  variable EMailHost &#34;&#34;
  variable EMailGateWay &#34;&#34;

}

<span class="comment-line"># set this to 1 if the Trf package is available.</span>
<span class="comment-line"># If set to 0, attachments can not be sent</span>
set ::EMail::enableAttachments 1

<span class="comment-line"># cooper comment out</span>
<span class="comment-line">#if {$::EMail::enableAttachments} then {</span>
<span class="comment-line"># package require Trf 2.0</span>
<span class="comment-line">#}</span>

<span class="comment-line"># ------------------------------------------------- EMail::Init ----</span>
<span class="comment-line"># Setup the from address and the host computer name that the</span>
<span class="comment-line"># e-mail is being sent from. The host computer is used in the</span>
<span class="comment-line"># HELO command.</span>
<strong><a name="::EMail::Init_48">proc <a href="email.tcl-annot.html#::EMail::Init">::EMail::Init</a></a></strong><a name="::EMail::Init"></a> { address host gateway } {
  variable EMailFromAddress
  variable EMailHost
  variable EMailGateWay

  set EMailFromAddress $address
  set EMailHost $host
  set EMailGateWay $gateway
}

<span class="comment-line"># --------------------------------------------------- EMail::Token ----</span>
<span class="comment-line"># internal routine</span>
<span class="comment-line"># Return the next unique TimeToken</span>
<strong><a name="::EMail::Token_61">proc <a href="email.tcl-annot.html#::EMail::Token">::EMail::Token</a></a></strong><a name="::EMail::Token"></a> {} {
  variable EMailID

  return &#34;[namespace current]::[incr EMailID]&#34;
}


<span class="comment-line"># ------------------------------------------------- EMail::Finish ----</span>
<strong><a name="::EMail::Finish_69">proc <a href="email.tcl-annot.html#::EMail::Finish">::EMail::Finish</a></a></strong><a name="::EMail::Finish"></a> { token {errormsg &#34;&#34;} } {
  variable debug
  variable $token
  upvar 0 $token state
  variable EMailWaitFlags
  variable EMailCompleteList

  global errorInfo errorCode

  if {$debug} then {
    puts &#34;Finish: $token&#34;
  }
  if {[string length $errormsg] != 0} {
    set state(error) [list $errormsg]
    set state(Status) error
  }
  catch {close $state(sock)}
  catch {after cancel $state(after)}
  catch {after cancel $state(afteropen)}
  if {[info exist state(-command)] &amp;&amp; ($state(-command) != &#34;&#34;)} {
    if {[catch {eval $state(-command) {$token}} err]} {
      if {[string length $errormsg] == 0} {
        set state(error) [list $err $errorInfo $errorCode]
        set state(Status) error
      }
    }
    unset state(-command)
  }
  set EMailWaitFlags($token) 1
  set EMailWaitFlags(Any) 1
  lappend EMailCompleteList $token
}

<span class="comment-line"># ------------------------------------------------- EMail::Reset ----</span>
<strong><a name="::EMail::Reset_103">proc <a href="email.tcl-annot.html#::EMail::Reset">::EMail::Reset</a></a></strong><a name="::EMail::Reset"></a> { token {why Reset} } {
  variable debug
  variable $token
  upvar 0 $token state

  set state(Status) error
  catch {fileevent $state(sock) readable {}}
  catch {fileevent $state(sock) writable {}}
  Finish $token $why
}

<span class="comment-line"># ----------------------------------------- EMail::Continue ----</span>
<strong><a name="::EMail::Continue_115">proc <a href="email.tcl-annot.html#::EMail::Continue">::EMail::Continue</a></a></strong><a name="::EMail::Continue"></a> { token index args } {
  variable $token
  upvar 0 $token state

  if {[llength $args] &gt; 0} then {
    foreach handle $args {
      catch {fileevent $state(sock) $handle {}}
    }
  }
  switch $index {
    &#34;afteropen&#34; {
      set state(Status) open
      catch {after cancel $state(afteropen)}
    }
  }
}

<span class="comment-line"># ------------------------------------------------- EMail::Event ----</span>
 <strong><a name="::EMail::Event_133">proc <a href="email.tcl-annot.html#::EMail::Event">::EMail::Event</a></a></strong><a name="::EMail::Event"></a> {token} {
  variable debug
  variable $token
  upvar 0 $token state
  global tcl_patchLevel

  if [::eof $state(sock)] then {
    Reset $token terminated
    return
  }
  set n [gets $state(sock) line]
  if {$debug} then {
    puts &#34;Event: $line&#34;
  }
  <span class="comment-line"># --- if a line was read</span>
  if {$n &gt;= 0} then {
    set ReceiveCode &#34;[string range $line 0 [expr [string length $state(GoodCode)] - 1]]&#34;
    if {$ReceiveCode == &#34;$state(GoodCode)&#34;} then {
      set Process Good
    } else {
      if {$debug} then {
        puts &#34;Event: Expected $state(GoodCode) but got $ReceiveCode&#34;
      }
      set Process Bad
    }
    switch $state(Status) {
      &#34;opening&#34; -
      &#34;open&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          Reset $token &#34;Opening: $line&#34;
        } else {
          puts $state(sock) &#34;HELO $state(EMailHost)&#34;
          set state(Status) helo
          if {$debug} then {
            puts &#34;Event: Status now $state(Status)&#34;
          }
          set state(GoodCode) &#34;250&#34;
          flush $state(sock)
        }
      }
      &#34;helo&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          Reset $token &#34;HELO: $line&#34;
        } else {
          puts $state(sock) &#34;MAIL FROM: &lt;$state(EMailFrom)&gt;&#34;
          set state(Status) from
          if {$debug} then {
            puts &#34;Event: Status now $state(Status)&#34;
          }
          set state(GoodCode) &#34;250&#34;
          flush $state(sock)
        }
      }
      &#34;from&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          Reset $token &#34;MAIL FROM: $line&#34;
        } else {
          puts $state(sock) &#34;RCPT TO: &lt;[lindex $state(RCPT) 0]&gt;&#34;
          flush stdout
          set state(Status) rcpt
          if {$debug} then {
            puts &#34;Event: Status now $state(Status)&#34;
            puts &#34;Event: RCPT &lt;[lindex $state(RCPT) 0]&gt;&#34;
          }
          set state(GoodCode) &#34;250&#34;
          set state(rcptIndex) 0
          set state(RCPTCount) 0
          flush $state(sock)
        }
      }
      &#34;rcpt&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          lappend state(BadList) [lindex $state(RCPT) $state(rcptIndex)]
        } else {
          incr state(RCPTCount)
        }
        <span class="comment-line"># --- are there more recipients</span>
        if {[incr state(rcptIndex)] &lt; [llength $state(RCPT)]} then {
          puts $state(sock) &#34;RCPT TO: &lt;[lindex $state(RCPT) $state(rcptIndex)]&gt;&#34;
          if {$debug} then {
            puts &#34;Event: RCPT &lt;[lindex $state(RCPT) 0]&gt;&#34;
          }
          set state(Status) rcpt
          set state(GoodCode) &#34;250&#34;
          flush $state(sock)
        } else {
          <span class="comment-line"># --- check for at least one valid recipient</span>
          if {$state(RCPTCount) == 0} then {
            puts $state(sock) &#34;QUIT&#34;
            set state(Status) complete
            if {$debug} then {
              puts &#34;Event: Status now $state(Status)&#34;
            }
            set state(GoodCode) &#34;221&#34;
            flush $state(sock)
          } else {
            puts $state(sock) &#34;DATA&#34;
            set state(Status) data
            if {$debug} then {
              puts &#34;Event: Status now $state(Status)&#34;
            }
            set state(GoodCode) &#34;354&#34;
            flush $state(sock)
          }
        }
      }
      &#34;data&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          Reset $token &#34;DATA: $line&#34;
        } else {
          puts -nonewline $state(sock) &#34;$state(Headers)&#34;
          if {[llength $state(-files)] &gt; 0} then {
            set state(Boundry) &#34;[clock seconds]-[clock clicks]-$tcl_patchLevel-[expr rand()]&#34;
            puts $state(sock) &#34;MIME-Version: 1.0&#34;
            puts $state(sock) &#34;Content-Type: MULTIPART/MIXED; BOUNDARY=\&#34;$state(Boundry)\&#34;\n&#34;
            puts $state(sock) &#34;--$state(Boundry)&#34;
            puts $state(sock) &#34;Content-Type: TEXT/PLAIN; charset=US-ASCII\n&#34;
            puts $state(sock) &#34;$state(Message)\n&#34;
            foreach file $state(-files) {
              if {! [catch {set fHandle [open &#34;$file&#34; &#34;r&#34;]} msg]} then {
                puts $state(sock) &#34;--$state(Boundry)&#34;
                puts $state(sock) &#34;Content-Type: text/plain&#34;
                puts $state(sock) &#34;Content-Disposition: attachment; filename=\&#34;[file tail $file]\&#34;&#34;
                puts $state(sock) &#34;&#34;

               while {[gets $fHandle line] != -1} {
                  puts $state(sock) $line
               }
               if {$debug} then {
                  puts &#34;Attachment: $file ([file size &#34;$file&#34;])&#34;
               }
                <span class="comment-line">#base64 -mode encode -in $fHandle -out $state(sock)</span>
                close $fHandle
              } else {
                if {$debug} then {
                  puts &#34;** Attachment fail: $file&#34;
                }
              }
            }      
            puts $state(sock) &#34;--$state(Boundry)--\n&#34;
          } else {
            puts $state(sock) &#34;\n$state(Message)\n&#34;
          }
          set state(Status) quiting
          if {$debug} then {
            puts &#34;Event: Status now $state(Status)&#34;
          }
          set state(GoodCode) &#34;250&#34;
          puts $state(sock) &#34;.&#34;
          flush $state(sock)
        }
      }
      &#34;quiting&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          Reset $token &#34;.: $line&#34;
        } else {
          puts $state(sock) &#34;QUIT&#34;
          set state(Status) complete
          if {$debug} then {
            puts &#34;Event: Status now $state(Status)&#34;
          }
          set state(GoodCode) &#34;221&#34;
          flush $state(sock)
          <span class="comment-line"># if do not want to wait for the SMTP server to acknowlege</span>
          <span class="comment-line"># the quit command, finish the connection.</span>
          <span class="comment-line"># NOTE: this does not comply with RFC 821</span>
          if {$state(-waitquit) == 0} then {
            Finish $token
          }
        }
      }
      &#34;complete&#34; {
        if {&#34;$Process&#34; == &#34;Bad&#34;} then {
          Reset $token &#34;QUIT: $line&#34;
        } else {
          Finish $token
        }
      }
    }
  }
}

<span class="comment-line"># ------------------------------------------------- EMail::Send ----</span>
<span class="comment-line"># EMail::Send ToList CCList BCCList Subject Message options</span>
<span class="comment-line">#   Send the </span>
<strong><a name="::EMail::Send_318">proc <a href="email.tcl-annot.html#::EMail::Send">::EMail::Send</a></a></strong><a name="::EMail::Send"></a> { ToList CCList BCCList Subject Message args } {
  variable Version
  variable debug
  variable enableAttachments
  variable EMailFromAddress
  variable EMailHost
  variable EMailGateWay

  set token [<a name="::EMail::Token(1)"><a href="./email.tcl.html#::EMail::Token_61">::EMail::Token</a></a>]
  variable $token
  upvar 0 $token state

  array set state {
    -connectwait     0
    -timeout         0
    -blocksize       1024
    -files           &#34;&#34;
    -waitquit        1
    error            &#34;&#34;
    RCPT             &#34;&#34;
    Message          &#34;&#34;
    GoodCode         &#34;220&#34;
    Status           &#34;new&#34;
    BadList          &#34;&#34;
    Boundry          &#34;&#34;
  }
  set state(EMailHost)     $EMailHost
  set state(EMailFrom)     $EMailFromAddress


  set options {-command -connectwait -timeout -waitquit}
  if {$enableAttachments} then {
    lappend options -files
  }
  set usage [join $options &#34;, &#34;]
  regsub -all -- - $options {} options
  set pat ^-([join $options |])$
  foreach {flag value} $args {
    if [regexp $pat $flag] {
      <span class="comment-line"># Validate numbers</span>
      if {[info exists state($flag)] &amp;&amp; \
          [regexp {^[0-9]+$} $state($flag)] &amp;&amp; \
          ![regexp {^[0-9]+$} $value]} {
        return -code error &#34;Bad value for $flag ($value), must be integer&#34;
      }
      set state($flag) $value
    } else {
      return -code error &#34;Unknown option $flag, can be: $usage&#34;
    }
  }

  <span class="comment-line"># --- create the entire recipient list</span>
  set state(RCPT) &#34;&#34;
  if {[llength $ToList] &gt; 0} then {
    set state(RCPT) [concat $state(RCPT) $ToList]
  }
  if {[llength $CCList] &gt; 0} then {
    set state(RCPT) [concat $state(RCPT) $CCList]
  }
  if {[llength $BCCList] &gt; 0} then {
    set state(RCPT) [concat $state(RCPT) $BCCList]
  }

  <span class="comment-line"># --- assemble the visible destination headers</span>
  set To &#34;&#34;
  set count 0
  foreach rcpt $ToList {
    incr count
    if {$count &lt;= 1} then {
      append To &#34;To: $rcpt&#34;
    } else {
      append To &#34;,\n    $rcpt&#34;
    }
  }
  set CCTo &#34;&#34;
  set count 0
  foreach rcpt $CCList {
    incr count
    if {$count &lt;= 1} then {
      append CCTo &#34;CC: $rcpt&#34;
    } else {
      append CCTo &#34;,\n    $rcpt&#34;
    }
  }

  <span class="comment-line"># --- assemble the visible headers</span>
  set Headers &#34;&#34;
  append Headers &#34;X-Mailer: TCL EMail Library $Version\n&#34;
  if {[string length $To] &gt; 0} then {
    append Headers &#34;$To\n&#34;
  }
  if {[string length $CCTo] &gt; 0} then {
   append Headers &#34;$CCTo\n&#34;
  }
  append Headers &#34;From: $EMailFromAddress\n&#34;
  append Headers &#34;Subject: $Subject\n&#34;
  set state(Headers) &#34;$Headers&#34;

  <span class="comment-line"># --- place the message into the token state variable</span>
  set state(Message) &#34;$Message&#34;

  <span class="comment-line"># --- open up the connection</span>
  if {[catch {set state(sock) [socket -async $EMailGateWay 25]} msg]} then {
    <a name="::EMail::Reset(1)"><a href="./email.tcl.html#::EMail::Reset_103">::EMail::Reset</a></a> $token connectwait
  } else {

    <span class="comment-line"># --- start the connection timer</span>
    if {$state(-connectwait) &gt; 0} {
      set state(afteropen) [after $state(-connectwait) [list EMail::Reset $token connectwait]]
      fileevent $state(sock) writable [list EMail::Continue $token afteropen writable]
    }

    <span class="comment-line"># start the processing timer</span>
    if {$state(-timeout) &gt; 0} {
      set state(after) [after $state(-timeout) [list EMail::Reset $token timeout]]
    }
  
    <span class="comment-line"># Send data in cr-lf format, but accept any line terminators</span>
  
    fconfigure $state(sock) -translation {auto crlf} -buffersize $state(-blocksize)
  
    <span class="comment-line"># The following is disallowed in safe interpreters, but the socket</span>
    <span class="comment-line"># is already in non-blocking mode in that case.</span>
  
    catch {fconfigure $state(sock) -blocking off}
    set state(Status)      &#34;opening&#34;
    set state(GoodCode)   &#34;220&#34;
    fileevent $state(sock) readable [list EMail::Event $token]
  
    if {! [info exists state(-command)]} {
      Wait $token
    }
  }
  return $token
}


<span class="comment-line"># ----------------------------------------------------- EMail::Wait ---</span>
<span class="comment-line"># EMail::Wait  (EMailToken | Any)</span>
<span class="comment-line">#   Wait for the specified email interaction to complete.</span>
<span class="comment-line">#   If argument is Any, return as soon as any single one completes</span>
<span class="comment-line">#   If the specified e-mail transaction has already completed, this</span>
<span class="comment-line">#   routine returns immediately</span>
<span class="comment-line">#   Returns the EMailToken of the completed transaction</span>
<span class="comment-line">#</span>
<span class="comment-line"># WARNING: It is possible to use a -command callback to process e</span>
<span class="comment-line">#   completed mail token. Then use the &#34;Wait Any&#34; command to retieve the</span>
<span class="comment-line">#   same mail token and attempt to process it again. When using a call</span>
<span class="comment-line">#   back to process completed mail tokens, you should call the Discard routine</span>
<span class="comment-line">#   prior to attempting to use the Wait Any routine.</span>

<strong><a name="::EMail::Wait_469">proc <a href="email.tcl-annot.html#::EMail::Wait">::EMail::Wait</a></a></strong><a name="::EMail::Wait"></a> { EMailToken } {
  variable debug
  variable EMailWaitFlags
  variable EMailCompleteList

  if {(&#34;$EMailToken&#34; == &#34;Any&#34;)} {
    if {[llength $EMailCompleteList] == 0} {
      if {$debug} then {
        puts &#34;Wait: Waiting for Any&#34;
      }
      vwait EMail::EMailWaitFlags(Any)
    }
    set EMailTemp [lindex $EMailCompleteList 0]
    set EMailCompleteList [lrange $EMailCompleteList 1 end]
    return $EMailTemp      
  } else {
    if {(![info exist EMailWaitFlags($EMailToken)]) || ($EMailWaitFlags($EMailToken) != 1)} {
      if {$debug} then {
        puts &#34;Wait: Waiting for $EMailToken&#34;
      }
      vwait EMail::EMailWaitFlags($EMailToken)
    }
    set EMailTemp [lsearch -exact $EMailCompleteList $EMailToken]
    if {$EMailTemp != -1} then {
      set EMailCompleteList [lreplace $EMailCompleteList $EMailTemp $EMailTemp]
    }
    return $EMailToken
  }
}

<span class="comment-line"># ---------------------------------------------------- EMail::Query ---</span>
<span class="comment-line">#  EMail::Query     Token </span>
<span class="comment-line">#</span>
<strong><a name="::EMail::Query_502">proc <a href="email.tcl-annot.html#::EMail::Query">::EMail::Query</a></a></strong><a name="::EMail::Query"></a> { token } {
  variable $token
  upvar 0 $token state

  if {[info exist state]} then {
    return $state(Status)
  } else {
    return unknown
  }
}

<span class="comment-line"># ---------------------------------------------------- EMail::Addresses ---</span>
<span class="comment-line">#  EMail::Addresses     Token </span>
<span class="comment-line">#</span>
<strong><a name="::EMail::Addresses_516">proc <a href="email.tcl-annot.html#::EMail::Addresses">::EMail::Addresses</a></a></strong><a name="::EMail::Addresses"></a> { token } {
  variable $token
  upvar 0 $token state

  if {[info exist state] &amp;&amp; [info exist state(RCPT)]} then {
    return $state(RCPT)
  } else {
    return &#34;&#34;
  }
}

<span class="comment-line"># ---------------------------------------------------- EMail::InvalidAddresses ---</span>
<span class="comment-line">#  EMail::InvalidAddresses     Token </span>
<span class="comment-line">#</span>
<strong><a name="::EMail::InvalidAddresses_530">proc <a href="email.tcl-annot.html#::EMail::InvalidAddresses">::EMail::InvalidAddresses</a></a></strong><a name="::EMail::InvalidAddresses"></a> { token } {
  variable $token
  upvar 0 $token state

  if {[info exist state] &amp;&amp; [info exist state(BadList)]} then {
    return $state(BadList)
  } else {
    return &#34;&#34;
  }
}

<span class="comment-line"># ---------------------------------------------------- EMail::GetError ---</span>
<span class="comment-line">#  EMail::GetError     Token </span>
<span class="comment-line">#</span>
<strong><a name="::EMail::GetError_544">proc <a href="email.tcl-annot.html#::EMail::GetError">::EMail::GetError</a></a></strong><a name="::EMail::GetError"></a> { token } {
  variable $token
  upvar 0 $token state

  if {[info exist state]} then {
    return $state(error)
  } else {
    return unknown
  }
}

<span class="comment-line"># ---------------------------------------------------- EMail::Discard ---</span>
<span class="comment-line">#  EMail::Discard     Token </span>
<span class="comment-line">#</span>
<strong><a name="::EMail::Discard_558">proc <a href="email.tcl-annot.html#::EMail::Discard">::EMail::Discard</a></a></strong><a name="::EMail::Discard"></a> { token } {
  variable EMailWaitFlags
  variable EMailCompleteList
  variable $token
  upvar 0 $token state

  if {[info exist state]} then {
    catch {close $state(sock)}
    catch {after cancel $state(after)}
    catch {after cancel $state(afteropen)}
    if {[info exist EMailWaitFlags($token)] &amp;&amp; ($EMailWaitFlags($token) &gt; 0)} then {
      incr EMailWaitFlags(Any) -1
    }
    catch {unset state}
    set EMailTemp [lsearch -exact $EMailCompleteList $token]
    if {$EMailTemp != -1} then {
      set EMailCompleteList [lreplace $EMailCompleteList $EMailTemp $EMailTemp]
    }
    return 0
  } else {
    return unknown
  }
}

<span class="comment-line">#           from address                machinename   smtp hostname</span>
<span class="comment-line">#EMail::Init ecooper@extremenetworks.com cooper5       smtp2</span>

<span class="comment-line">#           to address                  cc bcc subject msg      attachments</span>
<span class="comment-line">#EMail::Send ecooper@extremenetworks.com &#34;&#34; &#34;&#34;  Subject Message -files &#34;d:/test.tcl d:/test2.tcl&#34;</span>

<span class="comment-line">#http://web.uvic.ca/~erempel/tcl/Email/Email.html</span>
<span class="comment-line">#http://www.dpo.uab.edu/Email/attach.html</span>
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
