<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>ePTUtils.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#ePTUtils.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>ePTUtils.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="ePTUtils.tcl-annot.html">annotations</a> | <a href="ePTUtils.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<strong><a name="::::globalSetDefault_1">proc <a href="ePTUtils.tcl-annot.html#::::globalSetDefault">::::globalSetDefault</a></a></strong> {} {
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: incrHostIpAddr</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Increments the host portion of the IP address</span>
<span class="comment-line">#              NOTE:  will carry!!</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   ipAddress      - ip address to increment</span>
<span class="comment-line">#   amount         - amount to increment by</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::incrHostIpAddr_14">proc <a href="ePTUtils.tcl-annot.html#::::incrHostIpAddr">::::incrHostIpAddr</a></a></strong> {ipAddress {amount 1}} \
{
    return [<a name="::incrIpField(1)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipAddress 4 $amount]
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: lnumsort</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command sorts a list (like ports) into numerical order</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#       option        -decending</span>
<span class="comment-line">#       MyList        list of stuff</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::lnumsort_30">proc <a href="ePTUtils.tcl-annot.html#::::lnumsort">::::lnumsort</a></a></strong> {option {MyList &#34;&#34;}} \
{
    if {[string index [lindex $option 0] 0] != &#34;-&#34;} {
        set MyList  $option
        set sortedList  [lsort -dictionary $MyList]
    } else {
        set sortedList  [lsort -dictionary $option $MyList]
    }

    return $sortedList
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: mergeLists</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command merges two lists</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   MergedList  - returned merged list w/dups removed</span>
<span class="comment-line">#   args        - variable number of lists to be merged together</span>
<span class="comment-line">#   &lt;sortedOrder - return list in sorted order, default is no sort&gt;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return values:</span>
<span class="comment-line">#   If there are duplicate items in the list, returns number of dups, otherwise</span>
<span class="comment-line">#   returns 0</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::mergeLists_58">proc <a href="ePTUtils.tcl-annot.html#::::mergeLists">::::mergeLists</a></a></strong> {MergedList args} \
{
    upvar $MergedList   mergedList

    set mergedList  &#34;&#34;
    set sortFlag    0
    set duplicate   0

    foreach list $args {
        if {$list == &#34;sortedOrder&#34;} {
            set sortFlag    1
            continue
        }
        foreach item $list {
            if {[lsearch $mergedList $item] &gt;= 0} {
                incr duplicate
            } else {
                lappend mergedList $item
            }
        }
    }

    if {$sortFlag} {
        set mergedList  [<a name="::lnumsort(1)"><a href="./ePTUtils.tcl.html#::lnumsort_30">::lnumsort</a></a> $mergedList]
    }

    return $duplicate
}



<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:    host2addr</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  This command converts an IP address in form 100.101.102.103 </span>
<span class="comment-line">#               to a list of hex bytes all in upper case letters.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s): ipAddr: ip address to convert</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return(s):    IP address in list of hex bytes</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::host2addr_100">proc <a href="ePTUtils.tcl-annot.html#::::host2addr">::::host2addr</a></a></strong> {ipAddr} \
{
    set ipHex        {}

    set delimiter .
    regexp {([:.])} $ipAddr match delimiter

    set protocol [expr [string match $delimiter :]?&#34;ipV6&#34;:&#34;ip&#34;]

    switch $protocol {
        <a name="::ipV6(1)"><a href="./ePTClient.tcl.html#::ipV6_1593">::ipV6</a></a> {
            set ipHex [ipv6::host2addr $ipAddr]
        }
        <a name="::ip(1)"><a href="./ePTClient.tcl.html#::ip_974">::ip</a></a> {
            set ipname [split $ipAddr $delimiter]
            if {[llength [string trim [join $ipname]]] == 4} {
                foreach i $ipname {
                    if {$i &gt; 255 || $i &lt; 0} {
                        set ipHex {}
                        break
                    }
                    set hexCharacter [format &#34;%02X&#34; $i]
                    set ipHex [linsert $ipHex end $hexCharacter]
                }
            }
        }
    }

    return $ipHex
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:    long2IpAddr</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description   Converts long word into an IP address in </span>
<span class="comment-line">#                   form x.y.z.a</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):  longword to convert</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Ip Address x.y.z.a OR </span>
<span class="comment-line">#               0.0.0.0 if invalid input arguments</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::long2IpAddr_144">proc <a href="ePTUtils.tcl-annot.html#::::long2IpAddr">::::long2IpAddr</a></a></strong> {value} \
{
    if [catch {set ipAddress &#34;[expr {(($value &gt;&gt; 24) &amp; 0xff)}].[expr {(($value &gt;&gt; 16) &amp; 0xff)}].[expr {(($value &gt;&gt; 8 ) &amp; 0xff)}].[expr {$value &amp; 0xff}]&#34;} ipAddress] {
        set ipAddress 0.0.0.0
    }

    return $ipAddress
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:    byte2IpAddr</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description   Converts 4 hexideciaml bytes into an IP address in </span>
<span class="comment-line">#                   form x.y.z.a</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):  hexBytes:   list of bytes to convert</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      Ip Address x.y.z.a OR </span>
<span class="comment-line">#               0.0.0.0 if invalid input arguments</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::byte2IpAddr_166">proc <a href="ePTUtils.tcl-annot.html#::::byte2IpAddr">::::byte2IpAddr</a></a></strong> {hexBytes} \
{
    set newIpAddr       &#34;0.0.0.0&#34;

    <span class="comment-line"># Validate input parameters.</span>

    <span class="comment-line"># If given a string of 8 bytes instead of list of 4, convert it to a list.</span>
    set hexBytes       [string trim $hexBytes]
    set hexBytesLength  [llength $hexBytes]

    if {$hexBytesLength == 1} {

        if {[string length [string trim $hexBytes]] == 8} {

            set hexBytesString  $hexBytes
            set hexBytes [list]
            for {set i 0} {$i &lt; 4} {incr i} {
                lappend hexBytes   [string range   $hexBytesString 0 1]
                set hexBytesString [string replace $hexBytesString 0 1]
            }

        } else {
            set hexBytes [list 0 0 0 0]
        }

    } elseif {$hexBytesLength != 4} {
        set hexBytes [list 0 0 0 0]
    }


    <span class="comment-line"># Convert to decimal.</span>
    regsub -all {(.*) (.*) (.*) (.*)} $hexBytes \
        {[format &#34;%d %d %d %d&#34; &#34;0x\1&#34; &#34;0x\2&#34; &#34;0x\3&#34; &#34;0x\4&#34;]} newIpAddr
    if {[catch {subst $newIpAddr} newIpAddr]} {
        set newIpAddr [list 0 0 0 0]
    }

    <span class="comment-line"># If any invalid values, return 0.0.0.0</span>
    foreach byte $newIpAddr {
        if {$byte &lt; 0 || $byte &gt; 255} {
            set newIpAddr [list 0 0 0 0]
            break
        }
    }
    set newIpAddr [join $newIpAddr .]

    puts &#34;byte2IpAddr: newIpAddr = $newIpAddr&#34;
    return $newIpAddr
}




<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: num2ip</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:</span>
<span class="comment-line">#   This command convert a number to an IP address.</span>
<span class="comment-line"># </span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   num - number</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns: </span>
<span class="comment-line">#   An IP address.</span>
<span class="comment-line">#             </span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::num2ip_232">proc <a href="ePTUtils.tcl-annot.html#::::num2ip">::::num2ip</a></a></strong> {num} \
{
    set ipAddr [format &#34;%d.%d.%d.%d&#34; [expr {($num &gt;&gt; 24) &amp; 255}] [expr {($num &gt;&gt; 16) &amp; 255}] \
                                     [expr {($num &gt;&gt;  8) &amp; 255}] [expr { $num        &amp; 255}]]
    return $ipAddr
}



<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: ip2num</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command converts an IP address of the form d.d.d.d into a 32-bit</span>
<span class="comment-line"># unsigned number.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#   ipAddr      - ip address of the form d.d.d.d</span>
<span class="comment-line">#</span>
<span class="comment-line"># Return:</span>
<span class="comment-line">#   ipNum</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::ip2num_254">proc <a href="ePTUtils.tcl-annot.html#::::ip2num">::::ip2num</a></a></strong> {ipAddr} \
{
    set ipNum   0

    if {[scan $ipAddr &#34;%d.%d.%d.%d&#34; a b c d] == 4} {
        set ipNum   [format %u [expr {($a&lt;&lt;24)|($b&lt;&lt;16)|($c&lt;&lt;8)|$d}]]
    }

    return $ipNum
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: long2octet</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command converts a multi-byte number into multi octets in a list</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#       value           the value to convert</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::long2octet_275">proc <a href="ePTUtils.tcl-annot.html#::::long2octet">::::long2octet</a></a></strong> {value {sizeInBytes 2} } \
{

    switch $sizeInBytes {
            2 {
                return  [format &#34;%02x %02x&#34; \
                                    [expr {(($value &gt;&gt; 8) &amp; 0xff)}]   \
                                    [expr   {$value &amp; 0xff}]]
            }
            3 {
                return  [format &#34;%02x %02x %02x&#34; \
                                    [expr {(($value &gt;&gt; 16) &amp; 0xff)}]  \
                                    [expr {(($value &gt;&gt; 8 ) &amp; 0xff)}]  \
                                    [expr   {$value &amp; 0xff}]]
            }
            4 {
                return  [format &#34;%02x %02x %02x %02x&#34; \
                                    [expr {(($value &gt;&gt; 24) &amp; 0xff)}]  \
                                    [expr {(($value &gt;&gt; 16) &amp; 0xff)}]  \
                                    [expr {(($value &gt;&gt; 8 ) &amp; 0xff)}]  \
                                    [expr   {$value &amp; 0xff}]]     
            }
            1 -
            default {
                return [list [format %02x $value ]]
            }
    }  
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: list2word</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command converts a 2-byte list into a word</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#       mylist           the value to convert</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::list2word_314">proc <a href="ePTUtils.tcl-annot.html#::::list2word">::::list2word</a></a></strong> {mylist} \
{
    set listlength  [llength $mylist]
    set result      0

    if {$listlength &lt;= 2 &amp;&amp; $listlength &gt; 0} {
        incr listlength -1
        set j 0
        for {set i $listlength} {$i &gt;= 0} {incr i -1} {
            incr result  [expr [<a name="::hextodec(1)"><a href="./ePTUtils.tcl.html#::hextodec_451">::hextodec</a></a> [lindex $mylist $i]] &lt;&lt; ($j * 8)]
            incr j                
        }
    }

    return $result
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: value2Hexlist</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:	This command converts a number into a hex</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   value   - a number</span>
<span class="comment-line">#	width	- the hex list lenght to be generated</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::value2Hexlist_341">proc <a href="ePTUtils.tcl-annot.html#::::value2Hexlist">::::value2Hexlist</a></a></strong> { value width } \
{
    set retValue {}
    while { $width } {
        set retValue [linsert $retValue 0 [format &#34;%02x&#34; [expr $value &amp; 255]]]
        incr width -1
        set value [expr $value &gt;&gt; 8]
    }
    return $retValue
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: hexlist2Value</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:	This command converts a hex list into a number</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#       hexlist		- the hex list ( example {01 02 03 04} )</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::hexlist2Value_361">proc <a href="ePTUtils.tcl-annot.html#::::hexlist2Value">::::hexlist2Value</a></a></strong> { hexlist } \
{
   set retValue 0
   foreach byte $hexlist {
      set retValue [expr ($retValue &lt;&lt; 8) | 0x$byte]
   }
   return $retValue
}



<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure:    expandHexString</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Expands a string of delimited hex values:</span>
<span class="comment-line">#</span>
<span class="comment-line">#                   0 a b 1  becomes 00 0a 0b 01</span>
<span class="comment-line">#                   0:a:b:21 becomes 00:0a:0b:21</span>
<span class="comment-line">#</span>
<span class="comment-line">#               Does not verify the validity of the original hex string.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):  bytesList</span>
<span class="comment-line">#               delimiter</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:      expanded hex string</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::expandHexString_388">proc <a href="ePTUtils.tcl-annot.html#::::expandHexString">::::expandHexString</a></a></strong> {byteList {delimiter :}} \
{
    set hexList [list]

    regsub -all $delimiter $byteList &#34; &#34; byteList
    foreach byte $byteList {
        regsub -all {(.*)} $byte \
            {[format &#34;%02x &#34; 0x\1]} byte 
        append hexList [subst &#34;$byte&#34;]
    }
    regsub -all &#34; &#34; [string trim $hexList] $delimiter hexList

    return $hexList
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: getMultipleNumbers</span>
<span class="comment-line">#</span>
<span class="comment-line"># This procedure gives two numbers that are multiples of each other but</span>
<span class="comment-line"># less than the allowed maximum number. If he &#34;number&#34; is a prime number</span>
<span class="comment-line"># than this procedure may not be useful.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#       number              the number whose multiple is to be found</span>
<span class="comment-line">#       maxAllowedNum   the maximum allowed number</span>
<span class="comment-line">#       numA                the multiplier</span>
<span class="comment-line">#       numB                    the divider</span>
<span class="comment-line">#</span>
<span class="comment-line">#########################################################################</span>
<strong><a name="::::getMultipleNumbers_418">proc <a href="ePTUtils.tcl-annot.html#::::getMultipleNumbers">::::getMultipleNumbers</a></a></strong> {number maxAllowedNum numA numB} \
{
    upvar $numA a
    upvar $numB b

    <span class="comment-line"># just pick an arbitrary number for max value for loop</span>
    for {set divider 2} {$divider &lt;= 1000} {incr divider} {
        set result      [expr $number/$divider]
        set remainder   [expr $number%$divider]
        if {$remainder != 0} {
            continue
        }
        if {$result &gt; $maxAllowedNum} {
            continue
        }
        set a $result
        set b $divider
        return 0
    }

    return 1
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: hextodec</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command converts a hex number to a decimal number</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   number  - hex number to convert</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::hextodec_451">proc <a href="ePTUtils.tcl-annot.html#::::hextodec">::::hextodec</a></a></strong> {number} \
{
    if [catch {format &#34;%u&#34; &#34;0x$number&#34;} retCode] {
        puts &#34;Invalid hex number: $number&#34;
        set retCode -1
    }
    return $retCode
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: dectohex</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command converts a decimal number to a hex number</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   number  - decimal number to convert</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::dectohex_470">proc <a href="ePTUtils.tcl-annot.html#::::dectohex">::::dectohex</a></a></strong> {number} \
{
    if [catch {format &#34;%x&#34; $number} retCode] {
        puts &#34;Invalid decimal number: $number&#34;
        set retCode -1
    }

    return $retCode
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: incrMacAddress</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command increments the last three bytes (24-bit word) of the MAC</span>
<span class="comment-line"># address.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   macaddr         mac address to increment</span>
<span class="comment-line">#   amt             increment the field by this number</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::incrMacAddress_492">proc <a href="ePTUtils.tcl-annot.html#::::incrMacAddress">::::incrMacAddress</a></a></strong> {macaddr amt} \
{
    upvar $macaddr valList

    set hexnum [format &#34;%02x%02x%02x&#34; &#34;0x[lindex $valList 3]&#34; \
                             &#34;0x[lindex $valList 4]&#34; &#34;0x[lindex $valList 5]&#34;]
    set decnum [<a name="::hextodec(2)"><a href="./ePTUtils.tcl.html#::hextodec_451">::hextodec</a></a> $hexnum]
    set decnum [incr decnum $amt]
    set hexnum [format &#34;%06x&#34; &#34;0x[<a name="::dectohex(1)"><a href="./ePTUtils.tcl.html#::dectohex_470">::dectohex</a></a> $decnum]&#34;]

    scan $hexnum &#34;%02s%02s%02s&#34; byte3 byte4 byte5

    set valList [lreplace $valList 3 3 $byte3]
    set valList [lreplace $valList 4 5 $byte4 $byte5]
    return $valList
}


<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: incrIpField</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Increments the specified byte of IP address</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   ipAddress       IP address whose byte to be incremented</span>
<span class="comment-line">#   byteNum         the byte field to be incremented</span>
<span class="comment-line">#   amount             increment the field by this number</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::incrIpField_522">proc <a href="ePTUtils.tcl-annot.html#::::incrIpField">::::incrIpField</a></a></strong> {ipAddress {byteNum 4} {amount 1}} \
{
    set one [<a name="::ip2num(1)"><a href="./ePTUtils.tcl.html#::ip2num_254">::ip2num</a></a> $ipAddress]
    set two [expr {$amount&lt;&lt;(8*(4-$byteNum))}]

    return  [<a name="::long2IpAddr(1)"><a href="./ePTUtils.tcl.html#::long2IpAddr_144">::long2IpAddr</a></a> [expr {$one + $two}]]
}



<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: incrIpFieldHexFormat</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Increments the specified byte of IP address.  Both the input</span>
<span class="comment-line">#              and returned IP address are in hex format.</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   ipAddress       IP address whose byte to be incremented (It's in the form</span>
<span class="comment-line">#                    of 4 byte hex number:  ex, &#34;4c 2e 01 05&#34;  </span>
<span class="comment-line"># </span>
<span class="comment-line">#   byteNum         the byte field to be incremented</span>
<span class="comment-line">#   amount          increment the field by this number</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::incrIpFieldHexFormat_547">proc <a href="ePTUtils.tcl-annot.html#::::incrIpFieldHexFormat">::::incrIpFieldHexFormat</a></a></strong> {ipAddress {byteNum 4} {amount 1}} \
{
    set hexIpAddr   0x[join $ipAddress &#34;&#34;]

    set val [format %x [expr [format %d $hexIpAddr] + [expr {$amount&lt;&lt;(8*(4-$byteNum))}]]]
    return [<a name="::long2octet(1)"><a href="./ePTUtils.tcl.html#::long2octet_275">::long2octet</a></a> [format %d &#34;0x$val&#34;] 4]
}
<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: incrHostIpAddr</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Increments the host portion of the IP address</span>
<span class="comment-line">#              NOTE:  will carry!!</span>
<span class="comment-line">#</span>
<span class="comment-line"># Argument(s):</span>
<span class="comment-line">#   ipAddress      - ip address to increment</span>
<span class="comment-line">#   amount         - amount to increment by</span>
<span class="comment-line">#</span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::incrHostIpAddr_565">proc <a href="ePTUtils.tcl-annot.html#::::incrHostIpAddr">::::incrHostIpAddr</a></a></strong> {ipAddress {amount 1}} \
{
    return [<a name="::incrIpField(2)"><a href="./ePTUtils.tcl.html#::incrIpField_522">::incrIpField</a></a> $ipAddress 4 $amount]
}

<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure: isIpAddressValid</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Verify that the ip address is valid.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments: ipAddress - the ip address to validate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns: true if the ip address is valid, false otherwise.</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::isIpAddressValid_579">proc <a href="ePTUtils.tcl-annot.html#::::isIpAddressValid">::::isIpAddressValid</a></a></strong> {ipAddress} {

    set retCode $::true

    if {[info tclversion] == &#34;8.0&#34;} {
        <span class="comment-line"># Advanced regular expressions are not supported in 8.0</span>

        <span class="comment-line"># First check to see that there are four octets</span>
        if {[regexp {^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$} $ipAddress]} {

            <span class="comment-line"># Now check each octet for a legitimate value</span>
            foreach byte [split $ipAddress .] {
                if {($byte &lt; 0) || ($byte &gt; 255)} {
                    set retCode $::false
                    break
                }
            }
        } else {
            set retCode $::false
        }
    } else {

        <span class="comment-line"># The ip address should be four octets</span>
        if {[regexp {^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$} \
                $ipAddress]} {

            <span class="comment-line"># Now check each octet for a legitimate value</span>
            foreach byte [split $ipAddress .] {
                if {($byte &lt; 0) || ($byte &gt; 255)} {
                    set retCode $::false
                    break
                }
            }
        } else {
            set retCode $::false
        }
    }

    return $retCode
}


<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure:    isMacAddressValid</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:  Verify that the mac address is valid.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input:        macAddress:    address to validate</span>
<span class="comment-line">#</span>
<span class="comment-line"># Output:       TCL_OK if address is valid, else</span>
<span class="comment-line">#               TCL_ERROR</span>
<span class="comment-line">#</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::isMacAddressValid_632">proc <a href="ePTUtils.tcl-annot.html#::::isMacAddressValid">::::isMacAddressValid</a></a></strong> {macAddress} \
{
    set retCode $::TCL_ERROR

    regsub -all { |:} $macAddress &#34; &#34; macAddress
    if {[llength $macAddress] == 6} {

    	set retCode $::TCL_OK
        foreach value $macAddress {
            if {[string length $value] == 2} {
                if {![regexp {[0-9a-fA-F]} $value match]} {
                    set retCode $::TCL_ERROR
                    break
                }
            } else {
                set retCode $::TCL_ERROR
                break
            }
        }
    }

    return $retCode
}


<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure:   isPartialMacAddressValid</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Given a mac address, is it valid.  The given address does not have </span>
<span class="comment-line">#              to be complete</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:   macAddress - the partial address to verify</span>
<span class="comment-line">#</span>
<span class="comment-line"># Returns:     1 if it is valid, 0 if not valid</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::isPartialMacAddressValid_667">proc <a href="ePTUtils.tcl-annot.html#::::isPartialMacAddressValid">::::isPartialMacAddressValid</a></a></strong> { macAddress } \
{
    set retCode 1

    if {[info tclversion] &gt; 8.0} {
        if {![regexp {^([0-9a-fA-F]{1,2}( )*)*$} $macAddress]} {
            set retCode 0
        }
    } else {
        if {[string length $macAddress] &gt; 2} {
            set splitChar [string index $macAddress 2]
            set macAddress [split $macAddress $splitChar]
        }

        foreach value $macAddress {
            if {![regexp {^([0-9a-fA-F]+)$} $value]} {
                set retCode 0
            }
        }
    }

    return $retCode
}




<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure:   getIpV4MaskWidth</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc gets ip mask as input and calculates the maskWidth.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:   ip mask - ipV4 format.</span>
<span class="comment-line">#    </span>
<span class="comment-line"># Returns      mask width.</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::getIpV4MaskWidth_703">proc <a href="ePTUtils.tcl-annot.html#::::getIpV4MaskWidth">::::getIpV4MaskWidth</a></a></strong> {ipV4Mask} \
{
    scan $ipV4Mask &#34;%d.%d.%d.%d&#34; b1 b2 b3 b4
	
	set result  [expr ($b4 | $b3 &lt;&lt; 8 | $b2 &lt;&lt; 16 | $b1 &lt;&lt; 24) ^ 0xFFFFFFFF]
	
	for {set mask  0} { $mask &lt; 32} {incr mask} {
		if { [expr $result &gt;&gt; $mask] == 0} {
			break;
		}
	}
	set mask [expr 32 - $mask]
	
    return $mask
}


<span class="comment-line">###############################################################################</span>
<span class="comment-line"># Procedure:   getIpV4MaskFromWidth</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: This proc takes the mask prefix as input and calculates the ip mask.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments:   mask width - an integer number between 0 and 32.</span>
<span class="comment-line">#    </span>
<span class="comment-line"># Returns      mask ip.</span>
<span class="comment-line">###############################################################################</span>
<strong><a name="::::getIpV4MaskFromWidth_729">proc <a href="ePTUtils.tcl-annot.html#::::getIpV4MaskFromWidth">::::getIpV4MaskFromWidth</a></a></strong> {maskWidth} \
{
    set mask [expr (0xffffffff &lt;&lt; (32 - $maskWidth)) &amp; 0xffffffff]
    return [<a name="::num2ip(1)"><a href="./ePTUtils.tcl.html#::num2ip_232">::num2ip</a></a> $mask]
}

<span class="comment-line">########################################################################</span>
<span class="comment-line"># Procedure: buildIpMcastMacAddress</span>
<span class="comment-line">#</span>
<span class="comment-line"># This command builds the MAC address to use when transmitting multi-</span>
<span class="comment-line"># cast packets.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Arguments(s):</span>
<span class="comment-line">#       groupAddress    IP multicast group address</span>
<span class="comment-line">#</span>
<span class="comment-line"># NOTE:The Ethernet directly supports the sending of local multicast</span>
<span class="comment-line"># packets by allowing multicast addresses in the destination field of </span>
<span class="comment-line"># Ethernet packets. All that is needed to support the sending of</span>
<span class="comment-line"># multicast IP datagrams is a procedure for mapping IP host group</span>
<span class="comment-line"># addresses to Ethernet multicast addresses. </span>
<span class="comment-line">#</span>
<span class="comment-line"># An IP host group address is mapped to an Ethernet multicast address </span>
<span class="comment-line"># by placing the low-order 23-bits of the IP address into the low-order</span>
<span class="comment-line"># 23 bits of the Ethernet multicast address 01-00-5E-00-00-00 (hex)</span>
<span class="comment-line"># [RFC1112]. Because there are 28 significant bits in an IP host group</span>
<span class="comment-line"># address, more than one host group address may map to the same Ethernet</span>
<span class="comment-line"># multicast address. </span>
<span class="comment-line">########################################################################</span>
<strong><a name="::::buildIpMcastMacAddress_757">proc <a href="ePTUtils.tcl-annot.html#::::buildIpMcastMacAddress">::::buildIpMcastMacAddress</a></a></strong> {groupAddress} \
{
    set mcastIP [<a name="::host2addr(1)"><a href="./ePTUtils.tcl.html#::host2addr_100">::host2addr</a></a> $groupAddress]

    <span class="comment-line"># the lower 3 bytes of DA need to match the lower 23 bits of the multicast IP addr</span>
    set DA  [format &#34;%02x %02x %02x %02x %02x %02x&#34; 01 00 0x5e \
                    [expr &#34;0x[lindex $mcastIP 1]&#34; &amp; 0x7f] \
                    &#34;0x[lindex $mcastIP 2]&#34; \
                    &#34;0x[lindex $mcastIP 3]&#34;]

    return $DA
}


</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
