<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                       "http://www.w3.org/TR/html4/transitional.dtd">
<!-- Generated by TclDoc @@VERSION@@ -->
<html>
<head>
  <title>SendSwCmd.tcl</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="default.css">
</head>
<body class="src-html">
<div class="index-selector">
<!-- index for tcl source files -->
	Index by: 
	<a href="index_main.html#SendSwCmd.tcl">file name</a> | 
	<a href="index_main.html#byprocname">procedure name</a> | 
	<a href="index_main.html#bycall">procedure call</a> | 
	<a href="index_annot_full.html">annotation</a>

</div>
<hr>

<p><strong>SendSwCmd.tcl</strong>&nbsp;&nbsp;<span class="filetype-link">(<a href="SendSwCmd.tcl-annot.html">annotations</a> | <a href="SendSwCmd.tcl.txt">original source</a>)</span>
</p>
<pre class="src-code">
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: FailSafeForceful</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: Blast the login prompt with all failsafe</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             FailSafeForceful</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::FailSafeForceful_15">proc <a href="SendSwCmd.tcl-annot.html#::::FailSafeForceful">::::FailSafeForceful</a></a></strong> {} {
    global spawn_id spawn_ids MAIN
    global connectionTimeout

    set MAIN(FAILSAFEHIT) 1
    <a name="::result_debug(1)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Starting Failsafe&#34;
    set numVers 8
    set user(9) &#34;admin&#34;; <span class="comment-line">#Dummy</span>
    set pass(9) &#34;&#34;
    set vern(9) &#34;Dummy version&#34;;
    set user(10) j/D4pRCG1r/qP/AZfCI0; <span class="comment-line">#16.1</span>
    set pass(10) Dtyh4XyOkaPnfwKnaUE0
    set vern(10) &#34;EXOS FailSafe For 16.1&#34;;
    set user(11) 3RzJ6ufoZ1OmwJ4.jEq0; <span class="comment-line">#15.7</span>
    set pass(11) OaoaFpfogbsQa8HzSpB.
    set vern(11) &#34;EXOS FailSafe For 15.7&#34;;
    set user(12) OOE7HE2CLqAiRcAIrQL.; <span class="comment-line">#15.6</span>
    set pass(12) tBvQ85KlVvpHLemlPpB1
    set vern(12) &#34;EXOS FailSafe For 15.6&#34;;
    set user(13) tHFhUqVdi/O/FH9osCW/; <span class="comment-line">#15.5</span>
    set pass(13) XjutMy/9dgpFsScenMo.
    set vern(13) &#34;EXOS FailSafe For 15.5&#34;;
    set user(14) ECFpu2PkznVgPaMc2vu/; <span class="comment-line">#15.4</span>
    set pass(14) yberyVXQRhoiqdezqKS/
    set vern(14) &#34;EXOS FailSafe For 15.4&#34;;
    set user(15) zd0eleeil1ofiTMYMoS1; <span class="comment-line">#15.3</span>
    set pass(15) lvSh4fffJjsRY8s7xoP1
    set vern(15) &#34;EXOS FailSafe For 15.3&#34;;
    set user(16) 6451ZGd5riah.Ya/6ag0; <span class="comment-line">#15.2</span>
    set pass(16) F7pfG5uZ42oD9fVADH30
    set vern(16) &#34;EXOS FailSafe For 15.2&#34;;


    set timeout 3
    set i 9
    set tc 0
    exp_send &#34;\r&#34;
    expect {
        timeout {
            if {$tc&lt;5} {
                incr tc
                exp_send &#34;\r&#34;
                if {[info exists expect_out(buffer)]} {
                    puts $expect_out(buffer)
                }
                exp_continue;
            }
            puts &#34;Hit timeout&#34;
            set timeout $connectionTimeout
            if {[info exists expect_out(buffer)]} {
                puts $expect_out(buffer)
            }
            return
        }
        &#34;#&#34; {
            puts &#34;Hit good prompt&#34;
            set timeout $connectionTimeout
            return
        }
        &#34;&gt;&#34; {
            puts &#34;Hit good prompt&#34;
            set timeout $connectionTimeout
            return
        }
        -nocase {\[y/N]:} {
            puts &#34;Hit good prompt&#34;
            set timeout $connectionTimeout
            return
        }
        -nocase {\[y/N/q]:} {
            puts &#34;Hit good prompt&#34;
            set timeout $connectionTimeout
            return
        }
        &#34;ogin: &#34; {
            after 1500
            puts &#34;Login: Send user - $user($i) $vern($i)&#34;
            send &#34;$user($i)\r&#34;
            expect &#34;assword: &#34;
            puts &#34;Password: $pass($i) $vern($i)&#34;
            send &#34;$pass($i)\r&#34;
            incr i
            if {$i&gt;=17} {
                puts &#34;\n@@@@@\nYour out of luck\n@@@@@&#34;;
                set timeout $connectionTimeout
                send &#34;\r&#34;
                return;
            }
            exp_continue
        }
    }
    set timeout $connectionTimeout
}

<span class="comment-line"># Check for login questions</span>
<span class="comment-line"># i.e.</span>
<span class="comment-line"># Would you like to disable Telnet? [y/N]: No</span>
<span class="comment-line">#</span>
<span class="comment-line"># SNMP access is enabled by default. SNMP uses no encryption, SNMPv3 can be </span>
<span class="comment-line"># configured to eliminate this problem.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Would you like to disable SNMP? [y/N]: --- Send run msm-failover                    </span>
<strong><a name="::::_checkLoginQuestions_117">proc <a href="SendSwCmd.tcl-annot.html#::::_checkLoginQuestions">::::_checkLoginQuestions</a></a></strong> {} {

    ;<span class="comment-line"># Loop up to 10 times...</span>
    for {set i 0} {$i &lt; 10} {incr i} {
	expect {
	    &#34;#&#34; { 
		return
	    }
	    &#34;&gt;&#34; { 
		return
	    }
	    -nocase {\[y/N]:} {
		send &#34;\r&#34;
	    }
            -nocase {\[y/N/q]:} {
                send &#34;\r&#34;
            }
	}
    }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: SendACmd</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Sends a CLI command to a DUT</span>
<span class="comment-line">#              Reboots multiple DUTs simultaneously provided via duts</span>
<span class="comment-line">#              output from the cmd can be stored in a file by supplying fd_in</span>
<span class="comment-line">#     </span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cmd, fd_result, fd_input, showError</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             SendACmd $cmd</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>

<strong><a name="::::SendACmd_157">proc <a href="SendSwCmd.tcl-annot.html#::::SendACmd">::::SendACmd</a></a></strong> {{cmd &#34;NULL&#34;} \
	{fd_result &#34;NULL&#34;} \
	{fd_input  &#34;NULL&#34;} \
	{showError &#34;true&#34;} \
        {numResend 3}
	{yesorno &#34;y&#34;} {quit &#34; &#34;}} {

    global spawn_id
    global spawn_ids
    global connectionTimeout
    global whichDutNow whichMsmNow
    global DUTs_info 
    global hostname
    global MaxLoopCount
    global showSlotAfterPioneerHalErrors
    global queensFailOverCase bcmPlatform pioneerPlatform
    global SKIPBROADCOMFDB MAIN supportedPlatform i386Platform


    <span class="comment-line"># Set expect log_user for cleaner output.</span>
    <a name="::_initOutputOptions(1)"><a href="./SendSwCmd.tcl.html#::_initOutputOptions_3161">::_initOutputOptions</a></a>
    <span class="comment-line"># Check for HAL sync required</span>
    <a name="::_checkIfHalSyncNeeded(1)"><a href="./hal.tcl.html#::_checkIfHalSyncNeeded_72">::_checkIfHalSyncNeeded</a></a> $cmd 

    if {![info exists whichMsmNow]} {
        set whichMsmNow &#34;&#34;
    }
    global DUT${whichDutNow}_CONNECT${whichMsmNow}
    global DUT${whichDutNow}_CONNECT

    set showSlotAfterPioneerHalErrors 1 
    set queensFailOverCase 0
    
    set result &#34;&#34;
    set exp_out_buf &#34;&#34;
  
    set Stacking 0
    if {[string match &#34;sh*&#34; $cmd] &amp;&amp; [string match &#34;*stack*&#34; $cmd] &amp;&amp; [string match &#34;*deta*&#34; $cmd]} {     
        <span class="comment-line"># skiping for sh stacking slot command</span>
        set Stacking 1
    }

    <span class="comment-line">#For Aspen platform delay 15 seconds to sync FDB cache on MSM with HW learned FDBs on IO module</span>
    if {[string match &#34;sh*&#34; $cmd] &amp;&amp; [string match &#34;*fdb*&#34; $cmd]} {
        if {[regexp -nocase $bcmPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
            if {[info exists SKIPBROADCOMFDB] &amp;&amp; $SKIPBROADCOMFDB} {
                <a name="::result_print(1)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Skipping the usual 15 second Broadcom show fdb wait&#34;
            } else {
                <a name="::result_print(2)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Sleeping 15 seconds awaiting show fdb completion&#34;
                <a name="::exSleep(1)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 15
            }
        } elseif {[regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
            if { [string match &#34;*hardware*&#34; $cmd]  } {
                <a name="::result_print(3)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Sleeping 2s awaiting show fdb hardware completion&#34;
                <a name="::exSleep(2)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
            } else {
                <a name="::result_print(4)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Sleeping 20s awaiting show fdb completion&#34;
                <a name="::exSleep(3)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 20
            }
        }
    }
    if {[info exists DUTs_info(DUT$whichDutNow,platform)] &amp;&amp; [regexp -nocase &#34;vpex&#34; $DUTs_info(DUT$whichDutNow,platform)]} {
        set cmd [<a name="::_EnhanceVpexCli(1)"><a href="./SendSwCmd.tcl.html#::_EnhanceVpexCli_2854">::_EnhanceVpexCli</a></a> $cmd]
    }
    if {! [regexp -nocase &#34;stack-ports.*bandwidth|bytes|packets&#34; $cmd]} {
        set cmd [<a name="::_EnhanceShowPortCli(1)"><a href="./SendSwCmd.tcl.html#::_EnhanceShowPortCli_2753">::_EnhanceShowPortCli</a></a> $cmd]
    }
    set cmd [<a name="::_EnhanceStackingCli(1)"><a href="./SendSwCmd.tcl.html#::_EnhanceStackingCli_2821">::_EnhanceStackingCli</a></a> $cmd]

    if {[regexp -nocase {sh[ow]* *lo[g]*} $cmd]} {
        set cmd [<a name="::_EnhanceShowlog(1)"><a href="./SendSwCmd.tcl.html#::_EnhanceShowlog_2768">::_EnhanceShowlog</a></a> $cmd]
    }

    if {[regexp -nocase {jer[rry]* *} $cmd]} {
        set cmd [<a name="::_EnhanceJerryShow(1)"><a href="./SendSwCmd.tcl.html#::_EnhanceJerryShow_2775">::_EnhanceJerryShow</a></a> $cmd]
    }
    <span class="comment-line">#</span>
    <span class="comment-line"># CLI substitution for version related cli changes</span>
    <span class="comment-line">#</span>
    set cmd [<a name="::_cliSubstitution(1)"><a href="./cli_modify.tcl.html#::_cliSubstitution_231">::_cliSubstitution</a></a> -cmd $cmd]
    <span class="comment-line">#</span>
    <span class="comment-line"># Platform non-support modifications or test case skip</span>
    <span class="comment-line">#</span>
    set cmd [<a name="::_modifyPlatformSendCLI(1)"><a href="./cli_modify.tcl.html#::_modifyPlatformSendCLI_15">::_modifyPlatformSendCLI</a></a> -cmd $cmd]

    set shortCmd [<a name="::_GetShortCmd(1)"><a href="./SendSwCmd.tcl.html#::_GetShortCmd_2795">::_GetShortCmd</a></a> $cmd]

    set timeout 5   ;<span class="comment-line">#  This should be more than enough time to see cmd    </span>

    <span class="comment-line"># -- display and send the command</span>
    <span class="comment-line"># We try to re-send 3 times in the event of cmd truncation</span>
    <a name="::result_print(5)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;--- Send $cmd&#34;
    if {$numResend&gt;1} {
        while {$numResend} {
            send &#34;$cmd\r&#34;
            expect  {
                &#34;closed&#34; {
                    set loginLoop 0
                    <a name="::result_print(6)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\ntry_login_on_switch detects telnet \
                    to DUT$whichDutNow Closed Foreign Host\n~~~~~&#34;;
                    <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                    <a name="::_clearDutConnectionVars(1)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                    if {[<a name="::Login(1)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                        <a name="::result_error(1)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after foreign host closed&#34;
                        return &#34;&#34;
                    }
                    incr numResend -1
                }
                -exact &#34;$cmd&#34; {
                    break
                }
                <span class="comment-line"># 22.2 16.2 CR in cli breaks exact</span>
                &#34;$cmd&#34; {
                    break
                }
                <span class="comment-line">#&#34;$shortCmd&#34; {</span>
                <span class="comment-line">#    break</span>
                <span class="comment-line">#}</span>
                eof {
                    <a name="::result_print(7)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\n~~~~~\n1)Connection to DUT$whichDutNow dropped! \
                    Reconnect\n~~~~~\n~~~~~&#34;;
                    <span class="comment-line"># The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                    <a name="::_clearDutConnectionVars(2)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                    if {[<a name="::Login(2)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                        <a name="::result_error(2)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after connection dropped&#34;
                        return &#34;&#34;
                    }
                    incr numResend -1
                }
                timeout {
                    <a name="::result_print(8)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;SendACmd Timeout($numResend) sending $cmd....&#34;
                    puts &#34;SendACmd Timeout($numResend) sending $cmd....&#34;
                    incr numResend -1
                }
            }
        }
    } else {
        send &#34;$cmd\r&#34;
        expect  {
            -exact &#34;$cmd&#34; {
            }
            &#34;$cmd&#34; {
            }
            &#34;closed&#34; {
                set loginLoop 0
                <a name="::result_print(9)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\nSendACmd detects telnet \
                to DUT$whichDutNow Closed Foreign Host\n~~~~~&#34;;
                <a name="::_clearDutConnectionVars(3)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                if {[<a name="::Login(3)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                    <a name="::result_error(3)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;SendACmd is not successful on retry after foreign host closed&#34;
                    return &#34;&#34;
                }
            }
            eof {
                <a name="::result_print(10)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\n~~~~~\n2)Connection to DUT$whichDutNow dropped! Reconnect\n~~~~~\n~~~~~&#34;;
                <span class="comment-line"># The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                <a name="::_clearDutConnectionVars(4)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                <a name="::Login(4)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT$whichDutNow,connect)  -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;
            }
            timeout {
                <a name="::result_print(11)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;SendACmd Timeout sending $cmd....&#34;
                puts &#34;SendACmd Timeout  sending $cmd....&#34;
            }
        }
    }


    <span class="comment-line"># For Aspen and Cougar platform delay 5 seconds to sync FDB cache on MSM with HW deleted FDBs on IO module.</span>
    global bcmPlatform
    global pioneerPlatform    
        if {[string match &#34;cl*&#34; $cmd] &amp;&amp; [string match &#34;*fdb*&#34; $cmd] &amp;&amp; [regexp -nocase $pioneerPlatform $DUTs_info(DUT$whichDutNow,platform)]} {
            <a name="::result_print(12)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Sleeping 15s awaiting PIONEER clear fdb completion.... &#34;;
            <a name="::exSleep(4)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 15;
        }

    <span class="comment-line"># 07-18-2011: Everest needs delay after clearing fdb.</span>
    if {[string match -nocase &#34;cl*&#34; $cmd] &amp;&amp; [string match &#34;*fdb*&#34; $cmd] &amp;&amp; [regexp -nocase &#34;BD-X8&#34; $DUTs_info(DUT$whichDutNow,platform)]} {
        <a name="::result_print(13)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Sleeping 15s awaiting EVEREST clear fdb completion.... &#34;;
        <a name="::exSleep(5)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 15;
    }
    <span class="comment-line"># 08-11-2011:  Everest needs delay after clearing counters.</span>
    if {[string match -nocase &#34;cl*&#34; $cmd] &amp;&amp; [string match &#34;*counter*&#34; $cmd] &amp;&amp; [regexp -nocase &#34;BD-X8&#34; $DUTs_info(DUT$whichDutNow,platform)]} {
        <a name="::result_print(14)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;Sleeping 15s awaiting EVEREST clear counters completion.... &#34;;
        <a name="::exSleep(6)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5;
    }
    if {($numResend == 0) &amp;&amp; ($showError!=&#34;false&#34;)} {
	<a name="::result_error(4)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Error sending $cmd to device...&#34;
<span class="comment-line">#	return &#34;&#34;</span>
    }
    
    ;<span class="comment-line"># Increase timeout</span>
    set timeout $connectionTimeout   
    set LoopDetectionCounter 1
    set pioneerSlotRebootErrors &#34;Erro:HAL.Conduit|Crit:HALIO.CORE.Dump&#34;
    expect {
	timeout {
            <a name="::result_error(5)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No response from the switch DUT$whichDutNow for $timeout seconds&#34;
            expect *
            <a name="::SaveOutputBuffer(1)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
	    <span class="comment-line"># -- TODO: check whether there is a promp at the end of the </span>
	    <span class="comment-line">#    accumulated buffer, if yes, exit the expect loop no error</span>
            if {![info exists POWERCYCLE_DUT($whichDutNow)]} {
              <a name="::close_result_file(1)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
            }
            error &#34;No response from the switch DUT$whichDutNow for $timeout seconds&#34;
         }
 
         &#34;MSM does not support failover&#34; {
<span class="comment-line">#LK aspen queens hardware does not support run msm-failover hence doing a reboot msm instead of run msm-failover</span>
           set msmaSpawnId &#34;INVALID&#34;
           set msmbSpawnId &#34;INVALID&#34;
           set timeout 10   
           global DUT${whichDutNow}_CONNECTB
           <a name="::getSpawnId(1)"><a href="./bootRomLib.tcl.html#::getSpawnId_1">::getSpawnId</a></a> [set DUT${whichDutNow}_CONNECT] msmaSpawnId
           set queensMSMRebootCmd &#34; &#34;
           if { $msmaSpawnId == $spawn_id } {
             set queensMSMRebootCmd  &#34;reboot msm a&#34;
           } elseif {[info exists DUT${whichDutNow}_CONNECTB]} {
              <a name="::getSpawnId(2)"><a href="./bootRomLib.tcl.html#::getSpawnId_1">::getSpawnId</a></a> [set DUT${whichDutNow}_CONNECTB] msmbSpawnId
              if { $msmbSpawnId == $spawn_id } {     
                 set queensMSMRebootCmd  &#34;reboot msm b&#34;
              }
           }      
           <a name="::result_print(15)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;--- Send save configuration&#34;
           send &#34;save configuration\r&#34;
           expect {
	          timeout { <a name="::result_ok(1)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;timeout continue&#34; }
	          &#34;\\?&#34; {
	                regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf
	                append exp_out_buf $out_buf
                        if {!$Stacking} {
                            if {[regexp -nocase {(best, *\?|\\.[0-9]+ \?|\*.\?|Origin|or '\?|checkpoint?|errors?)} $expect_out(buffer) match str]!=1} {
		                send &#34;y\r&#34;
	                     }
                        }
	          }
              }
           sleep 5;
           set queensFailOverCase 1
           <a name="::result_print(16)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;--- Send $queensMSMRebootCmd&#34;
           send &#34;$queensMSMRebootCmd\r&#34;
               expect {
	          timeout { <a name="::result_ok(2)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;timeout continue&#34; }
	          &#34;\\?&#34; {
	                regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf
	                append exp_out_buf $out_buf
                        if {!$Stacking} {
                            if {[regexp -nocase {(best, *\?|\\.[0-9]+ \?|\*.\?|Origin|or '\?|checkpoint?|errors?)} $expect_out(buffer) match str]!=1} {
		                send &#34;y\r&#34;
	                     }
                        }
	          }
              }
             set timeout $connectionTimeout   
	     exp_continue
         }
 
         &#34;quit:&#34; { 
	     send &#34;$quit&#34;   
	     exp_continue
	 }

         <span class="comment-line"># EY-06-13-2006: Replaced platform-specifc CLI prompt patterns</span>
         <span class="comment-line"># with generic regular expression pattern.</span>
         <span class="comment-line"># EY-06-23-2006: Removed trailing &#34;$&#34; from regular expression.</span>
         <span class="comment-line">#   It was causing a failure to match the CLI prompt when a debug</span>
         <span class="comment-line">#   message was printed right after the prompt.</span>
         -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                <span class="comment-line"># ExtremeWare and ExtremeWare XOS prompt.</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># The pattern breaks down as follows:</span>
                <span class="comment-line">#</span>
                <span class="comment-line"># (\\* )?        Unsaved config marker</span>
                <span class="comment-line"># \[a-z0-9._-]+  Platform type or SNMP system name</span>
                <span class="comment-line"># (:|\\.)        Name and command ID separator</span>
                <span class="comment-line"># \[0-9]+        Command ID</span>
                <span class="comment-line"># (#|&gt;)          System or user prompt marker</span>
                if {[regexp -nocase &#34;\(debug\)&#34; $expect_out(buffer)]} {
                    set DUTs_info(DUT${whichDutNow}${whichMsmNow},DEBUGENABLED) 1
                } else {
                    set DUTs_info(DUT${whichDutNow}${whichMsmNow},DEBUGENABLED) 0
                }
                <span class="comment-line">#LK 01/27/2008 Made the below chage as TCP seq # in logs was being treaded as prompt</span>
                if {[regexp -nocase {(TCP seq #)} $expect_out(buffer) match str]==1} {
                    append exp_out_buf $expect_out(buffer) 
                    exp_continue
                }
                if {[regexp -nocase $pioneerSlotRebootErrors $expect_out(buffer) match str]==1} {
                    append exp_out_buf $expect_out(buffer) 
                    exp_continue
                }
                set MAIN(unregister_netdevice) 1
           }
        -nocase -re $pioneerSlotRebootErrors {
            if {$showSlotAfterPioneerHalErrors} {
             if { 0 } { 
                 send &#34;show slot\r&#34;
                       <a name="::exSleep(7)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
                       send &#34;\r&#34;
                       send &#34;\r&#34;
                       send &#34;show log\r&#34;
                       send &#34;\r&#34;
                       send &#34;\r&#34;
                       <a name="::exSleep(8)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
              }
                       set showSlotAfterPioneerHalErrors 0 
           }
	         append exp_out_buf $expect_out(buffer) 
                 exp_continue
             }

         -nocase -re &#34;installing.*bootrom&#34; {
             send &#34;y\n&#34;;
             exp_continue;
         }
         <span class="comment-line"># SK: 6/23/06 DO NOT ADD MORE SPECIFIC PROMPTS</span>
         <span class="comment-line"># AS ABOVE PROMPT WILL MATCH</span>
         -nocase -re &#34;regrouter.* # &#34;                   {}
         -nocase -re &#34;bd-10808.\[0-9]+ # &#34;	{}
         -nocase -re &#34;bd-20808.\[0-9]+ # &#34;	{}
         -nocase -re &#34;bd-20804.\[0-9]+ # &#34;	{}
         -nocase -re &#34;aspen-8810.\[0-9]+ # &#34;	{}
         -nocase -re &#34;bd-8810.\[0-9]+ # &#34;	{}
         -nocase -re &#34;aspen-8806.\[0-9]+ # &#34;	{}
         -nocase -re &#34;bd-8806.\[0-9]+ # &#34;	{}
         -nocase -re &#34;aspen.\[0-9]+ # &#34;		{}
         -nocase -re &#34;summitx450-24\[x,t].\[0-9]+ # &#34;	{}
         -nocase -re &#34;summitx406-24\[p,t].\[0-9]+ # &#34;	{}
         -nocase -re &#34;summitx450\[a,e]-24\[p,t].\[0-9]+ # &#34;	{}
         -nocase -re &#34;bd-pc.\[0-9]+ # &#34;		{}
         -nocase -re &#34;summit-pc.\[0-9]+ # &#34;	{}
         -nocase -re &#34;summit.* # &#34;     {}
         -nocase -re &#34;msm.* # &#34;        {
         <span class="comment-line">#LK 01/27/2008 Made the below chage as TCP seq # in logs was being treaded as prompt</span>
         if {[regexp -nocase {(TCP seq #)} $expect_out(buffer) match str]==1} {
	     append exp_out_buf $expect_out(buffer) 
                exp_continue
             }
         }
         -nocase -re &#34;bd.* # &#34;         {}
         -nocase -re &#34;alpine.* # &#34;     {}
         -nocase -re &#34;Enter debug mode password: &#34;  {}
<span class="comment-line">#         -nocase -re &#34;enetswitch.* # &#34; {}</span>
<span class="comment-line">#         -nocase -re &#34;godzilla.* # &#34;   {}</span>
<span class="comment-line">#         -nocase -re &#34;dut.* # &#34;        {}</span>
         -nocase -re &#34;exsh.* # &#34;       {}
         -nocase -re &#34;sh.2.05a# &#34;      {}
         -nocase -re &#34;\]# &#34;            {}
         -nocase -re &#34;msmA&gt;&#34;           {}
         -nocase -re &#34;msmB&gt;&#34;           {}
         -nocase -re &#34;tftp&gt; &#34;          {}
	 -nocase -re &#34;\[IO\-\[0-9]+\]#&#34;  {puts &#34;\nIO PROMPT&#34;;}
         &#34;firmware update in progress&#34; { ;<span class="comment-line">#SK3/9/07: POE firmware install 12.0.0.3</span>
                   <a name="::exSleep(9)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 90
                }
         &#34;login: &#34; {
             set connect _CONNECT
             set DUTName [format %s%d DUT $whichDutNow]
             global ${DUTName}_CONNECT
	     <a name="::result_warning(1)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;***** SendACmd login: ****&#34;
             
             <a name="::Login(5)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT${whichMsmNow}] -CheckOperational 0 -masterCheck 0
             if { $queensFailOverCase == 1 } {
                 <a name="::result_debug(2)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;waiting for slots to become operational&#34;
                 <a name="::CheckOperational(1)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>
                 set queensFailOverCase 0
             }
<span class="comment-line">#	     send &#34;admin\r&#34;</span>
<span class="comment-line">#             set aaaTimeout 0</span>
<span class="comment-line">#	     expect {</span>
<span class="comment-line">#                   &#34;password:&#34; {send &#34;\r&#34;}</span>
<span class="comment-line">#                    -nocase -re &#34;Error.*service.*not available.*try again&#34; {</span>
<span class="comment-line">#		    result_debug &#34;\n****Waiting for Authentication Service to Come up***\n&#34;</span>
<span class="comment-line">#                    exSleep 40</span>
<span class="comment-line">#                    set aaaTimeout 1</span>
<span class="comment-line">#                   }</span>
<span class="comment-line">#                  }</span>
<span class="comment-line">#             if {$aaaTimeout} {exp_continue}</span>
<span class="comment-line">#	     _checkLoginQuestions</span>
<span class="comment-line">#	     send &#34;dis clipaging\r&#34;</span>
<span class="comment-line">#	     expect -re &#34;#|&gt; $&#34;</span>
	 }

	 &#34;password: &#34; {
             set connect _CONNECT
             set DUTName [format %s%d DUT $whichDutNow]
             global ${DUTName}_CONNECT
	     <a name="::result_warning(2)"><a href="./ql_multi.tcl.html#::result_warning_407">::result_warning</a></a> &#34;***** SendACmd password: ****&#34;
             <a name="::Login(6)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT${whichMsmNow}] -CheckOperational 0 -masterCheck 0
<span class="comment-line">#	     send &#34;\r&#34;</span>
<span class="comment-line">#	     expect &#34;login:&#34;</span>
<span class="comment-line">#	     send &#34;admin\r&#34;</span>
<span class="comment-line">#	     expect &#34;password:&#34;</span>
<span class="comment-line">#	     send &#34;\r&#34;</span>
<span class="comment-line">#	     _checkLoginQuestions</span>
<span class="comment-line">#	     send &#34;dis clipaging\r&#34;</span>
<span class="comment-line">#	     expect -re &#34;#|&gt; $&#34;</span>
	 }

    -nocase &#34;remove existing files from&#34; {
        send &#34;y\r&#34;
        exp_continue
    }
    <span class="comment-line"># Currently this hits the 16.1 Signature Validation on download</span>
    -nocase &#34;image is not digitally signed&#34; {
        puts &#34;Hit Signature&#34;
        send &#34;y\r&#34;
        exp_continue
    }
    <span class="comment-line"># Press enter to continue: after SSH Key clear - new in 22.2</span>
    -nocase &#34;press enter to continue: &#34; {
        puts &#34;SSH zeroization case&#34;
        send &#34;\r&#34;
        exp_continue
    }
    &#34;\\?&#34; {
        regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf;
        append exp_out_buf $out_buf;
        <a name="::_cliQuestionHandler(1)"><a href="./SendSwCmd.tcl.html#::_cliQuestionHandler_3194">::_cliQuestionHandler</a></a> -buffer $exp_out_buf -cmd $cmd -yesorno $yesorno -stacking $Stacking
        exp_continue;
    }

	&#34;\~\&gt;&#34; {
        puts &#34;pacman prompt&#34;
		send &#34;c\r&#34;
		exp_continue
	}
<span class="comment-line">#LK 04/10/2009 Temporary workaround to avoid failures on g1_oly</span>
        -nocase {\[y/N]:} {
                send &#34;\r&#34;
	     exp_continue
        }
        -nocase {\[y/N/q]:} {
                send &#34;\r&#34;
             exp_continue
        }
<span class="comment-line">#         -nocase -re &#34;Aspen\[0-9a-zA-Z:]+ &gt; &#34;      {}</span>
<span class="comment-line">#         -nocase -re &#34;summit\[0-9a-zA-Z:]+ &gt; &#34;     {}</span>
<span class="comment-line">#         -nocase -re &#34;msm\[0-9a-zA-Z:]+ &gt; &#34;        {}</span>
<span class="comment-line">#         -nocase -re &#34;bd\[0-9a-zA-Z:]+ &gt; &#34;         {}</span>
<span class="comment-line">#         -nocase -re &#34;alpine\[0-9a-zA-Z:]+ &gt; &#34;     {}</span>
<span class="comment-line">#         -nocase -re &#34;enetswitch\[0-9a-zA-Z:]+ &gt; &#34; {}</span>
<span class="comment-line">#         -nocase -re &#34;godzilla\[0-9a-zA-Z:]+ &gt; &#34;   {}</span>
<span class="comment-line">#         -nocase -re &#34;dut\[0-9a-zA-Z:]+ &gt; &#34;        {}</span>
         -nocase -re &#34;root.* # &#34;                   {}
         -nocase -re &#34;root.*# &#34;                    {}
         -nocase -re &#34;regrouter.* # &#34;     {}


         &#34;yes, no, or cancel)&#34; { send &#34;n/r&#34; }
	 
         &#34;n)\\?  &#34; &#34;send $yesorno/r&#34;
	 
         &#34;\r&#34; {
                incr LoopDetectionCounter
                if {![info exists MaxLoopCount]} {
                    set MaxLoopCount 15000
                }
                if { $LoopDetectionCounter &gt; $MaxLoopCount } {
                    expect *
                    <a name="::SaveOutputBuffer(2)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
                    <a name="::close_result_file(2)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
                    error &#34;Loop Condition on Switch Please Debug and Restart regression &#34;
                } elseif {[regexp -nocase &#34;ESC\\-&gt;&#34; $expect_out(buffer)]} {
                    <a name="::exSleep(10)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 4
                    send &#34;\033&#34;
                    exp_continue
                } elseif {[regexp -nocase &#34;unregister_netdevice:&#34; $expect_out(buffer)]} {
                    if {![info exists MAIN(unregister_netdevice)]} {
                        set MAIN(unregister_netdevice) 1
                    } else {
                        incr MAIN(unregister_netdevice)
                    }
                    if {$MAIN(unregister_netdevice) &gt; 10} {
                        <a name="::report_start_test(1)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Unregister NetDevice Hit Power Cycle DUT $whichDutNow&#34;;
                        <a name="::result_error(6)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;unregister_netdevice detected on $whichDutNow - powerCycle if possible&#34;
                        if {[<a name="::PowerCycleDUT(1)"><a href="./poweroutlet.tcl.html#::PowerCycleDUT_377">::PowerCycleDUT</a></a> $whichDutNow]==1} {
                            <a name="::result_ok(3)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Successfully power cycled DUT $whichDutNow...&#34;
                        } else {
                            <a name="::result_error(7)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Could not power cycle DUT $whichDutNow...&#34;
                            puts &#34;@@@ Could not power cycle DUT @@@&#34;
                            error &#34;Stuck at unregister netdevice&#34;
                        }
                        <a name="::report_end_test(1)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
                    }
                } else {
                    regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf
                    append exp_out_buf $out_buf
                    exp_continue
                }
         }
	
	     ;<span class="comment-line">#nofeep command - also VM user shell prompt</span>
         -re &#34;\\$ $&#34; {
                if {[regexp -nocase &#34;$supportedPlatform|$i386Platform&#34; $expect_out(buffer)] == 1} {
                    <span class="comment-line">#puts &#34;At \$ prompt on the EXOS&#34;</span>
                } else {
                    <span class="comment-line">#puts &#34;At \$ prompt on non-EXOS&#34;</span>
                }
         }
         -re &#34; &gt; $&#34;  {
                if {[regexp -nocase &#34;$supportedPlatform|$i386Platform&#34; $expect_out(buffer)] == 1} {
                    <span class="comment-line">#puts &#34;At &gt; prompt on the EXOS&#34;</span>
                } else {
                    <span class="comment-line">#puts &#34;At &gt; prompt on non-EXOS&#34;</span>
                    append exp_out_buf $expect_out(buffer)
                    exp_continue
                }
         }
         -re &#34;# $&#34; {
                if {[regexp -nocase &#34;$supportedPlatform|$i386Platform&#34; $expect_out(buffer)] == 1} {
                    <span class="comment-line">#puts &#34;At # prompt on the EXOS&#34;</span>
                } else {
                    <span class="comment-line">#puts &#34;At # prompt on non-EXOS&#34;</span>
                    append exp_out_buf $expect_out(buffer)
                    exp_continue
                }
      	 }

      	 &#34;ESC\\-&gt;&#34; {
	     <span class="comment-line"># -- wait for data to come</span>
	     <a name="::exSleep(11)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 4
	     <span class="comment-line"># -- send esc characters</span>
	     send &#34;\033&#34;
	     exp_continue
      	 }

      	 &#34;for help&#34; {
      	    <span class="comment-line"># -- wait for data to come</span>
	     <a name="::exSleep(12)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 4
	     <span class="comment-line"># -- send esc characters</span>
	     send &#34;\033&#34;
	     exp_continue
      	 }

         full_buffer {
	    <a name="::result_print(17)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;***************  GOT FULL_BUFFER ****************&#34;
	    regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf
	    append exp_out_buf $out_buf
	    exp_continue
         }
     }

     append exp_out_buf $expect_out(buffer)
     regsub -all &#34;\n\r&#34; $exp_out_buf &#34;\n&#34; exp_out_buf
     regsub -all &#34;\t&#34; $exp_out_buf &#34; &#34; exp_out_buf
     
     if {$fd_input != &#34;NULL&#34; } { 
	     puts -nonewline $fd_input $exp_out_buf 
     }

     <span class="comment-line"># -- Do not print to the log file if in multiTask</span>
     if {$MAIN(PRINTTOLOG)} {
         <a name="::result_pre(1)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $exp_out_buf
     }

     <span class="comment-line"># Added for PD3-73117302 implementation</span>
     if {$showError != &#34;false&#34;} {
        <span class="comment-line"># Only if SendACmd was not called by CheckCmdIllegal</span>
        <a name="::_checkCommandAccepted(1)"><a href="./SendSwCmd.tcl.html#::_checkCommandAccepted_753">::_checkCommandAccepted</a></a> $cmd $exp_out_buf
     }

     set retVal $exp_out_buf
     <span class="comment-line">#For certain commands, send and addition command to the switch to verify hal</span>
     <span class="comment-line"># has synced.  The command will not return until this is true.</span>
     <a name="::_sendHalSyncCmd(1)"><a href="./hal.tcl.html#::_sendHalSyncCmd_106">::_sendHalSyncCmd</a></a> 

     <span class="comment-line">#</span>
     <span class="comment-line">#  Reset any necessary globals</span>
     <span class="comment-line">#</span>
     set DUTs_info(DUT$whichDutNow,checkPointFail) 0

     return $retVal
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: _checkCommandAccepted</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Added for PD3-73117302 implementation. </span>
<span class="comment-line">#     If a config command is not accepted by the switch,</span>
<span class="comment-line">#     SendACmd should report an error, causing testcase to appear as failed.</span>
<span class="comment-line">#     The following commands are not checked:</span>
<span class="comment-line">#         download edit exit history install load ls ping reboot save show </span>
<span class="comment-line">#         synchronize telnet terminate tftp top unconfigure uninstall upload use</span>
<span class="comment-line">#     Also, if SendACmd was called by CheckCmdIllegal, then this will not get executed.</span>
<span class="comment-line">#     The same SendACmd error will only be reported once per testcase.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cmd out_buf</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             _checkCommandAccepted $cmd $out_buf</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,VerifySwitchOutput)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_checkCommandAccepted_753">proc <a href="SendSwCmd.tcl-annot.html#::::_checkCommandAccepted">::::_checkCommandAccepted</a></a></strong> { cmd out_buf } {

    global erroredLines
    global DUT DUTs_info whichDutNow


    <span class="comment-line">#</span>
    <span class="comment-line"># Allow for 4 checkpoint errors.. with a resend of the comand on each</span>
    <span class="comment-line">#</span>
    if {[regexp -nocase {.*error:.* cannot .*checkpoint.*} $out_buf]} {
        if {![info exists DUTs_info(DUT$whichDutNow,checkPointFail)]} {
            set DUTs_info(DUT$whichDutNow,checkPointFail) 1
        } else {
            incr DUTs_info(DUT$whichDutNow,checkPointFail)
        }
        if {$DUTs_info(DUT$whichDutNow,checkPointFail) &lt;= 4} {
            set out_buf &#34;&#34;
            <a name="::result_debug(3)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$cmd - _checkCommandAccepted checkpoint error&#34;
            <a name="::result_debug(4)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Attempt #$DUTs_info(DUT$whichDutNow,checkPointFail) to wait another 30 seconds for checkpointing&#34;
            sleep 30
            <a name="::SendACmd(1)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> $cmd
        }
    }

    if { ![info exists erroredLines] } {
        lappend erroredLines &#34;{cannot be executed until configuration checkpoint} 0&#34;
        lappend erroredLines &#34;{This command cannot be executed while system is recovering from failure} 0&#34;
        lappend erroredLines &#34;{Ambiguous command} 0&#34;
        lappend erroredLines &#34;{killing process} 0&#34;
        lappend erroredLines &#34;{.*Crit:.*} 0&#34;
        lappend erroredLines &#34;{pid.*died} 0&#34;

        set numOfErroredLines [llength $erroredLines]

        for { set i 1 } { $i &lt;= $numOfErroredLines } { incr i } {
            set DUT(erroredLines,$i) 0
        }
    }

    set doNotCheckCmds {download edit exit history install load ls ping \
            reboot save show synchronize telnet terminate tftp top unconfigure \
            uninstall upload use head tail cat ps !kill}

    <span class="comment-line"># If the first word of the command is one of the $doNotCheckCmds items, dont do anything</span>
    <span class="comment-line"># For matching against $doNotCheckCmds, check only up to the number of letters in first word of $cmd, in case of any cmd abbreviations</span>
    set mainCmd [lindex $cmd 0]
    set mainCmdLen [expr [string length $mainCmd] -1]
    foreach cmdname $doNotCheckCmds {
        if { [regexp -nocase $mainCmd [string range $cmdname 0 $mainCmdLen]] } {
            return
        }
    }

    <span class="comment-line"># Verify the switch did not output any of the $erroredLines</span>
    set outList [split $out_buf &#34;\n&#34;]
    set pid [pid]
    set outfile [open &#34;Tmp/tmp_$pid&#34; &#34;w&#34;]
    foreach outputLine $outList {
        puts $outfile $outputLine
    }
    close $outfile
    set errorFound [<a name="::GetKeyValue(1)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;Tmp/tmp_$pid&#34; $erroredLines 0]
    file delete Tmp/tmp_$pid

    set lineCount 0
    foreach checkLine $erroredLines {
        set errorCode [lindex $errorFound $lineCount]
        incr lineCount
        if { ![regexp &#34;KEY_NOT_FOUND&#34; $errorCode] } {
            incr DUT(erroredLines,$lineCount)
            if { $DUT(erroredLines,$lineCount) == 1 } {
                <a name="::report_start_test(2)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;_checkCommandAccepted: Checking validity of &lt;$cmd&gt;&#34;
                <a name="::result_error(8)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Command &lt;$cmd&gt; was not properly executed by the switch.&#34;
                if { [regexp &#34;checkpoint&#34; $checkLine] } {
                    <a name="::SendACmd(2)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug ems show trace devmgr all logto file&#34;
                    <a name="::::ChangeTraceFileName(1)"><a href="./SystemSetup.tcl.html#::::ChangeTraceFileName_1242">::::ChangeTraceFileName</a></a>
                }
                if { [regexp &#34;pid.*died&#34; $checkLine] } {
                    <a name="::result_debug(5)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found : Process Died&#34;
                    <a name="::::ChangeCoreFileName(1)"><a href="./SystemSetup.tcl.html#::::ChangeCoreFileName_1310">::::ChangeCoreFileName</a></a>
                }
                if { [regexp &#34;Crit:DM.Critical.*Node State.*FAIL&#34; $checkLine] } {
                    <a name="::SendACmd(3)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show log&#34;
                    <a name="::SendACmd(4)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug ems show trace devmgr all logto file&#34;
                    <a name="::::ChangeTraceFileName(2)"><a href="./SystemSetup.tcl.html#::::ChangeTraceFileName_1242">::::ChangeTraceFileName</a></a>
                }
                <a name="::report_end_test(2)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
            } else {
                if { ([regexp &#34;pid.*died&#34; $checkLine]) &amp;&amp; ($DUT(erroredLines,$lineCount) &gt; 1) } {
                    <a name="::result_debug(6)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> $checkLine
                    <a name="::report_start_test(3)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;_checkCommandAccepted: Checking validity of &lt;$cmd&gt;&#34;
                    <a name="::result_error(9)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Command &lt;$cmd&gt; was not properly executed by the switch.&#34;
                    <a name="::result_debug(7)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Found : Process Died&#34;
                    <a name="::::ChangeCoreFileName(2)"><a href="./SystemSetup.tcl.html#::::ChangeCoreFileName_1310">::::ChangeCoreFileName</a></a>
                    <a name="::report_end_test(3)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
                }
            }
        }
    }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: send_a_sw_cmd_by_s_comm</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal proc to send cli command to serial com.</span>
<span class="comment-line">#              Reboots multiple DUTs simultaneously provided via duts</span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cmd, fd_result, fd_input</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             send_a_sw_cmd_by_s_comm $cm</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::send_a_sw_cmd_by_s_comm_870">proc <a href="SendSwCmd.tcl-annot.html#::::send_a_sw_cmd_by_s_comm">::::send_a_sw_cmd_by_s_comm</a></a></strong> {{cmd &#34;NULL&#34;}        \
                              {fd_result &#34;NULL&#34;}  \
                              {fd_input  &#34;NULL&#34;}} {
   global spawn_id
   global timeout

   set result &#34;&#34;
   set flag 0
   set time1 [clock seconds]
   <a name="::result_debug(8)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send $cmd&#34;
   send &#34;$cmd\r&#34;

   expect {
      timeout {
         <a name="::result_error(10)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No response from the switch for $timeout seconds&#34;
	 <a name="::close_result_file(3)"><a href="./result.tcl.html#::close_result_file_363">::close_result_file</a></a>
         exit
      } 
      &#34;(yes, no, or cancel)&#34; {
         set flag 2
	 send &#34;n\r&#34;
      }
      &#34;reboot\\?&#34; {
	 set flag 2
	 send &#34;yes\r&#34;
      }
      &#34;quit:&#34; {
         set flag 1
         send &#34; &#34;
      }
      &#34;quit: &#34; {
         set flag 1
         send &#34; &#34;
      }
      &#34;#&#34; {
         set flag 0
      } 
      &#34;\\?&#34; {
         set flag 0
	 send &#34;y\r&#34;
	 expect &#34;#&#34;
      }
      -nocase &#34;n)\\?  &#34; {
         <a name="::result_debug(9)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- (y/n)?  &#34;
         set flag 0
         send &#34;y/r&#34;
      }      
      &#34;\\-&gt;&#34; {
         set flag 0
      }
      &#34;login:&#34; {
	 set flag 0
         send &#34;admin\r&#34;                                    
         expect &#34;password:&#34;
         send &#34;\r&#34;
         expect &#34;#&#34;
      } 
      &#34;password:&#34; {
	 set flag 0
         send &#34;\r&#34;
         expect &#34;login:&#34;
         send &#34;admin\r&#34;
         expect &#34;password:&#34;
         send &#34;\r&#34;
         expect &#34;#&#34;
      }
   }
   set exp_out_buf &#34;&#34;
   regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; exp_out_buf
   if {$fd_input != &#34;NULL&#34; } { puts $fd_input $exp_out_buf }
   append result $exp_out_buf

   while { $flag &gt;= 1 } {
       expect {
         timeout {
            puts &#34;!!!!!! No response from the switch for $timeout seconds !!!!!\n&#34;
            exit
         } 
         &#34;(yes, no, or cancel)&#34; {
            set flag 2
	    send &#34;n\r&#34;
         }
	     &#34;reboot\\?)&#34; {
	    set flag 2
            send &#34;yes\r&#34;
         }
         &#34;quit:&#34; {
             set flag 1
             send &#34; &#34;
         }
         &#34;quit: &#34; {
             set flag 1
             send &#34; &#34;
         }
         &#34;#&#34; {
             set flag 0
         } 
      	 &#34;\\?&#34; {
	     if { $flag == 1 } {
                set flag 0
	     	send &#34;y\r&#34;
		expect &#34;#&#34;
             }
         }
         -nocase &#34;n)\\?  &#34; {
            <a name="::result_debug(10)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- (y/n)?  &#34;
            set flag 0
            send &#34;y/r&#34;
         }
	 &#34;\\-&gt;&#34; {
            set flag 0
	 }
         &#34;login:&#34; {
	     set flag 0
             send &#34;admin\r&#34;                                    
             expect &#34;password:&#34;
             send &#34;\r&#34;
	     expect &#34;#&#34;
         } 
         &#34;password:&#34; {
             send &#34;\r&#34;
             expect &#34;login:&#34;
             send &#34;admin\r&#34;
             expect &#34;password:&#34;
             send &#34;\r&#34;
	     expect &#34;#&#34;
	 }
      }
      set exp_out_buf &#34;&#34;
      regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; exp_out_buf
      regsub -all &#34;\t&#34; $exp_out_buf &#34; &#34; exp_out_buf
      <a name="::result_debug(11)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Data:$exp_out_buf&#34;
      if {$fd_input != &#34;NULL&#34; } { puts $fd_input $exp_out_buf }
      append result $exp_out_buf
   }
   <a name="::result_pre(2)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $result
   <span class="comment-line">#result_debug &#34;Time for $cmd = [expr $time2-$time1] secs&#34;</span>
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: SaveOutputBuffer</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal proc to save output buffer into log file</span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: buffer</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             SaveOutputBuffer $expect_out(buffer)</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::SaveOutputBuffer_1024">proc <a href="SendSwCmd.tcl-annot.html#::::SaveOutputBuffer">::::SaveOutputBuffer</a></a></strong> {buffer} {
   set exp_out_buf &#34;&#34;
   regsub -all &#34;\n\r&#34; $buffer &#34;\n&#34; exp_out_buf
   regsub -all &#34;\t&#34; $exp_out_buf &#34; &#34; exp_out_buf
   <a name="::result_pre(3)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $exp_out_buf
}
   
<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckDownloadConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Download a config file supplied by filename</span>
<span class="comment-line">#              Then checks for successful download.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: tftpServer, filename</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             CheckDownloadConfig $tftpServer $filename</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckDownloadConfig_1046">proc <a href="SendSwCmd.tcl-annot.html#::::CheckDownloadConfig">::::CheckDownloadConfig</a></a></strong> {tftpServer filename {incremental 0} args} {

    <a name="::parse_args(1)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckDownloadConfig $args {
      wait &#34;-1&#34;
      nameFormat &#34;dynamic&#34;
   }

   if { $wait &gt;= 0 } {
       set waitTime $wait
   } else {
       set waitTime 60
       global bcmChassis
       if  {[regexp -nocase $bcmChassis [<a name="::GetPlatform(1)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]]} {
	   set waitTime 90
       }
   }

   <a name="::result_debug(12)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Start downloading config $filename from $tftpServer&#34;
   set status [<a name="::DownloadConfig(1)"><a href="./SendSwCmd.tcl.html#::DownloadConfig_1091">::DownloadConfig</a></a> $tftpServer $filename $waitTime $incremental -nameFormat $nameFormat]

   <a name="::report_start_test(4)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Downloading config file $filename from $tftpServer&#34;
   if {$status == &#34;illegal&#34;} {
      <a name="::result_error(11)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to download config file from $tftpServer&#34;
   } else {
      <a name="::result_ok(4)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Config file successfully downloaded from $tftpServer&#34;
   }
   <a name="::report_end_test(4)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   return $status
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: DownloadConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Called by CheckDownloadConfig to perform download a config </span>
<span class="comment-line">#              file supplied by filename.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: TFTPServerIP, filename, wait</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [DownloadConfig $tftpServer $filename $waitTime ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DownloadConfig_1091">proc <a href="SendSwCmd.tcl-annot.html#::::DownloadConfig">::::DownloadConfig</a></a></strong> {TFTPServerIP filename {wait 60} {incremental 0} args} {
   <a name="::parse_args(2)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> DownloadConfig $args {
      nameFormat &#34;dynamic&#34;
   }
   global whichDutNow
   global DUT1_IP

   <span class="comment-line"># -- setup network to tftpserver</span>
   <a name="::ConfigGatewayNetwork(1)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   <a name="::exSleep(13)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5;
   if {[<a name="::CompareRelease(1)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(1)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow] 11.5]&gt;=0} {
      regsub -nocase {\.cfg} $filename &#34;&#34; filenamenew
<span class="comment-line"># LK 05/01/2008 appending the DUT1_IP to filename while getting it from tftp server </span>
<span class="comment-line"># which was added while upload to get a unique file name</span>
      if {$nameFormat == &#34;dynamic&#34;} {
          set filenamenew ${filenamenew}_$DUT1_IP
      } else {
          set filenamenew $filenamenew
      }
      set status [<a name="::CheckCmdLegal(1)"><a href="./checkCmdLegality.tcl.html#::CheckCmdLegal_58">::CheckCmdLegal</a></a> &#34;tftp $TFTPServerIP -v [<a name="::GetVrString(1)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] -g -r $filenamenew.xsf&#34;]
       if {$status!=&#34;illegal&#34;} {
          <a name="::SendACmd(5)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;load script $filenamenew.xsf&#34;
          <a name="::result_debug(13)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;wait for $wait sec for load script to complete&#34;
          <a name="::exSleep(14)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $wait
          <a name="::SendACmd(6)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;rm $filenamenew.xsf&#34;
	<span class="comment-line"># fix for 2.5.1 fail in 11.6 version</span>
       	  <a name="::UnconfigGatewayNetwork(1)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
       }
       return $status
   } else {
<span class="comment-line"># LK 05/01/2008 appending the DUT1_IP to filename while getting it from tftp server </span>
<span class="comment-line"># which was added while upload to get a unique file name</span>
       set status [<a name="::CheckCmdLegal(2)"><a href="./checkCmdLegality.tcl.html#::CheckCmdLegal_58">::CheckCmdLegal</a></a> &#34;tftp $TFTPServerIP -v [<a name="::GetVrString(2)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] -g -l downloadedConfig.cfg -r ${filename}_$DUT1_IP&#34;]
       if {$status!=&#34;illegal&#34;} {
	   <a name="::SendACmd(7)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;use configuration downloadedConfig&#34;
	   <a name="::CheckReboot(1)"><a href="./SendSwCmd.tcl.html#::CheckReboot_1202">::CheckReboot</a></a> $whichDutNow -save no
	   <span class="comment-line"># Not sure if should delete it before or after </span>
	   <span class="comment-line">#      SendACmd &#34;rm downloadedConfig.cfg&#34;</span>
       }
       <span class="comment-line"># -- tear down network to tftpserver</span>
       <a name="::UnconfigGatewayNetwork(2)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
       return $status
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckSaveConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Save switch configuration</span>
<span class="comment-line">#              Then check for successful save.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             CheckSaveConfig</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckSaveConfig_1151">proc <a href="SendSwCmd.tcl-annot.html#::::CheckSaveConfig">::::CheckSaveConfig</a></a></strong> {} {

   set status [<a name="::SaveConfig(1)"><a href="./SendSwCmd.tcl.html#::SaveConfig_1178">::SaveConfig</a></a>]
   <a name="::report_start_test(5)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;save configuration&#34;
   if {$status == &#34;error&#34;} {
      <a name="::result_error(12)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to save configuration&#34;
   } else {
      <a name="::result_ok(5)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;success saving configuration&#34;
   }
   <a name="::report_end_test(5)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   return $status
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: SaveConfig</span>
<span class="comment-line"># </span>
<span class="comment-line"># Description: Called by CheckSaveConfig to perform save</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: none</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             SaveConfig</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::SaveConfig_1178">proc <a href="SendSwCmd.tcl-annot.html#::::SaveConfig">::::SaveConfig</a></a></strong> {} {
   <a name="::SendACmd(8)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;save&#34;
   return &#34;ok&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckReboot</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Reboots the current DUT, saves the current config</span>
<span class="comment-line">#              Reboots multiple DUTs simultaneously provided via duts</span>
<span class="comment-line">#   ### NOTE: Unfortunately, can not perform waitForReboot on all the DUTs, only the last rebooted is checked.</span>
<span class="comment-line">#   ###       Login eats up all expect buffer leaving nothing for waitForReboot.</span>
<span class="comment-line">#     </span>
<span class="comment-line">#     </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: duts, save</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             CheckReboot 1,2,3 -save no -slots 6</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckReboot_1202">proc <a href="SendSwCmd.tcl-annot.html#::::CheckReboot">::::CheckReboot</a></a></strong> {{duts &#34;&#34;} args} {
    global DUT
    global DUTs_info MAIN
    global numDUT
    global whichDutNow

    <a name="::parse_args(3)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckReboot $args {
        save &#34;yes&#34;
        maxWait 20
        masterCheck 1
        msm &#34;a&#34;
        waitforloadcfg &#34;no&#34;  ; <span class="comment-line"># used for scalability test cases that have to reboot with huge cfg</span>
        rebootBpe &#34;yes&#34;
    }
    <a name="::DBug(1)"><a href="./misc.tcl.html#::DBug_951">::DBug</a></a> 1 &#34;the CheckReboot args vals: duts $duts, save $save, maxWait $maxWait&#34;

    global whichDutNow
    global hostname
    if {$duts==&#34;&#34;} {
        set duts $whichDutNow
    }
    set dutList [split $duts ,]

    set connect _CONNECT
    set rebootSuccessful 0
    set eofEncountered 0

    foreach i $dutList {
        set dutMsm($i) a
    }
    if {[llength $msm] == 1} {
        foreach i $dutList {
            set dutMsm($i) $msm
        }
    } else {
        set i 0
        foreach item $dutList {
            set dutMsm($item) [lindex $msm $i]
            incr i
        }
    }

    foreach dut $dutList {
        set DUTName [format %s%d DUT $dut]
        global ${DUTName}_CONNECT ${DUTName}_CONNECTB;
        global ${DUTName}_IP
        <a name="::CLIConnectMode(1)"><a href="./login.tcl.html#::CLIConnectMode_2263">::CLIConnectMode</a></a> -action &#34;forceConsole&#34;;<span class="comment-line"># Use the console if in telnet mode</span>
        set telnetIp [set ${DUTName}_IP]
        <span class="comment-line">#make sure Login will not reuse the lost telnet spawn id after reboot</span>
        if {[info exists hostname]} {set hostname [<a name="::ldelete(1)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> &#34;$hostname&#34; &#34;telnetIp&#34;]}
        if {$dutMsm($dut) == &#34;a&#34;} {
            <a name="::Login(7)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECT] -masterCheck $masterCheck
        } else {
            <a name="::Login(8)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set ${DUTName}_CONNECTB] -masterCheck $masterCheck
        }
        <a name="::SendACmd(9)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show switch&#34;;
        <span class="comment-line"># EY-06-23-2008: Removed call to DumpNvramContent as the /exos/bin/odo</span>
        <span class="comment-line"># program currently doesn't echo characters properly on the Stacking</span>
        <span class="comment-line"># and LynxG platforms.</span>
        <a name="::SendACmd(10)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ls&#34;
        <span class="comment-line">#DumpNvramContent</span>
        global spawn_id
        global spawn_ids
        foreach name $hostname {
            if { $spawn_id == $spawn_ids($name) } {
                set ipAddr $name
            }
        }
        <a name="::result_debug(14)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Rebooting with save $save option...&#34;
        <a name="::result_debug(15)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;reboot\r&#34;  ;<span class="comment-line"># need to log for debug purposes</span>
        <a name="::slow_send(1)"><a href="./SendSwCmd.tcl.html#::slow_send_1567">::slow_send</a></a> &#34;reboot\r&#34;
        expect {
            -nocase {\(y/N)} {
                <a name="::result_debug(16)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;;
                send &#34;y\n&#34;
            }
            &#34;y - save&#34; {
                if {[regexp -nocase &#34;^n&#34; $save]} {
                    <a name="::result_debug(17)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sent n&#34;
                    send &#34;n\n&#34;
                } else {
                    <a name="::result_debug(18)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sent y&#34;
                    send &#34;y\n&#34;
                }
            }
        }
        expect {
            -nocase &#34;bpe&#34; {
                if {[regexp -nocase &#34;^n&#34; $rebootBpe]} {
                    <a name="::result_debug(19)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sent n&#34;
                    send &#34;n\n&#34;
                } else {
                    <a name="::result_debug(20)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Sent y&#34;
                    send &#34;y\n&#34;
                }
                exp_continue
            }
            &#34;BootRom &gt; &#34; {
                <span class="comment-line">#stuck at boot prompt. Try to get past it</span>
                <a name="::result_debug(21)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nCheckReboot BootRom - send boot&#34;
                send &#34;boot\n&#34;
            }
            &#34;login:&#34; {
                <a name="::result_debug(22)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nCheckReboot login: prompt.  Continue to Wait for switch up&#34;
            }
            &#34; #&#34; {
                <a name="::result_debug(23)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Admin prompt reached after CheckReboot&#34;
                <a name="::result_debug(24)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;;
                set rebootSuccessful 1
            }
            &#34; &gt;&#34; {
                <a name="::result_debug(25)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;User prompt reached after CheckReboot&#34;
                <a name="::result_debug(26)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;;
                set rebootSuccessful 1
            }
            eof {
                <span class="comment-line">#the connection is closed because it is not a console connection</span>
                <span class="comment-line">#make sure Login will not reuse the lost telnet spawn id</span>
                <span class="comment-line">#after reboot</span>
                set rebootSuccessful 1
                set eofEncountered $DUTName$connect
                <a name="::result_debug(27)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;connection closed by switch.&#34;
                set hostname [<a name="::ldelete(2)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> &#34;$hostname&#34; &#34;$ipAddr&#34;];
            }
        }
        set connectIp $DUTName$connect
        if {$eofEncountered!=0} {   ;<span class="comment-line"># one of the connect was a telnet</span>
            <a name="::exSleep(15)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 240
            <span class="comment-line">#if it's a console connection, login</span>
            <span class="comment-line">#if it's not a console connection need to spawn the connection and login</span>
            <span class="comment-line">#in either case calling Login will take care of it</span>
            if {[<a name="::Login(9)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set $eofEncountered]] == 0} {
                <a name="::result_error(13)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Unable to login to switch after reboot&#34;
                return 0
            } else {
                <a name="::SendACmd(11)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show switch&#34;
            }
        }

        set status [<a name="::WaitForReboot(1)"><a href="./SendSwCmd.tcl.html#::WaitForReboot_1446">::WaitForReboot</a></a> $maxWait &#34;after sending reboot command to $DUTName&#34; $masterCheck]
        if {$status == &#34;error&#34;} {
            <a name="::report_start_test(6)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Failed to connect to switch after reboot&#34;
            <a name="::result_error(14)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to connect to switch after reboot&#34;
            <a name="::report_end_test(6)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
            <a name="::SendACmd(12)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show switch&#34;
            <span class="comment-line">#return 0</span>
        }
        if {[<a name="::CheckOperational(2)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a> -waitforloadcfg $waitforloadcfg] != 1} {
            <a name="::result_error(15)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Some slot is not operational&#34;
            puts &#34;@@@@ Some slot is not operational @@@@&#34;
            error &#34;Some slot is not operational&#34;
        }
        <a name="::result_debug(28)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Successfully login&#34;
        set status &#34;ok&#34;
        if {[regexp -nocase &#34;^n&#34; $save]} {
            sleep 2
            set buf [<a name="::SendACmd(13)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config default delete port all&#34;] ;<span class="comment-line"># should not do it for saved config</span>
            set backupStr &#34;Error: This command can only be executed on Master&#34;
            if {[regexp -nocase $backupStr $buf]} {
                set xos_version [<a name="::GetVersion(2)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4]
                if {$xos_version &lt; &#34;11.2.0&#34;} {
                    if { $xos_version &gt;= &#34;10.2.0&#34; } {
                        set virtualRouter VR-Control
                    } else {
                        set virtualRouter VR-1
                    }
                    <a name="::EnableDebugMode(1)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>  ;<span class="comment-line"># needed as 11.1.1.3 requires debug-mode</span>
                    global bcmChassis
                    if {[regexp -nocase $bcmChassis $buf]} {
                        <a name="::SendACmd(14)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.12.2&#34;
                    } else {
                        <a name="::SendACmd(15)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet vr $virtualRouter 10.0.10.2&#34;
                    }
                } else {
                    <span class="comment-line"># SendACmd &#34;telnet msm b&#34;</span>
                    if {[info exists DUT${whichDutNow}_CONNECTB]} {
                        <a name="::Login(10)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECTB] -CheckOperational 0
                    } else {
                        <a name="::SendACmd(16)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet msm b&#34;
                    }
                }
                <a name="::SendACmd(17)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;run msm-failover&#34;
                <span class="comment-line">#         logout   ;# do not send logout as vr-control gets kicked out</span>
                <a name="::Login(11)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT$whichDutNow,connect)
            }
        }
        <a name="::SendACmd(18)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show switch&#34;
        <a name="::SendACmd(19)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ls&#34;
        if {$save == &#34;yes&#34;} {
            lappend checkKeyList &#34;{Config Booted:.*(Factory Default|default.xsf)} exist&#34;
            if {[<a name="::CheckKeyValue(1)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;show switch&#34; $checkKeyList -reportResults 0] == &#34;ok&#34;} {
                <a name="::EnableDebugMode(2)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
                if {[<a name="::CompareRelease(2)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(3)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${numDUT}] &#34;12.0.3.1&#34;] &gt;= 0} {
                    lappend cfbuff &#34;{^0} exist&#34;
                    if {[<a name="::CheckKeyValue(2)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;!cat /proc/jffs2_corruption&#34; $cfbuff -reportResults 0] != &#34;ok&#34;} {
                        <a name="::result_error(16)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;CF corruption happened. Format CF&#34;
                        <a name="::SendACmd(20)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!dd if=/dev/hda7 of=/dev/null bs=1024 count=16384&#34;
                        unset cfbuff
                    } else {
                        global cfg
                        set  message1  &#34;\nOn cfg $cfg
                        Save reboot went to factory default cf on DUT$whichDutNow while running $MAIN(feature_directory) is ok&#34;
                        set tempMsgFile   &#34;/tmp/filedoesnot.txt.[pid]&#34;
                        exec echo $message1 &gt; $tempMsgFile
                        exec mail -s &#34;Save reboot went to Factory default&#34; sqaauto@extremenetworks.com &lt; $tempMsgFile
                        exec rm -f $tempMsgFile
                        <a name="::SendACmd(21)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show tech&#34;
                        <a name="::SendACmd(22)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show log&#34;
                        <a name="::SendACmd(23)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug ems show trace cfgmgr all logto file&#34;
                        <a name="::ConfigGatewayNetwork(2)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
                        <a name="::SendACmd(24)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;upload debug  [lindex $DUTs_info(tftpserverlist) 0] vr [<a name="::GetVrString(3)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $dut]&#34; &#34;NULL&#34; &#34;NULL&#34; &#34;true&#34; &#34;3&#34; &#34;n&#34;
                        <a name="::UnconfigGatewayNetwork(3)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
                        set timeout 10
                        <span class="comment-line"># EY-06-23-2008: Removed call to DumpNvramContent as the /exos/bin/odo</span>
                        <span class="comment-line"># program currently doesn't echo characters properly on the Stacking</span>
                        <span class="comment-line"># and LynxG platforms.</span>
                        <span class="comment-line">#DumpNvramContent</span>
                        <a name="::result_error(17)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Config Booted is Factory Default after save reboot&#34;
                    }
                }
            }

        }
        <a name="::::VerifyBpeOperational(1)"><a href="./vpex.tcl.html#::::VerifyBpeOperational_443">::::VerifyBpeOperational</a></a>;<span class="comment-line"># skipped if not a VPEX/BPE</span>
        <a name="::CLIConnectMode(2)"><a href="./login.tcl.html#::CLIConnectMode_2263">::CLIConnectMode</a></a> -action &#34;reconfigure&#34; 
    }
    return $status
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: WaitForReboot</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: Internal function that performs a login to the current DUT after waiting for wait time</span>
<span class="comment-line">#              prints the expect_buffer to log file, comment to report file</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: comment</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#                set status [WaitForReboot &#34;after sending reboot command to $DUTName&#34;]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::WaitForReboot_1446">proc <a href="SendSwCmd.tcl-annot.html#::::WaitForReboot">::::WaitForReboot</a></a></strong> {wait comment {masterCheck 1} {reLogin &#34;true&#34;}} {
    global whichDutNow connectionTimeout
    
    puts &#34;In WaitForReboot&#34;
    set expect_out(buffer) &#34;No Output:WaitForReboot&#34;
    set timeout 50
    set count 0
    set flag &#34;true&#34;
    exp_send &#34;\r&#34;
    while {$flag == &#34;true&#34;} {
        expect {
            timeout {
                if {$count &gt;= 10} {
                    expect &#34;*&#34;
                    <a name="::SaveOutputBuffer(3)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
                    set timeout $connectionTimeout
                    return &#34;error&#34;
                } else {
                    incr count
                    set flag &#34;true&#34;
                    <a name="::SaveOutputBuffer(4)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
                    send &#34;\r&#34;
                    exp_continue;
                }
            }
            full_buffer {
                set flag &#34;true&#34;
                <a name="::SaveOutputBuffer(5)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
            }
            &#34;assword:&#34; {
                set flag &#34;true&#34;
                <a name="::SaveOutputBuffer(6)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
                send &#34;\r&#34;
                exp_continue;
            }
            &#34;available for login&#34; {
                set flag &#34;true&#34;
                <a name="::SaveOutputBuffer(7)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
                send &#34;\r&#34;
                exp_continue;
            }
            &#34;login:&#34; {
                set flag &#34;false&#34;
                if {$wait != 0} {
                    <a name="::result_debug(29)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Wait for $wait seconds after logging in for ports to come up\n&#34;
                    <a name="::exSleep(16)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> $wait
                }
                <a name="::SaveOutputBuffer(8)"><a href="./SendSwCmd.tcl.html#::SaveOutputBuffer_1024">::SaveOutputBuffer</a></a> $expect_out(buffer)
                global stacking
                if {[regexp -nocase $stacking [<a name="::GetPlatform(2)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]]} {
                    <a name="::exSleep(17)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 56
                }
                if {$reLogin == &#34;true&#34;} {
                    if {[<a name="::try_login_on_switch(1)"><a href="./login.tcl.html#::try_login_on_switch_981">::try_login_on_switch</a></a> $comment &#34;admin&#34; &#34;&#34; $masterCheck]!=-1} {
                        set timeout $connectionTimeout
                        return &#34;ok&#34;
                    }
                } else {
                    set timeout $connectionTimeout
                    return &#34;ok&#34;
                }
            }
            &#34;System RAM Passed&#34; {
                send &#34;\033&#34;
                send &#34;\033&#34;
            }
            &#34;boot: &#34; {
                send &#34;\r&#34;
            }
            &#34;Removable&#34; {
                send &#34;\033&#34;
                send &#34;\033&#34;
            }
            &#34;closed by foreign host&#34; {
                set loginLoop 0
                <a name="::result_print(18)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\nWait for Reboot telnet \
                                 to DUT$whichDutNow Closed Foreign Host\n~~~~~&#34;;
                <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                <a name="::_clearDutConnectionVars(5)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                global DUT${whichDutNow}_CONNECT
                if {[<a name="::Login(12)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                    <a name="::result_error(18)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after foreign host closed&#34;
                    set timeout $connectionTimeout
                    return
                }
            }
            eof {
                <a name="::result_print(19)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\n~~~~~\n1)Wait for Reboot: Connection to DUT$whichDutNow dropped! \
                                Reconnect\n~~~~~\n~~~~~&#34;;
                <span class="comment-line"># The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
                <a name="::_clearDutConnectionVars(6)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
                global DUT${whichDutNow}_CONNECT
                if {[<a name="::Login(13)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
                    <a name="::result_error(19)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after connection dropped&#34;
                    set timeout $connectionTimeout
                    return &#34;&#34;
                }
            }
        }
    }
    set timeout $connectionTimeout
    return &#34;ok&#34;
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: slow_send</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: send a string to the connection character by character </span>
<span class="comment-line">#              wait for echo of a character before sending the next one</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: string</span>
<span class="comment-line"># Output args: 1 if successful </span>
<span class="comment-line">#              0 if not seeing echo character</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             slow_send &#34;unconfig sw all\r&#34;</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::slow_send_1567">proc <a href="SendSwCmd.tcl-annot.html#::::slow_send">::::slow_send</a></a></strong> { command
                 { setTimeout 60   } } {

  <span class="comment-line">#get rid of anything in the buffer</span>
  expect -re &#34;.*&#34;
  set timeout $setTimeout
  set command [<a name="::_EnhanceStackingCli(2)"><a href="./SendSwCmd.tcl.html#::_EnhanceStackingCli_2821">::_EnhanceStackingCli</a></a> $command]
  for { set i 0 } {$i &lt; [string length $command] } {incr i} {
     set character [string index $command $i]
     exp_send -- $character
     expect {
        -ex $character {
           continue
        }
        timeout {
           <a name="::result_debug(30)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;slow_send not seeing echo character.&#34;
           return 0
        }
       &#34;closed by foreign host&#34; {
           set loginLoop 0
           global whichDutNow
           <a name="::result_print(20)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\nslow_send detects telnet \
               to DUT$whichDutNow Closed Foreign Host\n~~~~~&#34;;
           <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
           <a name="::_clearDutConnectionVars(7)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
           global DUT${whichDutNow}_CONNECT
           if {[<a name="::Login(14)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;]&lt;=0} {
               <a name="::result_error(20)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Login is not successful on retry after foreign host closed&#34;
               return 0
           }
       }	   
        eof {
           global whichDutNow
           <a name="::result_print(21)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;\n~~~~~\ntry_login_on_switch detects telnet to DUT$whichDutNow dropped! Reconnect\n~~~~~&#34;;
           <span class="comment-line"># # The connection has been dropped so we have to clean up the spawnId and hostname entries</span>
           <a name="::_clearDutConnectionVars(8)"><a href="./login.tcl.html#::_clearDutConnectionVars_1969">::_clearDutConnectionVars</a></a> $whichDutNow
           global DUT${whichDutNow}_CONNECT
           <a name="::Login(15)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational &#34;0&#34; -masterCheck &#34;0&#34;
        }
     }
  }
  return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: UnconfigSwAll</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that unconfigures the current DUT to factory defaults.</span>
<span class="comment-line">#              Waits for a platform specific waitTime</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: initial_unconfig - yes if called first time</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             UnconfigSwAll</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UnconfigSwAll_1628">proc <a href="SendSwCmd.tcl-annot.html#::::UnconfigSwAll">::::UnconfigSwAll</a></a></strong> {args} {
   global hostname
   global CFG_PLATFORM
   global whichDutNow DUTs_info
   global DUT${whichDutNow}_IP
   global DUT${whichDutNow}_CONNECT DUT${whichDutNow}_CONNECTB
   global chassis
   global stacking
   global stackable
   global efence
   set connect _CONNECT

   global numDUT
   global spawn_id
   global spawn_ids
   global commonEfenceProcess
   global pioneerPlatform
   global bcmChassis bcmStackable bd8kChassis everestChassis

   <a name="::parse_args(4)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> UnconfigSwAll $args {
        initial_unconfig &#34;no&#34;
        at &#34;main&#34;
   }

   <span class="comment-line">#find out the ipAddr of this session in case this is not a console connection</span>
   <span class="comment-line">#this is the address to use if we need to spawn telnet again after </span>
   <span class="comment-line">#unconfig sw</span>
   set telnetIp [set DUT${whichDutNow}_IP]
   set connect [set DUT${whichDutNow}_CONNECT]
   set ipAddr $connect
   foreach name $hostname {
      if { $spawn_id == $spawn_ids($name) } {
         set ipAddr $name
      }
   }
   set telnetIp [set DUT${whichDutNow}_IP]
   set connect [set DUT${whichDutNow}_CONNECT]
   <span class="comment-line">#make sure Login will not reuse the lost telnet spawn id after reboot</span>
   set hostname [<a name="::ldelete(3)"><a href="./misc.tcl.html#::ldelete_3310">::ldelete</a></a> &#34;$hostname&#34; &#34;$telnetIp&#34;];
   if {$telnetIp == $ipAddr} {
       set ipAddr $connect
   }
   <a name="::CLIConnectMode(3)"><a href="./login.tcl.html#::CLIConnectMode_2263">::CLIConnectMode</a></a> -a &#34;forceConsole&#34; -loseCfg &#34;yes&#34;

   if {$at != &#34;download&#34;} {
       <span class="comment-line"># Get version string for xos_version using GetKeyValue, regular DUTs_info unavailable at start</span>
       set promptBuf [<a name="::SendACmd(25)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;&#34;]
       set verList &#34;&#34;
       lappend verList &#34;{XOS|XCM|NOS|OS version} 1&#34;
       set xos_version [<a name="::GetKeyValue(2)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show version&#34; $verList]
        if {[regexp &#34;KEY_NOT_FOUND&#34; $xos_version]} {
          puts &#34;Unconfig Switch All failed to get the version&#34;
          <a name="::logout(1)"><a href="./logout.tcl.html#::logout_21">::logout</a></a>
          set xos_version [<a name="::GetKeyValue(3)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show version&#34; $verList]
          
       }
       if {[regexp &#34;KEY_NOT_FOUND&#34; $xos_version]} {
         <a name="::result_debug(31)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;failed to get exos version - generating connectionBad&#34;
         return &#34;connectionBad&#34;
       }

        <span class="comment-line">################################################</span>
        <span class="comment-line"># Activate Electric Fence</span>
        <span class="comment-line">################################################</span>
        if {[info exists efence]} {
            set goEfence 1
            if {!($initial_unconfig == &#34;yes&#34;)} {
                set goEfence 0
                if {$at != &#34;download&#34;} {
                    <a name="::disableEfence(1)"><a href="./SendSwCmd.tcl.html#::disableEfence_2957">::disableEfence</a></a>
                }
            } else {
                if {([llength $efence] == 1) &amp;&amp; ([lindex $efence 0] == &#34;no&#34;)} {
                    set goEfence 0
                    <a name="::disableEfence(2)"><a href="./SendSwCmd.tcl.html#::disableEfence_2957">::disableEfence</a></a>
                } else {

                    <a name="::CheckOperational(3)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>
                    <a name="::SendACmd(26)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable clip&#34;
                    set getKeyList &#34;&#34;
                    lappend getKeyList &#34;{Image Selected:} 1&#34;
                    lappend getKeyList &#34;{Image Booted:} 1&#34;
                    lappend getKeyList &#34;{Primary ver:} 1&#34;
                    lappend getKeyList &#34;{Secondary ver:} 1&#34;
                    set shSwResults [<a name="::GetKeyValue(4)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $getKeyList]
                    <a name="::result_debug(32)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;the MSMs state: $shSwResults&#34;
                    set partitionSelected [lindex $shSwResults 0]
                    set partitionBooted [lindex $shSwResults 1]
                    set primaryBuild [lindex $shSwResults 2]
                    set secondaryBuild [lindex $shSwResults 3]

                    set preEfenceRebootNeeded false
                    set xos_version_for_efence $xos_version
                    if {$partitionBooted != $partitionSelected} {
                        set preEfenceRebootNeeded true
                        if {$partitionSelected == &#34;secondary&#34;} {
                            set xos_version_for_efence $secondaryBuild
                        } else {
                            set xos_version_for_efence $primaryBuild
                        }
                    }

                    <span class="comment-line">#report_start_test &#34;efence activation on DUT${whichDutNow}&#34;</span>
                    <span class="comment-line">#if {!([CompareRelease $xos_version_for_efence 12.0.3] &gt;=0)} {</span>
                    <span class="comment-line">#    result_skip &#34;$xos_version_for_efence doesn't support efence on DUT${whichDutNow}&#34;</span>
                    <span class="comment-line">#    set goEfence 0</span>
                    <span class="comment-line">#} elseif {([regexp -nocase &#34;$stacking&#34; $promptBuf] == 1)} {</span>
                    <span class="comment-line">#    result_skip &#34;skipping efence for a stack on DUT${whichDutNow}&#34;</span>
                    <span class="comment-line">#    set goEfence 0</span>
                    <span class="comment-line">#    set goEfence 1 </span>
                    <span class="comment-line">#} elseif {([regexp -nocase &#34;$stackable&#34; $promptBuf] == 1)} {</span>
                    <span class="comment-line">#    result_skip &#34;skipping efence for a stackable on DUT${whichDutNow}&#34;</span>
                    <span class="comment-line">#    set goEfence 0</span>
                    <span class="comment-line">#    set goEfence 1 </span>
                    <span class="comment-line">#} elseif {$preEfenceRebootNeeded} {</span>
                    <span class="comment-line">#    result_debug &#34;rebooting - Image Selected differs from Image Booted&#34;</span>
                    <span class="comment-line">#    CheckReboot $whichDutNow</span>
                    <span class="comment-line">#    set xos_version $xos_version_for_efence</span>
                    <span class="comment-line">#}</span>

                    if {$goEfence} {
                        result_h1 &#34;Activating Electric Fence on DUT${whichDutNow} MSM A&#34;
                        <span class="comment-line"># msm A</span>
                        <a name="::Login(16)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational 0 -masterCheck 0
                        <a name="::EnableDebugMode(3)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
                        <a name="::SendACmd(27)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm disable heapdbg process all&#34;
                        <a name="::result_ok(6)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;disabling  efence for all processes on DUT${whichDutNow}&#34;
                        <a name="::exSleep(18)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                        if {[info exist commonEfenceProcess] } {
                            <a name="::SendACmd(28)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm enable heapdbg process $commonEfenceProcess&#34;
                        } else {
                            <a name="::SendACmd(29)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm enable heapdbg process hal&#34;
                        } 
                        if {[llength $efence] &gt;= 1} {
                            foreach exosProcess $efence {
                                <a name="::SendACmd(30)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm enable heapdbg process $exosProcess&#34;
                                <a name="::result_ok(7)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;enabling efence for $exosProcess on DUT${whichDutNow}&#34;
                                <a name="::exSleep(19)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                            }
                        }
                        <a name="::DisableDebugMode(1)"><a href="./misc.tcl.html#::DisableDebugMode_2957">::DisableDebugMode</a></a>
                        global DUT${whichDutNow}_CONNECTB
                        if {[info exists DUT${whichDutNow}_CONNECTB]} {
                            result_h1 &#34;Activating Electric Fence on DUT${whichDutNow} MSM B&#34;
                            <span class="comment-line"># msm B</span>
                            <a name="::Login(17)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECTB] -CheckOperational 0 -masterCheck 0
                            <a name="::EnableDebugMode(4)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
                            <a name="::SendACmd(31)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm disable heapdbg process all&#34;
                            <a name="::result_ok(8)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;disabling  efence for all processes on DUT${whichDutNow} MSM B&#34;
                            <a name="::exSleep(20)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                            if {[info exist commonEfenceProcess] } {
                                <a name="::SendACmd(32)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm enable heapdbg process $commonEfenceProcess&#34;
                            } else {
                                <a name="::SendACmd(33)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm enable heapdbg process hal&#34;
                            } 
                            if {[llength $efence] &gt;= 1} {
                                foreach exosProcess $efence {
                                    <a name="::SendACmd(34)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm enable heapdbg process $exosProcess&#34;
                                    <a name="::result_ok(9)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;enabling efence for $exosProcess on DUT${whichDutNow}&#34;
                                    <a name="::exSleep(21)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 2
                                }
                            }
                            <a name="::DisableDebugMode(2)"><a href="./misc.tcl.html#::DisableDebugMode_2957">::DisableDebugMode</a></a>
                            <a name="::Login(18)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECT] -CheckOperational 0 -masterCheck 0
                        }
                    } else {  
                        <a name="::disableEfence(3)"><a href="./SendSwCmd.tcl.html#::disableEfence_2957">::disableEfence</a></a>
                    }
                    <span class="comment-line">#report_end_test</span>
                }
            }
        } else {
            <a name="::disableEfence(4)"><a href="./SendSwCmd.tcl.html#::disableEfence_2957">::disableEfence</a></a>
        }
   }
   <a name="::result_debug(33)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send Unconfig switch to DUT${whichDutNow}&#34;
   <a name="::result_debug(34)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Reseting to factory defaults...&#34;

   <span class="comment-line">#</span>
   <span class="comment-line"># Add code to send unconfigure switch all in download to cover 16.1.1 admin password hash issue</span>
   <span class="comment-line">#   and support versions lower than 16.1</span>
   <span class="comment-line">#   Stack cannot be supported due to unc sw all not being supported</span>
   global DUT${whichDutNow}_Stacking_msma_slot
   set SystemName &#34;Stack&#34;
   set pList &#34;&#34;;
   lappend pList &#34;{^SysName:} 1&#34;;
   lappend pList &#34;{^System Type:} 1&#34;;
   lappend pList &#34;{^System Type:} 2&#34;;
   set SystemName [<a name="::GetKeyValue(5)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $pList]
   unset pList;
   if {[info exists at] &amp;&amp; $at == &#34;download&#34; &amp;&amp; [regexp {[0-9]} $SystemName] &amp;&amp; \
       ![regexp -nocase &#34;stack&#34; &#34;$SystemName&#34;] &amp;&amp; ![regexp -nocase &#34;vpex&#34; $CFG_PLATFORM(${whichDutNow})]} {
            <span class="comment-line"># Case - in download and not Stack</span>
            <a name="::result_debug(35)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT${whichDutNow} Now sending unconfig switch ALL in DOWNLOAD for no STACK&#34;
            send &#34;unconfig switch all\r&#34;
   } elseif {$initial_unconfig == &#34;yes&#34; &amp;&amp; ![regexp -nocase &#34;stack&#34; &#34;$SystemName&#34;] &amp;&amp; \
       ![info exists DUT${whichDutNow}_Stacking_msma_slot] &amp;&amp; ![regexp -nocase &#34;vpex&#34; $CFG_PLATFORM(${whichDutNow})] &amp;&amp; \
       ([regexp -nocase &#34;$bd8kChassis|$everestChassis&#34; $SystemName] || \
        [regexp -nocase $bcmStackable $SystemName])} {
        <a name="::result_debug(36)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT${whichDutNow} Initial unconfigure - Now sending unconfig switch ALL&#34;
        send &#34;unconfig switch all\r&#34;
   } else {
        <a name="::result_debug(37)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;DUT${whichDutNow} Now sending unconfig switch&#34;
        send &#34;unconfig switch\r&#34;
   }

   set timeout 5
   expect {
       timeout {
           puts &#34;No more y/N prompts. Continue&#34;
       }
       -nocase {\(y/N)} {
           puts &#34;@@@@\nDUT$whichDutNow  GOT A Y/N AND SENT YES&#34;;
           send &#34;y\r&#34;
           exp_continue;
       }
   }

   global connectionTimeout
   set timeout $connectionTimeout;

   set waitcom &#34;Wait for reboot after Unconfigure Switch&#34;
   set status [<a name="::WaitForReboot(2)"><a href="./SendSwCmd.tcl.html#::WaitForReboot_1446">::WaitForReboot</a></a> 90 $waitcom 0 &#34;false&#34;];<span class="comment-line"># false to avoid login at this time</span>
   if {$status == &#34;error&#34;} {
       <a name="::report_start_test(7)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Failed to reach a login prompt after unconfigure switch&#34;
       <a name="::result_error(21)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to reach a login prompt after unconfigure switch&#34;
       <a name="::report_end_test(7)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   }

   <span class="comment-line"># Proc to handle extra delay. In cases where there may be a delay after login reached</span>
   <a name="::_UncSwitchDelay(1)"><a href="./sleep.tcl.html#::_UncSwitchDelay_303">::_UncSwitchDelay</a></a> -dut $whichDutNow

   if {[<a name="::Login(19)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $ipAddr -masterCheck 0 -CheckOperational 0] == 0} {
       if {[info exists at] &amp;&amp; $at == &#34;download&#34;} {
           <a name="::result_debug(38)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Unable to login to switch after reboot&#34;
           return 0
       } else {
           <a name="::result_error(22)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Unable to login to switch after reboot&#34;
           return 0
       }
   }
   if {[<a name="::CheckOperational(4)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>] != 1} {
      <a name="::result_error(23)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Some slot is not operational&#34;
      puts &#34;@@@@ Some slot is not operational @@@@&#34;
      error &#34;Some slot is not operational&#34;
   }
   <a name="::result_debug(39)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;
   <a name="::result_debug(40)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Successfully login&#34;
   <a name="::exSleep(22)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 3
   set buf [<a name="::SendACmd(35)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config default delete port all&#34;]
   set backupStr &#34;Error: This command can only be executed on Master&#34;
   if {[regexp -nocase $backupStr $buf]} {
      if {[info exists DUT${whichDutNow}_CONNECTB]} {
          <a name="::Login(20)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${whichDutNow}_CONNECTB] -CheckOperational 0
      } else {
          <a name="::SendACmd(36)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;telnet msm b&#34;
      }
      <a name="::SendACmd(37)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;run msm-failover&#34;
      <a name="::Login(21)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $connect
      global bcmChassis
      if {[regexp -nocase $bcmChassis $buf]} {
          <a name="::exSleep(23)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 100  ;<span class="comment-line"># Aspen resets line cards after failover</span>
      } else {
          <a name="::exSleep(24)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 30
      }
      if {[<a name="::CheckOperational(5)"><a href="./login.tcl.html#::CheckOperational_653">::CheckOperational</a></a>] != 1} {
          <a name="::result_error(24)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Some slot is not operational&#34;
          puts &#34;@@@@ Some slot is not operational @@@@&#34;
          error &#34;Some slot is not operational&#34;
      }
      <a name="::SendACmd(38)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;&#34;
      <a name="::SendACmd(39)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config default delete port all&#34;
   }
   <a name="::CLIConnectMode(4)"><a href="./login.tcl.html#::CLIConnectMode_2263">::CLIConnectMode</a></a> -a &#34;reconfigure&#34;
   <span class="comment-line">#CreateRegLogFilter</span>
   if {$at != &#34;download&#34;} {
       <a name="::::VerifyBpeOperational(2)"><a href="./vpex.tcl.html#::::VerifyBpeOperational_443">::::VerifyBpeOperational</a></a>;<span class="comment-line"># skipped if not a bpe platform</span>
   }
   return 1
}


<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: CheckUploadConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that checks the success/failure of upload config of a file in filename from a list of </span>
<span class="comment-line">#              tftp servers tftpServerList</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: tftpServerList, filename</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [CheckUploadConfig $tftpServerList $filename ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckUploadConfig_1925">proc <a href="SendSwCmd.tcl-annot.html#::::CheckUploadConfig">::::CheckUploadConfig</a></a></strong> {tftpServerList filename} {

   set waitTime 50
   
   set tftpServerList [<a name="::GetRandomTFTPList(1)"><a href="./downLoadCode.tcl.html#::GetRandomTFTPList_1151">::GetRandomTFTPList</a></a> $tftpServerList]
   foreach TFTPServerIP $tftpServerList {
      <a name="::result_debug(41)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Start uploading config $filename from $TFTPServerIP&#34;
      set status [<a name="::UploadConfig(1)"><a href="./SendSwCmd.tcl.html#::UploadConfig_1965">::UploadConfig</a></a> $TFTPServerIP $filename $waitTime ]

      if {$status == &#34;legal&#34;} {
         set status $TFTPServerIP
         break
      }
      flush stdout
   }
   <a name="::report_start_test(8)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Uploading config file $filename to $tftpServerList&#34;
   if {$status == &#34;illegal&#34;} {
      <a name="::result_error(25)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to upload config file to $tftpServerList&#34;
   } else {
      <a name="::result_ok(10)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Config file successfully uploaded to $tftpServerList&#34;
   }
   <a name="::report_end_test(8)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   return $status
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: UploadConfig</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that uploads config of a file in filename from the tftp server in TFTPServerIP</span>
<span class="comment-line">#              wait time is optional and it not ussed currently</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: TFTPServerIP, filename</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [UploadConfig $TFTPServerIP $filename ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UploadConfig_1965">proc <a href="SendSwCmd.tcl-annot.html#::::UploadConfig">::::UploadConfig</a></a></strong> {TFTPServerIP filename {wait 0}} {
   global whichDutNow
   global DUT1_IP

   <a name="::ConfigGatewayNetwork(3)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   <a name="::exSleep(25)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5;
   <a name="::result_debug(42)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Send upload config $TFTPServerIP $filename&#34;
   if {[<a name="::CompareRelease(3)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(4)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow] 11.5]&gt;=0} {
      regsub -nocase {\.cfg} $filename &#34;&#34; filenamenew
<span class="comment-line"># LK 05/01/2008 appending the DUT1_IP to filename while putting it on tftp server to get a unique file name</span>
      set str [<a name="::CheckCmdLegal(3)"><a href="./checkCmdLegality.tcl.html#::CheckCmdLegal_58">::CheckCmdLegal</a></a> &#34;upload configuration  $TFTPServerIP \
      ${filenamenew}_$DUT1_IP.xsf vr [<a name="::GetVrString(4)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow]&#34;]
   } else {
      <a name="::SendACmd(40)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;save config toBeUploaded&#34;
<span class="comment-line"># LK 05/01/2008 appending the DUT1_IP to filename while putting it on tftp server to get a unique file name</span>
      set str [<a name="::CheckCmdLegal(4)"><a href="./checkCmdLegality.tcl.html#::CheckCmdLegal_58">::CheckCmdLegal</a></a> &#34;tftp $TFTPServerIP -v [<a name="::GetVrString(5)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow] -p -l toBeUploaded.cfg -r ${filename}_$DUT1_IP&#34;]
<span class="comment-line">#   SendACmd &#34;rm toBeUploaded.cfg&#34;</span>
   }
   <a name="::UnconfigGatewayNetwork(4)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   return $str
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: GetBladeInfo</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that returns the blade info based on platform and slot number</span>
<span class="comment-line">#              performs checks on the DUT if flag is 3, by default is 1</span>
<span class="comment-line"># Input args: flag, slot</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [GetBladeInfo 1 3]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetBladeInfo_2001">proc <a href="SendSwCmd.tcl-annot.html#::::GetBladeInfo">::::GetBladeInfo</a></a></strong> {{flag &#34;1&#34;} {slot &#34;1&#34;}} {
   set pid _[pid];
    
   set val &#34;notfound&#34;;  
   if {$flag == &#34;3&#34;} {
       global stackable i386Stackable
       if {[regexp -nocase &#34;$stackable|$i386Stackable&#34; [<a name="::GetPlatform(3)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a>]]} {   
           lappend parameterList &#34;{sysName:} 1&#34;;
           set val [<a name="::GetKeyValue(6)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show switch&#34; $parameterList];
       } else {
           lappend parameterList &#34;{HW Module Type:} 1&#34;;
           set val [<a name="::GetKeyValue(7)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot $slot&#34; $parameterList];       
       }
       return $val;
   }   
   
   set fd_in [open &#34;Tmp/tmp_GetSlot$pid&#34; &#34;w&#34;];
   <a name="::SendACmd(41)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show slot&#34; NULL $fd_in;
   close $fd_in;   
   
   set val 0;
   set fd_in [open &#34;Tmp/tmp_GetSlot$pid&#34; &#34;r&#34;];
   while {[gets $fd_in line] != -1} {
      <span class="comment-line">#result_debug &#34;----- Line=|$line|&#34;</span>
      if {[regexp -nocase -indices &#34;Slot&#34; $line matchedRange] == 1} {
          <span class="comment-line">#---found the key</span>
          <span class="comment-line">#puts &#34; ====&gt; $line&#34;;</span>
          incr val;
      }  
   }   

   close $fd_in;
   file delete &#34;Tmp/tmp_GetSlot$pid&#34;;
   
   set k 0;
   set y &#34;&#34;;
   lappend parameterList &#34;{State:} 1&#34;;  
   for {set i 1} {$i &lt;= $val} {incr i} {
       set st [<a name="::GetKeyValue(8)"><a href="./OptionCheck.tcl.html#::GetKeyValue_438">::GetKeyValue</a></a> &#34;show slot $i&#34; $parameterList];    
       if {$st == &#34;Operational&#34;} {
           incr k;
           lappend y $i; 
       }
   }           
   unset parameterList;
      
   if {$flag == &#34;1&#34;} {
       return $k;
   } else {
       return $y;
   }
}

<span class="comment-line">################################################################## </span>
<span class="comment-line"># Procedure Name: SendAndCheckACmd</span>
<span class="comment-line">#   </span>
<span class="comment-line"># Description: proc that sends the command's letter one after other evert 10 mili seconds and check for success</span>
<span class="comment-line">#              the command is supplied in buf</span>
<span class="comment-line">#              returns passed or failed</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: buf</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [SendAndCheckACmd $buf]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::SendAndCheckACmd_2070">proc <a href="SendSwCmd.tcl-annot.html#::::SendAndCheckACmd">::::SendAndCheckACmd</a></a></strong> {buf} {
    <a name="::result_debug(43)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Send ($buf)&#34;;
    for {set i 0} {$i &lt; [string length $buf]} {incr i 1} {
        set letter [string index $buf $i];
        send $letter;
        expect {
            &#34;$letter&#34; {
                after 10;
             }
             timeout {
                 for {set c 0} {$c&lt;10} {incr c} {
                     send $letter;
                     expect {
                         &#34;$letter&#34; {
                             break;
                         }
                         timeout {
                             after 10;
                         }
                     }
                 }
             }
        }
    }
    send &#34;\r&#34;;
    return $ret;
}

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: ConfigGatewayNetwork   </span>
<span class="comment-line"># Description: proc to config the gateway vlan: commvlan or mgmt and add default route</span>
<span class="comment-line">#	       based on the values of global vars: DUTx_IP and defaultRouter etc.  The</span>
<span class="comment-line">#	       purpose is to dynamically set up the gateway network for tftp service instead</span>
<span class="comment-line">#	       to have static setup from config files throughout the regression.</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             ConfigGatewayNetwork;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">################################################################################</span>
<strong><a name="::::ConfigGatewayNetwork_2110">proc <a href="SendSwCmd.tcl-annot.html#::::ConfigGatewayNetwork">::::ConfigGatewayNetwork</a></a></strong> {} {
    global switchPort2DefaultRouter;  
    global defaultRouter;
    global whichDutNow;
    global DUT${whichDutNow}_IP;
    global DUT${whichDutNow}_MASK;
    global RemoveMgmtNetwork;
    global MGMT_REG;


    set xos_version [<a name="::GetVersion(5)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4]

    set ipAddr [set DUT${whichDutNow}_IP]

    if [info exist DUT${whichDutNow}_MASK] {
        set ipMask [set DUT${whichDutNow}_MASK]
    } else {
        set ipMask 24
    }

    <span class="comment-line"># -------- Check to see if the mgmt vlan is already configured ----------</span>
    <span class="comment-line">#         Controled by variable RemoveMgmtNetwork in common.cfg</span>
    set mgmtIpOk 0
    set mgmtGwOk 0
    if {[info exists RemoveMgmtNetwork] &amp;&amp; !$RemoveMgmtNetwork} {
        <a name="::result_debug(44)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nIf mgmt network is properly configured do not repeat the config&#34;
        <a name="::_setShowOutput(1)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen off -log off -res_fmt on
        set mgmt_out [<a name="::SendACmd(42)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show vlan mgmt&#34;]
        if {[regexp -nocase &#34;.*$ipAddr.*&#34; $mgmt_out]} {
            <a name="::result_debug(45)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nFound the mgmt vlan configure with IP $ipAddr&#34;
            set mgmtIpOk 1
        }
        set mgmt_out [<a name="::SendACmd(43)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;show iproute vr vr-mgmt&#34;]
        if {[regexp -nocase &#34;default route *$defaultRouter .*&#34; $mgmt_out]} {
            <a name="::result_debug(46)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nFound the mgmt vlan default gateway $defaultRouter&#34;
            set mgmtGwOk 1
        }
        <a name="::_setShowOutput(2)"><a href="./SendSwCmd.tcl.html#::_setShowOutput_3101">::_setShowOutput</a></a> -screen on -log on -res_fmt on
        if {$mgmtIpOk &amp;&amp; $mgmtGwOk} {
            <a name="::result_debug(47)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Mgmt Network is already configured correctly&#34;
            set MGMT_REG(telnetNeedsConfig) 0
            return;
        }        
    }

    <a name="::result_debug(48)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nConfigGatewayNetwork{}: set up gateway vlan $ipAddr/$ipMask on DUT$whichDutNow&#34;
    if {[regexp -nocase $switchPort2DefaultRouter &#34;mgmt&#34;]} {
        global supportedPlatform
        if {[regexp -nocase &#34;$supportedPlatform&#34; [<a name="::GetPlatform(4)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] || \
        [regexp -nocase &#34;$supportedPlatform&#34; [<a name="::GetSysType(1)"><a href="./misc.tcl.html#::GetSysType_453">::GetSysType</a></a> DUT${whichDutNow}]]} {
            <a name="::SendACmd(44)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfigure mgmt ipaddress&#34;
            if { $xos_version &gt;= &#34;10.6.0&#34; } {
                <a name="::SendACmd(45)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable auto-provision&#34;
                <a name="::exSleep(26)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 3
            }
            set mgmtOk 0
            set mCount 1
            lappend checkKeyList &#34;{Error} notExist&#34;
            while {!$mgmtOk &amp;&amp; $mCount &lt;= 3} {
                if {[<a name="::CheckKeyValue(3)"><a href="./OptionCheck.tcl.html#::CheckKeyValue_47">::CheckKeyValue</a></a> &#34;config mgmt ipa $ipAddr/$ipMask&#34; $checkKeyList \
                              -reportResults 0] != &#34;ok&#34;} {
                    <a name="::result_debug(49)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;--- Mgmt Configuration Failed on attempt $mCount - DUT${whichDutNow} ---&#34;
                    <a name="::SendACmd(46)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable auto-provision&#34;
                    <a name="::SendACmd(47)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable dhcp vlan mgmt&#34;
                    <a name="::SendACmd(48)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;unconfigure mgmt ipaddress&#34;
                    <a name="::exSleep(27)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 3
                    incr mCount
                } else {
                    <a name="::result_debug(50)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Mgmt Port Configuration Passed&#34;
                    set mgmtOk 1
                }
            }
            unset checkKeyList

            <span class="comment-line">#SendACmd &#34;config mgmt ipa $ipAddr/$ipMask&#34;</span>
            set xos_version [<a name="::GetVersion(6)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4]
            if { $xos_version &gt;= &#34;10.2.0&#34; } {
                set virtualRouter VR-mgmt
            } else {
                set virtualRouter VR-0
            }
            <a name="::SendACmd(49)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config ipr add default $defaultRouter vr $virtualRouter&#34;;
        } else {
            <a name="::SendACmd(50)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config mgmt ipa $ipAddr/$ipMask&#34;
        }
    } else {
        set gwPort [<a name="::GetDUTPort(1)"><a href="./ePTPortMapping.tcl.html#::GetDUTPort_78">::GetDUTPort</a></a> $switchPort2DefaultRouter $whichDutNow]
        <a name="::SendACmd(51)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable port $gwPort&#34;;
        sleep 5
        set virtualRouter [<a name="::GetVrString(6)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow];
        <a name="::SendACmd(52)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan commvlan vr $virtualRouter&#34;;
        <a name="::SendACmd(53)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config commvlan add port $gwPort&#34;;
        <a name="::SendACmd(54)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config commvlan ipaddress $ipAddr/$ipMask&#34;;
        <a name="::SendACmd(55)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable ipforwarding vlan commvlan&#34;;
        <a name="::SendACmd(56)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config ipr add default $defaultRouter vr $virtualRouter&#34;;
        <a name="::SendACmd(57)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;show port $gwPort&#34;;
    }
    set MGMT_REG(telnetNeedsConfig) 0
}

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: ConfigFrontPanelGw   </span>
<span class="comment-line"># Description: proc to config the gateway vlan: commvlan or mgmt and add default route</span>
<span class="comment-line">#	       based on the values of global vars: DUTx_IP and defaultRouter etc.  The</span>
<span class="comment-line">#	       purpose is to dynamically set up the gateway network for tftp service instead</span>
<span class="comment-line">#	       to have static setup from config files throughout the regression.</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             ConfigFrontPanelGw;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ConfigFrontPanelGw_2222">proc <a href="SendSwCmd.tcl-annot.html#::::ConfigFrontPanelGw">::::ConfigFrontPanelGw</a></a></strong> {} {
    global frontPanelPortToGw;  
    global fpdefaultRouter;
    global whichDutNow;
    global DUT${whichDutNow}_IP_FP;
    global DUT${whichDutNow}_MASK;

    set ipAddr [set DUT${whichDutNow}_IP_FP]

    if [info exist DUT${whichDutNow}_MASK] {
        set ipMask [set DUT${whichDutNow}_MASK]
    } else {
        set ipMask 24
    }

    <a name="::result_debug(51)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nConfigFrontPanelGw{}: set up gateway vlan $ipAddr/$ipMask on DUT$whichDutNow&#34;
        set gwPort [<a name="::GetDUTPort(2)"><a href="./ePTPortMapping.tcl.html#::GetDUTPort_78">::GetDUTPort</a></a> $frontPanelPortToGw $whichDutNow]
        <a name="::SendACmd(58)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable port $gwPort&#34;;
        sleep 5 
        <span class="comment-line">#set virtualRouter [GetVrString $whichDutNow];</span>
        <a name="::SendACmd(59)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan commvlan vr vr-default&#34;;
        <a name="::SendACmd(60)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config commvlan add port $gwPort&#34;;
        <a name="::SendACmd(61)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config commvlan ipa $ipAddr/$ipMask&#34;;
        <a name="::SendACmd(62)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable ipforwarding vlan commvlan&#34;
        <a name="::SendACmd(63)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config ipr add default $fpdefaultRouter vr vr-default&#34;;
}
<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: GetDutInBandPort</span>
<span class="comment-line"># Description: Proc to configure the frontpanel port on all or a single DUT.  IP</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set fpport [GetDutInBandPort]</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::GetDutInBandPort_2257">proc <a href="SendSwCmd.tcl-annot.html#::::GetDutInBandPort">::::GetDutInBandPort</a></a></strong> {} {
    global whichDutNow;
    global DUT${whichDutNow}_IP_FP;
    global DUT${whichDutNow}_DefaultBlade_FP
    global frontPanelPortToGw

    if {[info exists DUT${whichDutNow}_DefaultBlade_FP] &amp;&amp; [set DUT${whichDutNow}_DefaultBlade_FP] != &#34;0&#34;} {
        return [set DUT${whichDutNow}_DefaultBlade_FP]:$frontPanelPortToGw
    } else {
        return $frontPanelPortToGw
    }
}
<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: ConfigInBandNetwork</span>
<span class="comment-line"># Description: Proc to configure the frontpanel port on all or a single DUT.  IP</span>
<span class="comment-line">#              addresses are taken from the config file.  The inband network has</span>
<span class="comment-line">#              regression servers located on it.  It is isolated from the lab net</span>
<span class="comment-line">#              completely, except for a single link that allows routing to mgmt</span>
<span class="comment-line">#              ports.  This enables testing of mgmt and frontpanel ports on a more</span>
<span class="comment-line">#              isolated lab environment.</span>
<span class="comment-line"># Input args: DUT</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             ConfigFrontPanelGw;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::ConfigInBandNetwork_2283">proc <a href="SendSwCmd.tcl-annot.html#::::ConfigInBandNetwork">::::ConfigInBandNetwork</a></a></strong> {} {
    global frontPanelPortToGw;
    global fpdefaultRouter;
    global whichDutNow;
    global DUT${whichDutNow}_IP_FP;
    global DUT${whichDutNow}_MASK;
    global DUT${whichDutNow}_DefaultBlade_FP
    global GetDUTPort
    global USE_FP_PORT
    set USE_FP_PORT 1
    if {$whichDutNow &gt; 2} {
        puts &#34;InBand ports are only connected to DUT1 and DUT2&#34;
        return;
    }
    if {![info exists DUT${whichDutNow}_IP_FP]} {
        <a name="::result_debug(52)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No config file definition for DUT${whichDutNow}_IP_FP&#34;
        return;
    }
    set ipAddr [set DUT${whichDutNow}_IP_FP]

    set ipMask 24
    if {[info exists DUT${whichDutNow}_DefaultBlade_FP] &amp;&amp; [set DUT${whichDutNow}_DefaultBlade_FP] != &#34;0&#34;} {
        set gwPort [set DUT${whichDutNow}_DefaultBlade_FP]:$frontPanelPortToGw
    } else {
        set gwPort $frontPanelPortToGw
    }
    <a name="::result_debug(53)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nConfigInBandNetwork{}: set up commvlan network $ipAddr/$ipMask on DUT$whichDutNow&#34;
        <a name="::SendACmd(64)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable port $gwPort&#34;;
        sleep 5
        <a name="::SendACmd(65)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;create vlan commvlan vr vr-default&#34;;
        <a name="::SendACmd(66)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;configure commvlan add port $gwPort&#34;;
        <a name="::SendACmd(67)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;configure commvlan ipaddress $ipAddr/$ipMask&#34;;
        <a name="::SendACmd(68)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;enable ipforwarding vlan commvlan&#34;
        <a name="::SendACmd(69)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;configure iproute add default $fpdefaultRouter vr vr-default&#34;;
}
<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: UnconfigInBandNetwork</span>
<span class="comment-line"># Description: Delete the inband vlan and the static route associatated.</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             UnconfigGatewayNetwork;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UnconfigInBandNetwork_2327">proc <a href="SendSwCmd.tcl-annot.html#::::UnconfigInBandNetwork">::::UnconfigInBandNetwork</a></a></strong> {} {
    global fpdefaultRouter;
    global frontPanelPortToGw
    global whichDutNow;
    global DUT${whichDutNow}_DefaultBlade_FP
    global USE_FP_PORT
    set USE_FP_PORT 0

    if {[info exists DUT${whichDutNow}_DefaultBlade_FP] &amp;&amp; [set DUT${whichDutNow}_DefaultBlade_FP] != &#34;0&#34;} {
        set gwPort [set DUT${whichDutNow}_DefaultBlade_FP]:$frontPanelPortToGw
    } else {
        set gwPort $frontPanelPortToGw
    }
    <a name="::SendACmd(70)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable port $gwPort&#34;;
    <a name="::SendACmd(71)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete vlan commvlan&#34;;
    <a name="::SendACmd(72)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config iproute delete default $fpdefaultRouter vr vr-default&#34;;
}
<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: UnconfigGatewayNetwork   </span>
<span class="comment-line"># Description: proc to unconfig the gateway vlan: commvlan or mgmt and delete default route</span>
<span class="comment-line">#	       based on the values of global vars: DUTx_IP and defaultRouter etc.  The</span>
<span class="comment-line">#	       purpose is to dynamically remove the commvlan as tftp service is finished</span>
<span class="comment-line">#	       instead to have static setup from config files throughout the regression.</span>
<span class="comment-line"># Input args: n/a</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             UnconfigGatewayNetwork;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UnconfigGatewayNetwork_2356">proc <a href="SendSwCmd.tcl-annot.html#::::UnconfigGatewayNetwork">::::UnconfigGatewayNetwork</a></a></strong> {args} {
    global switchPort2DefaultRouter; 
    global defaultRouter;
    global whichDutNow;
    global RemoveMgmtNetwork;
 
    <a name="::parse_args(5)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> UnconfigGatewayNetwork $args {
        force   0
    }
    
    if {[regexp -nocase $switchPort2DefaultRouter &#34;mgmt&#34;] &amp;&amp; \
            ([info exists RemoveMgmtNetwork] &amp;&amp; $RemoveMgmtNetwork || $force)} {
        <a name="::result_debug(54)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nUnconfigGatewayNetwork{}: delete gateway vlan on DUT$whichDutNow&#34;
        <a name="::SendACmd(73)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable auto-provision&#34;;
        <a name="::SendACmd(74)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;unconf mgmt ipaddress&#34;;
        global supportedPlatform
        if {[regexp -nocase &#34;$supportedPlatform&#34; [<a name="::GetPlatform(5)"><a href="./misc.tcl.html#::GetPlatform_478">::GetPlatform</a></a> DUT${whichDutNow}]] || \
               [regexp -nocase &#34;$supportedPlatform&#34; [<a name="::GetSysType(2)"><a href="./misc.tcl.html#::GetSysType_453">::GetSysType</a></a> DUT${whichDutNow}]]} {
            set xos_version [<a name="::GetVersion(7)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow 4]
            if { $xos_version &gt;= &#34;10.2.0&#34; } {
                set virtualRouter VR-mgmt
            } else {
                set virtualRouter VR-0
            }
            <a name="::SendACmd(75)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config ipr del default $defaultRouter vr $virtualRouter&#34;;
        }
    } elseif {[regexp -nocase $switchPort2DefaultRouter &#34;mgmt&#34;] &amp;&amp; [info exists RemoveMgmtNetwork] &amp;&amp; !$RemoveMgmtNetwork} {
        <span class="comment-line">#         Controled by variable RemoveMgmtNetwork in common.cfg</span>
        <a name="::result_debug(55)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nLeave the mgmt network in place&#34;
        return;
    } else {   
        set gwPort [<a name="::GetDUTPort(3)"><a href="./ePTPortMapping.tcl.html#::GetDUTPort_78">::GetDUTPort</a></a> $switchPort2DefaultRouter $whichDutNow]
        <a name="::SendACmd(76)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;disable port $gwPort&#34;;       
        set virtualRouter [<a name="::GetVrString(7)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow];
        <a name="::SendACmd(77)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;delete commvlan&#34;;
        <a name="::SendACmd(78)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a>    &#34;config ipr delete default $defaultRouter vr $virtualRouter&#34;;  
    }
}

<span class="comment-line">################################################################################</span>
<span class="comment-line"># Procedure Name: UnconfigDutToDefault   </span>
<span class="comment-line"># Description: proc to unconfig the specified DUTs back to factory default except</span>
<span class="comment-line">#	       clipaging and idletimeout are disabled for automation purpose</span>
<span class="comment-line"># Input args: dutList</span>
<span class="comment-line"># Output args: n/a</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             UnconfigDutToDefault &#34;1 2 3&#34;;</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::UnconfigDutToDefault_2405">proc <a href="SendSwCmd.tcl-annot.html#::::UnconfigDutToDefault">::::UnconfigDutToDefault</a></a></strong> {{dutList &#34;1&#34;}} {
  
    global DUTs_info
    foreach dutNo $dutList {
        global DUT${dutNo}_CONNECT
        <a name="::Login(22)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT${dutNo}_CONNECT];
        <a name="::UnconfigSwAll(1)"><a href="./SendSwCmd.tcl.html#::UnconfigSwAll_1628">::UnconfigSwAll</a></a>;
        <a name="::SendACmd(79)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;config default delete port all&#34;
        <a name="::SendACmd(80)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable clip&#34;
        <a name="::SendACmd(81)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;disable idletimeout&#34;
        if {[info exists DUTs_info(DUT${dutNo},coreFileTarget)]} {
            <a name="::SendACmd(82)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;configure debug core-dumps $DUTs_info(DUT${dutNo},coreFileTarget)&#34;
        }
    }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CheckTftpPut</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: proc that checks the put of pol file from given dir to tftp servers</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: fileLocation</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [CheckTftpCopy $TFTPServerIP $fileLocation ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckTftpPut_2435">proc <a href="SendSwCmd.tcl-annot.html#::::CheckTftpPut">::::CheckTftpPut</a></a></strong> {fileLocation args} {
  <a name="::parse_args(6)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckTftpPut $args {
      nameFormat &#34;dynamic&#34;
   }

   global tcl_platform
   global tftpServerList
   global tftpServerLogin
   global tftpServerPasswd
   global tftpServerTftpboot
   global DUT1_IP
   set targetFile [file tail $fileLocation]
   if {$nameFormat == &#34;dynamic&#34;} {
<span class="comment-line"># LK 04/30/2008 appending the DUT1_IP to filename while putting it on tftp server to get a unique file name</span>
   set targetFile ${targetFile}_$DUT1_IP
   }
   set tStartTime [clock seconds]
   set pid [pid]
   set fd_out [open &#34;Tmp/tmp_$pid$tStartTime&#34; &#34;w&#34;];
   puts $fd_out &#34;put $fileLocation $targetFile&#34;
   puts $fd_out &#34;quit&#34;
   close $fd_out
   <a name="::report_start_test(9)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Putting the policy to tftp servers&#34;
   set tftpServerList [<a name="::GetRandomTFTPList(2)"><a href="./downLoadCode.tcl.html#::GetRandomTFTPList_1151">::GetRandomTFTPList</a></a> $tftpServerList]
   foreach TFTPServerIP $tftpServerList {
      <a name="::result_debug(56)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Putting $fileLocation onto tftp Server $TFTPServerIP as $targetFile&#34;
      if {[catch {exec /usr/bin/tftp $TFTPServerIP &lt; ./Tmp/tmp_$pid$tStartTime} reason]} {
         <a name="::result_debug(57)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;error: $reason&#34;
         set status failed
      } else {
        <a name="::result_ok(11)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;File successfully put on tftpservers: $tftpServerList&#34;
        set status passed
      }
   }
   file delete ./Tmp/tmp_$pid$tStartTime
   <a name="::report_end_test(9)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   return $status 
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CheckTftpPutMulti</span>
<span class="comment-line">#</span>
<span class="comment-line"># Description: proc that checks the put of multiple pol file from given dir to tftp servers</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: &#34;filename list&#34;</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [CheckTftpPutMulti &#34;Tmp/file1 Tmp/file2 Tmp/file3 Tmpfile4&#34; ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckTftpPutMulti_2488">proc <a href="SendSwCmd.tcl-annot.html#::::CheckTftpPutMulti">::::CheckTftpPutMulti</a></a></strong> {{nameList} args} {
 <a name="::parse_args(7)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckTftpPutMulti $args {
      nameFormat &#34;dynamic&#34;
   }

   global tcl_platform
   global tftpServerList
   global tftpServerLogin
   global tftpServerPasswd
   global tftpServerTftpboot
   global DUT1_IP MAIN

   set statFailed 0
   foreach fName $nameList {
      if {[info exists MAIN(user)] &amp;&amp; $MAIN(user) == &#34;autotest-rtp&#34;} {
          puts &#34;chmod sudo as autotest-rtp&#34;
          if {[catch {exec sudo chmod 777 $fName} rea]} {
              puts &#34;Failed the chmod 777 tmp file: $rea&#34;
          }
      } else {
          puts &#34;user set file privs&#34;
          if {[catch {exec chmod 777 $fName} rea]} {
              puts &#34;Failed the chmod 777 tmp file: $rea&#34;
          }
      }
      set targetFile [file tail $fName]
   if {$nameFormat == &#34;dynamic&#34;} {
<span class="comment-line"># LK 04/30/2008 appending the DUT1_IP to filename while putting it on tftp server to get a unique file name</span>
      set targetFile ${targetFile}_$DUT1_IP
     }

      set tStartTime [clock seconds]
      set pid [pid]
      set fd_out [open &#34;Tmp/tmp_$pid$tStartTime&#34; &#34;w&#34;];
      puts $fd_out &#34;put $fName $targetFile&#34;
      puts $fd_out &#34;quit&#34;
      close $fd_out
      <a name="::report_start_test(10)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Putting the policy to tftp servers&#34;
      set tftpServerList [<a name="::GetRandomTFTPList(3)"><a href="./downLoadCode.tcl.html#::GetRandomTFTPList_1151">::GetRandomTFTPList</a></a> $tftpServerList]
      foreach TFTPServerIP $tftpServerList {
         <a name="::result_debug(58)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Putting $fName onto tftp Server $TFTPServerIP as $targetFile&#34;
         if {[catch {exec /usr/bin/tftp $TFTPServerIP &lt; ./Tmp/tmp_$pid$tStartTime} reason]} {
            <a name="::result_debug(59)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;error: $reason&#34;
            incr statFailed
         } else {
            <a name="::result_ok(12)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;File successfully put $targetFile on tftpservers: $tftpServerList&#34;
         }
      }
      file delete ./Tmp/tmp_$pid$tStartTime
      <a name="::report_end_test(10)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   }
   if {$statFailed &gt;=1} {
      set status failed
   } else {
      set status passed
   }
   
   return $status 
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CheckTftpGet</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: proc that checks the get of pol file in given dir from tftp servers</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: fileName</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [CheckTftpGet $fileName ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckTftpGet_2562">proc <a href="SendSwCmd.tcl-annot.html#::::CheckTftpGet">::::CheckTftpGet</a></a></strong> {{fileName} args} {

   <a name="::parse_args(8)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckTftpGet $args {
      confGw &#34;yes&#34;
      nameFormat &#34;dynamic&#34;
	  filetype &#34;pol&#34;
   }
   global tftpServerList
   global switchPort2DefaultRouter
   global whichDutNow
   global DUT1_IP

   if  {[regexp -nocase $confGw &#34;yes&#34;]} {
      <a name="::ConfigGatewayNetwork(4)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
      after 5000   ;<span class="comment-line"># needs a delay or else reachability cant be made</span>
   }
   set rtValue &#34;&#34;
   set pid [pid]
   <span class="comment-line"># NOTE: We do not need to randomize the server list here; its already done in CheckTftpPut</span>
  foreach tftpServer $tftpServerList {
    set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;w&#34;]
    set virtualRouter [<a name="::GetVrString(8)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow]
   if {$nameFormat == &#34;dynamic&#34;} {
<span class="comment-line"># LK 04/30/2008 appending the DUT1_IP to filename while getting it from tftp server </span>
<span class="comment-line"># which was added while upload to get a unique file name</span>
    set buff [<a name="::SendACmd(83)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;tftp $tftpServer -v $virtualRouter -g -r ${fileName}_$DUT1_IP -l $fileName.$filetype&#34; NULL $fd_in]
   } else {
    set buff [<a name="::SendACmd(84)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;tftp $tftpServer -v $virtualRouter -g -r ${fileName} -l $fileName.$filetype&#34; NULL $fd_in]
   }
   close $fd_in
    set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;r&#34;]
    set rtValue [<a name="::check_illegality(1)"><a href="./checkCmdLegality.tcl.html#::check_illegality_139">::check_illegality</a></a> $fd_in]
    if {[string compare &#34;legal&#34; $rtValue]==0} {
      close $fd_in
      file delete &#34;Tmp/temp_$pid&#34;
      break
    }
    close $fd_in
    file delete &#34;Tmp/temp_$pid&#34;
  }

   <a name="::report_start_test(11)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Getting the policy from tftp servers&#34;
   if {[string compare &#34;illegal&#34; $rtValue]==0} {
        <a name="::result_error(26)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to get file from tftpservers: $tftpServerList&#34;
   } else {
<span class="comment-line"># SK: PD is fixed as of 11.0.0.20</span>
<span class="comment-line">#      if {![regexp -nocase &#34;BD-marnier|10808&#34; [GetPlatform DUT${whichDutNow}]]} {</span>
<span class="comment-line">#         # Fix for PD2-232904551 </span>
<span class="comment-line">#         EnableDebugMode</span>
<span class="comment-line">#         SendACmd &#34;!mv $fileName.pol /root/config&#34;</span>
<span class="comment-line">#      }</span>
      <a name="::result_ok(13)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;File successfully got from tftpservers: $tftpServerList&#34;
   }
   <a name="::report_end_test(11)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
   if  {[regexp -nocase $confGw &#34;yes&#34;]} {
      <a name="::UnconfigGatewayNetwork(5)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   }
   if {[catch {file delete &#34;/tftp/$targetFile&#34;} reason]} {
      catch {file delete &#34;/tftp2/$targetFile&#34;} reason
   }
   return $rtValue
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CheckTftpGetMulti</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: proc that checks the get of multiple pol files from tftp servers</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: nameList</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [CheckTftpGetMulti &#34;Tmp/name1 Tmp/name2&#34; ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckTftpGetMulti_2640">proc <a href="SendSwCmd.tcl-annot.html#::::CheckTftpGetMulti">::::CheckTftpGetMulti</a></a></strong> {dut {nameList &#34;&#34;} {filetype &#34;pol&#34;} } {
   global tftpServerList
   global switchPort2DefaultRouter
   global whichDutNow
   global DUTs_info
   global DUT1_IP

   <a name="::Login(23)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $DUTs_info(DUT$dut,connect)
   <a name="::ConfigGatewayNetwork(5)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>
   after 5000   ;<span class="comment-line"># needs a delay or else reachability cant be made</span>
   set rtValue &#34;&#34;
   set statFailed 0
   foreach fName $nameList {
      set pid [pid]
      <span class="comment-line"># NOTE: We do not need to randomize the server list here; its already done in CheckTftpPut</span>
      foreach tftpServer $tftpServerList {
         set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;w&#34;]
         set virtualRouter [<a name="::GetVrString(9)"><a href="./misc.tcl.html#::GetVrString_3157">::GetVrString</a></a> $whichDutNow]
<span class="comment-line"># LK 04/30/2008 appending the DUT1_IP to filename while getting it from tftp server </span>
<span class="comment-line"># which was added while upload to get a unique file name</span>
<span class="comment-line"># added for netlogin web </span>
		set buff [<a name="::SendACmd(85)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;tftp $tftpServer -v $virtualRouter -g -r ${fName}_$DUT1_IP -l $fName.$filetype&#34; NULL $fd_in]
         close $fd_in
         set fd_in [open &#34;Tmp/temp_$pid&#34; &#34;r&#34;]
         set rtValue [<a name="::check_illegality(2)"><a href="./checkCmdLegality.tcl.html#::check_illegality_139">::check_illegality</a></a> $fd_in]
         if {[string compare &#34;legal&#34; $rtValue]==0} {
            close $fd_in
            file delete &#34;Tmp/temp_$pid&#34;
            break
         }
         close $fd_in
         file delete &#34;Tmp/temp_$pid&#34;
      }
      <span class="comment-line">##############################################################</span>
      <a name="::report_start_test(12)"><a href="./report.tcl.html#::report_start_test_79">::report_start_test</a></a> &#34;Getting the policy from tftp servers&#34;
      <span class="comment-line">##############################################################</span>
      if {[string compare &#34;illegal&#34; $rtValue]==0} {
           <a name="::result_error(27)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Failed to get file $fName from tftpservers: $tftpServerList&#34;
           incr statFailed
           return &#34;illegal&#34;
      } else {
         <a name="::result_ok(14)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;File successfully got $fName from tftpservers: $tftpServerList&#34;
      }
      <a name="::report_end_test(12)"><a href="./report.tcl.html#::report_end_test_122">::report_end_test</a></a>
      
      if {[catch {file delete &#34;/tftp/$targetFile&#34;} reason]} {
         catch {file delete &#34;/tftp2/$targetFile&#34;} reason
      }
   }
   <a name="::UnconfigGatewayNetwork(6)"><a href="./SendSwCmd.tcl.html#::UnconfigGatewayNetwork_2356">::UnconfigGatewayNetwork</a></a>
   if {$statFailed&gt;=1} {
      return &#34;illegal&#34;
   } else {
      return &#34;legal&#34;
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: CheckTftpGetMultiWrapper</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: proc that checks the get of multiple pol files from tftp servers</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: nameList</span>
<span class="comment-line"># Output args: none</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             set status [CheckTftpGetMultiWrapper &#34;Tmp/name1 Tmp/name2&#34; ]</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Setup</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::CheckTftpGetMultiWrapper_2711">proc <a href="SendSwCmd.tcl-annot.html#::::CheckTftpGetMultiWrapper">::::CheckTftpGetMultiWrapper</a></a></strong> {dut {nameList &#34;&#34;}} {
   global regRouterMGMTPorts

   if {[<a name="::CheckTftpGetMulti(1)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$nameList&#34;] == &#34;legal&#34;} {
      return &#34;legal&#34;;
   } else {
      if {[info exists regRouterMGMTPorts]} {
         set portList [split $regRouterMGMTPorts]
         foreach portnum $portList {
            if { $portnum == &#34;&#34; } {
               continue
            }
            lappend pList $portnum
         }
         set portList [join $pList &#34;,&#34;]
         set status [<a name="::::EnableRegRouterMgmtLinks(1)"><a href="./swConf.tcl.html#::::EnableRegRouterMgmtLinks_396">::::EnableRegRouterMgmtLinks</a></a> $portList]
         if {$status == &#34;Error&#34;} {
            return illegal
         } else {
            return [<a name="::CheckTftpGetMulti(2)"><a href="./SendSwCmd.tcl.html#::CheckTftpGetMulti_2640">::CheckTftpGetMulti</a></a> $dut &#34;$nameList&#34;];
         }
      } else {
         return illegal
      }
   }

}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: _EnhanceShowPortCli</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cmd</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_EnhanceShowPortCli_2753">proc <a href="SendSwCmd.tcl-annot.html#::::_EnhanceShowPortCli">::::_EnhanceShowPortCli</a></a></strong> {cmd} {
   global whichDutNow

   set cmdToReturn $cmd
   if {[regexp -nocase {^sh[ow]* *por[ts]*} $cmd]&amp;&amp;![regexp -nocase &#34;clean$|no-refresh$&#34; $cmd] &amp;&amp; \
                ![regexp -nocase &#34;info|redun|shar|util|protocol|buffer|debounce|group|link-scan&#34; $cmd]} {
      set majmin [<a name="::GetVersion(8)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT${whichDutNow} majmin]
      if {$majmin&gt;=11.3} {
         <span class="comment-line"># For 11.3 onwards, add no-refresh/clean in show ports cli</span>
         set cmdToReturn &#34;$cmd no-refresh&#34;
      }
   }
   return $cmdToReturn
}

<strong><a name="::::_EnhanceShowlog_2768">proc <a href="SendSwCmd.tcl-annot.html#::::_EnhanceShowlog">::::_EnhanceShowlog</a></a></strong> {cmd} {

   set cmdToReturn $cmd
   regsub {(sh[ow]* * lo[g]* *) (war*|cri*|deb*|err*|inf*|not*)} $cmd &#34;\\1 severity \\2&#34; cmdToReturn
   return $cmdToReturn
}

<strong><a name="::::_EnhanceJerryShow_2775">proc <a href="SendSwCmd.tcl-annot.html#::::_EnhanceJerryShow">::::_EnhanceJerryShow</a></a></strong> {cmd} {
   global whichDutNow
   set cmdToReturn $cmd
   if {[<a name="::CompareRelease(4)"><a href="./misc.tcl.html#::CompareRelease_891">::CompareRelease</a></a> [<a name="::GetVersion(9)"><a href="./misc.tcl.html#::GetVersion_303">::GetVersion</a></a> DUT$whichDutNow] 12.1] &gt;= 0} {
      regsub {(jer[rry]* *sh[ow]* *) (vl[an]*.*|upm*.*)} $cmd &#34;debug show \\2&#34; cmdToReturn
      regsub {(jer[rry]* (vl[an]*.*|upm*.*) *sh[ow]* *)} $cmd &#34;debug \\2 show &#34; cmdToReturn
   }
   return $cmdToReturn
}

<span class="comment-line">##################################################################</span>
<span class="comment-line"># Add ability to match cmd echo from the terminal with CR added</span>
<span class="comment-line">#   due to column width settings in 22.2 and 16.2</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_GetShortCmd_2795">proc <a href="SendSwCmd.tcl-annot.html#::::_GetShortCmd">::::_GetShortCmd</a></a></strong> {cmd} {
   if {[string length $cmd] &gt; 200} {
       set a [string range $cmd 0 190]
       set l [expr [string length $cmd] - 2]
       set b [string range $cmd $l end]
       set regExCmd &#34;${a}.*${b}&#34;
       <span class="comment-line">#puts &#34;\nRegEx cli to match:\n$regExCmd&#34;</span>
       return $regExCmd
   } else {
       return $cmd
   }
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: _EnhanceStackingCli</span>
<span class="comment-line">#  </span>
<span class="comment-line"># Description: </span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: cmd</span>
<span class="comment-line"># Output args: </span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#             </span>
<span class="comment-line">#</span>
<span class="comment-line"># Category Types (Setup,GetSwitchInfo,SendTraffic,CaptureTraffic,VerifySwitchOutput</span>
<span class="comment-line">#                          VerifyTraffic)</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_EnhanceStackingCli_2821">proc <a href="SendSwCmd.tcl-annot.html#::::_EnhanceStackingCli">::::_EnhanceStackingCli</a></a></strong> {cmd} {
   global whichDutNow

   if {![info exists whichDutNow]} {
      set whichDutNow 1
   }

   set cmdToReturn $cmd
   global DUT${whichDutNow}_Stacking_msmb_slot DUT${whichDutNow}_Stacking_msma_slot
   if {[regexp -nocase &#34;msm *a|slot *a$|slot *a &#34; $cmd]} {
      if [info exists DUT${whichDutNow}_Stacking_msma_slot] {
         regsub -all -nocase &#34;msm *a&#34; $cmd &#34;slot [set DUT${whichDutNow}_Stacking_msma_slot]&#34; cmdToReturn
         regsub -all -nocase &#34;slot *a&#34; $cmdToReturn &#34;slot [set DUT${whichDutNow}_Stacking_msma_slot]&#34; cmdToReturn
       }
   } elseif {[regexp -nocase &#34;msm *b|slot *b$|slot *b &#34; $cmd]} {
      if [info exists DUT${whichDutNow}_Stacking_msmb_slot] {
         regsub -all -nocase &#34;msm *b&#34; $cmd &#34;slot [set DUT${whichDutNow}_Stacking_msmb_slot]&#34; cmdToReturn
         regsub -all -nocase &#34;slot *b&#34; $cmdToReturn &#34;slot [set DUT${whichDutNow}_Stacking_msmb_slot]&#34; cmdToReturn
      }
   }
   if {[regexp -nocase &#34;run *msm-fail&#34; $cmd]} {
      if [info exists DUT${whichDutNow}_Stacking_msma_slot] {
         regsub -all -nocase &#34;msm-fa&#34; $cmd &#34;fa&#34; cmdToReturn
      }
   }
   return $cmdToReturn
}
<span class="comment-line">##################################################################</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::_EnhanceVpexCli_2854">proc <a href="SendSwCmd.tcl-annot.html#::::_EnhanceVpexCli">::::_EnhanceVpexCli</a></a></strong> {cmd} {
    global whichDutNow

    set exceptions &#34;edp&#34;
    if {![info exists whichDutNow]} {
        set whichDutNow 1
    }
    if {![regexp -nocase {[0-9]+} $whichDutNow]} {
        set whichDutNow 1
    }
    set cmdToReturn $cmd

    if {[regexp -nocase {dis[able]{0,4}.*po[rts]{0,3} all} $cmd]} {
        if {[regexp -nocase &#34;$exceptions&#34; $cmd]} {
            return $cmdToReturn
        }
        set dutPortList [<a name="::_getDutPorts(1)"><a href="./PortMapping.tcl.html#::_getDutPorts_546">::_getDutPorts</a></a> -dut $whichDutNow]
        set newPorts [regsub &#34;all&#34; $cmd $dutPortList cmdToReturn]
        return $cmdToReturn
    } elseif {[regexp -nocase {rest[art]{0,3}.*po[rts]{0,3} ([0-9:,\- ]+|all)} $cmd allmatch myPorts]} {
        if {[regexp -nocase &#34;all&#34; $myPorts]} {
            set myPorts [<a name="::_getDutPorts(2)"><a href="./PortMapping.tcl.html#::_getDutPorts_546">::_getDutPorts</a></a> -dut $whichDutNow]
        }
        <a name="::result_debug(60)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;VPEX Restart port replace condition - disable/enable ports $myPorts&#34;
        exp_send &#34;disable port $myPorts \r&#34;
        expect {
            -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                <a name="::result_debug(61)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nVPEX Restart port replaced - disable ports $myPorts&#34;
            }
            timeout {
                <a name="::result_debug(62)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nTimeout on disable vpex port&#34;
            }
        }
        exp_send &#34;enable port $myPorts \r&#34;
        expect {
            -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                <a name="::result_debug(63)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nVPEX Restart port replaced - enable ports $myPorts&#34;
            }
            timeout {
                <a name="::result_debug(64)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nTimeout on disable vpex port&#34;
            }
        }
        return &#34;&#34;
    } elseif {[regexp -nocase {en[able]{0,4} learn.*po[rts]{0,3} all} $cmd]} {
        <a name="::result_debug(65)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;\nVPEX shared links will not allow all. Only enable ports of interest&#34;
        set dutPortList [<a name="::_getDutPorts(3)"><a href="./PortMapping.tcl.html#::_getDutPorts_546">::_getDutPorts</a></a> -dut $whichDutNow]
        set newPorts [regsub &#34;all&#34; $cmd $dutPortList cmdToReturn]
        return $cmdToReturn
    } else {
        return $cmdToReturn
    }

}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: DumpNvramContent </span>
<span class="comment-line">#</span>
<span class="comment-line"># Description:</span>
<span class="comment-line">#</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args:</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::DumpNvramContent_2919">proc <a href="SendSwCmd.tcl-annot.html#::::DumpNvramContent">::::DumpNvramContent</a></a></strong> {} {
   global whichDutNow

   if {![info exists whichDutNow]} {
      set whichDutNow 1
   }
    <a name="::EnableDebugMode(5)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
    <a name="::SendACmd(86)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ls&#34;
    <a name="::SendACmd(87)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;!df&#34;
    
      send &#34;!sh\r&#34;
      <a name="::exSleep(28)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
      expect {
        &#34;/exos/bin #&#34; {<a name="::result_debug(66)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;;  send &#34;/exos/bin/odo\r&#34; }
        timeout { <a name="::result_debug(67)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;/exos/bin/odo\r&#34; }
      }
      <a name="::exSleep(29)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
      expect {
         -exact &#34;-&gt;&#34; {<a name="::result_debug(68)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;nvram\r&#34;  }
        timeout { <a name="::result_debug(69)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;nvram\r&#34;; }
      }
      <a name="::exSleep(30)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
      expect {
        -exact &#34;-&gt;&#34; {<a name="::result_debug(70)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;lv\r&#34;  }
       timeout { <a name="::result_debug(71)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;lv\r&#34; }
      }
     <a name="::exSleep(31)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
     expect {
        -exact &#34;-&gt;&#34; {<a name="::result_debug(72)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;quit\r&#34;  }
       timeout { <a name="::result_debug(73)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;quit\r&#34;}
    }
    <a name="::exSleep(32)"><a href="./sleep.tcl.html#::exSleep_248">::exSleep</a></a> 5
    expect {
     -exact &#34;/exos/bin #&#34; {<a name="::result_debug(74)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;exit\r&#34;  }
       timeout { <a name="::result_debug(75)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; send &#34;exit\r&#34;}
    }
     <a name="::result_debug(76)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;;
}
<strong><a name="::::disableEfence_2957">proc <a href="SendSwCmd.tcl-annot.html#::::disableEfence">::::disableEfence</a></a></strong> { } {
         <a name="::EnableDebugMode(6)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
         set efenceBuf [<a name="::SendACmd(88)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm show heapdbg&#34;]
         if {([regexp -nocase &#34;not&#34; $efenceBuf])} {
             <a name="::result_debug(77)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$efenceBuf&#34;
	 } else {
             <a name="::result_debug(78)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Efence is enabled for process $efenceBuf&#34;
             <a name="::result_debug(79)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Disabling efence for all process now&#34;
             <a name="::SendACmd(89)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;debug epm disable heapdbg process all&#34;
         }
}

<strong><a name="::::SendACmdWithoutReLogin_2969">proc <a href="SendSwCmd.tcl-annot.html#::::SendACmdWithoutReLogin">::::SendACmdWithoutReLogin</a></a></strong> { {cmd &#34;NULL&#34;} {expectedMsg &#34;closed&#34;} {cmdTimeout 60} {yesorno &#34;y&#34;} } {
      set timeout $cmdTimeout
      set exp_out_buf &#34;&#34;
      exp_send &#34;$cmd\r&#34;
      expect {
             &#34;$expectedMsg&#34; {
             append exp_out_buf $expect_out(buffer)
             <a name="::result_ok(15)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Test Passed :&#34;
             }
             &#34;\\?&#34; {
             		regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf
		        append exp_out_buf $out_buf
                	if {[regexp -nocase {(best, *\?|\\.[0-9]+ \?|\*.\?|Origin|or '\?|checkpoint?|errors?)} $expect_out(buffer) match str]!=1} {
                 	;<span class="comment-line"># For debug hal show platform ipv4Mc (checkpoint?|errors?)</span>
                 	;<span class="comment-line">#  ? in bgp specific routes</span>
                 	send &#34;$yesorno\r&#34;
             		}
             		exp_continue
             }
             &#34;yes, no, or cancel)&#34; { send &#34;n/r&#34; }
             &#34;n)\\?  &#34; &#34;send $yesorno/r&#34;
             timeout {
                     send &#34;/r&#34;
                     expect *
                     append exp_out_buf $expect_out(buffer)
                     <a name="::result_error(28)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Test Failed: Did not got expected message $expectedMsg&#34;
             }
      }
return $exp_out_buf
}
<strong><a name="::::SendACmdWithoutReLogin_2999">proc <a href="SendSwCmd.tcl-annot.html#::::SendACmdWithoutReLogin">::::SendACmdWithoutReLogin</a></a></strong> { {cmd &#34;NULL&#34;} {expectedMsg &#34;closed&#34;} {cmdTimeout 60} {yesorno &#34;y&#34;} } {
      set timeout $cmdTimeout
      set exp_out_buf &#34;&#34;
      exp_send &#34;$cmd\r&#34;
      expect {
             &#34;$expectedMsg&#34; {
             append exp_out_buf $expect_out(buffer)
             <a name="::result_ok(16)"><a href="./lconsoles.tcl.html#::result_ok_9">::result_ok</a></a> &#34;Test Passed :&#34;
             }
             &#34;\\?&#34; {
             		regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; out_buf
		        append exp_out_buf $out_buf
                	if {[regexp -nocase {(best, *\?|\\.[0-9]+ \?|\*.\?|Origin|or '\?|checkpoint?|errors?)} $expect_out(buffer) match str]!=1} {
                 	;<span class="comment-line"># For debug hal show platform ipv4Mc (checkpoint?|errors?)</span>
                 	;<span class="comment-line">#  ? in bgp specific routes</span>
                 	send &#34;$yesorno\r&#34;
             		}
             		exp_continue
             }
             &#34;yes, no, or cancel)&#34; { send &#34;n/r&#34; }
             &#34;n)\\?  &#34; &#34;send $yesorno/r&#34;
             timeout {
                     send &#34;/r&#34;
                     expect *
                     append exp_out_buf $expect_out(buffer)
                     <a name="::result_error(29)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;Test Failed: Did not got expected message $expectedMsg&#34;
             }
      }
return $exp_out_buf
}
<span class="comment-line">##################################################################</span>
<span class="comment-line"># Procedure Name: formatExternalCF </span>
<span class="comment-line"># Description:</span>
<span class="comment-line"># Input args: </span>
<span class="comment-line"># Output args:</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line"># Category: Utility</span>
<span class="comment-line">##################################################################</span>
<strong><a name="::::formatExternalCF_3037">proc <a href="SendSwCmd.tcl-annot.html#::::formatExternalCF">::::formatExternalCF</a></a></strong> {} {
   global whichDutNow
   if {![info exists whichDutNow]} {
      set whichDutNow 1
   }
    set timeout 25   ;<span class="comment-line">#  This should be more than enough time to  format a bad CF    </span>
    <a name="::SendACmd(90)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;save&#34;
    <a name="::EnableDebugMode(7)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
    send &#34;!sh\r&#34;
    expect {
        &#34;/exos/bin #&#34; { 
                      send &#34;umount /mnt/a\r&#34; ; sleep 5; send &#34;\r&#34;
         }
         timeout { <a name="::result_debug(80)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; }
      }
      expect {
        &#34;/exos/bin #&#34; { 
                      send &#34;mkfs.vfat /dev/hdc1\r&#34; ; sleep 5; send &#34;\r&#34;
                      }
        timeout { <a name="::result_debug(81)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; }
      }
      expect {
        &#34;/exos/bin #&#34; { 
                      send &#34;mount /dev/hdc1 /mnt/a\r&#34; ; sleep 5; send &#34;\r&#34;
                      }
        timeout { <a name="::result_debug(82)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;; }
      }
      expect {
     &#34;/exos/bin #&#34; { 
                   send &#34;exit\r&#34; ; sleep 2; send &#34;\r&#34;
                    }
       timeout { send &#34;exit\r&#34;}
    }
    sleep 2;
    <a name="::result_debug(83)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;$expect_out(buffer)&#34;;
    <a name="::SendACmd(91)"><a href="./SendSwCmd.tcl.html#::SendACmd_157">::SendACmd</a></a> &#34;ls /usr/local/ext&#34;
}
<span class="comment-line">#####################################################################</span>
<span class="comment-line"># A wrapper for for ConfigGwNetwork to enable forking</span>
<span class="comment-line">#</span>
<span class="comment-line">#####################################################################</span>
<strong><a name="::::ConfigGwNetworkOnDut_3078">proc <a href="SendSwCmd.tcl-annot.html#::::ConfigGwNetworkOnDut">::::ConfigGwNetworkOnDut</a></a></strong> {dut} {
    global DUT[set dut]_CONNECT DUTs_info

    if {![info exists DUTs_info(DUT[set dut],version)]} {
        set DUTs_info(DUT[set dut],version) &#34;15.1.1.1&#34;
    }
    <a name="::Login(24)"><a href="./login.tcl.html#::Login_24">::Login</a></a> [set DUT[set dut]_CONNECT] -CheckOperational 0 -masterCheck 0
    <a name="::ConfigGatewayNetwork(6)"><a href="./SendSwCmd.tcl.html#::ConfigGatewayNetwork_2110">::ConfigGatewayNetwork</a></a>

}
<span class="comment-line">#####################################################################</span>
<span class="comment-line"># proc _setShowOutput</span>
<span class="comment-line">#</span>
<span class="comment-line">#   Turn on/off printing to stdout,log or to harness result_fmt</span>
<span class="comment-line">#</span>
<span class="comment-line"># Args: screen  - on/off print to stdout via expect log_user  </span>
<span class="comment-line">#       log     - on/off pass to result_pre</span>
<span class="comment-line">#       res_fmt - on/off formatted result_debug/error etc.</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage:</span>
<span class="comment-line">#       _setShowOutput -screen off -log off -res_fmt off</span>
<span class="comment-line">#</span>
<span class="comment-line">#####################################################################</span>
<strong><a name="::::_setShowOutput_3101">proc <a href="SendSwCmd.tcl-annot.html#::::_setShowOutput">::::_setShowOutput</a></a></strong> {args} {
    global MAIN

    <a name="::parse_args(9)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> CheckDownloadConfig $args {
        screen     &#34;on&#34;
        log        &#34;on&#34;
        res_fmt    &#34;on&#34;
    }

    switch $screen  {
        on    {
            set MAIN(SHOWSTDOUT) 1
            log_user 1
        }
        off {
            set MAIN(SHOWSTDOUT) 0
            log_user 0
        }
        default  {
            set MAIN(SHOWSTDOUT) 1
            log_user 1
        }
    }

    switch $log  {
        on    {
            set MAIN(PRINTTOLOG) 1
        }
        off {
            set MAIN(PRINTTOLOG) 0
        }
        default  {
            set MAIN(PRINTTOLOG) 1
        }
    }


    switch $res_fmt  {
        on    {
            set MAIN(SHOWRESULT_FMT) 1
        }
        off {
            set MAIN(SHOWRESULT_FMT) 0
        }
        default  {
            set MAIN(SHOWRESULT_FMT) 1
        }
    }

}
<span class="comment-line">#####################################################################</span>
<span class="comment-line"># proc _initOutputOptions</span>
<span class="comment-line">#</span>
<span class="comment-line">#   Verify the stdout,log and res_fmt vars and set if not set</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Typical usage</span>
<span class="comment-line">#   _initOutputOptions</span>
<span class="comment-line">#</span>
<span class="comment-line">#####################################################################</span>
<strong><a name="::::_initOutputOptions_3161">proc <a href="SendSwCmd.tcl-annot.html#::::_initOutputOptions">::::_initOutputOptions</a></a></strong> {} {
    global MAIN

    if ![info exists MAIN(SHOWSTDOUT)] {
        set MAIN(SHOWSTDOUT) 1
        catch {log_user 1} why
    } elseif {$MAIN(SHOWSTDOUT) == 1} {
        catch {log_user 1} why
    } elseif {$MAIN(SHOWSTDOUT) == 0} {
        catch {log_user 0} why
    } else {
        set MAIN(SHOWSTDOUT) 1
        catch {log_user 1} why
    }

    if ![info exists MAIN(PRINTTOLOG)] {
        set MAIN(PRINTTOLOG) 1
    }
    if ![info exists MAIN(SHOWRESULT_FMT)] {
        set MAIN(SHOWRESULT_FMT) 1
    }
}
<span class="comment-line">######################################################################</span>
<span class="comment-line"># Procedure: _cliQuestionHandler </span>
<span class="comment-line">#</span>
<span class="comment-line"># Handle different cases for yes no prompts that are not </span>
<span class="comment-line">#    default</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">######################################################################   </span>
<strong><a name="::::_cliQuestionHandler_3194">proc <a href="SendSwCmd.tcl-annot.html#::::_cliQuestionHandler">::::_cliQuestionHandler</a></a></strong> {args} {
    global MAIN
    <a name="::parse_args(10)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> _cliQuestionHandler $args {
        buffer    &#34;none&#34; 
        cmd       &#34;none&#34;
        yesorno   &#34;none&#34;
        stacking  0
    }
    <span class="comment-line"># No query conditions where question marks are appearing </span>
    if {!$stacking} {
        if {[regexp -nocase {(best, *\?|\\.[0-9]+ \?|\*.\?|Origin|or '\?|checkpoint?|errors?)} $buffer] != 1 &amp;&amp;
        [regexp -nocase {Port  *Mode  *State  *Cost  *Flags  *Priority  *Port ID  *Designated Bridge} $buffer] != 1 &amp;&amp;
        ![regexp -nocase {MAC Address/Mask +Password \(encrypted\) +Port} $buffer]} {
            <span class="comment-line"># For debug hal show platform ipv4Mc (checkpoint?|errors?)</span>
            <span class="comment-line">#  ? in bgp specific routes</span>
            send &#34;$yesorno\r&#34;;
            puts &#34;\nGeneral Question Mark Case - control response with SendACmd -yesorno default Yes&#34;
            return;
        }
    }

    <span class="comment-line"># - Add case for Clear log with FIPs mode on</span>
    if {[regexp -nocase {cl[ear]{0,3}.*lo[g]{0,1}} $cmd]} {
        puts &#34;Clear log default answer is yes&#34;
        send &#34;Yes\r&#34;;
    }
}
<span class="comment-line">######################################################################</span>
<span class="comment-line"># Procedure: ShellSend</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line"># Send a command to the exos shell.  Prompt matching and timeout</span>
<span class="comment-line">#                adjusted.</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">#</span>
<span class="comment-line">######################################################################</span>
<strong><a name="::::ShellSend_3233">proc <a href="SendSwCmd.tcl-annot.html#::::ShellSend">::::ShellSend</a></a></strong> {cmd args} {
    global DUTs_info whichDutNow whichMsmNow connectionTimeout MAIN
    <a name="::parse_args(11)"><a href="./parse_args.tcl.html#::parse_args_29">::parse_args</a></a> ShellSend $args {
        yesorno  &#34;yes&#34;
    }

    if {![info exists connectionTimeout]} {
        set connectionTimeout 120
    }
    set exp_shout_buf &#34;&#34;
    set timeout 30;<span class="comment-line"># only allow 10 sec for for shell to return a prompt</span>
    <a name="::result_print(22)"><a href="./loadConsoles.tcl.html#::result_print_12">::result_print</a></a> &#34;--- Send $cmd&#34;
    send &#34;$cmd\r&#34;
    expect {
        -exact &#34;$cmd&#34; {
            if {[regexp -nocase &#34;bcm\.shell&#34; $cmd]} {
                send &#34;\r&#34;
            }
            <span class="comment-line"># We want to match the echoed command and continue to the next expect</span>
        }
        &#34;$cmd&#34; {
            <span class="comment-line"># We want to match the echoed command and continue to the next expect</span>
        }
        eof {
            <a name="::result_debug(84)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;Connection dropped while in the shell&#34;
            send &#34;exit\r&#34;;
            set timeout $connectionTimeout
            return
        }
        timeout {
            <a name="::result_debug(85)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;No echo response while in EXOS shell after sending $cmd &#34;
            send &#34;exit\r&#34;;
            set timeout $connectionTimeout
            return
        }
    }
    expect {
        timeout {
            <a name="::result_error(30)"><a href="./lconsoles.tcl.html#::result_error_6">::result_error</a></a> &#34;No response from the switch DUT$whichDutNow for $timeout seconds&#34;
            expect *
            regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; sh_out_buf;
            append exp_shout_buf $sh_out_buf;
        }
        -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
            <span class="comment-line"># Hit a regular EXOS prompt.. Hope you intended to exit</span>
        }
        -re &#34;# $&#34; {
            <span class="comment-line"># Hit a root shell prompt</span>
        }
        -nocase -re &#34;BCM\.\[0-9]+&gt; &#34; {
            <span class="comment-line">#puts &#34;hits shell prompt&#34; </span>
        }
        -re &#34;\\$ $&#34; {
            <span class="comment-line"># Hit a user/admin shell prompt</span>
            <span class="comment-line"># To recover this we need to logout, log back in enabledebug, go to the shell and resend.</span>
            <a name="::result_debug(86)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;At shell user/admin prompt.  Need to recover the root # prompt&#34;
            send &#34;exit\r&#34; 
            expect {
                -nocase -re &#34;(\\* )?\[a-z0-9()._-]+(:|\\.)\[0-9]+ (#|&gt;) &#34; {
                    set timeout $connectionTimeout
                    <a name="::logout(2)"><a href="./logout.tcl.html#::logout_21">::logout</a></a> null -closeSession false
                    global DUT${whichDutNow}_CONNECT${whichMsmNow}
                    set conn [set DUT${whichDutNow}_CONNECT${whichMsmNow}]
                    <a name="::Login(25)"><a href="./login.tcl.html#::Login_24">::Login</a></a> $conn
                    <a name="::EnableDebugMode(8)"><a href="./misc.tcl.html#::EnableDebugMode_2430">::EnableDebugMode</a></a>
                    set timeout 8
                    if {[regexp -nocase &#34;bcm\.shell|\!sh&#34; $cmd]} {
                        send &#34;$cmd\r&#34;
                    } else {
                        send &#34;!sh\r&#34;
                    }
                    expect {
                        -nocase -re &#34;# $|bcm\.\[0-9]+&gt; &#34; {
                            <span class="comment-line"># great recovery</span>
                            if {![regexp -nocase &#34;bcm\.shell|\!sh&#34; $cmd]} {
                                send &#34;$cmd\r&#34;
                                expect -re &#34;# $|bcm\.\[0-9]+&gt;&#34;
                            }
                            set timeout $connectionTimeout
                            puts &#34;$expect_out(buffer)&#34;
                            return;
                        }
                    }
                }
                -re &#34;\\$ $&#34; {
                    <span class="comment-line"># exit didn't work.  bail</span>
                    send &#34;exit\r&#34;
                    set timeout $connectionTimeout
                    return;
                }
                timeout {
                    set timeout $connectionTimeout
                    return;
                }
            }

        }
        &#34;\\?&#34; {
            regsub -all &#34;\n\r&#34; $expect_out(buffer) &#34;\n&#34; sh_out_buf;
            append exp_shout_buf $sh_out_buf;
            send &#34;$yesorno\r&#34;
            exp_continue;
        }
        -nocase -re &#34;system reboot&#34; {
            <a name="::result_debug(87)"><a href="./lconsoles.tcl.html#::result_debug_3">::result_debug</a></a> &#34;A shell command just caused a reboot.&#34;
        }
    }
    append exp_shout_buf $expect_out(buffer)
    regsub -all &#34;\n\r&#34; $exp_shout_buf &#34;\n&#34; exp_shout_buf
    regsub -all &#34;\t&#34; $exp_shout_buf &#34; &#34; exp_shout_buf

    <span class="comment-line"># -- Do not print to the log file if in multiTask</span>
    if {$MAIN(PRINTTOLOG)} {
        <a name="::result_pre(4)"><a href="./loadConsoles.tcl.html#::result_pre_15">::result_pre</a></a> $exp_shout_buf
    }
    set timeout $connectionTimeout
}
</pre>
<hr>
<div class="index-selector">
	<a href="index_main.html#byfilename">file name</a> 
 | 
	<a href="index_main.html#byprocname">procedure name</a> 
 | 
	<a href="index_main.html#bycall">procedure call</a> 
 | 
	<a href="index_annot_full.html">annotation</a> 

<br>
<cite>File generated 2018-06-14 at 17:09.</cite>
</div>

</body>
</html>
