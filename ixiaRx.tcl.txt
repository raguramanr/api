
set auto_path [linsert $auto_path 0 . ]

################################################################## 
# Procedure Name: ixiaCapture
#   
# Description: Start capturing packets for all ports
#               
#     
#
# Input args:
#                Chid - chassis id
#                
# Output args: none
#
# Typical usage: 
#      return [ixiaCaptureOnePort $chasis $card $port $fd_res]
#
# Category: Setup
################################################################## 

proc ixiaCapture {{fd_res "NULL"} \
                  {chid 1}        \
                  {fd_in "NULL"}} {
   global spawn_id
   global one2oneArray

   foreach txMap [lsort [array names one2oneArray]] {
      set rxMap $one2oneArray($txMap)
	  scan $txMap "%d,%d,%d" x y z
      scan [join $rxMap] "%d %d %d" chid c p
      capture get $chid $c $p
      set numCapFrames [capture cget -nPackets]
      captureBuffer get $chid $c $p 1 $numCapFrames

      puts "--- txMap=$txMap rxMap=$rxMap"
      puts $fd_res "--- txMap=$txMap rxMap=$rxMap"
      if { $fd_in != "NULL" } { puts $fd_in "^ $txMap $rxMap" }
      stat get statAllStats $chid $c $p
      set uds1 [stat cget -userDefinedStat1]
      puts "frames sent = [stat cget -framesSent]"
      puts "frames received = [stat cget -framesReceived]"
      puts "capture cget -nPackets = $numCapFrames"
      puts $fd_res "frames sent = [stat cget -framesSent]"
      puts $fd_res "frames received = [stat cget -framesReceived]"
      puts $fd_res "capture cget -nPackets = $numCapFrames"
      if { $fd_in != "NULL" } { 
         puts $fd_in "[stat cget -framesSent]"
         puts $fd_in "[stat cget -framesReceived]"
      }

      for {set i 1} {$i <= $numCapFrames} {incr i} {
         captureBuffer getframe $i
         puts "captureBuffer cget -frame = [captureBuffer cget -frame]"
         puts $fd_res "captureBuffer cget -frame = [captureBuffer cget -frame]"
         if {$fd_in != "NULL"} { puts $fd_in "[captureBuffer cget -frame]" }
#         puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]"
      }
   }
}

################################################################## 
# Procedure Name: ixiaCaptureOnePort
#   
# Description: Start capturing packets for a port
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                
# Output args: 
#             if file = NULL, it will return a list containing raw captured data
#
# Typical usage: 
#      return [ixiaCaptureOnePort $chasis $card $port $fd_res]
#
# Category: Setup
################################################################## 

proc ixiaCaptureOnePort {{ch 1}          \
                         {cd 1}          \
                         {pt 1}          \
                         {fd_res "NULL"} \
                         {fd_in "NULL"}} {
   set rc [capture get $ch $cd $pt];
#   puts "capture get returned rc=$rc";
   set numCapFrames [capture cget -nPackets];
 #  puts "capture cget -nPackets = $numCapFrames";
   set rc [captureBuffer get $ch $cd $pt 1 $numCapFrames];
  # puts "captureBuffer get returned rc=$rc";
   #puts "--- ($ch $cd $pt)";
#   if { $fd_res != "NULL" } {
#      puts $fd_res "--- ($ch $cd $pt)";
#   }
   if { $fd_in != "NULL" } {
    #  puts $fd_in "^ ($ch $cd $pt)";
   }

   stat get statAllStats $ch $cd $pt;
   set uds1 [stat cget -userDefinedStat1];
  # puts "frames sent = [stat cget -framesSent]";
  # puts "frames received = [stat cget -framesReceived]";
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]";
      puts $fd_in "[stat cget -framesReceived]";
   }

   for {set i 1} {$i <= $numCapFrames} {incr i} {
      set rc [captureBuffer getframe $i];
    #  puts "captureBuffer getframe returned rc=$rc";
#      puts "capturebuffer cget -timestamp = [captureBuffer cget -timestamp]";
     # puts "captureBuffer cget -frame = [captureBuffer cget -frame]";
      if { $fd_res != "NULL" } {
         puts $fd_res "Traffic on port $pt=[captureBuffer cget -frame]";
      }
      if {$fd_in != "NULL"} {
         puts $fd_in "[captureBuffer cget -frame]";
      } else {
         lappend rawFrames "[captureBuffer cget -frame]";
      }
#      puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]";
   }
   if {$fd_in == "NULL"} {
      if { [ info exists rawFrames ] != "1" } {
         set rawFrames {};
      }
      return $rawFrames;
   }
}

################################################################## 
# Procedure Name: ixiaStat
#   
# Description: Get Ixia statistics for a port
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                
#                
# Output args: 
#             it will return a list containing statistics for that  port
#
# Typical usage: 
#      return [ixiaStat $chasis $card $port $fd_res]
#
# Category: Setup
################################################################## 

proc ixiaStat {{ch 1}          \
               {cd 1}          \
               {pt 1}          \
               {fd_res "NULL"} \
               {fd_in "NULL"}} {
   global spawn_id

   after 1000
   puts "--- ($ch $cd $pt)"
   puts $fd_res "--- ($ch $cd $pt)"
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }
   capture get $ch $cd $pt
   stat get statAllStats $ch $cd $pt
#   set uds1 [stat cget -userDefinedStat1]
   puts "frames sent = [stat cget -framesSent]"
   puts "frames received = [stat cget -framesReceived]"
   puts $fd_res "frames sent = [stat cget -framesSent]"
   puts $fd_res "frames received = [stat cget -framesReceived]"
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]"
      puts $fd_in "[stat cget -framesReceived]"
   }
}


################################################################## 
# Procedure Name: ixiaUserDefinedStat1
#   
# Description: Ixia statistics - get a port statistic based on user define stat 1
#     
#               
# Input args:
#              portId - port id  
#                                
# Output args: 
#              return $SentReceivedPackets
#
# Typical usage: 
#              [ixiaUserDefinedStat1 $portId $filePt]
#
# Category: Setup
################################################################## 

proc ixiaUserDefinedStat1 {{portId 1}          \
               {fd_res "NULL"} \
               {fd_in "NULL"}} {
   global spawn_id

   after 1000
   MapIxiaPortId $portId ch cd pt
   if {$fd_res != "NULL"} {puts $fd_res "--- ($ch $cd $pt)"}
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }
   capture get $ch $cd $pt
   stat get statAllStats $ch $cd $pt
   set frReceived [stat cget -userDefinedStat1]
   set frSent [stat cget -framesSent]
   puts "Frames sent = $frSent"
   if {$fd_res!="NULL"} {puts $fd_res "Frames sent = $frSent"}
   puts "Total frames received = [stat cget -framesReceived] (not used)"
   puts "Filtered frames UDS1 received = $frReceived"
   if {$fd_res!="NULL"} {puts $fd_res "Filtered frames UDS1 received = $frReceived"}
   if { $fd_in != "NULL" } { 
      puts $fd_in "$frSent"
      puts $fd_in "$frReceived"
   } else {
      set SentReceivedPackets "$frSent $frReceived"
      return $SentReceivedPackets
   }
}

################################################################## 
# Procedure Name: ixiaStatFlood
#   
# Description: Ixia statistics - get a port statistics
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                fd_res - file pointer
#                fd_in - file pointer
#                                
# Output args: none
#              
#
# Typical usage: 
#              [ixiaStatFlood $chasis $card $port $fd_res $fd_in]
#
# Category: utility
################################################################## 

proc ixiaStatFlood {{ch 1}          \
                    {cd 1}          \
                    {pt 1}          \
                    {fd_res "NULL"} \
                    {fd_in "NULL"}} {
   global spawn_id

   puts "--- ($ch $cd $pt)"
   puts $fd_res "--- ($ch $cd $pt)"
	if { $fd_in != "NULL" } {
		puts $fd_in "^ ($ch $cd $pt)"
	}
   capture get $ch $cd $pt
   stat get statAllStats $ch $cd $pt
   puts "frames sent = [stat cget -framesSent]\nflooding frames received = [stat cget -userDefinedStat1]"
   puts $fd_res "frames sent = [stat cget -framesSent]\nflooding frames received = [stat cget -userDefinedStat1]"
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]"
      puts $fd_in "[stat cget -userDefinedStat1]"
   }
}

################################################################## 
# Procedure Name: ixiaPayloadOnePort
#   
# Description: Return statistic on a Ixia's port.
#              It will return the transmit rate or receive rate based on the port 
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id 
#                direction - traffic direction 
#                fd_res - file pointer
#                                
# Output args: 
#              TxRate
#
# Typical usage: 
#              [ixiaPayloadOnePort $chasis $card $port $direction $fd_res]
#
# Category: utility
################################################################## 

proc ixiaPayloadOnePort {{ch 1}            \
                         {cd 1}            \
                         {pt 1}            \
                         {direction "tx"}  \
                         {fd_res "NULL"}} {
   global spawn_id

   result_debug "--- ($ch $cd $pt)"
#   capture get $ch $cd $pt
   stat getRate statAllStats $ch $cd $pt
   set txRate [stat cget -framesSent]
   set rxRate [stat cget -framesReceived]

   result_debug "frames sent rate = $txRate\nframes received rate = $rxRate"

   if { $direction == "tx" } {
      return $txRate
   } else {
      return $rxRate
   }
}

################################################################## 
# Procedure Name: ixiaCapture_ip
#   
# Description: Capture IP packets for all ports
#               
# Input args:
#                Chid - chassis id
#                fd_res - file pointer
#                fd_in - file pointer
#                                
# Output args: 
#                Return information in a file
#
# Typical usage: 
#              [ixiaCapture_ip $fd_res $chid $fd_in]
#
# Category: utility
################################################################## 

proc ixiaCapture_ip {{fd_res "NULL"} \
                     {chid 1}        \
                     {fd_in "NULL"}} {
   global spawn_id
   global one2oneArray

   foreach txMap [lsort [array names one2oneArray]] {
      set rxMap $one2oneArray($txMap)
	  scan $txMap "%d,%d,%d" x y z
      scan [join $rxMap] "%d %d %d" chid c p
      capture get $chid $c $p
      set numCapFrames [capture cget -nPackets]
      captureBuffer get $chid $c $p 1 $numCapFrames

      puts "--- txMap=$txMap rxMap=$rxMap"
      puts $fd_res "--- txMap=$txMap rxMap=$rxMap"
      if { $fd_in != "NULL" } { puts $fd_in "^ $txMap $rxMap" }
      stat get statAllStats $chid $c $p
      set uds1 [stat cget -userDefinedStat1]
      puts "    frames sent = [stat cget -framesSent]"
      puts "    frames received = [stat cget -framesReceived]"
      puts "    capture cget -nPackets = $numCapFrames"
      puts $fd_res "    frames sent = [stat cget -framesSent]"
      puts $fd_res "    frames received = [stat cget -framesReceived]"
      puts $fd_res "    capture cget -nPackets = $numCapFrames"
      if { $fd_in != "NULL" } { 
         puts $fd_in "[stat cget -framesSent]"
         puts $fd_in "[stat cget -framesReceived]"
      }

      for {set i 1} {$i <= $numCapFrames} {incr i} {
         captureBuffer getframe $i
         puts "    captureBuffer cget -frame = [captureBuffer cget -frame]"
         puts $fd_res "    captureBuffer cget -frame = [captureBuffer cget -frame]"
         if {$fd_in != "NULL"} { puts $fd_in "[captureBuffer cget -frame]" }
      }
      puts "-------------------\n"
      puts $fd_res "-------------------\n"
   }
   puts "\r"
   puts $fd_res "\r"
}

################################################################## 
# Procedure Name: ixiaCaptureOnePort_ip
#   
# Description: Capture IP packets for a port
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                dList - 
#                fd_res - file pointer
#                                
# Output args:  
#                Write information in a file
#
# Typical usage: 
#              [ixiaCaptureOnePort_ip $chasis $card $port $dList $fd_res]
#
# Category: utility
################################################################## 

proc ixiaCaptureOnePort_ip {{ch 1}			 \
                            {cd 1}			 \
                            {pt 1}			 \
		            {dList {}}  	 \
                            {fd_res "NULL"}	 \
						    {fd_in "NULL"}} {
   global spawn_id

   capture get $ch $cd $pt
   set numCapFrames [capture cget -nPackets]
   captureBuffer get $ch $cd $pt 1 $numCapFrames

   puts "--- ($ch $cd $pt)"
   puts $fd_res "--- ($ch $cd $pt)"
   if { $fd_in != "NULL" } { puts $fd_in "^ ($ch $cd $pt)" }

   stat get statAllStats $ch $cd $pt
   set uds1 [stat cget -userDefinedStat1]
   puts "    frames sent = [stat cget -framesSent]"
   puts "    frames received = [stat cget -framesReceived]"
   puts "    capture cget -nPackets = $numCapFrames"
   puts $fd_res "    frames sent = [stat cget -framesSent]"
   puts $fd_res "    frames received = [stat cget -framesReceived]"
   puts $fd_res "    capture cget -nPackets = $numCapFrames"
   if { $fd_in != "NULL" } { 
      puts $fd_in "[stat cget -framesSent]"
      puts $fd_in "[capture cget -nPackets]"
   }

   for {set i 1} {$i <= $numCapFrames} {incr i} {
      captureBuffer getframe $i
      puts "    captureBuffer cget -frame = [captureBuffer cget -frame]"
      puts $fd_res "    captureBuffer cget -frame = [captureBuffer cget -frame]"
      if {$fd_in != "NULL"} { puts $fd_in "[captureBuffer cget -frame]" }

      set capframe [captureBuffer getframe $i]
      ip decode $capframe
      foreach item [lsort $dList] {
result_debug "--- item=$item"
		 set value [ip cget -$item]
         result_debug "    $item=$value"
         if { $fd_in != "NULL" } { 
            result_debug "    $item=$value"
		 }
	  }
   }
   puts "\r"
}

################################################################## 
# Procedure Name: StartPortsCapture
#   
# Description: Start ports capture
#               
# Input args:
#              portIdList - port list
#                                
# Output args: 
#              none  
#
# Typical usage: 
#              [StartPortsCapture $portIdList]
#
# Category: setup
################################################################## 
proc StartPortsCapture {portIdList} {

  # foreach portId $portIdList {
  #    MapIxiaPortId $portId chas card port
  #    ixStartPortCapture  $chas $card $port
  #    puts "ixStartPortCapture  $chas $card $port"      
  # }

  global TrafficGen
  switch -exact -- $TrafficGen {
      agilent {
          ::AgtExtreme::StartPortsCapture -portidlist $portIdList
          return
      }
      stc {
            # Enable capture on each of the ports.
            foreach iPortId $portIdList {
                # Get the capture object. (Automatically created)
                set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $iPortId] -children-capture]
                
                # Configure capture options.
                logcmd stc::config $hCapture -mode REGULAR_MODE -srcMode TX_RX_MODE  
                
                # Start capturing on the port.
                logcmd stc::perform CaptureStart -captureProxyId $hCapture
            }
            return
      }
      ixia -
      ixvm {
  global portMappingList
  
  ClearPortsStats $portIdList

  ClearPortsStats $portIdList 

  #foreach p $portIdList {
  #   set portList [lindex $portMappingList [expr $p-1]]
  #   result_debug "INFO: DUT[lindex $portList 2] [lindex $portList 1] egresses to portId [lindex $portList 0]"
  #}
  set delay 0;
  foreach portId $portIdList {
      set speed [GetPortIdSpeed $portId];
      if {$speed == 40000} {
          set delay 1;
      }
      MapIxiaPortId $portId chas card port
      lappend plist "$chas $card $port"
  }

  ixStartCapture plist
  if {$delay} {
      exSleep 3;
  }
      }
  }

  

}

################################################################## 
# Procedure Name: StopPortsCapture
#   
# Description: Stop ports capture
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##              [StopPortsCapture $portIdList]
#
# Category: setup
################################################################## 
proc StopPortsCapture {portIdList} {

   #foreach portId $portIdList {
   #   MapIxiaPortId $portId chas card port
   #   ixStopPortCapture  $chas $card $port
   #}

   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           ::AgtExtreme::StopPortsCapture
           return
       }
       stc {
            # Stop capturing on each of the ports.
            foreach iPortId $portIdList {
                # Get the capture object.
                set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $iPortId] -children-capture]
                
                # Stop capturing on the port.
                logcmd stc::perform CaptureStop -captureProxyId $hCapture
                set TIMESTAMP [clock format [clock seconds] -format %m%d%y%H%M]
                logcmd stc::perform CaptureDataSave -captureProxyId $hCapture -FileName "/tmp/capture-$TIMESTAMP.pcap" -FileNameFormat PCAP
            }
            return
       }
       ixia -
       ixvm {
   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixStopCapture plist
       }
   }

   

}

################################################################## 
# Procedure Name: StopPortsTransmit
#   
# Description: Stop Ports Transmit
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##              [StopPortsCapture $portIdList]
#
# Category: setup
################################################################## 
proc StopPortsTransmit {portIdList} {
   #foreach portId $portIdList {
   #   MapIxiaPortId $portId txChas txCard txPort
   #   ixStopPortTransmit  $txChas $txCard $txPort
   #}  
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           ::AgtExtreme::StopPortsTransmit -portidlist $portIdList
           return
       }
       stc {
          set idList {}
          foreach iPortId $portIdList {
             # Retrieve the generator object for the port.
             if {[string is integer $iPortId]} {set iPortId [hMapPortIdToSpirentPort $iPortId]}
             lappend idList [logcmd stc::get $iPortId -children-Generator]
         }
         # Start the generator.
         logcmd stc::perform GeneratorStop -GeneratorList $idList
           return
       }
       ixia -
       ixvm {
   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixStopTransmit plist
}
   }

   
}

################################################################## 
# Procedure Name: StartPortsTransmit
#   
# Description: Start Ports Transmit
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##             [StartPortsTransmit $portIdList]
#
# Category: setup
################################################################## 
proc StartPortsTransmit {portIdList} {
   #foreach portId $portIdList {
   #   MapIxiaPortId $portId txChas txCard txPort
   #   ixStartPortTransmit  $txChas $txCard $txPort
   #}  
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           ::AgtExtreme::StartPortsTransmit -portidlist $portIdList
           return
       }
       stc {
            # Start transmitting on the specified ports.
            foreach iPortId $portIdList {
                # Retrieve the generator object for the port.	
                set hGenerator [logcmd stc::get [hMapPortIdToSpirentPort $iPortId] -children-Generator]
                
                # Start the generator.
                logcmd stc::perform GeneratorStart -GeneratorList $hGenerator
                
                # Can't use this since rate tests are calculated after this call. There would be no rates 
                #	if the traffic had completed.
                # Wait for traffic to stop.  Maximum wait time is 300 seconds.
                #  stc::perform GeneratorWaitForStop -GeneratorList $hGenerator -WaitTimeout 300
            }
            return
       }
       ixia -
       ixvm {
   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixStartTransmit plist
}
   }

   
}
       
################################################################## 
# Procedure Name: ClearPortsStats
#   
# Description: Clear all Ports Stats
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
# Typical usage: 
##              [ClearPortsStats $portIdList]
#
# Category: setup
##################################################################            
proc ClearPortsStats {portIdList} {
   #foreach portId $portIdList {
   #   MapIxiaPortId $portId txChas txCard txPort
   #   ixClearPortStats $txChas $txCard $txPort
   #}
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           # do nothing, since stats and traffic are tied, so stats
           # get cleared when a test (i.e. traffic) is started
           return
       }
       stc {	
            # Clear all the traffic results for the specified ports.
            #result_debug "\nIn stc ClearPortsStats $portIdList"
            set lstPorts [hMapPortIdToSpirentPort $portIdList]
            logcmd stc::perform ResultClearAllTraffic -PortList $lstPorts  
            return
       }
       ixia -
       ixvm {
   foreach portId $portIdList {
     MapIxiaPortId $portId chas card port
     lappend plist "$chas $card $port"
   }

   ixClearStats plist
       }
   }

 

}

################################################################## 
# Procedure Name: GetCapturedFrames
#   
# Description: Get the captured frames
#               
# Input args:
#              portId - Port id
#                                
# Output args: 
#              return the captured frames
#              
# Typical usage: 
#             [GetCapturedFrames $portId]
#
# Category: setup
################################################################## 
proc GetCapturedFrames {portId {fd_res "NULL"} {packThreshold 200} } {
#   puts "portId: $portId"
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           # ignore argument 'fd_res', not applicable for Agilent N2X
           return [::AgtExtreme::GetCapturedFrames -portid $portId -threshold $packThreshold]
       }
       stc {
            # Get the capture object.
			
            StopPortsCapture $portId
            set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-capture]
            set pktCount [logcmd stc::get $hCapture -PktCount]
			result_debug "pktCount $pktCount"
			set packetCaptureData {}
			for {set i 0} {$i < $pktCount} {incr i} {
				array set returnList [logcmd stc::perform CaptureGetFrameCommand -CaptureProxyId $hCapture -FrameIndex $i]
				set szFrameContents [string range $returnList(-PacketData) 16 end]
				#set szFrameContents [string range $returnList(-PacketData) 0 end]
				set szFrameContents [scan $szFrameContents  [string repeat "%2s" [expr [string length $szFrameContents]/2]]]
				lappend packetCaptureData $szFrameContents
			}
			return $packetCaptureData
			
       }
       ixia -
       ixvm {
       }
   }

   set numRece [GetNumFramesReceived $portId]
   if {$numRece > $packThreshold} {
      result_debug "High number of packets ($numRece) captured. \
                    Return without getting any packets"
      return
   }
   MapIxiaPortId $portId chasis card port
      return [ixiaCaptureOnePort $chasis $card $port $fd_res]
}
##################################################################
# Procedure Name: DecodeCapturedFrames
#
# Description: Decode the captured frames using tshark
#
# Input args:
#              portId - Port id
#
# Output args:
#              return the captured frames
#
# Typical usage:
#             [GetCapturedFrames $portId]
#
# Category: setup
##################################################################
proc DecodeCapturedFrames {portId {packThreshold 200} {filter ""} } {
   puts "PROC - DecodeCapturedFrames portId: $portId"
   global TrafficGen NTAF_ENABLED

   if {[info exists NTAF_ENABLED] && $NTAF_ENABLED} {
       #set packThreshold 200
   }
   switch -exact -- $TrafficGen {
       agilent {
           # ignore argument 'fd_res', not applicable for Agilent N2X
           return [::AgtExtreme::GetCapturedFrames -portid $portId -threshold $packThreshold]
       }
       stc {
            # Get the capture object.
            StopPortsCapture $portId
            set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-capture]
            set pktCount [logcmd stc::get $hCapture -PktCount]
            result_debug "pktCount $pktCount"
            set packetCaptureData {}
            for {set i 0} {$i < $pktCount} {incr i} {
                array set returnList [logcmd stc::perform CaptureGetFrameCommand -CaptureProxyId $hCapture -FrameIndex $i]
                set szFrameContents [string range $returnList(-PacketData) 16 end]
                #set szFrameContents [string range $returnList(-PacketData) 0 end]
                set szFrameContents [scan $szFrameContents  [string repeat "%2s" [expr [string length $szFrameContents]/2]]]
                lappend packetCaptureData $szFrameContents
            }
            set myFrames $packetCaptureData
            set file "/tmp/capture_[pid].txt"
            set pcap "/tmp/capture_[pid].pcap"
            #set lfile "/tmp/capture_list_[pid].txt"
            set fid [open $file w]
            #set lid [open $lfile w]
            #puts $lid "$myFrames\n";
            #close $lid

            set i 1
            foreach theFrame $myFrames {
                set res {}
                set ctr 0
                while {[string length $theFrame]>48} {
                    set     pos [string wordstart $theFrame 48]
                    lappend res "[format %4.6X $ctr]  [string range $theFrame 0   [expr $pos-1]]"
                    set     theFrame   [string range $theFrame $pos end]
                    incr ctr 16
                }
 
                lappend res "[format %4.6X $ctr]  $theFrame"
                set theFrame [join $res "\n"]
                puts $fid "\n$theFrame ";
                if {$i==$packThreshold} {
                    break
                }
            }
  
            close $fid
            if [catch {exec text2pcap $file $pcap} reason] {
                #puts "Error running text2pcap: $reason"
            }
            if {$filter != "NULL"} {
                set filterString " $filter"
            } else {
                set filterString ""
            }
            if [catch {exec tshark -r $pcap -n -V $filterString} reason] {
                puts "$reason"
            } else {
                puts $reason
            }
            catch {file delete $file} x
            catch {file delete $pcap} y
     ` }
       ixia -
       ixvm {
       }
       ept {
       }
       default {
       }
   }
   set numRece [GetNumFramesReceived $portId]
   if {$numRece > $packThreshold} {
      result_debug "High number of packets ($numRece) captured. \

                    Return without getting any packets"
      return
   }
   MapIxiaPortId $portId chasis card port
   if {[info exists NTAF_ENABLED] && $NTAF_ENABLED} {
       set myFrames [ixiaCaptureOnePort $chasis $card $port NULL]
       set file "/tmp/capture_[pid].txt"
       set pcap "/tmp/capture_[pid].pcap"
       #set lfile "/tmp/capture_list_[pid].txt"
       set fid [open $file w]
       #set lid [open $lfile w]
       #puts $lid "$myFrames\n";
       #close $lid
       set i 1
       foreach theFrame $myFrames {
           set res {}
           set ctr 0
           while {[string length $theFrame]>48} {
               set     pos [string wordstart $theFrame 48]
               lappend res "[format %4.6X $ctr]  [string range $theFrame 0   [expr $pos-1]]"
               set     theFrame   [string range $theFrame $pos end]
               incr ctr 16
           }
           
           lappend res "[format %4.6X $ctr]  $theFrame"
           set theFrame [join $res "\n"]
           puts $fid "\n$theFrame ";
           if {$i==$packThreshold} {
               break
           }
           incr i
       }

       close $fid
       if [catch {exec text2pcap $file $pcap} reason] {
           #puts "Error running text2pcap: $reason"
       }
       if {$filter != "NULL"} {
           set filterString " $filter"
       } else {
           set filterString ""
       }
       if [catch {exec tshark -r $pcap -n -V $filterString} reason] {
           puts "$reason"
       } else {
           puts $reason
       }
       catch {file delete $file} x
       catch {file delete $pcap} y
      # return [ixiaCaptureOnePort $chasis $card $port $fd_res]
   } else {
   return [ixiaCaptureOnePort $chasis $card $port $fd_res]
}
}
################################################################## 
# Procedure Name: GetCapturedFramesTimeStamp
#   
# Description: Get the captured frames time stamp
#               
# Input args:
#              portId - Port id
#                                
# Output args: 
#              return the captured frames time stamp
#              
# Typical usage: 
##             [GetCapturedFramesTimeStamp $portId]
#
# Category: setup
################################################################## 
proc GetCapturedFramesTimeStamp {portId {fd_res "NULL"}} {
#  puts "portId: $portId"
   MapIxiaPortId $portId chasis card port
   return [ixiaCapturedFramesTimeStamp $chasis $card $port $fd_res]
}


################################################################## 
# Procedure Name: GetCapturedFramesTimeStampIndexed
#   
# Description: Get the captured frames time stamp
#               
# Input args:  indexList - List of index numbers "1 4 9 10"
#              portId - Port id
#                                
# Output args: 
#              return a list of captured frames time stamps
#              for the indexes input.  Time is the 6 MSDigits
#              
# Typical usage: 
##             [GetCapturedFramesTimeStampIndexed $indexList $portId]
#
# Category: setup
##################################################################
proc GetCapturedFramesTimeStampIndexed {{indexList "1 2 3"} {portId 1}} {
   set zeroTime 0
   set hitFirst 0
   foreach pCount $indexList {
      set timeString [lindex [GetCapturedFramesTimeStamp $portId] $pCount]
      set timeLength [string length $timeString]
      switch $timeLength {
         "18" {
            lappend actTimeList [string range $timeString 0 8]
            set currentTime [string range $timeString 0 8]
         }         
         "17" {
            lappend actTimeList [string range $timeString 0 7]
            set currentTime [string range $timeString 0 7]
         }
         "16" {
            lappend actTimeList [string range $timeString 0 6]
            set currentTime [string range $timeString 0 6]
         }
         "15" {
            lappend actTimeList [string range $timeString 0 5]
            set currentTime [string range $timeString 0 5]
         }
         "14" {
            lappend actTimeList [string range $timeString 0 4]
            set currentTime [string range $timeString 0 4]
         }
         "13" {
            lappend actTimeList [string range $timeString 0 3]
            set currentTime [string range $timeString 0 3]
         }
         default {
            result_debug "Illegal time length $timeLength $timeString"
            lappend actTimeList ""
         }
      }
      if {$hitFirst == 0} {
         set hitFirst 1;
         set zeroTime $currentTime
         
      }
      result_debug "Normalized Time: [expr $currentTime - $zeroTime] \
                    TimeStamp: $currentTime"
   }
return $actTimeList
}
################################################################## 
# Procedure Name: EnablePorts
#   
# Description: Turn on loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [EnablePorts $portIdList]
#
# Category: setup
################################################################## 
proc EnablePorts {portIdList} {
	global TrafficGen
	
	switch -exact -- $TrafficGen {
		stc {
				foreach portId $portIdList {
					set txPortId [hMapPortIdToSpirentPort $portId]
					logcmd stc::perform L2TestRestoreLinkCommand -Port $txPortId
				}
			}
		ixia -
                ixvm {
    EnableIxiaPorts $portIdList;
}
	}
}

################################################################## 
# Procedure Name: EnableIxiaPorts
#   
# Description: Turn on loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [EnableIxiaPorts $portIdList]
##             [EnableIxiaPorts $portIdList 0]  ;# Do not wait for link
#
# Category: setup
################################################################## 
proc EnableIxiaPorts {portIdList {maxWait 15}} {

    result_debug "Enabling Ixia ports $portIdList"

    foreach portId $portIdList {
	MapIxiaPortId $portId chasis card port
	#SK  Get the port before re-writing to avoid messing up the old port info.
	port get $chasis $card $port
	
        set ixiaCardType [getIxiaCardType $portId]
        result_debug "port $portId IXIA CARD IS $ixiaCardType"

        #GV 05-06-2011:  Added HSE to account for newer Ixia modules
        if {![regexp -nocase "TXS|GBIC|STX|HSE|LSM" $ixiaCardType]} { ;# LM dont have cabledisconnect
           port config -loopback false
        } else {
           port config -enableSimulateCableDisconnect false
        }
	
	# add this line for GBIC card
	port config -rxTxMode gigNormal
	
	port set $chasis $card $port
	port write $chasis $card $port
	
# ---   Required for Ixia ports shared across setups by a Extreme
#       Device as L1 Switch
        exDevIxiaPortEnable -portId $portId

	if {$maxWait == 0} {
	    continue
	}

	set maxWaitCounter $maxWait
	while { $maxWaitCounter } {
	    port get $chasis $card $port
	    if {[port cget -linkState] == 1} {
		result_debug "FOUND LINK UP for portId:$portId!"
		break
	    } else {
		result_debug "Waiting for portId:$portId linkUp.."
		sleep 1
		incr maxWaitCounter -1
	    }
	}
	if {$maxWaitCounter == 0} {
	    result_warning "WARNING: No linkUp for Ixia portId:$portId"
	}
   }
}

################################################################## 
# Procedure Name: DisablePorts
#   
# Description: Turn off loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [DisablePorts $portIdList]
#
# Category: setup
################################################################## 
proc DisablePorts {portIdList} {
   DisableIxiaPorts $portIdList;
}
################################################################## 
# Procedure Name: DisableIxiaPorts
#   
# Description: Turn off loop back on the ixia port
#               
# Input args:
#              portIdList - Port list
#                                
# Output args: none
#              
#              
# Typical usage: 
##             [DisableIxiaPorts $portIdList]
#
# Category: setup
################################################################## 
proc DisableIxiaPorts {portIdList} {

	global TrafficGen
	
	switch -exact -- $TrafficGen {
		stc {
				foreach portId $portIdList {
					set txPortId [hMapPortIdToSpirentPort $portId]
					logcmd stc::perform L2TestBreakLinkCommand -Port $txPortId
				}
			}
		ixia -
                ixvm {
   result_debug "Disabling Ixia ports $portIdList"

   #an indirect way to disable a port
   foreach portId $portIdList {
      MapIxiaPortId $portId chasis card port

      #SK  Get the port before re-writing to avoid messing up the old port info.
      port get $chasis $card $port

      set ixiaCardType [getIxiaCardType $portId]
      result_debug "port $portId IXIA CARD IS $ixiaCardType"

      #SK: Following code needed to clear the buffer on disabled port.
      #SK: Put the port on loopback, start port capture to clear the buffer
      if {![regexp -nocase "TXS|GBIC" $ixiaCardType]} {
         port config -loopback true
      } else {
         port config -loopback true
         port config -rxTxMode gigLoopback
      }
      port set $chasis $card $port
      port write $chasis $card $port

      StartPortsCapture $portId
      StartPortsCapture $portId
      if {![regexp -nocase "TXS|GBIC" $ixiaCardType]} {
         port config -loopback false
      } else {
         port config -loopback false
	 port config -rxTxMode gigNormal
      }

      #GV 05-06-2011:  Separated loopback off and loopback/disconnect on events
      port set $chasis $card $port
      port write $chasis $card $port
      
      #SK: Actual disable port
      #GV 05-06-2011:  Added HSE to account for newer Ixia modules
      if {![regexp -nocase "TXS|GBIC|STX|HSE|LSM" $ixiaCardType]} {
         port config -loopback true
      } else {
         port config -enableSimulateCableDisconnect true
      }

      port set $chasis $card $port
      port write $chasis $card $port

# --- Required for Ixia ports shared across setups by a Extreme
#     Device as L1 Switch
      exDevIxiaPortDisable -portId $portId
   }
}
	}

  
}

################################################################## 
# Procedure Name: GetNumBytesSent

################################################################## 
# Procedure Name: GetNumBytesSent
#   
# Description: Get the number of bytes sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return bytes sent
#              
# Typical usage: 
#              [GetNumBytesSent $portId]
#
# Category: setup
################################################################## 
proc GetNumBytesSent {portId} {

   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set txBytes [::AgtExtreme::GetNumBytesSent -portid $portId]
           return $txBytes
       }
       stc {
            set txBytes [logcmd stc::get [hMapPortIdToSpirentPort $portId].Generator.GeneratorPortResults \
                -GeneratorOctetCount]
            return $txBytes	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }

   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   version get
   set ver [version cget -productVersion]
   set bytesSent [stat cget -bytesSent]
   #this bytesSent is only half of the actual bytes sent (Ixia bug)
   port get $chasisId $card $port
   if {([port cget -speed] == 100) && ([regexp -nocase "2.1" $ver])} {
      return [expr $bytesSent/2]
   } else { return $bytesSent }
}

################################################################## 
# Procedure Name: GetNumBytesReceived
#   
# Description: Get the number of bytes received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return bytes received
#              
# Typical usage: 
#              [GetNumBytesReceived $portId]
#
# Category: setup
################################################################## 
proc GetNumBytesReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxBytes [::AgtExtreme::GetNumBytesReceived -portid $portId]
           return $rxBytes
       }
       stc {
            set rxBytes [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -TotalOctetCount]
            return $rxBytes	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }

   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   set bytesRecv [stat cget -bytesReceived]
   #remove the stupid comma
   regsub -all {,} $bytesRecv {} bytesRecv
   return $bytesRecv
}

################################################################## 
# Procedure Name: GetNumFramesSent
#   
# Description: Get the number of frames sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frames sent
#              
# Typical usage: 
#              [GetNumFramesSent $portId]
#
# Category: setup
##################################################################
proc GetNumFramesSent {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set txFrames [::AgtExtreme::GetNumFramesSent -portid $portId]
           return $txFrames
       }
       stc {
            set txFrames [logcmd stc::get [hMapPortIdToSpirentPort $portId].Generator.GeneratorPortResults -GeneratorFrameCount]
            return $txFrames	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -framesSent]
}

################################################################## 
# Procedure Name: GetNumFramesReceived
#   
# Description: Get the number of frames received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frames received
#              
# Typical usage: 
#              [GetNumFramesReceived $portId]
#
# Category: setup
##################################################################
proc GetNumFramesReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxFrames [::AgtExtreme::GetNumFramesReceived -portid $portId]
           return $rxFrames
       }
       stc {
            # Retrieve the total number of frames received.
            set rxFrames [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -TotalFrameCount]
            return $rxFrames	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -framesReceived]
}

proc GetNumOversizedFramesReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxLongFrames [::AgtExtreme::GetNumOversizedFramesReceived -portid $portId]
           return $rxLongFrames
       }
       stc {
            # Retrieve the total number of oversized frames received.
            set rxLongFrames [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -OversizeFrameCount]
            return $rxLongFrames	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -oversize]
}

################################################################## 
# Procedure Name: GetFrameRateSent
#   
# Description: Get the number of frame rate sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frame rate sent
#              
# Typical usage: 
#              [GetFrameRateSent $portId]
#
# Category: setup
##################################################################
proc GetFrameRateSent {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set txFrameRate [::AgtExtreme::GetFrameRateSent -portid $portId]
           return $txFrameRate
       }
       stc {
            after 2000
            puts "\n\nFrame Rate info+\n\n[logcmd stc::get \
                [hMapPortIdToSpirentPort $portId].Generator.GeneratorPortResults]\n\n\n"
            set txFrameRate [logcmd stc::get [hMapPortIdToSpirentPort $portId].Generator.GeneratorPortResults \
                -GeneratorFrameRate]
            return $txFrameRate	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -framesSent]
}

proc GetOversizedFrameRateReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxLongFrameRate [::AgtExtreme::GetOversizedFrameRateReceived -portid $portId]
           return $rxLongFrameRate
       }
       stc {
            set rxLongFrameRate [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -OversizeFrameRate]
            return $rxLongFrameRate	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -oversize]
}

################################################################## 
# Procedure Name: GetFrameRateReceived
#   
# Description: Get the number of frame rate received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return frame rate received
#              
# Typical usage: 
#              [GetFrameRateReceived $portId]
#
# Category: setup
##################################################################
proc GetFrameRateReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxFrameRate [::AgtExtreme::GetFrameRateReceived -portid $portId]
           return $rxFrameRate
       }
       stc {
            #logcmd stc::perform ResultClearAllTraffic -PortList [hMapPortIdToSpirentPort $portId]
            #after 10000
            set rxFrameRate [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -TotalFrameRate]
            return $rxFrameRate	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -framesReceived]
}

################################################################## 
# Procedure Name: GetTaggedFrameRateReceived
#   
# Description: Get the number of tagged frame rate received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return tagged frame rate received
#              
# Typical usage: 
#              [GetTaggedFrameRateReceived $portId]
#
# Category: setup
##################################################################
proc GetTaggedFrameRateReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxVlanFrameRate [::AgtExtreme::GetTaggedFrameRateReceived -portid $portId]
           return $rxVlanFrameRate
       }
       stc {
            set rxVlanFrameRate [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -VlanFrameRate]
            return $rxVlanFrameRate	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -vlanTaggedFramesRx]
}

################################################################## 
# Procedure Name: GetByteRateSent
#   
# Description: Get the number of byte rate sent on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return byte rate sent
#              
# Typical usage: 
#              [GetByteRateSent $portId]
#
# Category: setup
##################################################################
proc GetByteRateSent {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set txByteRate [::AgtExtreme::GetByteRateSent -portid $portId]
           return $txByteRate
       }
       stc {
            set txByteRate [logcmd stc::get [hMapPortIdToSpirentPort $portId].Generator.GeneratorPortResults -GeneratorOctetRate]
            return $txByteRate	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -bytesSent]
   
}

################################################################## 
# Procedure Name: GetByteRateReceived
#   
# Description: Get the number of byte rate received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return byte rate received
#              
# Typical usage: 
#              [GetByteRateReceived $portId]
#
# Category: setup
##################################################################
proc GetByteRateReceived {portId} {
   global TrafficGen
   switch -exact -- $TrafficGen {
       agilent {
           set rxByteRate [::AgtExtreme::GetByteRateReceived -portid $portId]
           return $rxByteRate
       }
       stc {
            set rxVlanFrameRate [logcmd stc::get [hMapPortIdToSpirentPort $portId].Analyzer.AnalyzerPortResults -TotalOctetRate]
            return $rxVlanFrameRate	
       }
       ixia {
       }
       ept {
       }
       default {
       }
   }
   MapIxiaPortId $portId chasisId card port
   stat getRate statAllStats $chasisId $card $port
   return [stat cget -bytesReceived]
   
}

################################################################## 
# Procedure Name: GetRxArpRequest
#   
# Description: Get the number of ARP request received on a port
#               
# Input args:
#              portId - Port Id
#                                
# Output args: 
#              return numer of ARP request received
#              
# Typical usage: 
#              [GetRxArpRequest $portId]
#
# Category: utility
##################################################################
proc GetRxArpRequest {{portId "1"}} {
	MapIxiaPortId $portId chasis card port
	stat get statAllStats $chasis $card $port
	return [stat cget -rxArpRequest]
}

##################################################################    
# Description: CheckRates
#     This proc can be used to check the tx and Rx packet rate.
#     It accepts Rx ports' list to check on multiple rx ports.
#     It calls GetFrameRateSent and GetFrameRateReceived.
# Input args: txPortId, rxPortIdList, percent_tolerance
# Output args: None.
# Typical usage:
# CheckRates $txPort $rxPortList
##################################################################    

proc CheckRates {txPortId rxPortIdList {comment ""} {percent_tolerance .011} args } {
   global TrafficGen
   set rtValue "ok"
  parse_args CheckRates $args {
    reportResults 1
     oversize "false"
     reportResults 1
  }

   if {$TrafficGen == "stc"} {
     set clearlist {}
     foreach i $rxPortIdList { lappend clearlist [lindex $i 0] } 
     ClearPortsStats $clearlist 
     after 3000
   }
   
   if {$txPortId > 100 } {
      set txRate $txPortId
   } else { set txRate [GetFrameRateSent $txPortId] }

   if {$reportResults} {
      report_start_test "Checking Rates $comment"
   }

   foreach var $rxPortIdList {
  
      set rxPort [lindex $var 0]
      set rxPercent [lindex $var 1]
      set tag [lindex $var 2]
      if {$tag!=""} {
         set rxRate [GetTaggedFrameRateReceived $rxPort]
      } else {
         set rxRate [GetFrameRateReceived $rxPort]
      }
      if {$oversize=="true"} {
         set rxRate [GetOversizedFrameRateReceived $rxPort]
      }
   
      if {$reportResults} {
         report_start_test "Comparing txRate($txPortId)=$txRate and rxRate($rxPort)=$rxRate"
      }
      result_debug "Comparing txRate($txPortId)=$txRate and rxRate($rxPort)=$rxRate"

      if { $txRate == 0 } {         
         if { $rxRate == 0 } {
            if {$reportResults == 1} {
        	    result_error "txRate($txPortId)=rxRate($rxPort)=0"
		} else {
	            result_debug "txRate($txPortId)=rxRate($rxPort)=0"
		}
	         set rtValue "error"
         } else {
            if {$reportResults == 1} {
	         result_error "txRate($txPortId)=0 but rxRate($rxPort)=$rxRate"
		 } else {
	         result_debug "txRate($txPortId)=0 but rxRate($rxPort)=$rxRate"
		 }
	         set rtValue "error"
         }
      } else {
         set exp_rxRate [expr abs (double($txRate) * $rxPercent/100)]
         if {$rxRate < $exp_rxRate} {
             set diff [expr abs( double($exp_rxRate) - double($rxRate) )]
         } else {
             set diff [expr abs( double($rxRate) - double($exp_rxRate) )]
         }
         result_debug "Rate $exp_rxRate Diff $diff"
         if {$exp_rxRate < 0.0001 } {
            if {($txRate > 1000) && ($rxRate <= 10)} {
                set pPercent 0;
            } else {
                ##set pPercent [expr $diff * $percent_tolerance] ;# not sure this is right
                # nellinivasu : Changed to correctly compute loss percentage
                set pPercent [expr double($diff) / double($txRate) * 100.0]
            }
         } else {
            set pPercent [expr double($diff) / double($exp_rxRate) * 100.0]
         }           
         result_debug "--- pPercent=$pPercent"
         if { $pPercent <= $percent_tolerance } {
            result_ok "TxRate:$txRate, rxRate:$rxRate check Passed"
	      set rtValue "ok"
	 } elseif { $diff <= 5 } {
            result_ok "TxRate:$txRate, rxRate:$rxRate check Passed"
	      set rtValue "ok"	         
         } else {
	if {$reportResults == 1} {
            result_error "TxRate:$txRate, rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
            result_error [format "Difference (%01.2f%%) exceeds tolerance (%01.2f%%). Tx Rate is $txRate, Rx Rate is $rxRate.\n" $pPercent $percent_tolerance]
	  } else {
	    result_debug "TxRate:$txRate, rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
            result_debug [format "Difference (%01.2f%%) exceeds tolerance (%01.2f%%). Tx Rate is $txRate, Rx Rate is $rxRate.\n" $pPercent $percent_tolerance]
	  }
            set rtValue "error"
         }
      }
      if {$reportResults} {
         report_end_test
      }
   }
   if {$reportResults} {
      report_end_test
   }
   return $rtValue
}

##################################################################    
# Description: CheckRatesTxRx
#     This proc can be used to check the tx and Rx packet rate.
#     It accepts Tx and Rx ports' list to check on multiple rx ports.
#     It calls GetFrameRateSent and GetFrameRateReceived.
#
#     Differs from CheckRates in that specific Tx port %s are matched to
#     specific rx port %s.  negTest is used to verify 0% receives
#
# Input args: infoList, percent_tolerance
# Output args: None.
#
# lappend infoList {{1 1} {9 100 1}} :port1 tagged tx to port9 tagged expect 100%
# lappend infoList {{2 1} {10 100 1}}
# lappend infoList {{3} {11 50}} :port3 untag tx to port9 untag expect 50%
# lappend infoList {{4} {12 100}}
# lappend infoList {{negTest} {1 0}} :port1 expects 0%
# lappend infoList {{negTest} {2 0}}
# lappend infoList {{negTest} {3 0}}
# lappend infoList {{negTest} {4 0}}
# Typical usage:
# CheckRatesTxRx $infoList
# Category: utility
##################################################################    

proc CheckRatesTxRx {infoList {comment ""} {percent_tolerance .011} {sumRx "No"} {expectedSum 100}} {
    set rtValue "ok"
    
    report_start_test "Checking Rates $comment"
    set getSumTx 1
    set sumRxList ""
    foreach var $infoList {
        set txInfoList [lindex $var 0]
        set rxInfoList [lindex $var 1]
        result_debug "Transmit Information = $txInfoList"
        result_debug "Receive Information = $rxInfoList"
        # set tx vars
        set txPort [lindex $txInfoList 0]
        set txTag [lindex $txInfoList 1]
        #   set the sumTx for sumRx comparison
        if {$getSumTx && $txPort != "negTest"} {
           set sumTx [GetFrameRateSent $txPort]
           set getSumTx 0
        }
        # set rx vars
        set rxPort [lindex $rxInfoList 0]
        set rxPercent [lindex $rxInfoList 1]
        set rxTag [lindex $rxInfoList 2]
        #######################################################
        # Setup the the RX port rates
        #######################################################
        if {$rxTag!=""} {
            set rxRate [GetTaggedFrameRateReceived $rxPort]
        } else {
            set rxRate [GetFrameRateReceived $rxPort]
        }
        lappend sumRxList $rxRate
        #######################################################
        # Setup Negative Test rx Port Verification
        #######################################################
        if {$txPort == "negTest"} {
            report_start_test "Negative Test: Expecting 0% on rxRate($rxPort)=$rxRate"
            result_debug "Negative Test: Expecting 0% on rxRate($rxPort)=$rxRate"
            result_debug "--- rxPercent=$rxPercent"
            if { $rxRate < [expr [GetPortIdSpeed $rxPort] * $percent_tolerance] } {
                    result_ok "Negative Test: $rxPort RxRate:$rxRate check Passed"
                    set rtValue "ok"
            } else {
                    set pPercent [expr [GetPortIdSpeed $rxPort] * $percent_tolerance]
                    result_error "Negative Test: $rxPort rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
                    set rtValue "error"
            }

            report_end_test
            continue;

        }
        #######################################################
        # Setup the the TX port rates
        #######################################################
        set txRate [GetFrameRateSent $txPort]
        
        result_debug "tx1 = [GetFrameRateReceived 1] tx2 = [GetFrameRateReceived 2] \
                      tx3 = [GetFrameRateReceived 3] tx4 = [GetFrameRateReceived 4]"
        #######################################################
        # Start port compare
        #######################################################
        set exp_rxRate [expr abs (double($txRate) * $rxPercent/100)]
        report_start_test "txRate($txPort)=$txRate to rxRate($rxPort)=$rxRate (want $exp_rxRate)"
        result_debug "Sending txRate($txPort)=$txRate to rxRate($rxPort)=$rxRate"
        
        if {$rxRate < $exp_rxRate} {
            set diff [expr abs( double($exp_rxRate) - double($rxRate) )]
        } else {
            set diff [expr abs( double($rxRate) - double($exp_rxRate) )]
        }
        result_debug "Expected Rate at rxRate($rxPort) = $exp_rxRate Difference = $diff"
        if {$exp_rxRate < 0.0001 } {
            # If expected rate = 0
            if {$txRate != 0} {
                set pPercent [expr double($diff) / double($txRate)] ;# not sure this is right
        } else {
                set pPercent 0
            }
                         
        } else {
            set pPercent [expr double($diff) / double($exp_rxRate)] ;# perc missed by
        }           
        result_debug "--- pPercent=$pPercent"
        if { $pPercent <= $percent_tolerance } {
            result_ok "$txPort TxRate:$txRate, $rxPort RxRate:$rxRate check Passed"
            set rtValue "ok"
        } elseif { $diff <= 5 } {
            result_ok "$txPort TxRate:$txRate, $rxPort rxRate:$rxRate check Passed"
            set rtValue "ok"	         
        } else {
            result_error "$txPort TxRate:$txRate, $rxPort rxRate:$rxRate check Failed. diff percentage:$pPercent exceeds %tolerance:$percent_tolerance"
            result_error [format "Difference (%01.2f%%) exceeds tolerance (%01.2f%%). Tx Rate is $txRate, Rx Rate is $rxRate.\n" $pPercent $percent_tolerance]
            set rtValue "error"
        }
        report_end_test
   }
   if {$sumRx == "SumRx"} {
      #set expectCount [expr double($sumTx) * $rxPercent / 100]
      set expectCount [expr (double($expectedSum) / double(100)) * $sumTx]
      set rSum 0
      foreach sRate $sumRxList {
         set rSum [expr abs( double($rSum) + double($sRate) )]
      }
      set diff [expr abs( double($rSum) - double($expectCount) )]
      if {$expectCount != 0} {
         set pPercent [expr double($diff) / double($expectCount)]
      } else {
         if {$rSum < 100} {
            set pPercent 0.0
         } else {
            set pPercent 0.20
         }
      }
      report_start_test "Sum Rx Totals: $rSum (want ${expectCount})"
      if {$pPercent < 0.18} {
         result_ok "Expected Rx Sum: $expectCount  Actual Sum: $rSum  Diff: $diff"
      } else {
         result_error "Expected Rx Sum: $expectCount  Actual Sum: $rSum  Diff: $diff"
      }
      report_end_test
   }
   report_end_test
   return $rtValue
}    


################################################################## 
# Procedure Name: ixiaCapturedFramesTimeStamp
#   
# Description: Ixia capture frames timestamp
#               
# Input args:
#                Ch - chassis id
#                cd - card id
#                pt - port id  
#                fd_res - file pointer
#                                            
# Output args: 
#              return $timeStamps
# 
# Typical usage: 
#              [ixiaCapturedFramesTimeStamp $chasis $card $port $fd_res]
#
# Category: utility
################################################################## 
proc ixiaCapturedFramesTimeStamp {{ch 1}          \
                         {cd 1}          \
                         {pt 1}          \
                         {fd_res "NULL"} \
						 {fd_in "NULL"}} {
   global spawn_id

   capture get $ch $cd $pt
   set numCapFrames [capture cget -nPackets]
   captureBuffer get $ch $cd $pt 1 $numCapFrames


   for {set i 1} {$i <= $numCapFrames} {incr i} {
      captureBuffer getframe $i
      puts "capturebuffer cget -timestamp = [captureBuffer cget -timestamp]"
      if { $fd_res != "NULL" } { 
         puts $fd_res "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]"
      }
      if {$fd_in != "NULL"} { 
         puts $fd_in "[captureBuffer cget -timestamp]" 
      } else {
         lappend timeStamps "[captureBuffer cget -timestamp]"
      }
#      puts "captureBuffer cget -timestamp = [captureBuffer cget -timestamp]"
   }
   if {$fd_in == "NULL"} { 
     if { [ info exists timeStamps ] != "1" } { set timeStamps {} }
      return $timeStamps
   }
}

##################################################################    
# Description:
#     This proc can be used to enable filter on the rx Ports.
#     Each rx port filters and counts the received frames based on UDS1.
# Input args: PortIdList, daMacList, saMacList, daIpList
# Output args: None.
# Typical usage example:
#  ixiaPortFilterStat1 "1 2" "$daMAc1 $daMac2" "$saMac1 $saMac2" "$daIpAddress"
################################################################## 
proc EnablePortFilter { portIdList {daMacList "{00 00 00 00 00 00}"} \
			   {saMacList "{00 00 00 00 00 00}"} \
			   {daIpList ""} {patternMask {00 00 00 00}} {pattern1 ""} {patternOffset1 "32"} {saMaskLst "{00 00 00 00 00 00}"} {daMaskLst "{00 00 00 00 00 00}"}} {

   global one2oneArray
   global TrafficGen
   
   switch -exact -- $TrafficGen {
		
		stc {
				for {set i 0} {$i < [llength $portIdList]} {incr i} {
					set portId [lindex $portIdList $i]
					set hPort [hMapPortIdToSpirentPort $portId]
					
					set analyzerFilter [logcmd stc::create AnalyzerFrameConfigFilter -under [logcmd stc::get $hPort -children-analyzer] -Num16BitFilters 0 -Num32BitFilters 1 -Active true]
					logcmd stc::create ethernet:EthernetII -under $analyzerFilter -name af[subst $portId]_eth \
								-srcMac "[lindex $saMacList $i]/FF:FF:FF:FF:FF:FF#[join [lindex $saMaskLst $i] :]"
					if {![regexp ":" [lindex $daIpList $i]]} {
						logcmd stc::create ipv4:IPv4 -under $analyzerFilter \
												-name af[subst $portId]_ip \
												-destAddr "[lindex $daIpList $i]/255.255.255.255#[join $patternMask .]"
					} else {
						if {$patternMask == "00 00 00 00"} {
							set patternMask "::"
						}
						logcmd stc::create ipv6:IPv6 -under $analyzerFilter \
												-name af[subst $portId]_ip \
												-destAddr "[lindex $daIpList $i]/::FFFF:FFFF:FFFF:FFFF:FFFF:FFFF#[subst $patternMask]"
					}
					
				}
			
		}
		ixia -
                ixvm {
   
   result_debug "\nEnabling filter UDS1 for ports: $portIdList"
   if {[llength $portIdList] < 1} {
     result_debug "empty port list: can't enable port filter"
     return
   }   
   map new -type  one2one
   map config -type  one2one
   set pos 0  
   foreach portId $portIdList {
      set daMac [lindex $daMacList $pos] 
      if {$daMac == ""} {
        set daMac "00 00 00 00 00 00"
      }
      set saMac [lindex $saMacList $pos] 
      if {$saMac == ""} {
        set saMac "00 00 00 00 00 00"
      }
      set daIp [lindex $daIpList $pos]
      #----- addding saMask and daMask for the source and dest mac
      set saMask [lindex $saMaskLst $pos]
      if {$saMask == ""} {
        set saMask "00 00 00 00 00 00"
      }
      set daMask [lindex $daMaskLst $pos]
      if {$daMask == ""} {
        set daMask "00 00 00 00 00 00"
      }
   
      MapIxiaPortId $portId ch c p
      map add $ch $c $p $ch $c $p
      filter setDefault        
      filter config -userDefinedStat1Enable  true
      filter config -captureFilterEnable                true
      filter config -captureTriggerEnable               true
      if {[regexp -nocase "00 00 00 00 00 00" $saMac]} {
        filter config -userDefinedStat1SA      anyPattern
      } else {
        filter config -userDefinedStat1SA      addr1
      }
      if {[regexp -nocase "00 00 00 00 00 00" $daMac]} {
        filter config -userDefinedStat1DA      anyPattern
      } else {
        filter config -userDefinedStat1DA      addr1
      }

      filter config -captureFilterPattern       anyPattern
      filter config -captureTriggerPattern   anyPattern
      filter config -captureTriggerDA   anyAddr
      filter config -captureFilterDA    anyAddr


 if {$daIp != ""} {
        filter config -userDefinedStat1Pattern    pattern1
      }
if {$pattern1 != "" } {
   filter config -userDefinedStat1Pattern    pattern1
}

      filter                       set               $ch $c $p
      filterPallette setDefault
      filterPallette config -DA1  $daMac
      filterPallette config -SA1  $saMac
      filterPallette config -DAMask1 $daMask
      filterPallette config -SAMask1 $saMask
 if {$daIp != ""} {
      filterPallette config -matchType1   matchIpDAEthernetII
      set fir ""
      set sec ""
      set thi ""
      set fou ""
      scan $daIp %d.%d.%d.%d fir sec thi fou
      if {($fir!="")&&($sec!="")&&($thi!="")&&($fou!="")} {
         set pattern1 [string toupper [format "%02x %02x %02x %02x" $fir $sec $thi $fou]]
      } else {

         set pattern1 ""
      }

 filterPallette config -pattern1 $pattern1
      filterPallette config -patternOffset1 32
}
 if {$patternMask!="00 00 00 00"} {
         filterPallette config -patternMask1 $patternMask
      }
if {$pattern1 != "" } {
filterPallette               config            -pattern1           $pattern1 
filterPallette               config            -patternOffset1     $patternOffset1              
}

filterPallette               set               $ch $c $p
      
      result_debug "port $portId: DA1=$daMac; SA1=$saMac; pattern1=$pattern1 patternOffset1 $patternOffset1"
      incr pos
   }
   parray one2oneArray
   writeConfigToHardware one2oneArray
		}
	}

}

################################################################## 
# Procedure Name: DisablePortFilter
#   
# Description: Turn off the ixia ports filter
#               
# Input args:
#              portIdList - port list
#                                
# Output args: none
#              
#
# Typical usage: 
#              [DisablePortFilter $portIdList]
#
# Category: setup
################################################################## 
proc DisablePortFilter { portIdList } {
   
   
   global one2oneArray
   global TrafficGen
   
   switch -exact -- $TrafficGen {
		
		stc {
				for {set i 0} {$i < [llength $portIdList]} {incr i} {					
					logcmd stc::delete [logcmd stc::get [logcmd stc::get [hMapPortIdToSpirentPort [lindex $portIdList $i]] -children-analyzer] -children-AnalyzerFrameConfigFilter]							
				}			
		}
		ixia -
                ixvm {
   result_debug "\nDisabling filter UDS1 for ports: $portIdList"
   if {[llength $portIdList] < 1} {
     result_debug "empty port list: can't disable port filter"
     return
   }
   map new -type  one2one
   map config -type  one2one
   foreach portId $portIdList {
      MapIxiaPortId $portId ch c p
      map add $ch $c $p $ch $c $p
      filter setDefault
      filter config -captureTriggerEnable true ;# needed to capture pkts
      filter config -captureFilterEnable true ;# needed to capture pkts
      filter set $ch $c $p
      filterPallette setDefault
      filterPallette set $ch $c $p
   }
   writeConfigToHardware one2oneArray
}
	}
}

################################################################## 
# Procedure Name: CheckMatchPacketType   
# Description: 
#	check and return the no. of matched packets from the captured frames list on 
#	given ixia port no. by comparing the specified packet type (required), source ip,
#	destination ip, source Mac, and destination Mac.  The latter 4 optional parameters
#	can be bypassed with default value "dontcare".   		     
# Input args: portId pktType args(-scrIp -destIp -srcMac -destMac)
# Output args: none
# Typical usage: 
#	set matchCnt [CheckMatchPacketType 1 "ARP_REQUEST" -srcIp "10.10.10.1"]   
# Category: Utility
##################################################################
proc CheckMatchPacketType {portId pktType args } {
  parse_args CheckMatchPacketType $args {
  	srcIp "dontcare"
  	destIp "dontcare"
  	srcMac "dontcare"
  	destMac "dontcare"
  }
  result_debug "CheckMatchPacketType{}: checking $pktType in the captured packets on port $portId"
  set frameList [GetCapturedFrames $portId]
  set matchCnt 0    
  foreach frame $frameList {
    set sIpMatch 0
    set dIpMatch 0
    set sMacMatch 0
    set dMacMatch 0
    set msgtype [GetMessageType $frame]
    if {$srcIp == "dontcare" || $srcIp == [GetSourceIPAddress $frame]} {set sIpMatch 1}
    if {$destIp == "dontcare" || $destIp == [GetDestIPAddress $frame]} {set dIpMatch 1}
    if {$srcMac == "dontcare" || $srcMac == [GetSenderMacAddress $frame]} {set sMacMatch 1}
    if {$destMac == "dontcare" || $destMac == [GetTargetMacAddress $frame]} {set dMacMatch 1}   
    if {($msgtype == $pktType) && $sIpMatch && $dIpMatch && $sMacMatch && $dMacMatch } {
       incr matchCnt
       result_debug "matched $msgtype packet #$matchCnt:"
       result_debug "$frame"       
    }
  }
  result_debug "CheckMatchPacketType{}: total $matchCnt matched $pktType packets identified"
  return $matchCnt
}  
################################################################## 
# Procedure Name: getNumOfCapturedPackets   
# Description: 
#	gets the number of packets in a ports capture buffer
# Input args: portid 
# Output args: none
# Typical usage: 
#	set numCapPackets [getNumOfCapturedPackets ]
# Category: Utility
##################################################################
proc getNumOfCapturedPackets {portid } {
      set numCapFrames 0

      global TrafficGen
      switch -exact -- $TrafficGen {
          agilent {
              return [::AgtExtreme::getNumOfCapturedPackets -portid $portid]
          }
          stc {
                return [logcmd stc::get [hMapPortIdToSpirentPort $portid].capture -PktCount]
          }
          ixia {
          }
          ept {
          }
          default {
          }
      }

      MapIxiaPortId $portid chassis card port
      capture get $chassis $card $port
      set numCapFrames [capture cget -nPackets]

      return $numCapFrames
}
##################################################################
# Procedure Name: StartPortsTransmitDuration
#
# Description: Start Ports Transmit for duration
#
# Input args:
#              portIdList - Port list
#              duration   - time in secs
#
# Output args: none
#
# Typical usage:
##             [StartPortsTransmitDuration $portIdList 210]
#
# Category: setup
##################################################################
proc StartPortsTransmitDuration {portIdList duration} {


foreach portId $portIdList {
   MapIxiaPortId $portId chas card port
   lappend plist "$chas $card $port"
}

if [ixSetScheduledTransmitTime plist $duration] {
   ixPuts $::ixErrorInfo }
}

##################################################################
# Procedure Name: GetNumFilteredFramesReceived
#
# Description: Get the number of Filtered frames received on a port
#              with filter enabled using EnablePortFilter proc
#
# Input args:
#              portId - Port Id
#
# Output args:
#              return Filtered frames received
#
# Typical usage:
#              [GetNumFilteredFramesReceived $portId]
#
# Category: setup
##################################################################
proc GetNumFilteredFramesReceived {portId} {
   MapIxiaPortId $portId chasisId card port
   stat get statAllStats $chasisId $card $port
   return [stat cget -userDefinedStat1]
}


##################################################################
# Description:
#     This proc can be used to enable filter on the rx Ports.
#     Each rx port filters and counts the received frames based on UDS1.
# Input args: PortIdList, daMacList, saMacList, daIpList
# Output args: None.
# Typical usage example:
#  ixiaPortFilterStat1 "1 2" "$daMAc1 $daMac2" "$saMac1 $saMac2" "$daIpAddress"
##################################################################

proc SetPortFilter { portId pattern1 offset1} {

   global one2oneArray
   result_debug "\nEnabling filter UDS1 for ports: $portId"

   map new -type  one2one
   map config -type  one2one

   MapIxiaPortId $portId ch c p
   map add $ch $c $p $ch $c $p
   filter setDefault
   filter config -captureFilterEnable                true
   filter config -captureTriggerEnable               true

   filter config -captureFilterPattern       anyPattern
   filter config -captureTriggerPattern   anyPattern
   filter config -captureTriggerDA   anyAddr
   filter config -captureFilterDA    anyAddr
   filter config -userDefinedStat1Enable  true
   filter config -userDefinedStat1SA      anyPattern
   filter config -userDefinedStat1DA      anyPattern
   filter config -userDefinedStat1Pattern    pattern1
   filter set $ch $c $p

   filterPallette setDefault
   filterPallette config -pattern1 $pattern1
   filterPallette config -patternOffset1 $offset1
   filterPallette config -patternMask1 "00 00 00 00"
   filterPallette set $ch $c $p

   result_debug "port $portId: pattern=$pattern1; offset=$offset1; "
   set portList [list $ch,$c,$p]
    if [ ixWriteConfigToHardware portList -noVerbose -noProtocolServer] {
      result_error "writeStreams:: Error in writing the Config to hardware $ch $c $p"
      return -1
   }


}
##################################################################
# Procedure Name: WireSharkDecodeCapture
#
# Description: Decode the captured frames using tshark
#
# Input args:
#              portId - Port id
#
#              filter - "sflow.sysuptime>1460000 && sflow.sysuptime<1477440"
#
#
# Output args:
#              return the captured frames
#
# Typical usage:
#             [WireSharkDecodeCapture $portId]
#
# Category: setup
##################################################################
proc WireSharkDecodeCapture {args} {
    global TrafficGen NTAF_ENABLED TSHARKVERSION

    parse_args WireSharkDecodeCapture $args {
        portId "1"
        packThreshold "200"
        condition "null"
        T "fields"
        eList "null"
        V "true"
        count "null"
    }

    puts "PROC - WireSharkDecodeCapture portId: $portId"

    set fStr ""
    if {$V == "true"} {
        append fStr "-V "
    }
    if {$condition != "null"} {
        append fStr "\"$condition\" "
    }
    if {$eList != "null"} {
        append fStr "-T $T "
        foreach e $eList {
            append fStr "-e $e "
        }
    }
    if {$count != "null"} {
        #display the count table for now.
        if {$TSHARKVERSION < "1.3.0"} {
            set fStr "-qz io,stat,0.002,$condition"
        } else {
            set fStr "-qz io,stat,0,$condition"
        }
    }
    set filterString $fStr

    if {[info exists NTAF_ENABLED] && $NTAF_ENABLED} {
        #set packThreshold 200
    }
    switch -exact -- $TrafficGen {
        stc {
            # Get the capture object.
            StopPortsCapture $portId
            set hCapture [logcmd stc::get [hMapPortIdToSpirentPort $portId] -children-capture]
            set pktCount [logcmd stc::get $hCapture -PktCount]
            result_debug "pktCount $pktCount"
            set packetCaptureData {}
            for {set i 0} {$i < $pktCount} {incr i} {
                array set returnList [logcmd stc::perform CaptureGetFrameCommand -CaptureProxyId $hCapture -FrameIndex $i]
                set szFrameContents [string range $returnList(-PacketData) 16 end]
                #set szFrameContents [string range $returnList(-PacketData) 0 end]
                set szFrameContents [scan $szFrameContents  [string repeat "%2s" [expr [string length $szFrameContents]/2]]]
                lappend packetCaptureData $szFrameContents
            }
            set myFrames $packetCaptureData
            set file "/tmp/capture_[pid].txt"
            set pcap "/tmp/capture_[pid].pcap"
            set fid [open $file w]

            set i 1
            foreach theFrame $myFrames {
                set res {}
                set ctr 0
                while {[string length $theFrame]>48} {
                    set     pos [string wordstart $theFrame 48]
                    lappend res "[format %4.6X $ctr]  [string range $theFrame 0   [expr $pos-1]]"
                    set     theFrame   [string range $theFrame $pos end]
                    incr ctr 16
                }

                lappend res "[format %4.6X $ctr]  $theFrame"
                set theFrame [join $res "\n"]
                puts $fid "\n$theFrame ";
                if {$i==$packThreshold} {
                    break
                }
            }

            close $fid
            if [catch {exec text2pcap $file $pcap} reason] {
                #puts "Error running text2pcap: $reason"
            }
            if [catch {exec tshark -r $pcap -n $filterString } reason] {
                puts "$reason"
            } else {
                puts "All is well"
            }
            catch {file delete $file} x
            catch {file delete $pcap} y
        }
        ixia -
        ixvm {
        }
        default {
        }
    }
    set numRece [GetNumFramesReceived $portId]
    if {$numRece > $packThreshold} {
        result_debug "High number of packets ($numRece) captured. \
        Return without getting any packets"
        return
    }
    MapIxiaPortId $portId chasis card port
    if {1 || [info exists NTAF_ENABLED] && $NTAF_ENABLED} {
        set myFrames [ixiaCaptureOnePort $chasis $card $port NULL]
        set file "/tmp/capture_[pid].txt"
        set pcap "/tmp/capture_[pid].pcap"
        set fid [open $file w]
        set i 1
        foreach theFrame $myFrames {
            set res {}
            set ctr 0
            while {[string length $theFrame]>48} {
                set     pos [string wordstart $theFrame 48]
                lappend res "[format %4.6X $ctr]  [string range $theFrame 0   [expr $pos-1]]"
                set     theFrame   [string range $theFrame $pos end]
                incr ctr 16
            }
            lappend res "[format %4.6X $ctr]  $theFrame"
            set theFrame [join $res "\n"]
            puts $fid "\n$theFrame ";
            if {$i==$packThreshold} {
                break
            }
            incr i
        }

        close $fid
        if [catch {exec text2pcap $file $pcap} reason] {
            #puts "Error running text2pcap: $reason"
        }
        if {[file exists $pcap]} {puts "$pcap is there"}
        puts "\n---\n---\nCalling tshark cli: tshark -r $pcap -n $filterString\n---\n---";
        set cmd "tshark -r $pcap -n $filterString"
        if [catch {exec {*}$cmd} reason] {
            puts "$reason"
        } else {
            puts $reason
        }
        catch {file delete $file} x
        catch {file delete $pcap} y
    } else {
        return [ixiaCaptureOnePort $chasis $card $port $fd_res]
    }
}
#################################################################################
# Procedure: InitWireshark
# Wireshark filters seem to change based on version.  That's a pain
#
#
# Internal proc to get the tshark version
#
#################################################################################
proc InitWireshark {} {
    global TSHARKVERSION TSFILTER

    set pid [pid]
    set TSHARKVERSION "NULL"

    if {[catch {exec tshark -v > /tmp/ts$pid} why]} {
        puts "!!\n!!\nGetting tshark version failed\n!!\n!!"
        #There seems to be something wrong.  No tshark installed ?
    } else {
        set fd_in [open "/tmp/ts$pid" "r"]
        while {[gets $fd_in line] != -1} {
            set cookedLine [cookString $line]
puts "Reading Line $line"
            set lList [split $cookedLine]
            if {[lindex $lList 0] == "TShark" && $TSHARKVERSION == "NULL"} {
                set TSHARKVERSION [lindex $lList 1]
            }
        }
        close $fd_in
        eval [file delete -force /tmp/ts$pid]
    } 
}
#################################################################################
# Procedure: GetWireSharkFilter
#
#
#
# args: filter - the wireshark display filter to verify
#
#
#
#
#
#
#################################################################################
proc GetWireSharkFilter {filter} {
    global TSHARKVERSION TSFILTER

    if [info exists TSHARKVERSION] {
        puts "TShark version = $TSHARKVERSION"
    } else {
        puts "TShark version NOT SET"
    } 
    if {![info exists TSFILTER($filter)]} {
        puts "$filter is not version dependent"
        return $filter
    }

    # -----  Examples from the tshark.cfg file   ----------------------------------
    # set TSFILTER("filter") [list "start ver" "end ver" "alternate list"]
    # set TSFILTER("sflow.sysuptime") [list "1.0.0" "1.2.18" "sflow_245.sysuptime"]
    # set TSFILTER("sflow_245.sysuptime") [list "1.4.0" "2.0.4" "sflow.sysuptime"]
    # -----------------------------------------------------------------------------
    set fAlt [lindex $TSFILTER($filter) 2];# wireshark alternate filter LIST

    set filterList [concat $filter $fAlt]
    foreach f $filterList {
        puts "Looking for $f"
        set fStartV [lindex $TSFILTER($f) 0];# wireshark start support version
        set fEndV [lindex $TSFILTER($f) 1];# wireshark end support version
        if {$TSHARKVERSION >= $fStartV && $TSHARKVERSION <= $fEndV} {
            puts "Matched between $fStartV && $fEndV - return $f"
            return $f
        }
    }
    puts "Error - no filter hit"
}

